{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwODAyODMz", "number": 3404, "reviewThreads": {"totalCount": 96, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxNzoyODoyNVrOEJXbWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMzo0MDozMlrOEbRnvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjU2NDczOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxNzoyODoyNVrOGp3H3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxODowOTowN1rOGrwVgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0NzkzMw==", "bodyText": "It was unclear whether QualifierKindHierarchy represents a single qualifier hierarchy (that's what the name implied to me), or a set of qualifier hierarchies (I think this is correct, because tops and bottoms are sets rather than singletons), or just contains utility methods.  Please clarify and possibly rename the class.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446547933", "createdAt": "2020-06-27T17:28:25Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,876 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86e98ad5a689f29dc39832caf12c933e2c56b775"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODUzMzg5MQ==", "bodyText": "[Just document that there may be more than one hierarchy.]", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r448533891", "createdAt": "2020-07-01T18:09:07Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,876 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0NzkzMw=="}, "originalCommit": {"oid": "86e98ad5a689f29dc39832caf12c933e2c56b775"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjU2NTAwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxNzoyODo1MFrOGp3H_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMToyMDo1OFrOG0ftRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0Nzk2Ng==", "bodyText": "The terminology \"kind\" is not explained in the documentation.  Given that the documentation says that QualifierKind represents a class, how about renaming this to \"QualifierClass\" or even \"Qualifier\"?\n(I think you are making a distinction between (1) concrete qualifier uses or instantiations in the programmer's source code and (2) a \"kind\" that represents many possible instantiations.  But it took me a while to come to this understanding.)", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446547966", "createdAt": "2020-06-27T17:28:50Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,876 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86e98ad5a689f29dc39832caf12c933e2c56b775"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI0ODEyOA==", "bodyText": "I had originally named this class \"QualifierClass\", but it is confusing because a qualifier class would have type Class<Annotation>. For example, see the constructor of QualifierKindHierarchy.\nThis class does not represent a \"Qualifier\" because a qualifier may have values for the annotation elements, but QualifierKinds do not.  So @Regex(1) is a qualifier but it can't be represents by this class.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r447248128", "createdAt": "2020-06-29T20:54:58Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,876 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0Nzk2Ng=="}, "originalCommit": {"oid": "86e98ad5a689f29dc39832caf12c933e2c56b775"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYyMDA5OQ==", "bodyText": "I also found the Kind part confusing - in other places, like in Tree.Kind the Kind is some enum that distinguishes different, well, kinds of trees.\nWhat about QualifierTemplate, QualifierMold, QualifierPrototype, or QualifierArchetype?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456620099", "createdAt": "2020-07-17T18:56:46Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,876 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0Nzk2Ng=="}, "originalCommit": {"oid": "86e98ad5a689f29dc39832caf12c933e2c56b775"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5ODYzMQ==", "bodyText": "TODO: Document why it's called kind.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r457698631", "createdAt": "2020-07-20T21:20:58Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,876 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0Nzk2Ng=="}, "originalCommit": {"oid": "86e98ad5a689f29dc39832caf12c933e2c56b775"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjU2NTE2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxNzoyOTowMVrOGp3IDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxNjo1MjoxNlrOGqZrdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0Nzk4Mw==", "bodyText": "Regarding @Interned:  is it possible that two different QualifierKindHierarchy objects exist, each of which creates a QualifierKind for the same Class?  If not, what prevents that?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446547983", "createdAt": "2020-06-27T17:29:01Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,876 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86e98ad5a689f29dc39832caf12c933e2c56b775"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExNDEwMQ==", "bodyText": "No.  Its constructor is private and the Interning Checker, which is run in CI, reports only one error in #createQualifierKinds.  See that method for why that warning is suppressed.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r447114101", "createdAt": "2020-06-29T16:52:16Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,876 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0Nzk4Mw=="}, "originalCommit": {"oid": "86e98ad5a689f29dc39832caf12c933e2c56b775"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjU2OTA3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxNzozNDoxN1rOGp3J4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxNzozNDoxN1rOGp3J4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0ODQ0OQ==", "bodyText": "Does this represent a forall relationship (every instantiation of a QualifierKind in superTypes is a supertype of every instantiation of this) or an exists relationship (some instantiation of a QualifierKind in superTypes is a supertype of some instantiation of this)?\nFor example, \" can imagine that some instantiations of QualifierKind Super are supertypes of some instantiations of QualifierKind Sub; for example, @Super(\"a\") is a supertype of @Sub(\"a\"), but @Super(\"b\") is not a supertype of @Sub(\"a\").  How would that be represented here?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446548449", "createdAt": "2020-06-27T17:34:17Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,876 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86e98ad5a689f29dc39832caf12c933e2c56b775"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjU3NTQ1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxNzo0MToyM1rOGp3Mww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxNzo0MToyM1rOGp3Mww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0OTE4Nw==", "bodyText": "Is this reflexive or strict subtype?  Please clarify in the documentation.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446549187", "createdAt": "2020-06-27T17:41:23Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,872 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84f3d2a049952d29d0c28ec30358ee35d160950b"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjU4MTc4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxNzo0ODo1NFrOGp3PoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxNzo0ODo1NFrOGp3PoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0OTkyMQ==", "bodyText": "Every existing clients calls this method and then immediately calls get or values on the result.  Do type systems need access to this map?  You could provide two methods that do the things that clients want, which is to look up by name or to get all the QualifierKinds.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446549921", "createdAt": "2020-06-27T17:48:54Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,872 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all the qualifier\n+     * kinds for the hierarchy.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier kind to its direct super types; used to verify\n+     *     that a polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the heirarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null && tops.size() == 1) {\n+                    qualifierKind.top = tops.iterator().next();\n+                } else if (qualifierKind.top == null) {\n+                    throw new UserError(\n+                            \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier, %s, specified %s, instead of a top qualifier in a hierarchy. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. (This method does not initialize all fields in the {@link QualifierKind}\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.)\n+     *\n+     * @param qualifierClasses a collection of classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            // If another QualifierKind exists with the same class, an exception will be thrown\n+            // below.\n+            @SuppressWarnings(\"interning\")\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used to by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Class<? extends Annotation>[] superQualifiers = subtypeOfMetaAnno.value();\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : superQualifiers) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at runtime, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * @Override\n+     * protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *     super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     * }\n+     * </pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);\n+            superTypes.addAll(directSuperMap.keySet());\n+            superTypes.remove(bottomKind);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers without any direct super qualifiers.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        for (Map.Entry<QualifierKind, Set<QualifierKind>> entry : directSuperMap.entrySet()) {\n+            QualifierKind qualifierKind = entry.getKey();\n+            if (entry.getValue().size() == 0) {\n+                tops.add(qualifierKind);\n+                qualifierKind.top = qualifierKind;\n+            }\n+        }\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by search {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier of another qualifier.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        // Bottom starts with all qualifiers\n+        Set<QualifierKind> bottoms = new TreeSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            // Remove any qualifier that is a direct super qualifier of another qualifier\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifiers to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#isPoly} to true and {@link\n+     * QualifierKind#top} to top if the meta-annotation {@link PolymorphicQualifier} specifies a\n+     * top.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     *\n+     * @throws UserError if the meta-annotation {@link PolymorphicQualifier} specifies an annotation\n+     *     that is not in the hierarchy.\n+     * @return a mapping from a top qualifier to the polymorphic qualifier in the heirarchy\n+     */\n+    protected Map<QualifierKind, QualifierKind> initializePolymorphicQualifiers() {\n+        Map<QualifierKind, QualifierKind> topToPoly = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetAnno != null) {\n+                qualifierKind.isPoly = true;\n+                String topName = polyMetAnno.value().getCanonicalName();\n+                if (nameToQualifierKind.containsKey(topName)) {\n+                    qualifierKind.top = nameToQualifierKind.get(topName);\n+                } else if (topName.equals(PolymorphicQualifier.class.getCanonicalName())) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"The polymorphic qualifier, %s, did not specify a top annotation class. Tops: [%s]\",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else {\n+                    throw new UserError(\n+                            \"The polymorphic qualifier, %s, specified a top annotation class that is not a supported qualifier. Found: %s.\",\n+                            qualifierKind, topName);\n+                }\n+                topToPoly.put(qualifierKind.top, qualifierKind);\n+            }\n+        }\n+        return topToPoly;\n+    }\n+\n+    /**\n+     * Initializes {@link QualifierKind#superTypes}, {@link QualifierKind#top} and {@link\n+     * QualifierKind#bottom}. (Requires tops, bottoms, and polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @throws UserError if a qualifier isn't a subtype of one of the top qualifiers or if multiple\n+     *     tops or bottoms are found for the same hierarchy.\n+     */\n+    protected void initializeQualifierKindFields(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            if (qualifierKind.isPoly) {\n+                qualifierKind.superTypes = new TreeSet<>();\n+                qualifierKind.superTypes.add(qualifierKind.top);\n+            } else {\n+                qualifierKind.superTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top != null && qualifierKind.top != top) {\n+                        throw new UserError(\n+                                \"Multiple tops found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, top, qualifierKind.top);\n+                    }\n+                    qualifierKind.top = top;\n+                }\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind bot : bottoms) {\n+                if (bot.top == qualifierKind.top) {\n+                    if (qualifierKind.bottom != null && qualifierKind.top != bot) {\n+                        throw new UserError(\n+                                \"Multiple bottoms found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, bot, qualifierKind.bottom);\n+                    }\n+                    qualifierKind.bottom = bot;\n+                    if (qualifierKind.isPoly) {\n+                        bot.superTypes.add(qualifierKind);\n+                    }\n+                }\n+            }\n+            if (qualifierKind.top == null) {\n+                throw new UserError(\"Qualifier isn't in hierarchy: %s\", qualifierKind);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the set of all qualifiers that are a supertype of {@code qualifierKind}.\n+     *\n+     * @param qualifierKind the qualifier whose super types should be returned\n+     * @param directSuperMap directSuperMap\n+     * @return the set of all qualifiers that are a supertype of {@code qualifierKind}\n+     * @throws UserError if there is a cycle in the hierarchy\n+     */\n+    private Set<QualifierKind> findAllTheSupers(\n+            QualifierKind qualifierKind, Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Queue<QualifierKind> queue = new ArrayDeque<>(directSuperMap.get(qualifierKind));\n+        Set<QualifierKind> allSupers = new TreeSet<>(directSuperMap.get(qualifierKind));\n+        while (!queue.isEmpty()) {\n+            QualifierKind superQual = queue.remove();\n+            if (superQual == qualifierKind) {\n+                throw new UserError(\"Cycle in hierarchy: %s\", qualifierKind);\n+            }\n+            queue.addAll(directSuperMap.get(superQual));\n+            allSupers.addAll(directSuperMap.get(superQual));\n+        }\n+        return allSupers;\n+    }\n+\n+    /**\n+     * Creates a mapping from {@link QualifierKindPair} to the least upper bound of both\n+     * QualifierKinds.\n+     *\n+     * @return a mapping from {@link QualifierKindPair} to their lub.\n+     */\n+    protected Map<QualifierKindPair, QualifierKind> createLubsMap() {\n+        Map<QualifierKindPair, QualifierKind> lubs = new TreeMap<>();\n+        for (QualifierKind qual1 : nameToQualifierKind.values()) {\n+            for (QualifierKind qual2 : nameToQualifierKind.values()) {\n+                if (qual1.top != qual2.top) {\n+                    continue;\n+                }\n+                QualifierKind lub = findLub(qual1, qual2);\n+                QualifierKindPair pair = new QualifierKindPair(qual1, qual2);\n+                QualifierKind otherLub = lubs.get(pair);\n+                if (otherLub != null) {\n+                    if (otherLub != lub) {\n+                        throw new BugInCF(\n+                                \"Multiple lubs for qualifiers %s and %s. Found lubs %s and %s\",\n+                                qual1, qual2, lub, otherLub);\n+                    }\n+                } else {\n+                    lubs.put(pair, lub);\n+                }\n+            }\n+        }\n+        return lubs;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code qual1} and {@code qual2}.\n+     *\n+     * @param qual1 a qualifier kind\n+     * @param qual2 a qualifier kind\n+     * @return the least upper bound of {@code qual1} and {@code qual2}\n+     */\n+    private QualifierKind findLub(QualifierKind qual1, QualifierKind qual2) {\n+        if (qual1 == qual2) {\n+            return qual1;\n+        } else if (qual1.isSubtype(qual2)) {\n+            return qual2;\n+        } else if (qual2.isSubtype(qual1)) {\n+            return qual1;\n+        }\n+        Set<QualifierKind> allSuperTypes = new TreeSet<>(qual1.superTypes);\n+        allSuperTypes.retainAll(qual2.superTypes);\n+        Set<QualifierKind> lubs = findLowestQualifiers(allSuperTypes);\n+        if (lubs.size() != 1) {\n+            throw new BugInCF(\n+                    \"Not exactly 1 lub for %s and %s. Found lubs: [%s].\",\n+                    qual1, qual2, SystemUtil.join(\", \", lubs));\n+        }\n+        QualifierKind lub = lubs.iterator().next();\n+        if (lub.isPoly && !qual1.isPoly && !qual2.isPoly) {\n+            return lub.top;\n+        }\n+        return lub;\n+    }\n+\n+    /**\n+     * Returns the lowest qualifiers in the passed set.\n+     *\n+     * @param qualifierKinds the passed set\n+     * @return the lowest qualifiers in the passed set\n+     */\n+    protected final Set<QualifierKind> findLowestQualifiers(Set<QualifierKind> qualifierKinds) {\n+        Set<QualifierKind> lowestQualifiers = new TreeSet<>(qualifierKinds);\n+        for (QualifierKind a1 : qualifierKinds) {\n+            lowestQualifiers.removeIf(a2 -> a1 != a2 && a1.isSubtype(a2));\n+        }\n+        return lowestQualifiers;\n+    }\n+\n+    /**\n+     * Creates a mapping from {@link QualifierKindPair} to the greatest lower bound of both\n+     * QualifierKinds.\n+     *\n+     * @return a mapping from {@link QualifierKindPair} to their glb.\n+     */\n+    private Map<QualifierKindPair, QualifierKind> createGlbsMap() {\n+        Map<QualifierKindPair, QualifierKind> glbs = new TreeMap<>();\n+        for (QualifierKind qual1 : nameToQualifierKind.values()) {\n+            for (QualifierKind qual2 : nameToQualifierKind.values()) {\n+                if (qual1.top != qual2.top) {\n+                    continue;\n+                }\n+                QualifierKind glb = findGlb(qual1, qual2);\n+                QualifierKindPair pair = new QualifierKindPair(qual1, qual2);\n+                QualifierKind otherGlb = glbs.get(pair);\n+                if (otherGlb != null) {\n+                    if (otherGlb != glb) {\n+                        throw new BugInCF(\n+                                \"Multiple glbs for qualifiers %s and %s. Found lubs %s and %s\",\n+                                qual1, qual2, glb, otherGlb);\n+                    }\n+                } else {\n+                    glbs.put(pair, glb);\n+                }\n+            }\n+        }\n+        return glbs;\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code qual1} and {@code qual2}.\n+     *\n+     * @param qual1 a qualifier kind\n+     * @param qual2 a qualifier kind\n+     * @return the greatest lower bound of {@code qual1} and {@code qual2}\n+     */\n+    private QualifierKind findGlb(QualifierKind qual1, QualifierKind qual2) {\n+        if (qual1 == qual2) {\n+            return qual1;\n+        } else if (qual1.isSubtype(qual2)) {\n+            return qual1;\n+        } else if (qual2.isSubtype(qual1)) {\n+            return qual2;\n+        }\n+        Set<QualifierKind> allSubTypes = new TreeSet<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            if (qualifierKind.isSubtype(qual1) && qualifierKind.isSubtype(qual2)) {\n+                allSubTypes.add(qualifierKind);\n+            }\n+        }\n+        Set<QualifierKind> glbs = findHighestQualifiers(allSubTypes);\n+        if (glbs.size() != 1) {\n+            throw new BugInCF(\n+                    \"Not exactly 1 glb for %s and %s. Found glb: [%s].\",\n+                    qual1, qual2, SystemUtil.join(\", \", glbs));\n+        }\n+        QualifierKind lub = glbs.iterator().next();\n+        if (lub.isPoly && !qual1.isPoly && !qual2.isPoly) {\n+            return lub.bottom;\n+        }\n+        return lub;\n+    }\n+\n+    /**\n+     * Returns the highest qualifiers in the passed set.\n+     *\n+     * @param qualifierKinds the passed set\n+     * @return the highest qualifiers in the passed set\n+     */\n+    protected final Set<QualifierKind> findHighestQualifiers(Set<QualifierKind> qualifierKinds) {\n+        Set<QualifierKind> lowestQualifiers = new TreeSet<>(qualifierKinds);\n+        for (QualifierKind a1 : qualifierKinds) {\n+            lowestQualifiers.removeIf(a2 -> a1 != a2 && a2.isSubtype(a1));\n+        }\n+        return lowestQualifiers;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(new QualifierKindPair(q1, q2));\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(new QualifierKindPair(q1, q2));\n+    }\n+\n+    /**\n+     * Returns the mapping from the fully-qualified class name of an annotation to its qualifier\n+     * kind.\n+     *\n+     * @return the mapping from the fully-qualified class name of an annotation to its qualifier\n+     *     kind\n+     */\n+    public Map<@Interned String, QualifierKind> getNameToQualifierKind() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa80abc9820992ccae5f78e513ddf7a5598656d4"}, "originalPosition": 796}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjU5NTYzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxODowNTo1NlrOGp3V-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxODowNTo1NlrOGp3V-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MTU0NQ==", "bodyText": "Is this a fully-qualified name or a canonical name?  The name field of QualifierKind is documented as a canonical name.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446551545", "createdAt": "2020-06-27T18:05:56Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,872 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa80abc9820992ccae5f78e513ddf7a5598656d4"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjYwNDYwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxODoxNzoyN1rOGp3aMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxODoxNzoyN1rOGp3aMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MjYyNQ==", "bodyText": "I suggest that you dispense with the QualifierKindPair class.  Instead, make the type of lubs be Map<QualifierKind, Map<QualifierKind, QualifierKind>>.  Instead of lubs.get(new QualifierKindPair(q1, q2)), clients will call lubs.get(q1).get(q2).  This will be more efficient for clients because they do not have to spend the time to create, then garbage-collect, many QualifierKindPair objects.  Also, don't do any sorting of the elements in the pair:  just represent both orders redundantly in the maps.  That will also save a small amount of computation.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446552625", "createdAt": "2020-06-27T18:17:27Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,872 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa80abc9820992ccae5f78e513ddf7a5598656d4"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjYwNzkzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxODoyMDo0MlrOGp3btQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxODoyMDo0MlrOGp3btQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1MzAxMw==", "bodyText": "What is the format of the annotation name?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446553013", "createdAt": "2020-06-27T18:20:42Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,873 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fccaf88c2f2308a79ee2ab9d2b6faa7166285f3c"}, "originalPosition": 349}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjYxOTEzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxODozNToxNlrOGp3g2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxODozNToxNlrOGp3g2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1NDMzMQ==", "bodyText": "Can also be null, in which case this method has no effect.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446554331", "createdAt": "2020-06-27T18:35:16Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,870 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daef6dd212baf9f41a6eccc5bb771e6f9796ebd9"}, "originalPosition": 422}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjYxOTE1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxODozNToxOVrOGp3g3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxODozNToxOVrOGp3g3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1NDMzMw==", "bodyText": "I would rename superTypes to directSuperTypes for clarity.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446554333", "createdAt": "2020-06-27T18:35:19Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,870 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daef6dd212baf9f41a6eccc5bb771e6f9796ebd9"}, "originalPosition": 430}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjYxOTE3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxODozNToyMlrOGp3g4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxODozNToyMlrOGp3g4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1NDMzNw==", "bodyText": "Why does this add/augment rather than replacing?  Why does it add all of directSuperMap's keySet, when some of those values might not be direct supertypes of bottom?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446554337", "createdAt": "2020-06-27T18:35:22Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,870 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);\n+            superTypes.addAll(directSuperMap.keySet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daef6dd212baf9f41a6eccc5bb771e6f9796ebd9"}, "originalPosition": 431}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjYxOTE5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxODozNToyNVrOGp3g5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQxODoxNzowNFrOGqcoRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1NDM0MQ==", "bodyText": "How can this be necessary?  That is, how can bottomKind be one of its own direct supertypes?  directSuperMap should have no self-mappings.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446554341", "createdAt": "2020-06-27T18:35:25Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,870 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);\n+            superTypes.addAll(directSuperMap.keySet());\n+            superTypes.remove(bottomKind);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daef6dd212baf9f41a6eccc5bb771e6f9796ebd9"}, "originalPosition": 432}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE2MjQzOQ==", "bodyText": "The line above adds the keySet of directSuperMap to superTypes, so it has to be removed.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r447162439", "createdAt": "2020-06-29T18:17:04Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,870 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);\n+            superTypes.addAll(directSuperMap.keySet());\n+            superTypes.remove(bottomKind);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1NDM0MQ=="}, "originalCommit": {"oid": "daef6dd212baf9f41a6eccc5bb771e6f9796ebd9"}, "originalPosition": 432}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjYxOTQ0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxODozNTozN1rOGp3hAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMTo1OTo0NlrOGrP-YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1NDM3MA==", "bodyText": "This has some other side effects:  it sets or augments the given class's super qualifiers from directSuperMap.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446554370", "createdAt": "2020-06-27T18:35:37Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,870 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daef6dd212baf9f41a6eccc5bb771e6f9796ebd9"}, "originalPosition": 405}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAwMzY4MQ==", "bodyText": "Added below.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r448003681", "createdAt": "2020-06-30T21:59:46Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,870 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1NDM3MA=="}, "originalCommit": {"oid": "daef6dd212baf9f41a6eccc5bb771e6f9796ebd9"}, "originalPosition": 405}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjYyMzc2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxODo0MTo0MVrOGp3jAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxODo0MTo0MVrOGp3jAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1NDg4MA==", "bodyText": "Also sets the top field, but only for top annotations. Please document that.\nI find this design a bit surprising.  Why not set all the top fields in the same method?  I think that might be conceptually simpler, but maybe I am missing something important about the current design.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446554880", "createdAt": "2020-06-27T18:41:41Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,870 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);\n+            superTypes.addAll(directSuperMap.keySet());\n+            superTypes.remove(bottomKind);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers without any direct super qualifiers.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daef6dd212baf9f41a6eccc5bb771e6f9796ebd9"}, "originalPosition": 441}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjY1MDYyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxOToxNTowOFrOGp3vaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxOToxNTowOFrOGp3vaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU1ODA1Nw==", "bodyText": "I find this confusing.  What does the user-written source code look like when this if condition evaluates to true?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446558057", "createdAt": "2020-06-27T19:15:08Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,870 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);\n+            superTypes.addAll(directSuperMap.keySet());\n+            superTypes.remove(bottomKind);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers without any direct super qualifiers.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        for (Map.Entry<QualifierKind, Set<QualifierKind>> entry : directSuperMap.entrySet()) {\n+            QualifierKind qualifierKind = entry.getKey();\n+            if (entry.getValue().size() == 0) {\n+                tops.add(qualifierKind);\n+                qualifierKind.top = qualifierKind;\n+            }\n+        }\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by search {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier of another qualifier.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        // Bottom starts with all qualifiers\n+        Set<QualifierKind> bottoms = new TreeSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            // Remove any qualifier that is a direct super qualifier of another qualifier\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifiers to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#isPoly} to true and {@link\n+     * QualifierKind#top} to top if the meta-annotation {@link PolymorphicQualifier} specifies a\n+     * top.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     *\n+     * @throws UserError if the meta-annotation {@link PolymorphicQualifier} specifies an annotation\n+     *     that is not in the hierarchy.\n+     * @return a mapping from a top qualifier to the polymorphic qualifier in the heirarchy\n+     */\n+    protected Map<QualifierKind, QualifierKind> initializePolymorphicQualifiers() {\n+        Map<QualifierKind, QualifierKind> topToPoly = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetAnno != null) {\n+                qualifierKind.isPoly = true;\n+                String topName = polyMetAnno.value().getCanonicalName();\n+                if (nameToQualifierKind.containsKey(topName)) {\n+                    qualifierKind.top = nameToQualifierKind.get(topName);\n+                } else if (topName.equals(PolymorphicQualifier.class.getCanonicalName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daef6dd212baf9f41a6eccc5bb771e6f9796ebd9"}, "originalPosition": 502}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjY3OTIwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxOTo1NDozOFrOGp380A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxOTo1NDozOFrOGp380A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU2MTQ4OA==", "bodyText": "What does \"supported\" mean?  Should this just say that the qualifier is not in the hierarchy?\nAlso change $s to %s (that was my typo, sorry).", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446561488", "createdAt": "2020-06-27T19:54:38Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,870 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);\n+            superTypes.addAll(directSuperMap.keySet());\n+            superTypes.remove(bottomKind);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers without any direct super qualifiers.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        for (Map.Entry<QualifierKind, Set<QualifierKind>> entry : directSuperMap.entrySet()) {\n+            QualifierKind qualifierKind = entry.getKey();\n+            if (entry.getValue().isEmpty()) {\n+                tops.add(qualifierKind);\n+                qualifierKind.top = qualifierKind;\n+            }\n+        }\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier of another qualifier.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        // Bottom starts with all qualifiers\n+        Set<QualifierKind> bottoms = new TreeSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            // Remove any qualifier that is a direct super qualifier of another qualifier\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifiers to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#isPoly} to true and {@link\n+     * QualifierKind#top} to top if the meta-annotation {@link PolymorphicQualifier} specifies a\n+     * top.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     *\n+     * @throws UserError if the meta-annotation {@link PolymorphicQualifier} specifies an annotation\n+     *     that is not in the hierarchy.\n+     * @return a mapping from a top qualifier to the polymorphic qualifier in the heirarchy\n+     */\n+    protected Map<QualifierKind, QualifierKind> initializePolymorphicQualifiers() {\n+        Map<QualifierKind, QualifierKind> topToPoly = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno != null) {\n+                qualifierKind.isPoly = true;\n+                String topName = polyMetaAnno.value().getCanonicalName();\n+                if (nameToQualifierKind.containsKey(topName)) {\n+                    qualifierKind.top = nameToQualifierKind.get(topName);\n+                } else if (topName.equals(PolymorphicQualifier.class.getCanonicalName())) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else {\n+                    throw new UserError(\n+                            \"polymorphic qualifier %s's top $s is not a supported qualifier. Found: %s.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f8be435471e6f035c6ace3d6edd9c7db18ab9cc"}, "originalPosition": 512}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjY4MDY4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxOTo1Njo0M1rOGp39fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QxOTo1Njo0M1rOGp39fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU2MTY2MQ==", "bodyText": "Can you call Collections.singleton instead?  That is more efficient.  Use of these two lines implies that it is important to clients that the superTypes field is modifiable.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446561661", "createdAt": "2020-06-27T19:56:43Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,870 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);\n+            superTypes.addAll(directSuperMap.keySet());\n+            superTypes.remove(bottomKind);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers without any direct super qualifiers.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        for (Map.Entry<QualifierKind, Set<QualifierKind>> entry : directSuperMap.entrySet()) {\n+            QualifierKind qualifierKind = entry.getKey();\n+            if (entry.getValue().isEmpty()) {\n+                tops.add(qualifierKind);\n+                qualifierKind.top = qualifierKind;\n+            }\n+        }\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier of another qualifier.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        // Bottom starts with all qualifiers\n+        Set<QualifierKind> bottoms = new TreeSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            // Remove any qualifier that is a direct super qualifier of another qualifier\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifiers to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#isPoly} to true and {@link\n+     * QualifierKind#top} to top if the meta-annotation {@link PolymorphicQualifier} specifies a\n+     * top.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     *\n+     * @throws UserError if the meta-annotation {@link PolymorphicQualifier} specifies an annotation\n+     *     that is not in the hierarchy.\n+     * @return a mapping from a top qualifier to the polymorphic qualifier in the heirarchy\n+     */\n+    protected Map<QualifierKind, QualifierKind> initializePolymorphicQualifiers() {\n+        Map<QualifierKind, QualifierKind> topToPoly = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno != null) {\n+                qualifierKind.isPoly = true;\n+                String topName = polyMetaAnno.value().getCanonicalName();\n+                if (nameToQualifierKind.containsKey(topName)) {\n+                    qualifierKind.top = nameToQualifierKind.get(topName);\n+                } else if (topName.equals(PolymorphicQualifier.class.getCanonicalName())) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else {\n+                    throw new UserError(\n+                            \"polymorphic qualifier %s's top $s is not a supported qualifier. Found: %s.\",\n+                            qualifierKind, topName);\n+                }\n+                topToPoly.put(qualifierKind.top, qualifierKind);\n+            }\n+        }\n+        return topToPoly;\n+    }\n+\n+    /**\n+     * Initializes {@link QualifierKind#superTypes}, {@link QualifierKind#top} and {@link\n+     * QualifierKind#bottom}. (Requires tops, bottoms, and polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @throws UserError if a qualifier isn't a subtype of one of the top qualifiers or if multiple\n+     *     tops or bottoms are found for the same hierarchy.\n+     */\n+    protected void initializeQualifierKindFields(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            if (qualifierKind.isPoly) {\n+                qualifierKind.superTypes = new TreeSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f8be435471e6f035c6ace3d6edd9c7db18ab9cc"}, "originalPosition": 534}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjY4OTEzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QyMDowODo0M1rOGp4BYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMTo1MzoyNVrOGrPzxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU2MjY1OA==", "bodyText": "As I noted elsewhere, I found it surprising that the top field is set for tops elsewhere, and here for all non-tops.  I would put them all in the same place.  Or, document the design.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446562658", "createdAt": "2020-06-27T20:08:43Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,874 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);\n+            superTypes.addAll(directSuperMap.keySet());\n+            superTypes.remove(bottomKind);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers without any direct super qualifiers.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        for (Map.Entry<QualifierKind, Set<QualifierKind>> entry : directSuperMap.entrySet()) {\n+            QualifierKind qualifierKind = entry.getKey();\n+            if (entry.getValue().isEmpty()) {\n+                tops.add(qualifierKind);\n+                qualifierKind.top = qualifierKind;\n+            }\n+        }\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier of another qualifier.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        // Bottom starts with all qualifiers\n+        Set<QualifierKind> bottoms = new TreeSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            // Remove any qualifier that is a direct super qualifier of another qualifier\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifiers to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#isPoly} to true and {@link\n+     * QualifierKind#top} to top if the meta-annotation {@link PolymorphicQualifier} specifies a\n+     * top.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     *\n+     * @throws UserError if the meta-annotation {@link PolymorphicQualifier} specifies an annotation\n+     *     that is not in the hierarchy.\n+     * @return a mapping from a top qualifier to the polymorphic qualifier in the heirarchy\n+     */\n+    protected Map<QualifierKind, QualifierKind> initializePolymorphicQualifiers() {\n+        Map<QualifierKind, QualifierKind> topToPoly = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno != null) {\n+                qualifierKind.isPoly = true;\n+                String topName = polyMetaAnno.value().getCanonicalName();\n+                if (nameToQualifierKind.containsKey(topName)) {\n+                    qualifierKind.top = nameToQualifierKind.get(topName);\n+                } else if (topName.equals(PolymorphicQualifier.class.getCanonicalName())) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else {\n+                    throw new UserError(\n+                            \"polymorphic qualifier %s's top $s is not a supported qualifier. Found: %s.\",\n+                            qualifierKind, topName);\n+                }\n+                topToPoly.put(qualifierKind.top, qualifierKind);\n+            }\n+        }\n+        return topToPoly;\n+    }\n+\n+    /**\n+     * For each qualifier in {@code directSuperMap}, initializes {@link QualifierKind#superTypes},\n+     * {@link QualifierKind#top} and {@link QualifierKind#bottom}. (Requires tops, bottoms, and\n+     * polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; created by {@link #createDirectSuperMap()}\n+     * @throws UserError if a qualifier isn't a subtype of one of the top qualifiers or if multiple\n+     *     tops or bottoms are found for the same hierarchy.\n+     */\n+    protected void initializeQualifierKindFields(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            if (qualifierKind.isPoly) {\n+                qualifierKind.superTypes = new TreeSet<>();\n+                qualifierKind.superTypes.add(qualifierKind.top);\n+            } else {\n+                qualifierKind.superTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1ea0737d154fc21b64cdfca2c0683b74731816d"}, "originalPosition": 545}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAwMDk2NQ==", "bodyText": "They are all set here now.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r448000965", "createdAt": "2020-06-30T21:53:25Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,874 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);\n+            superTypes.addAll(directSuperMap.keySet());\n+            superTypes.remove(bottomKind);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers without any direct super qualifiers.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        for (Map.Entry<QualifierKind, Set<QualifierKind>> entry : directSuperMap.entrySet()) {\n+            QualifierKind qualifierKind = entry.getKey();\n+            if (entry.getValue().isEmpty()) {\n+                tops.add(qualifierKind);\n+                qualifierKind.top = qualifierKind;\n+            }\n+        }\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier of another qualifier.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        // Bottom starts with all qualifiers\n+        Set<QualifierKind> bottoms = new TreeSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            // Remove any qualifier that is a direct super qualifier of another qualifier\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifiers to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#isPoly} to true and {@link\n+     * QualifierKind#top} to top if the meta-annotation {@link PolymorphicQualifier} specifies a\n+     * top.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     *\n+     * @throws UserError if the meta-annotation {@link PolymorphicQualifier} specifies an annotation\n+     *     that is not in the hierarchy.\n+     * @return a mapping from a top qualifier to the polymorphic qualifier in the heirarchy\n+     */\n+    protected Map<QualifierKind, QualifierKind> initializePolymorphicQualifiers() {\n+        Map<QualifierKind, QualifierKind> topToPoly = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno != null) {\n+                qualifierKind.isPoly = true;\n+                String topName = polyMetaAnno.value().getCanonicalName();\n+                if (nameToQualifierKind.containsKey(topName)) {\n+                    qualifierKind.top = nameToQualifierKind.get(topName);\n+                } else if (topName.equals(PolymorphicQualifier.class.getCanonicalName())) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else {\n+                    throw new UserError(\n+                            \"polymorphic qualifier %s's top $s is not a supported qualifier. Found: %s.\",\n+                            qualifierKind, topName);\n+                }\n+                topToPoly.put(qualifierKind.top, qualifierKind);\n+            }\n+        }\n+        return topToPoly;\n+    }\n+\n+    /**\n+     * For each qualifier in {@code directSuperMap}, initializes {@link QualifierKind#superTypes},\n+     * {@link QualifierKind#top} and {@link QualifierKind#bottom}. (Requires tops, bottoms, and\n+     * polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; created by {@link #createDirectSuperMap()}\n+     * @throws UserError if a qualifier isn't a subtype of one of the top qualifiers or if multiple\n+     *     tops or bottoms are found for the same hierarchy.\n+     */\n+    protected void initializeQualifierKindFields(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            if (qualifierKind.isPoly) {\n+                qualifierKind.superTypes = new TreeSet<>();\n+                qualifierKind.superTypes.add(qualifierKind.top);\n+            } else {\n+                qualifierKind.superTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU2MjY1OA=="}, "originalCommit": {"oid": "e1ea0737d154fc21b64cdfca2c0683b74731816d"}, "originalPosition": 545}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjY5MTEwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QyMDoxMDo0NlrOGp4CUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo0MjoxNlrOGrFQXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU2Mjg5Nw==", "bodyText": "This logic does not find all cycles.  For example, suppose there is qualifierKind -> A -> B -> A.  This will infinite-loop because superQual will ping-pong between A and B but never be equal to qualifierKind.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446562897", "createdAt": "2020-06-27T20:10:46Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,874 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);\n+            superTypes.addAll(directSuperMap.keySet());\n+            superTypes.remove(bottomKind);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers without any direct super qualifiers.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        for (Map.Entry<QualifierKind, Set<QualifierKind>> entry : directSuperMap.entrySet()) {\n+            QualifierKind qualifierKind = entry.getKey();\n+            if (entry.getValue().isEmpty()) {\n+                tops.add(qualifierKind);\n+                qualifierKind.top = qualifierKind;\n+            }\n+        }\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier of another qualifier.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        // Bottom starts with all qualifiers\n+        Set<QualifierKind> bottoms = new TreeSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            // Remove any qualifier that is a direct super qualifier of another qualifier\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifiers to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#isPoly} to true and {@link\n+     * QualifierKind#top} to top if the meta-annotation {@link PolymorphicQualifier} specifies a\n+     * top.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     *\n+     * @throws UserError if the meta-annotation {@link PolymorphicQualifier} specifies an annotation\n+     *     that is not in the hierarchy.\n+     * @return a mapping from a top qualifier to the polymorphic qualifier in the heirarchy\n+     */\n+    protected Map<QualifierKind, QualifierKind> initializePolymorphicQualifiers() {\n+        Map<QualifierKind, QualifierKind> topToPoly = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno != null) {\n+                qualifierKind.isPoly = true;\n+                String topName = polyMetaAnno.value().getCanonicalName();\n+                if (nameToQualifierKind.containsKey(topName)) {\n+                    qualifierKind.top = nameToQualifierKind.get(topName);\n+                } else if (topName.equals(PolymorphicQualifier.class.getCanonicalName())) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else {\n+                    throw new UserError(\n+                            \"polymorphic qualifier %s's top $s is not a supported qualifier. Found: %s.\",\n+                            qualifierKind, topName);\n+                }\n+                topToPoly.put(qualifierKind.top, qualifierKind);\n+            }\n+        }\n+        return topToPoly;\n+    }\n+\n+    /**\n+     * For each qualifier in {@code directSuperMap}, initializes {@link QualifierKind#superTypes},\n+     * {@link QualifierKind#top} and {@link QualifierKind#bottom}. (Requires tops, bottoms, and\n+     * polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; created by {@link #createDirectSuperMap()}\n+     * @throws UserError if a qualifier isn't a subtype of one of the top qualifiers or if multiple\n+     *     tops or bottoms are found for the same hierarchy.\n+     */\n+    protected void initializeQualifierKindFields(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            if (qualifierKind.isPoly) {\n+                qualifierKind.superTypes = new TreeSet<>();\n+                qualifierKind.superTypes.add(qualifierKind.top);\n+            } else {\n+                qualifierKind.superTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;\n+                    } else if (qualifierKind.top != top) {\n+                        throw new UserError(\n+                                \"Multiple tops found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, top, qualifierKind.top);\n+                    }\n+                }\n+            }\n+            if (qualifierKind.top == null) {\n+                throw new UserError(\"Qualifier isn't in hierarchy: %s\", qualifierKind);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind bot : bottoms) {\n+                if (bot.top != qualifierKind.top) {\n+                    continue;\n+                }\n+                if (qualifierKind.bottom == null) {\n+                    qualifierKind.bottom = bot;\n+                } else if (qualifierKind.top != bot) {\n+                    throw new UserError(\n+                            \"Multiple bottoms found for qualifier %s. Tops: %s and %s.\",\n+                            qualifierKind, bot, qualifierKind.bottom);\n+                }\n+                if (qualifierKind.isPoly) {\n+                    bot.superTypes.add(qualifierKind);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the set of all qualifiers that are a supertype of {@code qualifierKind}.\n+     *\n+     * @param qualifierKind the qualifier whose super types should be returned\n+     * @param directSuperMap directSuperMap\n+     * @return the set of all qualifiers that are a supertype of {@code qualifierKind}\n+     * @throws UserError if there is a cycle in the hierarchy\n+     */\n+    private Set<QualifierKind> findAllTheSupers(\n+            QualifierKind qualifierKind, Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Queue<QualifierKind> queue = new ArrayDeque<>(directSuperMap.get(qualifierKind));\n+        Set<QualifierKind> allSupers = new TreeSet<>(directSuperMap.get(qualifierKind));\n+        while (!queue.isEmpty()) {\n+            QualifierKind superQual = queue.remove();\n+            if (superQual == qualifierKind) {\n+                throw new UserError(\"Cycle in hierarchy: %s\", qualifierKind);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1ea0737d154fc21b64cdfca2c0683b74731816d"}, "originalPosition": 591}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgyODA2MA==", "bodyText": "I added logic to break this loop.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r447828060", "createdAt": "2020-06-30T16:42:16Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,874 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);\n+            superTypes.addAll(directSuperMap.keySet());\n+            superTypes.remove(bottomKind);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers without any direct super qualifiers.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        for (Map.Entry<QualifierKind, Set<QualifierKind>> entry : directSuperMap.entrySet()) {\n+            QualifierKind qualifierKind = entry.getKey();\n+            if (entry.getValue().isEmpty()) {\n+                tops.add(qualifierKind);\n+                qualifierKind.top = qualifierKind;\n+            }\n+        }\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier of another qualifier.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        // Bottom starts with all qualifiers\n+        Set<QualifierKind> bottoms = new TreeSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            // Remove any qualifier that is a direct super qualifier of another qualifier\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifiers to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#isPoly} to true and {@link\n+     * QualifierKind#top} to top if the meta-annotation {@link PolymorphicQualifier} specifies a\n+     * top.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     *\n+     * @throws UserError if the meta-annotation {@link PolymorphicQualifier} specifies an annotation\n+     *     that is not in the hierarchy.\n+     * @return a mapping from a top qualifier to the polymorphic qualifier in the heirarchy\n+     */\n+    protected Map<QualifierKind, QualifierKind> initializePolymorphicQualifiers() {\n+        Map<QualifierKind, QualifierKind> topToPoly = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno != null) {\n+                qualifierKind.isPoly = true;\n+                String topName = polyMetaAnno.value().getCanonicalName();\n+                if (nameToQualifierKind.containsKey(topName)) {\n+                    qualifierKind.top = nameToQualifierKind.get(topName);\n+                } else if (topName.equals(PolymorphicQualifier.class.getCanonicalName())) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else {\n+                    throw new UserError(\n+                            \"polymorphic qualifier %s's top $s is not a supported qualifier. Found: %s.\",\n+                            qualifierKind, topName);\n+                }\n+                topToPoly.put(qualifierKind.top, qualifierKind);\n+            }\n+        }\n+        return topToPoly;\n+    }\n+\n+    /**\n+     * For each qualifier in {@code directSuperMap}, initializes {@link QualifierKind#superTypes},\n+     * {@link QualifierKind#top} and {@link QualifierKind#bottom}. (Requires tops, bottoms, and\n+     * polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; created by {@link #createDirectSuperMap()}\n+     * @throws UserError if a qualifier isn't a subtype of one of the top qualifiers or if multiple\n+     *     tops or bottoms are found for the same hierarchy.\n+     */\n+    protected void initializeQualifierKindFields(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            if (qualifierKind.isPoly) {\n+                qualifierKind.superTypes = new TreeSet<>();\n+                qualifierKind.superTypes.add(qualifierKind.top);\n+            } else {\n+                qualifierKind.superTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;\n+                    } else if (qualifierKind.top != top) {\n+                        throw new UserError(\n+                                \"Multiple tops found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, top, qualifierKind.top);\n+                    }\n+                }\n+            }\n+            if (qualifierKind.top == null) {\n+                throw new UserError(\"Qualifier isn't in hierarchy: %s\", qualifierKind);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind bot : bottoms) {\n+                if (bot.top != qualifierKind.top) {\n+                    continue;\n+                }\n+                if (qualifierKind.bottom == null) {\n+                    qualifierKind.bottom = bot;\n+                } else if (qualifierKind.top != bot) {\n+                    throw new UserError(\n+                            \"Multiple bottoms found for qualifier %s. Tops: %s and %s.\",\n+                            qualifierKind, bot, qualifierKind.bottom);\n+                }\n+                if (qualifierKind.isPoly) {\n+                    bot.superTypes.add(qualifierKind);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the set of all qualifiers that are a supertype of {@code qualifierKind}.\n+     *\n+     * @param qualifierKind the qualifier whose super types should be returned\n+     * @param directSuperMap directSuperMap\n+     * @return the set of all qualifiers that are a supertype of {@code qualifierKind}\n+     * @throws UserError if there is a cycle in the hierarchy\n+     */\n+    private Set<QualifierKind> findAllTheSupers(\n+            QualifierKind qualifierKind, Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Queue<QualifierKind> queue = new ArrayDeque<>(directSuperMap.get(qualifierKind));\n+        Set<QualifierKind> allSupers = new TreeSet<>(directSuperMap.get(qualifierKind));\n+        while (!queue.isEmpty()) {\n+            QualifierKind superQual = queue.remove();\n+            if (superQual == qualifierKind) {\n+                throw new UserError(\"Cycle in hierarchy: %s\", qualifierKind);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU2Mjg5Nw=="}, "originalCommit": {"oid": "e1ea0737d154fc21b64cdfca2c0683b74731816d"}, "originalPosition": 591}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjY5MjcwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QyMDoxMzo0MVrOGp4DDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QyMDoxMzo0MVrOGp4DDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU2MzA4Nw==", "bodyText": "When reading this, I was confused abouh how this can happen.  I think the answer is that QualifierKindPair canonicalizes the order of the elements of the pair.  With the elimination of that class that I suggested, this will not be relevant any more.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446563087", "createdAt": "2020-06-27T20:13:41Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,874 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);\n+            superTypes.addAll(directSuperMap.keySet());\n+            superTypes.remove(bottomKind);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers without any direct super qualifiers.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        for (Map.Entry<QualifierKind, Set<QualifierKind>> entry : directSuperMap.entrySet()) {\n+            QualifierKind qualifierKind = entry.getKey();\n+            if (entry.getValue().isEmpty()) {\n+                tops.add(qualifierKind);\n+                qualifierKind.top = qualifierKind;\n+            }\n+        }\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier of another qualifier.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        // Bottom starts with all qualifiers\n+        Set<QualifierKind> bottoms = new TreeSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            // Remove any qualifier that is a direct super qualifier of another qualifier\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifiers to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#isPoly} to true and {@link\n+     * QualifierKind#top} to top if the meta-annotation {@link PolymorphicQualifier} specifies a\n+     * top.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     *\n+     * @throws UserError if the meta-annotation {@link PolymorphicQualifier} specifies an annotation\n+     *     that is not in the hierarchy.\n+     * @return a mapping from a top qualifier to the polymorphic qualifier in the heirarchy\n+     */\n+    protected Map<QualifierKind, QualifierKind> initializePolymorphicQualifiers() {\n+        Map<QualifierKind, QualifierKind> topToPoly = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno != null) {\n+                qualifierKind.isPoly = true;\n+                String topName = polyMetaAnno.value().getCanonicalName();\n+                if (nameToQualifierKind.containsKey(topName)) {\n+                    qualifierKind.top = nameToQualifierKind.get(topName);\n+                } else if (topName.equals(PolymorphicQualifier.class.getCanonicalName())) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else {\n+                    throw new UserError(\n+                            \"polymorphic qualifier %s's top $s is not a supported qualifier. Found: %s.\",\n+                            qualifierKind, topName);\n+                }\n+                topToPoly.put(qualifierKind.top, qualifierKind);\n+            }\n+        }\n+        return topToPoly;\n+    }\n+\n+    /**\n+     * For each qualifier in {@code directSuperMap}, initializes {@link QualifierKind#superTypes},\n+     * {@link QualifierKind#top} and {@link QualifierKind#bottom}. (Requires tops, bottoms, and\n+     * polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; created by {@link #createDirectSuperMap()}\n+     * @throws UserError if a qualifier isn't a subtype of one of the top qualifiers or if multiple\n+     *     tops or bottoms are found for the same hierarchy.\n+     */\n+    protected void initializeQualifierKindFields(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            if (qualifierKind.isPoly) {\n+                qualifierKind.superTypes = new TreeSet<>();\n+                qualifierKind.superTypes.add(qualifierKind.top);\n+            } else {\n+                qualifierKind.superTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;\n+                    } else if (qualifierKind.top != top) {\n+                        throw new UserError(\n+                                \"Multiple tops found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, top, qualifierKind.top);\n+                    }\n+                }\n+            }\n+            if (qualifierKind.top == null) {\n+                throw new UserError(\"Qualifier isn't in hierarchy: %s\", qualifierKind);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind bot : bottoms) {\n+                if (bot.top != qualifierKind.top) {\n+                    continue;\n+                }\n+                if (qualifierKind.bottom == null) {\n+                    qualifierKind.bottom = bot;\n+                } else if (qualifierKind.top != bot) {\n+                    throw new UserError(\n+                            \"Multiple bottoms found for qualifier %s. Tops: %s and %s.\",\n+                            qualifierKind, bot, qualifierKind.bottom);\n+                }\n+                if (qualifierKind.isPoly) {\n+                    bot.superTypes.add(qualifierKind);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the set of all qualifiers that are a supertype of {@code qualifierKind}.\n+     *\n+     * @param qualifierKind the qualifier whose super types should be returned\n+     * @param directSuperMap directSuperMap\n+     * @return the set of all qualifiers that are a supertype of {@code qualifierKind}\n+     * @throws UserError if there is a cycle in the hierarchy\n+     */\n+    private Set<QualifierKind> findAllTheSupers(\n+            QualifierKind qualifierKind, Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Queue<QualifierKind> queue = new ArrayDeque<>(directSuperMap.get(qualifierKind));\n+        Set<QualifierKind> allSupers = new TreeSet<>(directSuperMap.get(qualifierKind));\n+        while (!queue.isEmpty()) {\n+            QualifierKind superQual = queue.remove();\n+            if (superQual == qualifierKind) {\n+                throw new UserError(\"Cycle in hierarchy: %s\", qualifierKind);\n+            }\n+            queue.addAll(directSuperMap.get(superQual));\n+            allSupers.addAll(directSuperMap.get(superQual));\n+        }\n+        return allSupers;\n+    }\n+\n+    /**\n+     * Creates a mapping from {@link QualifierKindPair} to the least upper bound of both\n+     * QualifierKinds.\n+     *\n+     * @return a mapping from {@link QualifierKindPair} to their lub.\n+     */\n+    protected Map<QualifierKindPair, QualifierKind> createLubsMap() {\n+        Map<QualifierKindPair, QualifierKind> lubs = new TreeMap<>();\n+        for (QualifierKind qual1 : nameToQualifierKind.values()) {\n+            for (QualifierKind qual2 : nameToQualifierKind.values()) {\n+                if (qual1.top != qual2.top) {\n+                    continue;\n+                }\n+                QualifierKind lub = findLub(qual1, qual2);\n+                QualifierKindPair pair = new QualifierKindPair(qual1, qual2);\n+                QualifierKind otherLub = lubs.get(pair);\n+                if (otherLub != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1ea0737d154fc21b64cdfca2c0683b74731816d"}, "originalPosition": 615}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjY5NDUwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QyMDoxNTo0OFrOGp4D3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMTowNjoyN1rOGr1XHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU2MzI5Mw==", "bodyText": "This logic is a bit inefficient.  I think that's OK because this version is only ever called once per pair, at the beginning of the Checker Framework run, and the result is cached.  Explaining when various methods will be called would be useful to help readers understand the design.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446563293", "createdAt": "2020-06-27T20:15:48Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,874 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);\n+            superTypes.addAll(directSuperMap.keySet());\n+            superTypes.remove(bottomKind);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers without any direct super qualifiers.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        for (Map.Entry<QualifierKind, Set<QualifierKind>> entry : directSuperMap.entrySet()) {\n+            QualifierKind qualifierKind = entry.getKey();\n+            if (entry.getValue().isEmpty()) {\n+                tops.add(qualifierKind);\n+                qualifierKind.top = qualifierKind;\n+            }\n+        }\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier of another qualifier.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        // Bottom starts with all qualifiers\n+        Set<QualifierKind> bottoms = new TreeSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            // Remove any qualifier that is a direct super qualifier of another qualifier\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifiers to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#isPoly} to true and {@link\n+     * QualifierKind#top} to top if the meta-annotation {@link PolymorphicQualifier} specifies a\n+     * top.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     *\n+     * @throws UserError if the meta-annotation {@link PolymorphicQualifier} specifies an annotation\n+     *     that is not in the hierarchy.\n+     * @return a mapping from a top qualifier to the polymorphic qualifier in the heirarchy\n+     */\n+    protected Map<QualifierKind, QualifierKind> initializePolymorphicQualifiers() {\n+        Map<QualifierKind, QualifierKind> topToPoly = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno != null) {\n+                qualifierKind.isPoly = true;\n+                String topName = polyMetaAnno.value().getCanonicalName();\n+                if (nameToQualifierKind.containsKey(topName)) {\n+                    qualifierKind.top = nameToQualifierKind.get(topName);\n+                } else if (topName.equals(PolymorphicQualifier.class.getCanonicalName())) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else {\n+                    throw new UserError(\n+                            \"polymorphic qualifier %s's top $s is not a supported qualifier. Found: %s.\",\n+                            qualifierKind, topName);\n+                }\n+                topToPoly.put(qualifierKind.top, qualifierKind);\n+            }\n+        }\n+        return topToPoly;\n+    }\n+\n+    /**\n+     * For each qualifier in {@code directSuperMap}, initializes {@link QualifierKind#superTypes},\n+     * {@link QualifierKind#top} and {@link QualifierKind#bottom}. (Requires tops, bottoms, and\n+     * polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; created by {@link #createDirectSuperMap()}\n+     * @throws UserError if a qualifier isn't a subtype of one of the top qualifiers or if multiple\n+     *     tops or bottoms are found for the same hierarchy.\n+     */\n+    protected void initializeQualifierKindFields(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            if (qualifierKind.isPoly) {\n+                qualifierKind.superTypes = new TreeSet<>();\n+                qualifierKind.superTypes.add(qualifierKind.top);\n+            } else {\n+                qualifierKind.superTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;\n+                    } else if (qualifierKind.top != top) {\n+                        throw new UserError(\n+                                \"Multiple tops found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, top, qualifierKind.top);\n+                    }\n+                }\n+            }\n+            if (qualifierKind.top == null) {\n+                throw new UserError(\"Qualifier isn't in hierarchy: %s\", qualifierKind);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind bot : bottoms) {\n+                if (bot.top != qualifierKind.top) {\n+                    continue;\n+                }\n+                if (qualifierKind.bottom == null) {\n+                    qualifierKind.bottom = bot;\n+                } else if (qualifierKind.top != bot) {\n+                    throw new UserError(\n+                            \"Multiple bottoms found for qualifier %s. Tops: %s and %s.\",\n+                            qualifierKind, bot, qualifierKind.bottom);\n+                }\n+                if (qualifierKind.isPoly) {\n+                    bot.superTypes.add(qualifierKind);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the set of all qualifiers that are a supertype of {@code qualifierKind}.\n+     *\n+     * @param qualifierKind the qualifier whose super types should be returned\n+     * @param directSuperMap directSuperMap\n+     * @return the set of all qualifiers that are a supertype of {@code qualifierKind}\n+     * @throws UserError if there is a cycle in the hierarchy\n+     */\n+    private Set<QualifierKind> findAllTheSupers(\n+            QualifierKind qualifierKind, Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Queue<QualifierKind> queue = new ArrayDeque<>(directSuperMap.get(qualifierKind));\n+        Set<QualifierKind> allSupers = new TreeSet<>(directSuperMap.get(qualifierKind));\n+        while (!queue.isEmpty()) {\n+            QualifierKind superQual = queue.remove();\n+            if (superQual == qualifierKind) {\n+                throw new UserError(\"Cycle in hierarchy: %s\", qualifierKind);\n+            }\n+            queue.addAll(directSuperMap.get(superQual));\n+            allSupers.addAll(directSuperMap.get(superQual));\n+        }\n+        return allSupers;\n+    }\n+\n+    /**\n+     * Creates a mapping from {@link QualifierKindPair} to the least upper bound of both\n+     * QualifierKinds.\n+     *\n+     * @return a mapping from {@link QualifierKindPair} to their lub.\n+     */\n+    protected Map<QualifierKindPair, QualifierKind> createLubsMap() {\n+        Map<QualifierKindPair, QualifierKind> lubs = new TreeMap<>();\n+        for (QualifierKind qual1 : nameToQualifierKind.values()) {\n+            for (QualifierKind qual2 : nameToQualifierKind.values()) {\n+                if (qual1.top != qual2.top) {\n+                    continue;\n+                }\n+                QualifierKind lub = findLub(qual1, qual2);\n+                QualifierKindPair pair = new QualifierKindPair(qual1, qual2);\n+                QualifierKind otherLub = lubs.get(pair);\n+                if (otherLub != null) {\n+                    if (otherLub != lub) {\n+                        throw new BugInCF(\n+                                \"Multiple lubs for qualifiers %s and %s. Found lubs %s and %s\",\n+                                qual1, qual2, lub, otherLub);\n+                    }\n+                } else {\n+                    lubs.put(pair, lub);\n+                }\n+            }\n+        }\n+        return lubs;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code qual1} and {@code qual2}.\n+     *\n+     * @param qual1 a qualifier kind\n+     * @param qual2 a qualifier kind\n+     * @return the least upper bound of {@code qual1} and {@code qual2}\n+     */\n+    private QualifierKind findLub(QualifierKind qual1, QualifierKind qual2) {\n+        if (qual1 == qual2) {\n+            return qual1;\n+        } else if (qual1.isSubtype(qual2)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1ea0737d154fc21b64cdfca2c0683b74731816d"}, "originalPosition": 639}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxNjIyMw==", "bodyText": "Explaining when various methods will be called would be useful to help readers understand the design.\n\nAny method in this class that does anything more than return a value or do a map.get is only called once.  I added\n    ///////////////////////////////////////////////////////////////////////////\n    /// <editor-fold desc=\"Initialize hierarchy\">\n    /// Methods that initialize the hierarchy; only called once.\n    ///\n...\n    // </editor-fold> End of methods that initialize hierarchy\n\nAround these methods to make that clear.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r448616223", "createdAt": "2020-07-01T21:06:27Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,874 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);\n+            superTypes.addAll(directSuperMap.keySet());\n+            superTypes.remove(bottomKind);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers without any direct super qualifiers.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        for (Map.Entry<QualifierKind, Set<QualifierKind>> entry : directSuperMap.entrySet()) {\n+            QualifierKind qualifierKind = entry.getKey();\n+            if (entry.getValue().isEmpty()) {\n+                tops.add(qualifierKind);\n+                qualifierKind.top = qualifierKind;\n+            }\n+        }\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier of another qualifier.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        // Bottom starts with all qualifiers\n+        Set<QualifierKind> bottoms = new TreeSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            // Remove any qualifier that is a direct super qualifier of another qualifier\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifiers to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#isPoly} to true and {@link\n+     * QualifierKind#top} to top if the meta-annotation {@link PolymorphicQualifier} specifies a\n+     * top.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     *\n+     * @throws UserError if the meta-annotation {@link PolymorphicQualifier} specifies an annotation\n+     *     that is not in the hierarchy.\n+     * @return a mapping from a top qualifier to the polymorphic qualifier in the heirarchy\n+     */\n+    protected Map<QualifierKind, QualifierKind> initializePolymorphicQualifiers() {\n+        Map<QualifierKind, QualifierKind> topToPoly = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno != null) {\n+                qualifierKind.isPoly = true;\n+                String topName = polyMetaAnno.value().getCanonicalName();\n+                if (nameToQualifierKind.containsKey(topName)) {\n+                    qualifierKind.top = nameToQualifierKind.get(topName);\n+                } else if (topName.equals(PolymorphicQualifier.class.getCanonicalName())) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else {\n+                    throw new UserError(\n+                            \"polymorphic qualifier %s's top $s is not a supported qualifier. Found: %s.\",\n+                            qualifierKind, topName);\n+                }\n+                topToPoly.put(qualifierKind.top, qualifierKind);\n+            }\n+        }\n+        return topToPoly;\n+    }\n+\n+    /**\n+     * For each qualifier in {@code directSuperMap}, initializes {@link QualifierKind#superTypes},\n+     * {@link QualifierKind#top} and {@link QualifierKind#bottom}. (Requires tops, bottoms, and\n+     * polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; created by {@link #createDirectSuperMap()}\n+     * @throws UserError if a qualifier isn't a subtype of one of the top qualifiers or if multiple\n+     *     tops or bottoms are found for the same hierarchy.\n+     */\n+    protected void initializeQualifierKindFields(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            if (qualifierKind.isPoly) {\n+                qualifierKind.superTypes = new TreeSet<>();\n+                qualifierKind.superTypes.add(qualifierKind.top);\n+            } else {\n+                qualifierKind.superTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;\n+                    } else if (qualifierKind.top != top) {\n+                        throw new UserError(\n+                                \"Multiple tops found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, top, qualifierKind.top);\n+                    }\n+                }\n+            }\n+            if (qualifierKind.top == null) {\n+                throw new UserError(\"Qualifier isn't in hierarchy: %s\", qualifierKind);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind bot : bottoms) {\n+                if (bot.top != qualifierKind.top) {\n+                    continue;\n+                }\n+                if (qualifierKind.bottom == null) {\n+                    qualifierKind.bottom = bot;\n+                } else if (qualifierKind.top != bot) {\n+                    throw new UserError(\n+                            \"Multiple bottoms found for qualifier %s. Tops: %s and %s.\",\n+                            qualifierKind, bot, qualifierKind.bottom);\n+                }\n+                if (qualifierKind.isPoly) {\n+                    bot.superTypes.add(qualifierKind);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the set of all qualifiers that are a supertype of {@code qualifierKind}.\n+     *\n+     * @param qualifierKind the qualifier whose super types should be returned\n+     * @param directSuperMap directSuperMap\n+     * @return the set of all qualifiers that are a supertype of {@code qualifierKind}\n+     * @throws UserError if there is a cycle in the hierarchy\n+     */\n+    private Set<QualifierKind> findAllTheSupers(\n+            QualifierKind qualifierKind, Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Queue<QualifierKind> queue = new ArrayDeque<>(directSuperMap.get(qualifierKind));\n+        Set<QualifierKind> allSupers = new TreeSet<>(directSuperMap.get(qualifierKind));\n+        while (!queue.isEmpty()) {\n+            QualifierKind superQual = queue.remove();\n+            if (superQual == qualifierKind) {\n+                throw new UserError(\"Cycle in hierarchy: %s\", qualifierKind);\n+            }\n+            queue.addAll(directSuperMap.get(superQual));\n+            allSupers.addAll(directSuperMap.get(superQual));\n+        }\n+        return allSupers;\n+    }\n+\n+    /**\n+     * Creates a mapping from {@link QualifierKindPair} to the least upper bound of both\n+     * QualifierKinds.\n+     *\n+     * @return a mapping from {@link QualifierKindPair} to their lub.\n+     */\n+    protected Map<QualifierKindPair, QualifierKind> createLubsMap() {\n+        Map<QualifierKindPair, QualifierKind> lubs = new TreeMap<>();\n+        for (QualifierKind qual1 : nameToQualifierKind.values()) {\n+            for (QualifierKind qual2 : nameToQualifierKind.values()) {\n+                if (qual1.top != qual2.top) {\n+                    continue;\n+                }\n+                QualifierKind lub = findLub(qual1, qual2);\n+                QualifierKindPair pair = new QualifierKindPair(qual1, qual2);\n+                QualifierKind otherLub = lubs.get(pair);\n+                if (otherLub != null) {\n+                    if (otherLub != lub) {\n+                        throw new BugInCF(\n+                                \"Multiple lubs for qualifiers %s and %s. Found lubs %s and %s\",\n+                                qual1, qual2, lub, otherLub);\n+                    }\n+                } else {\n+                    lubs.put(pair, lub);\n+                }\n+            }\n+        }\n+        return lubs;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code qual1} and {@code qual2}.\n+     *\n+     * @param qual1 a qualifier kind\n+     * @param qual2 a qualifier kind\n+     * @return the least upper bound of {@code qual1} and {@code qual2}\n+     */\n+    private QualifierKind findLub(QualifierKind qual1, QualifierKind qual2) {\n+        if (qual1 == qual2) {\n+            return qual1;\n+        } else if (qual1.isSubtype(qual2)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU2MzI5Mw=="}, "originalCommit": {"oid": "e1ea0737d154fc21b64cdfca2c0683b74731816d"}, "originalPosition": 639}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjY5NDkxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QyMDoxNjozN1rOGp4EEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QyMDoxNjozN1rOGp4EEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU2MzM0NQ==", "bodyText": "Why isn't this an error?  (All comments about lub apply to corresponding glb methods too.)", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r446563345", "createdAt": "2020-06-27T20:16:37Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,874 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy}\n+ * classes to implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s,\n+ * such as {@link org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a qualifier class. It holds information about the relationship between itself and\n+     * other {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this ispolymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a super qualifier of this qualifier, except for this\n+         * qualifier itself.\n+         *\n+         * @return all the qualifier kinds that are a super qualifier of this qualifier, except for\n+         *     this qualifier itself\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier is a subtype of {@code superQual}.\n+         *\n+         * @param superQual other qualifier\n+         * @return true if this qualifier is a subtype of {@code superQual}\n+         */\n+        public boolean isSubtype(QualifierKind superQual) {\n+            return this == superQual || superTypes.contains(superQual);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from interned, fully-qualified class name of a qualifier to the QualifierKind\n+     * object representing that class.\n+     */\n+    private final Map<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /** A mapping from a pair of qualifier kinds to their lub. */\n+    private final Map<QualifierKindPair, QualifierKind> lubs;\n+\n+    /** A mapping from a pair of qualifier kinds to their glb. */\n+    private final Map<QualifierKindPair, QualifierKind> glbs;\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifiers.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+        // printLubs();\n+        // printIsSubtype();\n+    }\n+\n+    //    private void printLubs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"LUB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printLubsWithElements() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : lubs.entrySet()) {\n+    //            if (entry.getValue().hasElements) {\n+    //                System.out.printf(\n+    //                        \"LUB(%s, %s): %s%n\",\n+    //                        entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //            }\n+    //        }\n+    //    }\n+    //\n+    //    private void printGlbs() {\n+    //        for (Map.Entry<QualifierKindPair, QualifierKind> entry : glbs.entrySet()) {\n+    //            System.out.printf(\n+    //                    \"GLB(%s, %s): %s%n\",\n+    //                    entry.getKey().qual1, entry.getKey().qual2, entry.getValue());\n+    //        }\n+    //    }\n+    //\n+    //    private void printIsSubtype() {\n+    //        for (QualifierKind subKind : nameToQualifierKind.values()) {\n+    //            for (QualifierKind superKind : nameToQualifierKind.values()) {\n+    //                if (subKind.isSubtype(superKind)\n+    //                        && superKind.hasElements()\n+    //                        && subKind.hasElements()) {\n+    //                    System.out.printf(\"Sub: %s Super: %s%n\", subKind, superKind);\n+    //                }\n+    //            }\n+    //        }\n+    //    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtype = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtype) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers. \"\n+                                + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\n+            } else if (!isPoly && !hasSubtype) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given {@code qualifierClasses} and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from annotation name to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        Map<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"\");\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifiers using\n+     * the {@link SubtypeOf} meta-annotation. The direct super qualifiers must not contain the\n+     * qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor and only {@link #nameToQualifierKind}\n+     * has been initialized.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype meta-annotation refers to a qualifier, %s, that isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Explicitly set bottom to the given class.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * If this method is not overridden, it has no effect.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers\n+     * @param bottom the class of the bottom qualifier\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            String name = bottom.getCanonicalName();\n+            QualifierKind bottomKind = getNameToQualifierKind().get(name);\n+            Set<QualifierKind> superTypes = directSuperMap.get(bottomKind);\n+            superTypes.addAll(directSuperMap.keySet());\n+            superTypes.remove(bottomKind);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers without any direct super qualifiers.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        for (Map.Entry<QualifierKind, Set<QualifierKind>> entry : directSuperMap.entrySet()) {\n+            QualifierKind qualifierKind = entry.getKey();\n+            if (entry.getValue().isEmpty()) {\n+                tops.add(qualifierKind);\n+                qualifierKind.top = qualifierKind;\n+            }\n+        }\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier of another qualifier.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; create by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        // Bottom starts with all qualifiers\n+        Set<QualifierKind> bottoms = new TreeSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            // Remove any qualifier that is a direct super qualifier of another qualifier\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifiers to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#isPoly} to true and {@link\n+     * QualifierKind#top} to top if the meta-annotation {@link PolymorphicQualifier} specifies a\n+     * top.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     *\n+     * @throws UserError if the meta-annotation {@link PolymorphicQualifier} specifies an annotation\n+     *     that is not in the hierarchy.\n+     * @return a mapping from a top qualifier to the polymorphic qualifier in the heirarchy\n+     */\n+    protected Map<QualifierKind, QualifierKind> initializePolymorphicQualifiers() {\n+        Map<QualifierKind, QualifierKind> topToPoly = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno != null) {\n+                qualifierKind.isPoly = true;\n+                String topName = polyMetaAnno.value().getCanonicalName();\n+                if (nameToQualifierKind.containsKey(topName)) {\n+                    qualifierKind.top = nameToQualifierKind.get(topName);\n+                } else if (topName.equals(PolymorphicQualifier.class.getCanonicalName())) {\n+                    if (tops.size() == 1) {\n+                        qualifierKind.top = tops.iterator().next();\n+                    } else {\n+                        throw new UserError(\n+                                \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                                qualifierKind, SystemUtil.join(\", \", tops));\n+                    }\n+                } else {\n+                    throw new UserError(\n+                            \"polymorphic qualifier %s's top $s is not a supported qualifier. Found: %s.\",\n+                            qualifierKind, topName);\n+                }\n+                topToPoly.put(qualifierKind.top, qualifierKind);\n+            }\n+        }\n+        return topToPoly;\n+    }\n+\n+    /**\n+     * For each qualifier in {@code directSuperMap}, initializes {@link QualifierKind#superTypes},\n+     * {@link QualifierKind#top} and {@link QualifierKind#bottom}. (Requires tops, bottoms, and\n+     * polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; created by {@link #createDirectSuperMap()}\n+     * @throws UserError if a qualifier isn't a subtype of one of the top qualifiers or if multiple\n+     *     tops or bottoms are found for the same hierarchy.\n+     */\n+    protected void initializeQualifierKindFields(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            if (qualifierKind.isPoly) {\n+                qualifierKind.superTypes = new TreeSet<>();\n+                qualifierKind.superTypes.add(qualifierKind.top);\n+            } else {\n+                qualifierKind.superTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;\n+                    } else if (qualifierKind.top != top) {\n+                        throw new UserError(\n+                                \"Multiple tops found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, top, qualifierKind.top);\n+                    }\n+                }\n+            }\n+            if (qualifierKind.top == null) {\n+                throw new UserError(\"Qualifier isn't in hierarchy: %s\", qualifierKind);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind bot : bottoms) {\n+                if (bot.top != qualifierKind.top) {\n+                    continue;\n+                }\n+                if (qualifierKind.bottom == null) {\n+                    qualifierKind.bottom = bot;\n+                } else if (qualifierKind.top != bot) {\n+                    throw new UserError(\n+                            \"Multiple bottoms found for qualifier %s. Tops: %s and %s.\",\n+                            qualifierKind, bot, qualifierKind.bottom);\n+                }\n+                if (qualifierKind.isPoly) {\n+                    bot.superTypes.add(qualifierKind);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the set of all qualifiers that are a supertype of {@code qualifierKind}.\n+     *\n+     * @param qualifierKind the qualifier whose super types should be returned\n+     * @param directSuperMap directSuperMap\n+     * @return the set of all qualifiers that are a supertype of {@code qualifierKind}\n+     * @throws UserError if there is a cycle in the hierarchy\n+     */\n+    private Set<QualifierKind> findAllTheSupers(\n+            QualifierKind qualifierKind, Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Queue<QualifierKind> queue = new ArrayDeque<>(directSuperMap.get(qualifierKind));\n+        Set<QualifierKind> allSupers = new TreeSet<>(directSuperMap.get(qualifierKind));\n+        while (!queue.isEmpty()) {\n+            QualifierKind superQual = queue.remove();\n+            if (superQual == qualifierKind) {\n+                throw new UserError(\"Cycle in hierarchy: %s\", qualifierKind);\n+            }\n+            queue.addAll(directSuperMap.get(superQual));\n+            allSupers.addAll(directSuperMap.get(superQual));\n+        }\n+        return allSupers;\n+    }\n+\n+    /**\n+     * Creates a mapping from {@link QualifierKindPair} to the least upper bound of both\n+     * QualifierKinds.\n+     *\n+     * @return a mapping from {@link QualifierKindPair} to their lub.\n+     */\n+    protected Map<QualifierKindPair, QualifierKind> createLubsMap() {\n+        Map<QualifierKindPair, QualifierKind> lubs = new TreeMap<>();\n+        for (QualifierKind qual1 : nameToQualifierKind.values()) {\n+            for (QualifierKind qual2 : nameToQualifierKind.values()) {\n+                if (qual1.top != qual2.top) {\n+                    continue;\n+                }\n+                QualifierKind lub = findLub(qual1, qual2);\n+                QualifierKindPair pair = new QualifierKindPair(qual1, qual2);\n+                QualifierKind otherLub = lubs.get(pair);\n+                if (otherLub != null) {\n+                    if (otherLub != lub) {\n+                        throw new BugInCF(\n+                                \"Multiple lubs for qualifiers %s and %s. Found lubs %s and %s\",\n+                                qual1, qual2, lub, otherLub);\n+                    }\n+                } else {\n+                    lubs.put(pair, lub);\n+                }\n+            }\n+        }\n+        return lubs;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code qual1} and {@code qual2}.\n+     *\n+     * @param qual1 a qualifier kind\n+     * @param qual2 a qualifier kind\n+     * @return the least upper bound of {@code qual1} and {@code qual2}\n+     */\n+    private QualifierKind findLub(QualifierKind qual1, QualifierKind qual2) {\n+        if (qual1 == qual2) {\n+            return qual1;\n+        } else if (qual1.isSubtype(qual2)) {\n+            return qual2;\n+        } else if (qual2.isSubtype(qual1)) {\n+            return qual1;\n+        }\n+        Set<QualifierKind> allSuperTypes = new TreeSet<>(qual1.superTypes);\n+        allSuperTypes.retainAll(qual2.superTypes);\n+        Set<QualifierKind> lubs = findLowestQualifiers(allSuperTypes);\n+        if (lubs.size() != 1) {\n+            throw new BugInCF(\n+                    \"Not exactly 1 lub for %s and %s. Found lubs: [%s].\",\n+                    qual1, qual2, SystemUtil.join(\", \", lubs));\n+        }\n+        QualifierKind lub = lubs.iterator().next();\n+        if (lub.isPoly && !qual1.isPoly && !qual2.isPoly) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1ea0737d154fc21b64cdfca2c0683b74731816d"}, "originalPosition": 653}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzA2OTI2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNToyMjowM1rOGr91tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQyMjo0NDoyNVrOGtFWlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc1NTEyNg==", "bodyText": "I don't understand what \"[]\" means in this comment (and in other similar comments).", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r448755126", "createdAt": "2020-07-02T05:22:03Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A qualifier hierarchy where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>Subclasses must implement {@link #isSubtype(AnnotationMirror, QualifierKind, AnnotationMirror,\n+ * QualifierKind)}, {@link #leastUpperBound(AnnotationMirror, QualifierKind, AnnotationMirror,\n+ * QualifierKind)}, and {@link #greatestLowerBound(AnnotationMirror, QualifierKind,\n+ * AnnotationMirror, QualifierKind)} for cases when the annotations have elements. For cases where\n+ * the annotations have no elements, the {@link org.checkerframework.framework.qual.SubtypeOf}\n+ * meta-annotation is used.\n+ *\n+ * <p>ComplexQualifierHierarchy uses a {@link QualifierKindHierarchy} to model the relationships\n+ * between qualifiers. Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to\n+ * return a subclass of QualifierKindHierarchy.\n+ */\n+public abstract class ComplexQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils} */\n+    private Elements elements;\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** A mapping from top QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> topsMap;\n+\n+    /** The set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** A mapping from bottom QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> bottomsMap;\n+\n+    /** The set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /**\n+     * A mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations do not\n+     * have elements.\n+     */\n+    protected final Map<QualifierKind, AnnotationMirror> qualifierMap;\n+\n+    /**\n+     * Creates a type hierarchy from the given classes.\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers for this hierarchy\n+     * @param elements element utils\n+     */\n+    protected ComplexQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.elements = elements;\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.topsMap = Collections.unmodifiableMap(createTops());\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        tops.addAll(topsMap.values());\n+        this.tops = Collections.unmodifiableSet(tops);\n+\n+        this.bottomsMap = Collections.unmodifiableMap(createBottoms());\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        bottoms.addAll(bottomsMap.values());\n+        this.bottoms = Collections.unmodifiableSet(bottoms);\n+        this.qualifierMap = createQualifiers();\n+\n+        for (AnnotationMirror top : tops) {\n+            // This throws an error if poly is a qualifier that has an element.\n+            getPolymorphicAnnotation(top);\n+        }\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers for this hierarchy\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations\n+     * do not have elements.\n+     *\n+     * @return the mapping\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createQualifiers() {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (!kind.hasElements()) {\n+                quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+            }\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top.\n+     *\n+     * <p>Subclasses must override this if the top annotation has elements and provides not default.\n+     *\n+     * @return a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createTops() {\n+        Map<QualifierKind, AnnotationMirror> topsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getTops()) {\n+            topsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return topsMap;\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom.\n+     *\n+     * <p>Subclasses must override this if the bottom annotation has elements and provides not\n+     * default.\n+     *\n+     * @return a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createBottoms() {\n+        Map<QualifierKind, AnnotationMirror> bottomsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getBottoms()) {\n+            bottomsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return bottomsMap;\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the given annotation.\n+     *\n+     * @param anno annotation mirror\n+     * @return the qualifier kind for the given annotation\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        return getQualifierKind(name);\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the annotation with the fully qualified name {@code name}.\n+     *\n+     * @param name fully qualified annotation name\n+     * @return the qualifier kind for the annotation with {@code name}\n+     */\n+    protected QualifierKind getQualifierKind(String name) {\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"QualifierKind not in hierarchy: %s\", name);\n+        }\n+        return kind;\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getTopAnnotations() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public AnnotationMirror getTopAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return topsMap.get(kind.getTop());\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getBottomAnnotations() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    public AnnotationMirror getPolymorphicAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        QualifierKind poly = qualifierKindHierarchy.getTopToPoly().get(kind);\n+        if (poly == null) {\n+            return null;\n+        }\n+        if (qualifierMap.containsKey(poly)) {\n+            return qualifierMap.get(poly);\n+        } else {\n+            throw new BugInCF(\n+                    \"Poly has an element. Override ComplexQualifierHierarchy#getPolymorphicAnnotation. Poly: %s\",\n+                    poly);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isPolymorphicQualifier(AnnotationMirror qualifier) {\n+        return getQualifierKind(qualifier).isPoly();\n+    }\n+\n+    @Override\n+    public AnnotationMirror getBottomAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return bottomsMap.get(kind.getBottom());\n+    }\n+\n+    @Override\n+    public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        QualifierKind subKind = getQualifierKind(subAnno);\n+        QualifierKind superKind = getQualifierKind(superAnno);\n+        if (subKind.isSubtype(superKind)) {\n+            if (superKind.hasElements() && subKind.hasElements()) {\n+                return isSubtype(subAnno, subKind, superAnno, superKind);\n+            } else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns whether or not {@code subAnno} is a subtype of {@code superAnno}. Both {@code\n+     * subAnno} and {@code superAnno} are annotations with elements.\n+     *\n+     * @param subAnno possible subtype annotation; has elements\n+     * @param subKind QualifierKind of{@code subAnno}\n+     * @param superAnno possible super annotation; has elements\n+     * @param superKind QualifierKind of{@code superAnno}\n+     * @return whether or not {@code subAnno} is a subtype of {@code superAnno}\n+     */\n+    protected abstract boolean isSubtype(\n+            AnnotationMirror subAnno,\n+            QualifierKind subKind,\n+            AnnotationMirror superAnno,\n+            QualifierKind superKind);\n+\n+    @Override\n+    public boolean isSubtype(\n+            Collection<? extends AnnotationMirror> subAnnos,\n+            Collection<? extends AnnotationMirror> superAnnos) {\n+        int isSubtypeCount = 0;\n+        for (AnnotationMirror subAnno : subAnnos) {\n+            QualifierKind subKind = getQualifierKind(subAnno);\n+            for (AnnotationMirror superAnno : superAnnos) {\n+                QualifierKind superKind = getQualifierKind(superAnno);\n+                if (subKind.areInSameHierarchy(superKind)) {\n+                    if (isSubtype(subAnno, superAnno)) {\n+                        isSubtypeCount++;\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return isSubtypeCount == superAnnos.size();\n+    }\n+\n+    @Override\n+    public AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2) {\n+        QualifierKind qual1 = getQualifierKind(a1);\n+        QualifierKind qual2 = getQualifierKind(a2);\n+        if (!qual1.areInSameHierarchy(qual2)) {\n+            return null;\n+        }\n+        QualifierKind lub = qualifierKindHierarchy.leastUpperBound(qual1, qual2);\n+        if (lub.hasElements()) {\n+            return leastUpperBound(a1, qual1, a2, qual2);\n+        }\n+        return qualifierMap.get(lub);\n+    }\n+\n+    /**\n+     * Returns the least upper bound between {@code a1} and {@code a2}.\n+     *\n+     * <p>This method is only called when the lub is an annotation with elements.\n+     *\n+     * @param a1 first annotation\n+     * @param qual1 QualifierKind for {@code a1}\n+     * @param a2 second annotation\n+     * @param qual2 QualifierKind for {@code a2}\n+     * @return the least upper bound between {@code a1} and {@code a2}.\n+     */\n+    protected abstract AnnotationMirror leastUpperBound(\n+            AnnotationMirror a1, QualifierKind qual1, AnnotationMirror a2, QualifierKind qual2);\n+\n+    @Override\n+    public AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2) {\n+        QualifierKind qual1 = getQualifierKind(a1);\n+        QualifierKind qual2 = getQualifierKind(a2);\n+        if (!qual1.areInSameHierarchy(qual2)) {\n+            return null;\n+        }\n+        QualifierKind glb = qualifierKindHierarchy.greatestLowerBound(qual1, qual2);\n+        if (glb.hasElements()) {\n+            return greatestLowerBound(a1, qual1, a2, qual2);\n+        }\n+        return qualifierMap.get(glb);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound between {@code a1} and {@code a2}.\n+     *\n+     * <p>This method is only called when the glb is an annotation with elements.\n+     *\n+     * @param a1 first annotation\n+     * @param qual1 QualifierKind for {@code a1}\n+     * @param a2 second annotation\n+     * @param qual2 QualifierKind for {@code a2}\n+     * @return the greatest lower bound between {@code a1} and {@code a2}.\n+     */\n+    protected abstract AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, QualifierKind qual1, AnnotationMirror a2, QualifierKind qual2);\n+\n+    @Override\n+    public boolean isSubtypeTypeVariable(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        if (superAnno == null) {\n+            // [] is a supertype of any qualifier, and [] <: []", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc14d48ffcf7bc92ae52117ad5717ccaf38049b"}, "originalPosition": 322}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkyNjgwNQ==", "bodyText": "Ping on this comment.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r449926805", "createdAt": "2020-07-05T22:44:25Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A qualifier hierarchy where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>Subclasses must implement {@link #isSubtype(AnnotationMirror, QualifierKind, AnnotationMirror,\n+ * QualifierKind)}, {@link #leastUpperBound(AnnotationMirror, QualifierKind, AnnotationMirror,\n+ * QualifierKind)}, and {@link #greatestLowerBound(AnnotationMirror, QualifierKind,\n+ * AnnotationMirror, QualifierKind)} for cases when the annotations have elements. For cases where\n+ * the annotations have no elements, the {@link org.checkerframework.framework.qual.SubtypeOf}\n+ * meta-annotation is used.\n+ *\n+ * <p>ComplexQualifierHierarchy uses a {@link QualifierKindHierarchy} to model the relationships\n+ * between qualifiers. Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to\n+ * return a subclass of QualifierKindHierarchy.\n+ */\n+public abstract class ComplexQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils} */\n+    private Elements elements;\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** A mapping from top QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> topsMap;\n+\n+    /** The set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** A mapping from bottom QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> bottomsMap;\n+\n+    /** The set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /**\n+     * A mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations do not\n+     * have elements.\n+     */\n+    protected final Map<QualifierKind, AnnotationMirror> qualifierMap;\n+\n+    /**\n+     * Creates a type hierarchy from the given classes.\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers for this hierarchy\n+     * @param elements element utils\n+     */\n+    protected ComplexQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.elements = elements;\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.topsMap = Collections.unmodifiableMap(createTops());\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        tops.addAll(topsMap.values());\n+        this.tops = Collections.unmodifiableSet(tops);\n+\n+        this.bottomsMap = Collections.unmodifiableMap(createBottoms());\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        bottoms.addAll(bottomsMap.values());\n+        this.bottoms = Collections.unmodifiableSet(bottoms);\n+        this.qualifierMap = createQualifiers();\n+\n+        for (AnnotationMirror top : tops) {\n+            // This throws an error if poly is a qualifier that has an element.\n+            getPolymorphicAnnotation(top);\n+        }\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers for this hierarchy\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations\n+     * do not have elements.\n+     *\n+     * @return the mapping\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createQualifiers() {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (!kind.hasElements()) {\n+                quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+            }\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top.\n+     *\n+     * <p>Subclasses must override this if the top annotation has elements and provides not default.\n+     *\n+     * @return a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createTops() {\n+        Map<QualifierKind, AnnotationMirror> topsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getTops()) {\n+            topsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return topsMap;\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom.\n+     *\n+     * <p>Subclasses must override this if the bottom annotation has elements and provides not\n+     * default.\n+     *\n+     * @return a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createBottoms() {\n+        Map<QualifierKind, AnnotationMirror> bottomsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getBottoms()) {\n+            bottomsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return bottomsMap;\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the given annotation.\n+     *\n+     * @param anno annotation mirror\n+     * @return the qualifier kind for the given annotation\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        return getQualifierKind(name);\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the annotation with the fully qualified name {@code name}.\n+     *\n+     * @param name fully qualified annotation name\n+     * @return the qualifier kind for the annotation with {@code name}\n+     */\n+    protected QualifierKind getQualifierKind(String name) {\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"QualifierKind not in hierarchy: %s\", name);\n+        }\n+        return kind;\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getTopAnnotations() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public AnnotationMirror getTopAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return topsMap.get(kind.getTop());\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getBottomAnnotations() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    public AnnotationMirror getPolymorphicAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        QualifierKind poly = qualifierKindHierarchy.getTopToPoly().get(kind);\n+        if (poly == null) {\n+            return null;\n+        }\n+        if (qualifierMap.containsKey(poly)) {\n+            return qualifierMap.get(poly);\n+        } else {\n+            throw new BugInCF(\n+                    \"Poly has an element. Override ComplexQualifierHierarchy#getPolymorphicAnnotation. Poly: %s\",\n+                    poly);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isPolymorphicQualifier(AnnotationMirror qualifier) {\n+        return getQualifierKind(qualifier).isPoly();\n+    }\n+\n+    @Override\n+    public AnnotationMirror getBottomAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return bottomsMap.get(kind.getBottom());\n+    }\n+\n+    @Override\n+    public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        QualifierKind subKind = getQualifierKind(subAnno);\n+        QualifierKind superKind = getQualifierKind(superAnno);\n+        if (subKind.isSubtype(superKind)) {\n+            if (superKind.hasElements() && subKind.hasElements()) {\n+                return isSubtype(subAnno, subKind, superAnno, superKind);\n+            } else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns whether or not {@code subAnno} is a subtype of {@code superAnno}. Both {@code\n+     * subAnno} and {@code superAnno} are annotations with elements.\n+     *\n+     * @param subAnno possible subtype annotation; has elements\n+     * @param subKind QualifierKind of{@code subAnno}\n+     * @param superAnno possible super annotation; has elements\n+     * @param superKind QualifierKind of{@code superAnno}\n+     * @return whether or not {@code subAnno} is a subtype of {@code superAnno}\n+     */\n+    protected abstract boolean isSubtype(\n+            AnnotationMirror subAnno,\n+            QualifierKind subKind,\n+            AnnotationMirror superAnno,\n+            QualifierKind superKind);\n+\n+    @Override\n+    public boolean isSubtype(\n+            Collection<? extends AnnotationMirror> subAnnos,\n+            Collection<? extends AnnotationMirror> superAnnos) {\n+        int isSubtypeCount = 0;\n+        for (AnnotationMirror subAnno : subAnnos) {\n+            QualifierKind subKind = getQualifierKind(subAnno);\n+            for (AnnotationMirror superAnno : superAnnos) {\n+                QualifierKind superKind = getQualifierKind(superAnno);\n+                if (subKind.areInSameHierarchy(superKind)) {\n+                    if (isSubtype(subAnno, superAnno)) {\n+                        isSubtypeCount++;\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return isSubtypeCount == superAnnos.size();\n+    }\n+\n+    @Override\n+    public AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2) {\n+        QualifierKind qual1 = getQualifierKind(a1);\n+        QualifierKind qual2 = getQualifierKind(a2);\n+        if (!qual1.areInSameHierarchy(qual2)) {\n+            return null;\n+        }\n+        QualifierKind lub = qualifierKindHierarchy.leastUpperBound(qual1, qual2);\n+        if (lub.hasElements()) {\n+            return leastUpperBound(a1, qual1, a2, qual2);\n+        }\n+        return qualifierMap.get(lub);\n+    }\n+\n+    /**\n+     * Returns the least upper bound between {@code a1} and {@code a2}.\n+     *\n+     * <p>This method is only called when the lub is an annotation with elements.\n+     *\n+     * @param a1 first annotation\n+     * @param qual1 QualifierKind for {@code a1}\n+     * @param a2 second annotation\n+     * @param qual2 QualifierKind for {@code a2}\n+     * @return the least upper bound between {@code a1} and {@code a2}.\n+     */\n+    protected abstract AnnotationMirror leastUpperBound(\n+            AnnotationMirror a1, QualifierKind qual1, AnnotationMirror a2, QualifierKind qual2);\n+\n+    @Override\n+    public AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2) {\n+        QualifierKind qual1 = getQualifierKind(a1);\n+        QualifierKind qual2 = getQualifierKind(a2);\n+        if (!qual1.areInSameHierarchy(qual2)) {\n+            return null;\n+        }\n+        QualifierKind glb = qualifierKindHierarchy.greatestLowerBound(qual1, qual2);\n+        if (glb.hasElements()) {\n+            return greatestLowerBound(a1, qual1, a2, qual2);\n+        }\n+        return qualifierMap.get(glb);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound between {@code a1} and {@code a2}.\n+     *\n+     * <p>This method is only called when the glb is an annotation with elements.\n+     *\n+     * @param a1 first annotation\n+     * @param qual1 QualifierKind for {@code a1}\n+     * @param a2 second annotation\n+     * @param qual2 QualifierKind for {@code a2}\n+     * @return the greatest lower bound between {@code a1} and {@code a2}.\n+     */\n+    protected abstract AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, QualifierKind qual1, AnnotationMirror a2, QualifierKind qual2);\n+\n+    @Override\n+    public boolean isSubtypeTypeVariable(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        if (superAnno == null) {\n+            // [] is a supertype of any qualifier, and [] <: []", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc1NTEyNg=="}, "originalCommit": {"oid": "1bc14d48ffcf7bc92ae52117ad5717ccaf38049b"}, "originalPosition": 322}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzA3MDg4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNToyMzowM1rOGr92rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQyMjo0Mzo1MVrOGtFWag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc1NTM3NA==", "bodyText": "It is more efficient to break; right after this increment operation.\n(Alternately, you could abstract out the inner loop into a separate method, and there would be no need for a count variable.  It might be a bit less efficient because of the method calls, but would be more efficient in being able to exit early rather than checking all type hierarchies.)\nSame comment applies in 3 other places in the pull request.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r448755374", "createdAt": "2020-07-02T05:23:03Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A qualifier hierarchy where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>Subclasses must implement {@link #isSubtype(AnnotationMirror, QualifierKind, AnnotationMirror,\n+ * QualifierKind)}, {@link #leastUpperBound(AnnotationMirror, QualifierKind, AnnotationMirror,\n+ * QualifierKind)}, and {@link #greatestLowerBound(AnnotationMirror, QualifierKind,\n+ * AnnotationMirror, QualifierKind)} for cases when the annotations have elements. For cases where\n+ * the annotations have no elements, the {@link org.checkerframework.framework.qual.SubtypeOf}\n+ * meta-annotation is used.\n+ *\n+ * <p>ComplexQualifierHierarchy uses a {@link QualifierKindHierarchy} to model the relationships\n+ * between qualifiers. Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to\n+ * return a subclass of QualifierKindHierarchy.\n+ */\n+public abstract class ComplexQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils} */\n+    private Elements elements;\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** A mapping from top QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> topsMap;\n+\n+    /** The set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** A mapping from bottom QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> bottomsMap;\n+\n+    /** The set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /**\n+     * A mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations do not\n+     * have elements.\n+     */\n+    protected final Map<QualifierKind, AnnotationMirror> qualifierMap;\n+\n+    /**\n+     * Creates a type hierarchy from the given classes.\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers for this hierarchy\n+     * @param elements element utils\n+     */\n+    protected ComplexQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.elements = elements;\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.topsMap = Collections.unmodifiableMap(createTops());\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        tops.addAll(topsMap.values());\n+        this.tops = Collections.unmodifiableSet(tops);\n+\n+        this.bottomsMap = Collections.unmodifiableMap(createBottoms());\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        bottoms.addAll(bottomsMap.values());\n+        this.bottoms = Collections.unmodifiableSet(bottoms);\n+        this.qualifierMap = createQualifiers();\n+\n+        for (AnnotationMirror top : tops) {\n+            // This throws an error if poly is a qualifier that has an element.\n+            getPolymorphicAnnotation(top);\n+        }\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers for this hierarchy\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations\n+     * do not have elements.\n+     *\n+     * @return the mapping\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createQualifiers() {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (!kind.hasElements()) {\n+                quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+            }\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top.\n+     *\n+     * <p>Subclasses must override this if the top annotation has elements and provides not default.\n+     *\n+     * @return a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createTops() {\n+        Map<QualifierKind, AnnotationMirror> topsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getTops()) {\n+            topsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return topsMap;\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom.\n+     *\n+     * <p>Subclasses must override this if the bottom annotation has elements and provides not\n+     * default.\n+     *\n+     * @return a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createBottoms() {\n+        Map<QualifierKind, AnnotationMirror> bottomsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getBottoms()) {\n+            bottomsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return bottomsMap;\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the given annotation.\n+     *\n+     * @param anno annotation mirror\n+     * @return the qualifier kind for the given annotation\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        return getQualifierKind(name);\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the annotation with the fully qualified name {@code name}.\n+     *\n+     * @param name fully qualified annotation name\n+     * @return the qualifier kind for the annotation with {@code name}\n+     */\n+    protected QualifierKind getQualifierKind(String name) {\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"QualifierKind not in hierarchy: %s\", name);\n+        }\n+        return kind;\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getTopAnnotations() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public AnnotationMirror getTopAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return topsMap.get(kind.getTop());\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getBottomAnnotations() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    public AnnotationMirror getPolymorphicAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        QualifierKind poly = qualifierKindHierarchy.getTopToPoly().get(kind);\n+        if (poly == null) {\n+            return null;\n+        }\n+        if (qualifierMap.containsKey(poly)) {\n+            return qualifierMap.get(poly);\n+        } else {\n+            throw new BugInCF(\n+                    \"Poly has an element. Override ComplexQualifierHierarchy#getPolymorphicAnnotation. Poly: %s\",\n+                    poly);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isPolymorphicQualifier(AnnotationMirror qualifier) {\n+        return getQualifierKind(qualifier).isPoly();\n+    }\n+\n+    @Override\n+    public AnnotationMirror getBottomAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return bottomsMap.get(kind.getBottom());\n+    }\n+\n+    @Override\n+    public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        QualifierKind subKind = getQualifierKind(subAnno);\n+        QualifierKind superKind = getQualifierKind(superAnno);\n+        if (subKind.isSubtype(superKind)) {\n+            if (superKind.hasElements() && subKind.hasElements()) {\n+                return isSubtype(subAnno, subKind, superAnno, superKind);\n+            } else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns whether or not {@code subAnno} is a subtype of {@code superAnno}. Both {@code\n+     * subAnno} and {@code superAnno} are annotations with elements.\n+     *\n+     * @param subAnno possible subtype annotation; has elements\n+     * @param subKind QualifierKind of{@code subAnno}\n+     * @param superAnno possible super annotation; has elements\n+     * @param superKind QualifierKind of{@code superAnno}\n+     * @return whether or not {@code subAnno} is a subtype of {@code superAnno}\n+     */\n+    protected abstract boolean isSubtype(\n+            AnnotationMirror subAnno,\n+            QualifierKind subKind,\n+            AnnotationMirror superAnno,\n+            QualifierKind superKind);\n+\n+    @Override\n+    public boolean isSubtype(\n+            Collection<? extends AnnotationMirror> subAnnos,\n+            Collection<? extends AnnotationMirror> superAnnos) {\n+        int isSubtypeCount = 0;\n+        for (AnnotationMirror subAnno : subAnnos) {\n+            QualifierKind subKind = getQualifierKind(subAnno);\n+            for (AnnotationMirror superAnno : superAnnos) {\n+                QualifierKind superKind = getQualifierKind(superAnno);\n+                if (subKind.areInSameHierarchy(superKind)) {\n+                    if (isSubtype(subAnno, superAnno)) {\n+                        isSubtypeCount++;\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return isSubtypeCount == superAnnos.size();\n+    }\n+\n+    @Override\n+    public AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2) {\n+        QualifierKind qual1 = getQualifierKind(a1);\n+        QualifierKind qual2 = getQualifierKind(a2);\n+        if (!qual1.areInSameHierarchy(qual2)) {\n+            return null;\n+        }\n+        QualifierKind lub = qualifierKindHierarchy.leastUpperBound(qual1, qual2);\n+        if (lub.hasElements()) {\n+            return leastUpperBound(a1, qual1, a2, qual2);\n+        }\n+        return qualifierMap.get(lub);\n+    }\n+\n+    /**\n+     * Returns the least upper bound between {@code a1} and {@code a2}.\n+     *\n+     * <p>This method is only called when the lub is an annotation with elements.\n+     *\n+     * @param a1 first annotation\n+     * @param qual1 QualifierKind for {@code a1}\n+     * @param a2 second annotation\n+     * @param qual2 QualifierKind for {@code a2}\n+     * @return the least upper bound between {@code a1} and {@code a2}.\n+     */\n+    protected abstract AnnotationMirror leastUpperBound(\n+            AnnotationMirror a1, QualifierKind qual1, AnnotationMirror a2, QualifierKind qual2);\n+\n+    @Override\n+    public AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2) {\n+        QualifierKind qual1 = getQualifierKind(a1);\n+        QualifierKind qual2 = getQualifierKind(a2);\n+        if (!qual1.areInSameHierarchy(qual2)) {\n+            return null;\n+        }\n+        QualifierKind glb = qualifierKindHierarchy.greatestLowerBound(qual1, qual2);\n+        if (glb.hasElements()) {\n+            return greatestLowerBound(a1, qual1, a2, qual2);\n+        }\n+        return qualifierMap.get(glb);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound between {@code a1} and {@code a2}.\n+     *\n+     * <p>This method is only called when the glb is an annotation with elements.\n+     *\n+     * @param a1 first annotation\n+     * @param qual1 QualifierKind for {@code a1}\n+     * @param a2 second annotation\n+     * @param qual2 QualifierKind for {@code a2}\n+     * @return the greatest lower bound between {@code a1} and {@code a2}.\n+     */\n+    protected abstract AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, QualifierKind qual1, AnnotationMirror a2, QualifierKind qual2);\n+\n+    @Override\n+    public boolean isSubtypeTypeVariable(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        if (superAnno == null) {\n+            // [] is a supertype of any qualifier, and [] <: []\n+            return true;\n+        }\n+        if (subAnno == null) {\n+            // [] is a subtype of no qualifier (only [])\n+            return false;\n+        }\n+        return isSubtype(subAnno, superAnno);\n+    }\n+\n+    @Override\n+    public boolean isSubtypeTypeVariable(\n+            Collection<? extends AnnotationMirror> subAnnos,\n+            Collection<? extends AnnotationMirror> superAnnos) {\n+        int isSubtypeCount = 0;\n+        for (AnnotationMirror subAnno : subAnnos) {\n+            QualifierKind subKind = getQualifierKind(subAnno);\n+            for (AnnotationMirror superAnno : superAnnos) {\n+                QualifierKind superKind = getQualifierKind(superAnno);\n+                if (subKind.areInSameHierarchy(superKind)) {\n+                    if (isSubtype(subAnno, superAnno)) {\n+                        isSubtypeCount++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc14d48ffcf7bc92ae52117ad5717ccaf38049b"}, "originalPosition": 343}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkyNjc2Mg==", "bodyText": "Ping on this comment.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r449926762", "createdAt": "2020-07-05T22:43:51Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A qualifier hierarchy where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>Subclasses must implement {@link #isSubtype(AnnotationMirror, QualifierKind, AnnotationMirror,\n+ * QualifierKind)}, {@link #leastUpperBound(AnnotationMirror, QualifierKind, AnnotationMirror,\n+ * QualifierKind)}, and {@link #greatestLowerBound(AnnotationMirror, QualifierKind,\n+ * AnnotationMirror, QualifierKind)} for cases when the annotations have elements. For cases where\n+ * the annotations have no elements, the {@link org.checkerframework.framework.qual.SubtypeOf}\n+ * meta-annotation is used.\n+ *\n+ * <p>ComplexQualifierHierarchy uses a {@link QualifierKindHierarchy} to model the relationships\n+ * between qualifiers. Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to\n+ * return a subclass of QualifierKindHierarchy.\n+ */\n+public abstract class ComplexQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils} */\n+    private Elements elements;\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** A mapping from top QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> topsMap;\n+\n+    /** The set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** A mapping from bottom QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> bottomsMap;\n+\n+    /** The set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /**\n+     * A mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations do not\n+     * have elements.\n+     */\n+    protected final Map<QualifierKind, AnnotationMirror> qualifierMap;\n+\n+    /**\n+     * Creates a type hierarchy from the given classes.\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers for this hierarchy\n+     * @param elements element utils\n+     */\n+    protected ComplexQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.elements = elements;\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.topsMap = Collections.unmodifiableMap(createTops());\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        tops.addAll(topsMap.values());\n+        this.tops = Collections.unmodifiableSet(tops);\n+\n+        this.bottomsMap = Collections.unmodifiableMap(createBottoms());\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        bottoms.addAll(bottomsMap.values());\n+        this.bottoms = Collections.unmodifiableSet(bottoms);\n+        this.qualifierMap = createQualifiers();\n+\n+        for (AnnotationMirror top : tops) {\n+            // This throws an error if poly is a qualifier that has an element.\n+            getPolymorphicAnnotation(top);\n+        }\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers for this hierarchy\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations\n+     * do not have elements.\n+     *\n+     * @return the mapping\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createQualifiers() {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (!kind.hasElements()) {\n+                quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+            }\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top.\n+     *\n+     * <p>Subclasses must override this if the top annotation has elements and provides not default.\n+     *\n+     * @return a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createTops() {\n+        Map<QualifierKind, AnnotationMirror> topsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getTops()) {\n+            topsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return topsMap;\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom.\n+     *\n+     * <p>Subclasses must override this if the bottom annotation has elements and provides not\n+     * default.\n+     *\n+     * @return a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createBottoms() {\n+        Map<QualifierKind, AnnotationMirror> bottomsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getBottoms()) {\n+            bottomsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return bottomsMap;\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the given annotation.\n+     *\n+     * @param anno annotation mirror\n+     * @return the qualifier kind for the given annotation\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        return getQualifierKind(name);\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the annotation with the fully qualified name {@code name}.\n+     *\n+     * @param name fully qualified annotation name\n+     * @return the qualifier kind for the annotation with {@code name}\n+     */\n+    protected QualifierKind getQualifierKind(String name) {\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"QualifierKind not in hierarchy: %s\", name);\n+        }\n+        return kind;\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getTopAnnotations() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public AnnotationMirror getTopAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return topsMap.get(kind.getTop());\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getBottomAnnotations() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    public AnnotationMirror getPolymorphicAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        QualifierKind poly = qualifierKindHierarchy.getTopToPoly().get(kind);\n+        if (poly == null) {\n+            return null;\n+        }\n+        if (qualifierMap.containsKey(poly)) {\n+            return qualifierMap.get(poly);\n+        } else {\n+            throw new BugInCF(\n+                    \"Poly has an element. Override ComplexQualifierHierarchy#getPolymorphicAnnotation. Poly: %s\",\n+                    poly);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isPolymorphicQualifier(AnnotationMirror qualifier) {\n+        return getQualifierKind(qualifier).isPoly();\n+    }\n+\n+    @Override\n+    public AnnotationMirror getBottomAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return bottomsMap.get(kind.getBottom());\n+    }\n+\n+    @Override\n+    public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        QualifierKind subKind = getQualifierKind(subAnno);\n+        QualifierKind superKind = getQualifierKind(superAnno);\n+        if (subKind.isSubtype(superKind)) {\n+            if (superKind.hasElements() && subKind.hasElements()) {\n+                return isSubtype(subAnno, subKind, superAnno, superKind);\n+            } else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns whether or not {@code subAnno} is a subtype of {@code superAnno}. Both {@code\n+     * subAnno} and {@code superAnno} are annotations with elements.\n+     *\n+     * @param subAnno possible subtype annotation; has elements\n+     * @param subKind QualifierKind of{@code subAnno}\n+     * @param superAnno possible super annotation; has elements\n+     * @param superKind QualifierKind of{@code superAnno}\n+     * @return whether or not {@code subAnno} is a subtype of {@code superAnno}\n+     */\n+    protected abstract boolean isSubtype(\n+            AnnotationMirror subAnno,\n+            QualifierKind subKind,\n+            AnnotationMirror superAnno,\n+            QualifierKind superKind);\n+\n+    @Override\n+    public boolean isSubtype(\n+            Collection<? extends AnnotationMirror> subAnnos,\n+            Collection<? extends AnnotationMirror> superAnnos) {\n+        int isSubtypeCount = 0;\n+        for (AnnotationMirror subAnno : subAnnos) {\n+            QualifierKind subKind = getQualifierKind(subAnno);\n+            for (AnnotationMirror superAnno : superAnnos) {\n+                QualifierKind superKind = getQualifierKind(superAnno);\n+                if (subKind.areInSameHierarchy(superKind)) {\n+                    if (isSubtype(subAnno, superAnno)) {\n+                        isSubtypeCount++;\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return isSubtypeCount == superAnnos.size();\n+    }\n+\n+    @Override\n+    public AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2) {\n+        QualifierKind qual1 = getQualifierKind(a1);\n+        QualifierKind qual2 = getQualifierKind(a2);\n+        if (!qual1.areInSameHierarchy(qual2)) {\n+            return null;\n+        }\n+        QualifierKind lub = qualifierKindHierarchy.leastUpperBound(qual1, qual2);\n+        if (lub.hasElements()) {\n+            return leastUpperBound(a1, qual1, a2, qual2);\n+        }\n+        return qualifierMap.get(lub);\n+    }\n+\n+    /**\n+     * Returns the least upper bound between {@code a1} and {@code a2}.\n+     *\n+     * <p>This method is only called when the lub is an annotation with elements.\n+     *\n+     * @param a1 first annotation\n+     * @param qual1 QualifierKind for {@code a1}\n+     * @param a2 second annotation\n+     * @param qual2 QualifierKind for {@code a2}\n+     * @return the least upper bound between {@code a1} and {@code a2}.\n+     */\n+    protected abstract AnnotationMirror leastUpperBound(\n+            AnnotationMirror a1, QualifierKind qual1, AnnotationMirror a2, QualifierKind qual2);\n+\n+    @Override\n+    public AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2) {\n+        QualifierKind qual1 = getQualifierKind(a1);\n+        QualifierKind qual2 = getQualifierKind(a2);\n+        if (!qual1.areInSameHierarchy(qual2)) {\n+            return null;\n+        }\n+        QualifierKind glb = qualifierKindHierarchy.greatestLowerBound(qual1, qual2);\n+        if (glb.hasElements()) {\n+            return greatestLowerBound(a1, qual1, a2, qual2);\n+        }\n+        return qualifierMap.get(glb);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound between {@code a1} and {@code a2}.\n+     *\n+     * <p>This method is only called when the glb is an annotation with elements.\n+     *\n+     * @param a1 first annotation\n+     * @param qual1 QualifierKind for {@code a1}\n+     * @param a2 second annotation\n+     * @param qual2 QualifierKind for {@code a2}\n+     * @return the greatest lower bound between {@code a1} and {@code a2}.\n+     */\n+    protected abstract AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, QualifierKind qual1, AnnotationMirror a2, QualifierKind qual2);\n+\n+    @Override\n+    public boolean isSubtypeTypeVariable(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        if (superAnno == null) {\n+            // [] is a supertype of any qualifier, and [] <: []\n+            return true;\n+        }\n+        if (subAnno == null) {\n+            // [] is a subtype of no qualifier (only [])\n+            return false;\n+        }\n+        return isSubtype(subAnno, superAnno);\n+    }\n+\n+    @Override\n+    public boolean isSubtypeTypeVariable(\n+            Collection<? extends AnnotationMirror> subAnnos,\n+            Collection<? extends AnnotationMirror> superAnnos) {\n+        int isSubtypeCount = 0;\n+        for (AnnotationMirror subAnno : subAnnos) {\n+            QualifierKind subKind = getQualifierKind(subAnno);\n+            for (AnnotationMirror superAnno : superAnnos) {\n+                QualifierKind superKind = getQualifierKind(superAnno);\n+                if (subKind.areInSameHierarchy(superKind)) {\n+                    if (isSubtype(subAnno, superAnno)) {\n+                        isSubtypeCount++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc1NTM3NA=="}, "originalCommit": {"oid": "1bc14d48ffcf7bc92ae52117ad5717ccaf38049b"}, "originalPosition": 343}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzA3MzM2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNToyNDo1MVrOGr94Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNToyNDo1MVrOGr94Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc1NTc3MA==", "bodyText": "This code assumes that kind is a key in getTopToPoly(), but there is no guarantee that start is a top.  (The specification of this method in QualifierHierarchy does not demand it.)", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r448755770", "createdAt": "2020-07-02T05:24:51Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * A qualifier hierarchy where no qualifiers have arguments; that is, no qualifier is represented by\n+ * an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the hierarchy.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+public class SimpleQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** Set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** Set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /** Mapping from {@link QualifierKind} to its corresponding {@link AnnotationMirror}. */\n+    protected final Map<QualifierKind, AnnotationMirror> qualifierMap;\n+\n+    /** Set of all annotations in the hierarchy. */\n+    protected final Set<? extends AnnotationMirror> qualifiers;\n+\n+    /**\n+     * Creates a type hierarchy from the given classes.\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers for this hierarchy\n+     * @param elements element utils\n+     */\n+    public SimpleQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.qualifierMap = createAnnotationMirrors(elements);\n+        Set<AnnotationMirror> qualifiers = AnnotationUtils.createAnnotationSet();\n+        qualifiers.addAll(qualifierMap.values());\n+        this.qualifiers = Collections.unmodifiableSet(qualifiers);\n+\n+        this.tops = createTops();\n+        this.bottoms = createBottoms();\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers for this hierarchy\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates and returns a mapping from qualifier kind to an annotation mirror created from the\n+     * qualifier kind's annotation class.\n+     *\n+     * @param elements element utils\n+     * @return a mapping from qualifier kind to an annotation mirror created from the qualifier\n+     *     kind's annotation class\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createAnnotationMirrors(Elements elements) {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (kind.hasElements()) {\n+                throw new UserError(\n+                        \"SimpleQualifierHierarchy cannot be used with annotations that have elements. Found %s: \",\n+                        kind);\n+            }\n+            quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    protected Set<AnnotationMirror> createTops() {\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : qualifierMap.entrySet()) {\n+            if (entry.getKey().isTop()) {\n+                tops.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(tops);\n+    }\n+\n+    protected Set<AnnotationMirror> createBottoms() {\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : qualifierMap.entrySet()) {\n+            if (entry.getKey().isBottom()) {\n+                bottoms.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(bottoms);\n+    }\n+\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (name == null) {\n+            throw new BugInCF(\"Annotation not in hierarchy: %s\", anno);\n+        }\n+        return kind;\n+    }\n+\n+    @Override\n+    public AnnotationMirror findAnnotationInHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror top) {\n+        return findAnnotationInSameHierarchy(annos, top);\n+    }\n+\n+    @Override\n+    public AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {\n+        QualifierKind kind = getQualifierKind(annotationMirror);\n+        for (AnnotationMirror anno : annos) {\n+            QualifierKind annoKind = getQualifierKind(anno);\n+            if (annoKind.areInSameHierarchy(kind)) {\n+                return anno;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getTopAnnotations() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public AnnotationMirror getTopAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return qualifierMap.get(kind.getTop());\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getBottomAnnotations() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    public AnnotationMirror getBottomAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return qualifierMap.get(kind.getBottom());\n+    }\n+\n+    @Override\n+    public AnnotationMirror getPolymorphicAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        QualifierKind poly = qualifierKindHierarchy.getTopToPoly().get(kind);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc14d48ffcf7bc92ae52117ad5717ccaf38049b"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzA3OTE3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNToyODozM1rOGr971w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNToyODozM1rOGr971w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc1NjY5NQ==", "bodyText": "areInSameHierarchy reads strangely to me, since the \"subject\" of the \"sentence\" is subKind which is singular.\nHow about renaming the method to inSameHierarchyAs or isInSameHierarchyAs or the like?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r448756695", "createdAt": "2020-07-02T05:28:33Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+\n+/**\n+ * A qualifier hierarchy where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>Subclasses must implement {@link #isSubtype(AnnotationMirror, QualifierKind, AnnotationMirror,\n+ * QualifierKind)}, {@link #leastUpperBound(AnnotationMirror, QualifierKind, AnnotationMirror,\n+ * QualifierKind)}, and {@link #greatestLowerBound(AnnotationMirror, QualifierKind,\n+ * AnnotationMirror, QualifierKind)} for cases when the annotations have elements. For cases where\n+ * the annotations have no elements, the {@link org.checkerframework.framework.qual.SubtypeOf}\n+ * meta-annotation is used.\n+ *\n+ * <p>ComplexQualifierHierarchy uses a {@link QualifierKindHierarchy} to model the relationships\n+ * between qualifiers. Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to\n+ * return a subclass of QualifierKindHierarchy.\n+ */\n+public abstract class ComplexQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils} */\n+    private Elements elements;\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** A mapping from top QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> topsMap;\n+\n+    /** The set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** A mapping from bottom QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> bottomsMap;\n+\n+    /** The set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /**\n+     * A mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations do not\n+     * have elements.\n+     */\n+    protected final Map<QualifierKind, AnnotationMirror> qualifierMap;\n+\n+    /**\n+     * Creates a type hierarchy from the given classes.\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers for this hierarchy\n+     * @param elements element utils\n+     */\n+    protected ComplexQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.elements = elements;\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.topsMap = Collections.unmodifiableMap(createTops());\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        tops.addAll(topsMap.values());\n+        this.tops = Collections.unmodifiableSet(tops);\n+\n+        this.bottomsMap = Collections.unmodifiableMap(createBottoms());\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        bottoms.addAll(bottomsMap.values());\n+        this.bottoms = Collections.unmodifiableSet(bottoms);\n+        this.qualifierMap = createQualifiers();\n+\n+        for (AnnotationMirror top : tops) {\n+            // This throws an error if poly is a qualifier that has an element.\n+            getPolymorphicAnnotation(top);\n+        }\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers for this hierarchy\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations\n+     * do not have elements.\n+     *\n+     * @return the mapping\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createQualifiers() {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (!kind.hasElements()) {\n+                quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+            }\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top.\n+     *\n+     * <p>Subclasses must override this if the top annotation has elements and provides not default.\n+     *\n+     * @return a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createTops() {\n+        Map<QualifierKind, AnnotationMirror> topsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getTops()) {\n+            topsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return topsMap;\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom.\n+     *\n+     * <p>Subclasses must override this if the bottom annotation has elements and provides not\n+     * default.\n+     *\n+     * @return a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createBottoms() {\n+        Map<QualifierKind, AnnotationMirror> bottomsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getBottoms()) {\n+            bottomsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return bottomsMap;\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the given annotation.\n+     *\n+     * @param anno annotation mirror\n+     * @return the qualifier kind for the given annotation\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        return getQualifierKind(name);\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the annotation with the fully qualified name {@code name}.\n+     *\n+     * @param name fully qualified annotation name\n+     * @return the qualifier kind for the annotation with {@code name}\n+     */\n+    protected QualifierKind getQualifierKind(String name) {\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"QualifierKind not in hierarchy: %s\", name);\n+        }\n+        return kind;\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getTopAnnotations() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public AnnotationMirror getTopAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return topsMap.get(kind.getTop());\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getBottomAnnotations() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    public AnnotationMirror getPolymorphicAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        QualifierKind poly = qualifierKindHierarchy.getTopToPoly().get(kind);\n+        if (poly == null) {\n+            return null;\n+        }\n+        if (qualifierMap.containsKey(poly)) {\n+            return qualifierMap.get(poly);\n+        } else {\n+            throw new BugInCF(\n+                    \"Poly has an element. Override ComplexQualifierHierarchy#getPolymorphicAnnotation. Poly: %s\",\n+                    poly);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isPolymorphicQualifier(AnnotationMirror qualifier) {\n+        return getQualifierKind(qualifier).isPoly();\n+    }\n+\n+    @Override\n+    public AnnotationMirror getBottomAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return bottomsMap.get(kind.getBottom());\n+    }\n+\n+    @Override\n+    public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        QualifierKind subKind = getQualifierKind(subAnno);\n+        QualifierKind superKind = getQualifierKind(superAnno);\n+        if (subKind.isSubtype(superKind)) {\n+            if (superKind.hasElements() && subKind.hasElements()) {\n+                return isSubtype(subAnno, subKind, superAnno, superKind);\n+            } else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns whether or not {@code subAnno} is a subtype of {@code superAnno}. Both {@code\n+     * subAnno} and {@code superAnno} are annotations with elements.\n+     *\n+     * @param subAnno possible subtype annotation; has elements\n+     * @param subKind QualifierKind of{@code subAnno}\n+     * @param superAnno possible super annotation; has elements\n+     * @param superKind QualifierKind of{@code superAnno}\n+     * @return whether or not {@code subAnno} is a subtype of {@code superAnno}\n+     */\n+    protected abstract boolean isSubtype(\n+            AnnotationMirror subAnno,\n+            QualifierKind subKind,\n+            AnnotationMirror superAnno,\n+            QualifierKind superKind);\n+\n+    @Override\n+    public boolean isSubtype(\n+            Collection<? extends AnnotationMirror> subAnnos,\n+            Collection<? extends AnnotationMirror> superAnnos) {\n+        int isSubtypeCount = 0;\n+        for (AnnotationMirror subAnno : subAnnos) {\n+            QualifierKind subKind = getQualifierKind(subAnno);\n+            for (AnnotationMirror superAnno : superAnnos) {\n+                QualifierKind superKind = getQualifierKind(superAnno);\n+                if (subKind.areInSameHierarchy(superKind)) {\n+                    if (isSubtype(subAnno, superAnno)) {\n+                        isSubtypeCount++;\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+            }\n+        }\n+        return isSubtypeCount == superAnnos.size();\n+    }\n+\n+    @Override\n+    public AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2) {\n+        QualifierKind qual1 = getQualifierKind(a1);\n+        QualifierKind qual2 = getQualifierKind(a2);\n+        if (!qual1.areInSameHierarchy(qual2)) {\n+            return null;\n+        }\n+        QualifierKind lub = qualifierKindHierarchy.leastUpperBound(qual1, qual2);\n+        if (lub.hasElements()) {\n+            return leastUpperBound(a1, qual1, a2, qual2);\n+        }\n+        return qualifierMap.get(lub);\n+    }\n+\n+    /**\n+     * Returns the least upper bound between {@code a1} and {@code a2}.\n+     *\n+     * <p>This method is only called when the lub is an annotation with elements.\n+     *\n+     * @param a1 first annotation\n+     * @param qual1 QualifierKind for {@code a1}\n+     * @param a2 second annotation\n+     * @param qual2 QualifierKind for {@code a2}\n+     * @return the least upper bound between {@code a1} and {@code a2}.\n+     */\n+    protected abstract AnnotationMirror leastUpperBound(\n+            AnnotationMirror a1, QualifierKind qual1, AnnotationMirror a2, QualifierKind qual2);\n+\n+    @Override\n+    public AnnotationMirror greatestLowerBound(AnnotationMirror a1, AnnotationMirror a2) {\n+        QualifierKind qual1 = getQualifierKind(a1);\n+        QualifierKind qual2 = getQualifierKind(a2);\n+        if (!qual1.areInSameHierarchy(qual2)) {\n+            return null;\n+        }\n+        QualifierKind glb = qualifierKindHierarchy.greatestLowerBound(qual1, qual2);\n+        if (glb.hasElements()) {\n+            return greatestLowerBound(a1, qual1, a2, qual2);\n+        }\n+        return qualifierMap.get(glb);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound between {@code a1} and {@code a2}.\n+     *\n+     * <p>This method is only called when the glb is an annotation with elements.\n+     *\n+     * @param a1 first annotation\n+     * @param qual1 QualifierKind for {@code a1}\n+     * @param a2 second annotation\n+     * @param qual2 QualifierKind for {@code a2}\n+     * @return the greatest lower bound between {@code a1} and {@code a2}.\n+     */\n+    protected abstract AnnotationMirror greatestLowerBound(\n+            AnnotationMirror a1, QualifierKind qual1, AnnotationMirror a2, QualifierKind qual2);\n+\n+    @Override\n+    public boolean isSubtypeTypeVariable(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        if (superAnno == null) {\n+            // [] is a supertype of any qualifier, and [] <: []\n+            return true;\n+        }\n+        if (subAnno == null) {\n+            // [] is a subtype of no qualifier (only [])\n+            return false;\n+        }\n+        return isSubtype(subAnno, superAnno);\n+    }\n+\n+    @Override\n+    public boolean isSubtypeTypeVariable(\n+            Collection<? extends AnnotationMirror> subAnnos,\n+            Collection<? extends AnnotationMirror> superAnnos) {\n+        int isSubtypeCount = 0;\n+        for (AnnotationMirror subAnno : subAnnos) {\n+            QualifierKind subKind = getQualifierKind(subAnno);\n+            for (AnnotationMirror superAnno : superAnnos) {\n+                QualifierKind superKind = getQualifierKind(superAnno);\n+                if (subKind.areInSameHierarchy(superKind)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc14d48ffcf7bc92ae52117ad5717ccaf38049b"}, "originalPosition": 341}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzA4MjgwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNTozMDozMFrOGr996Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNTozMDozMFrOGr996Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc1NzIyNQ==", "bodyText": "Please write Javadoc documentation for all methods.\nThe next two methods need it, too.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r448757225", "createdAt": "2020-07-02T05:30:30Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * A qualifier hierarchy where no qualifiers have arguments; that is, no qualifier is represented by\n+ * an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the hierarchy.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+public class SimpleQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** Set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** Set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /** Mapping from {@link QualifierKind} to its corresponding {@link AnnotationMirror}. */\n+    protected final Map<QualifierKind, AnnotationMirror> qualifierMap;\n+\n+    /** Set of all annotations in the hierarchy. */\n+    protected final Set<? extends AnnotationMirror> qualifiers;\n+\n+    /**\n+     * Creates a type hierarchy from the given classes.\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers for this hierarchy\n+     * @param elements element utils\n+     */\n+    public SimpleQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.qualifierMap = createAnnotationMirrors(elements);\n+        Set<AnnotationMirror> qualifiers = AnnotationUtils.createAnnotationSet();\n+        qualifiers.addAll(qualifierMap.values());\n+        this.qualifiers = Collections.unmodifiableSet(qualifiers);\n+\n+        this.tops = createTops();\n+        this.bottoms = createBottoms();\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers for this hierarchy\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates and returns a mapping from qualifier kind to an annotation mirror created from the\n+     * qualifier kind's annotation class.\n+     *\n+     * @param elements element utils\n+     * @return a mapping from qualifier kind to an annotation mirror created from the qualifier\n+     *     kind's annotation class\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createAnnotationMirrors(Elements elements) {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (kind.hasElements()) {\n+                throw new UserError(\n+                        \"SimpleQualifierHierarchy cannot be used with annotations that have elements. Found %s: \",\n+                        kind);\n+            }\n+            quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    protected Set<AnnotationMirror> createTops() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc14d48ffcf7bc92ae52117ad5717ccaf38049b"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzA4MzQ1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNTozMDo1MVrOGr9-QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNTozMDo1MVrOGr9-QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc1NzMxMw==", "bodyText": "I think this should be kind == null.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r448757313", "createdAt": "2020-07-02T05:30:51Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,287 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * A qualifier hierarchy where no qualifiers have arguments; that is, no qualifier is represented by\n+ * an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the hierarchy.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+public class SimpleQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** Set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** Set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /** Mapping from {@link QualifierKind} to its corresponding {@link AnnotationMirror}. */\n+    protected final Map<QualifierKind, AnnotationMirror> qualifierMap;\n+\n+    /** Set of all annotations in the hierarchy. */\n+    protected final Set<? extends AnnotationMirror> qualifiers;\n+\n+    /**\n+     * Creates a type hierarchy from the given classes.\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers for this hierarchy\n+     * @param elements element utils\n+     */\n+    public SimpleQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.qualifierMap = createAnnotationMirrors(elements);\n+        Set<AnnotationMirror> qualifiers = AnnotationUtils.createAnnotationSet();\n+        qualifiers.addAll(qualifierMap.values());\n+        this.qualifiers = Collections.unmodifiableSet(qualifiers);\n+\n+        this.tops = createTops();\n+        this.bottoms = createBottoms();\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers for this hierarchy\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates and returns a mapping from qualifier kind to an annotation mirror created from the\n+     * qualifier kind's annotation class.\n+     *\n+     * @param elements element utils\n+     * @return a mapping from qualifier kind to an annotation mirror created from the qualifier\n+     *     kind's annotation class\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createAnnotationMirrors(Elements elements) {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (kind.hasElements()) {\n+                throw new UserError(\n+                        \"SimpleQualifierHierarchy cannot be used with annotations that have elements. Found %s: \",\n+                        kind);\n+            }\n+            quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    protected Set<AnnotationMirror> createTops() {\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : qualifierMap.entrySet()) {\n+            if (entry.getKey().isTop()) {\n+                tops.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(tops);\n+    }\n+\n+    protected Set<AnnotationMirror> createBottoms() {\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : qualifierMap.entrySet()) {\n+            if (entry.getKey().isBottom()) {\n+                bottoms.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(bottoms);\n+    }\n+\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (name == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc14d48ffcf7bc92ae52117ad5717ccaf38049b"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzA4NjgzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNTozMjo1MVrOGr-AHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNTozMjo1MVrOGr-AHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc1Nzc4OA==", "bodyText": "I wondered why this used a TreeSet.  It's not obviously more efficient.  Is it because you want the method to return the qualifiers in a deterministic order?  The Javadoc doesn't promise it.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r448757788", "createdAt": "2020-07-02T05:32:51Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,839 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is represented by the {@link QualifierKind} class and is analogous to the\n+ * annotation class of a qualifier. If a type system has more than one hierarchy, information about\n+ * all hierarchies are stored in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the value of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this is polymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier kind is a subtype of or equal to {@code superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            return this == superQualKind || superTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    private final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * The mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     * hierarchy.\n+     *\n+     * @return the mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     *     hierarchy\n+     */\n+    public Map<QualifierKind, QualifierKind> getTopToPoly() {\n+        return topToPoly;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new UserError(\n+                            \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected NavigableMap<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"Duplicate QualifierKind \" + qualifierKind.name);\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableNavigableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds\n+     * using the {@link SubtypeOf} meta-annotation. The direct super qualifier kinds do not contain\n+     * the qualifier itself. This mapping is used by {@link #createBottomsSet(Map)}, {@link\n+     * #createTopsSet(Map)}, and {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>Subclasses may override this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @throws UserError if the {@link SubtypeOf} meta-annotation refers to a class that is not a\n+     *     qualifier\n+     * @return a mapping from a {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new UserError(\n+                                \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Set {@code bottom} to the given class and modify {@code directSuperMap} to add all leaves to\n+     * its super qualifier kinds. Leaves are qualifier kinds that are not super qualifier kinds of\n+     * another qualifier kind.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; side-effected by this method\n+     * @param bottom the class of the bottom qualifier or {@code null}; if {@code null}, this method\n+     *     has no effect\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            QualifierKind bottomKind = getQualifierKind(bottom.getCanonicalName());\n+            if (bottomKind == null) {\n+                throw new BugInCF(\n+                        \"QualifierKindHierarchy#specifyBottom: the given bottom class, %s, is not in the hierarchy.\",\n+                        bottom.getCanonicalName());\n+            }\n+            Set<QualifierKind> currentLeafs = new TreeSet<>(allQualifierKinds());\n+            currentLeafs.remove(bottomKind);\n+            directSuperMap.forEach(\n+                    (sub, supers) -> {\n+                        currentLeafs.removeAll(supers);\n+                    });\n+            Set<QualifierKind> bottomDirectSuperQuals = directSuperMap.get(bottomKind);\n+            bottomDirectSuperQuals.addAll(currentLeafs);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifier kinds without any direct super qualifier kinds.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        directSuperMap.forEach(\n+                (qualifierKind, superQuals) -> {\n+                    if (superQuals.isEmpty()) {\n+                        tops.add(qualifierKind);\n+                    }\n+                });\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier kind of another qualifier kind.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> bottoms = new TreeSet<>(directSuperMap.keySet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc14d48ffcf7bc92ae52117ad5717ccaf38049b"}, "originalPosition": 538}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzA4OTA4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNTozNDoyOFrOGr-Bfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNTozNDoyOFrOGr-Bfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc1ODE0Mw==", "bodyText": "Be specific about the needed fix, similarly to the errors in the previous two cases.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r448758143", "createdAt": "2020-07-02T05:34:28Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,839 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is represented by the {@link QualifierKind} class and is analogous to the\n+ * annotation class of a qualifier. If a type system has more than one hierarchy, information about\n+ * all hierarchies are stored in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the value of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this is polymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier kind is a subtype of or equal to {@code superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            return this == superQualKind || superTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    private final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * The mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     * hierarchy.\n+     *\n+     * @return the mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     *     hierarchy\n+     */\n+    public Map<QualifierKind, QualifierKind> getTopToPoly() {\n+        return topToPoly;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new UserError(\n+                            \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc14d48ffcf7bc92ae52117ad5717ccaf38049b"}, "originalPosition": 383}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzA5MjA0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNTozNTo1OVrOGr-DJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNzozOTo0M1rOGsXYxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc1ODU2Nw==", "bodyText": "Why is this required?  Since the QualifierKind class is annotated as @Interned, I expect its constructor to return an @Interned object.  Am I incorrect about that?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r448758567", "createdAt": "2020-07-02T05:35:59Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,839 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is represented by the {@link QualifierKind} class and is analogous to the\n+ * annotation class of a qualifier. If a type system has more than one hierarchy, information about\n+ * all hierarchies are stored in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the value of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this is polymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier kind is a subtype of or equal to {@code superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            return this == superQualKind || superTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    private final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * The mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     * hierarchy.\n+     *\n+     * @return the mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     *     hierarchy\n+     */\n+    public Map<QualifierKind, QualifierKind> getTopToPoly() {\n+        return topToPoly;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new UserError(\n+                            \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected NavigableMap<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc14d48ffcf7bc92ae52117ad5717ccaf38049b"}, "originalPosition": 412}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MzcwMQ==", "bodyText": "The type of the constructor result is @UnknownInterned.  See the manual.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r449173701", "createdAt": "2020-07-02T17:39:43Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,839 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is represented by the {@link QualifierKind} class and is analogous to the\n+ * annotation class of a qualifier. If a type system has more than one hierarchy, information about\n+ * all hierarchies are stored in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the value of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this is polymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier kind is a subtype of or equal to {@code superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            return this == superQualKind || superTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    private final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * The mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     * hierarchy.\n+     *\n+     * @return the mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     *     hierarchy\n+     */\n+    public Map<QualifierKind, QualifierKind> getTopToPoly() {\n+        return topToPoly;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new UserError(\n+                            \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected NavigableMap<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc1ODU2Nw=="}, "originalCommit": {"oid": "1bc14d48ffcf7bc92ae52117ad5717ccaf38049b"}, "originalPosition": 412}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzA5MzQyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNTozNjozNFrOGr-D7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNTozNjozNFrOGr-D7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc1ODc2NA==", "bodyText": "You suggested adding a TypeSystemError to complement BugInCF and UserError.  I think that is a good thing to do, in a separate pull request that is merged before this one.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r448758764", "createdAt": "2020-07-02T05:36:34Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,839 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is represented by the {@link QualifierKind} class and is analogous to the\n+ * annotation class of a qualifier. If a type system has more than one hierarchy, information about\n+ * all hierarchies are stored in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the value of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this is polymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getSuperTypes() {\n+            return superTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier kind is a subtype of or equal to {@code superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            return this == superQualKind || superTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    private final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * The mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     * hierarchy.\n+     *\n+     * @return the mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     *     hierarchy\n+     */\n+    public Map<QualifierKind, QualifierKind> getTopToPoly() {\n+        return topToPoly;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws UserError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // This is currently not supported. At some point we might add\n+                // polymorphic qualifiers with upper and lower bounds.\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new UserError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new UserError(\n+                            \"PolymorphicQualifier, %s,  has to specify type hierarchy, if more than one exist; top types: [%s] \",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new UserError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new UserError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected NavigableMap<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new UserError(\"Duplicate QualifierKind \" + qualifierKind.name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc14d48ffcf7bc92ae52117ad5717ccaf38049b"}, "originalPosition": 415}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzA5ODI0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNTozOToyMVrOGr-G3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwNTozOToyMVrOGr-G3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc1OTUxNg==", "bodyText": "It bugs me a bit that when we speak of subtypes, it is a reflexive operation, but when we speak of supertypes, it is strict (non-reflexive).  This lack of symmetry is confusing.  We could imagine renaming this method to getStrictSuperTypes.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r448759516", "createdAt": "2020-07-02T05:39:21Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,839 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is represented by the {@link QualifierKind} class and is analogous to the\n+ * annotation class of a qualifier. If a type system has more than one hierarchy, information about\n+ * all hierarchies are stored in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the value of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this is polymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private Set<QualifierKind> superTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            superTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getSuperTypes() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bc14d48ffcf7bc92ae52117ad5717ccaf38049b"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNDY1NzM0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQxNToyNzo0OFrOGtDFMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQxNToyNzo0OFrOGtDFMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg4OTU4Nw==", "bodyText": "Putt getter/setter methods in the same order as the fields.  (Change one or the other.)", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r449889587", "createdAt": "2020-07-05T15:27:48Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,839 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is represented by the {@link QualifierKind} class and is analogous to the\n+ * annotation class of a qualifier. If a type system has more than one hierarchy, information about\n+ * all hierarchies are stored in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the value of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b02f53c2ed77227cc99a2a3e6f7cfa65a82c80"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNDY2MDM5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQxNTozMjoxOFrOGtDGpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQxNTozMjoxOFrOGtDGpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg4OTk1Nw==", "bodyText": "top and bottom are fields in QualifierKind, but poly information is in this external field.  Would it make sense to make poly a field in QualifierKind too?  Then there would not be the need to translate to top and look up in an external map.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r449889957", "createdAt": "2020-07-05T15:32:18Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,839 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is represented by the {@link QualifierKind} class and is analogous to the\n+ * annotation class of a qualifier. If a type system has more than one hierarchy, information about\n+ * all hierarchies are stored in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the value of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this is polymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private Set<QualifierKind> strictSuperTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            strictSuperTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier kind is a subtype of or equal to {@code superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    private final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b02f53c2ed77227cc99a2a3e6f7cfa65a82c80"}, "originalPosition": 238}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNDY2MzIwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQxNTozNjowM1rOGtDH9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzoyNjowNVrOGzbLzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg5MDI5NQ==", "bodyText": "I don't see any clients that require this to be sorted -- all the clients do their own sorting too.\n(I don't object to this, but I wonder why it is necessary.  Is it to make logging and diagnostics deterministic?  Or is it just a side effect of the implementation, and we tell clients in case they can take advantage of it?)", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r449890295", "createdAt": "2020-07-05T15:36:03Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,839 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is represented by the {@link QualifierKind} class and is analogous to the\n+ * annotation class of a qualifier. If a type system has more than one hierarchy, information about\n+ * all hierarchies are stored in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the value of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this is polymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private Set<QualifierKind> strictSuperTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            strictSuperTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier kind is a subtype of or equal to {@code superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    private final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0b02f53c2ed77227cc99a2a3e6f7cfa65a82c80"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY1OTYwMw==", "bodyText": "Many methods iterate over the collection and throw TypeSystemErrors.  It's sorted so those exceptions are deterministic.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r451659603", "createdAt": "2020-07-08T16:07:24Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,839 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is represented by the {@link QualifierKind} class and is analogous to the\n+ * annotation class of a qualifier. If a type system has more than one hierarchy, information about\n+ * all hierarchies are stored in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the value of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this is polymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private Set<QualifierKind> strictSuperTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            strictSuperTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier kind is a subtype of or equal to {@code superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    private final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg5MDI5NQ=="}, "originalCommit": {"oid": "f0b02f53c2ed77227cc99a2a3e6f7cfa65a82c80"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3NTk1MA==", "bodyText": "Should the return type be List then?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456575950", "createdAt": "2020-07-17T17:26:05Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,839 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.checkerframework.javacutil.UserError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is represented by the {@link QualifierKind} class and is analogous to the\n+ * annotation class of a qualifier. If a type system has more than one hierarchy, information about\n+ * all hierarchies are stored in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the value of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this is polymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private Set<QualifierKind> strictSuperTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them values here, because the Java compiler requires it.\n+            isPoly = false;\n+            strictSuperTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Return the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Whether or not this qualifier kind is a subtype of or equal to {@code superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String[] split = name.split(\"\\\\.\");\n+            if (split.length == 0) {\n+                return name;\n+            }\n+            return split[split.length - 1];\n+        }\n+    }\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    private final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}.\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg5MDI5NQ=="}, "originalCommit": {"oid": "f0b02f53c2ed77227cc99a2a3e6f7cfa65a82c80"}, "originalPosition": 303}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNDk0Mjg2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQyMjoyMDoyNlrOGtFPLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxOTo0ODowMFrOGtk6CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkyNDkxMA==", "bodyText": "This code treats the absence of @SubtypeOf identically to @SubtypeOf() or @SubtypeOf({}).  I think that's OK, but the Javadoc says to always write @SubtypeOf({}).  I suggest that we adjust the Javadoc and the manual to indicate that omitting @SubtypeOf is OK.  Or do we want to require an empty @SubtypeOf annotation on the top type, for emphasis?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r449924910", "createdAt": "2020-07-05T22:20:26Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,832 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the value of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this is polymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private Set<QualifierKind> strictSuperTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            isPoly = false;\n+            strictSuperTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Returns whether or not this qualifier kind is a subtype of or equal to {@code\n+         * superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name.substring(name.lastIndexOf(\".\") + 1);\n+        }\n+    }\n+\n+    // End of QualifierKind class, start of QualifierKindHierarchy fields.\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    private final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}. Ignores elements/arguments (as\n+     * QualifierKind always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}. Ignores elements/arguments (as\n+     * QualifierKind always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * The mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     * hierarchy.\n+     *\n+     * @return the mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     *     hierarchy\n+     */\n+    public Map<QualifierKind, QualifierKind> getTopToPoly() {\n+        return topToPoly;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected NavigableMap<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.name);\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableNavigableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f3e4c30a5248e2bfd30e05701487219cbbbed94"}, "originalPosition": 440}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ0Mzc4NQ==", "bodyText": "This code treats the absence of @SubtypeOf identically to @SubtypeOf() or @SubtypeOf({})\n\nThat's not true.  If an annotation class does not have a @Subtype, then it is not added to the directSuperType map.  If a qualifier is not a polymorphic qualifier nor in the directSuperTypes map, then QualifierKindHierarchy#verifyHierarchy throws a TypeSystemError.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r450443785", "createdAt": "2020-07-06T19:48:00Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,832 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the value of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this is polymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private Set<QualifierKind> strictSuperTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            isPoly = false;\n+            strictSuperTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Returns whether or not this qualifier kind is a subtype of or equal to {@code\n+         * superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name.substring(name.lastIndexOf(\".\") + 1);\n+        }\n+    }\n+\n+    // End of QualifierKind class, start of QualifierKindHierarchy fields.\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    private final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}. Ignores elements/arguments (as\n+     * QualifierKind always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}. Ignores elements/arguments (as\n+     * QualifierKind always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * The mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     * hierarchy.\n+     *\n+     * @return the mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     *     hierarchy\n+     */\n+    public Map<QualifierKind, QualifierKind> getTopToPoly() {\n+        return topToPoly;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected NavigableMap<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.name);\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableNavigableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkyNDkxMA=="}, "originalCommit": {"oid": "5f3e4c30a5248e2bfd30e05701487219cbbbed94"}, "originalPosition": 440}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNDk0NzU4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQyMjoyNzozMVrOGtFRdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDowODowOVrOGtldVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkyNTQ5Mg==", "bodyText": "The argument to @PolymorphicQualifier is by convention the top qualifier, but that is not required.  This code assumes it is the top qualifier and I think the code will misbehave (eg, by making a non-top qualifier a key in topsToPoly) if it is not.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r449925492", "createdAt": "2020-07-05T22:27:31Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,832 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the value of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this is polymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private Set<QualifierKind> strictSuperTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            isPoly = false;\n+            strictSuperTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Returns whether or not this qualifier kind is a subtype of or equal to {@code\n+         * superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name.substring(name.lastIndexOf(\".\") + 1);\n+        }\n+    }\n+\n+    // End of QualifierKind class, start of QualifierKindHierarchy fields.\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    private final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}. Ignores elements/arguments (as\n+     * QualifierKind always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}. Ignores elements/arguments (as\n+     * QualifierKind always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * The mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     * hierarchy.\n+     *\n+     * @return the mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     *     hierarchy\n+     */\n+    public Map<QualifierKind, QualifierKind> getTopToPoly() {\n+        return topToPoly;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected NavigableMap<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.name);\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableNavigableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new TypeSystemError(\n+                                \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Set {@code bottom} to the given class and modify {@code directSuperMap} to add all leaves to\n+     * its super qualifier kinds. Leaves are qualifier kinds that are not super qualifier kinds of\n+     * another qualifier kind.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; side-effected by this method\n+     * @param bottom the class of the bottom qualifier or {@code null}; if {@code null}, this method\n+     *     has no effect\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            QualifierKind bottomKind = getQualifierKind(bottom.getCanonicalName());\n+            if (bottomKind == null) {\n+                throw new TypeSystemError(\n+                        \"QualifierKindHierarchy#specifyBottom: the given bottom class, %s, is not in the hierarchy.\",\n+                        bottom.getCanonicalName());\n+            }\n+            Set<QualifierKind> currentLeafs = new TreeSet<>(allQualifierKinds());\n+            currentLeafs.remove(bottomKind);\n+            directSuperMap.forEach(\n+                    (sub, supers) -> {\n+                        currentLeafs.removeAll(supers);\n+                    });\n+            Set<QualifierKind> bottomDirectSuperQuals = directSuperMap.get(bottomKind);\n+            bottomDirectSuperQuals.addAll(currentLeafs);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifier kinds without any direct super qualifier kinds.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        directSuperMap.forEach(\n+                (qualifierKind, superQuals) -> {\n+                    if (superQuals.isEmpty()) {\n+                        tops.add(qualifierKind);\n+                    }\n+                });\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier kind of another qualifier kind.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> bottoms = new HashSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifier kinds to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#isPoly} to true and {@link\n+     * QualifierKind#top} to top for the polymophic qualifiers.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     *\n+     * @return a mapping from a top qualifier to the polymorphic qualifier in the heirarchy\n+     */\n+    protected Map<QualifierKind, QualifierKind> initializePolymorphicQualifiers() {\n+        Map<QualifierKind, QualifierKind> topToPoly = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno == null) {\n+                continue;\n+            }\n+            qualifierKind.isPoly = true;\n+            String topName = polyMetaAnno.value().getCanonicalName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f3e4c30a5248e2bfd30e05701487219cbbbed94"}, "originalPosition": 561}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ1MjgyMA==", "bodyText": "The argument to @PolymorphicQualifier should always be a top qualifier.  I changed the documentation.  The old implementation assumes it is top. This implementation will throw a TypeSystemError (in QualifierKindHierarchy#verifyHierarchy) if it is not top.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r450452820", "createdAt": "2020-07-06T20:08:09Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,832 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the value of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this is polymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private Set<QualifierKind> strictSuperTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            isPoly = false;\n+            strictSuperTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Returns whether or not this qualifier kind is a subtype of or equal to {@code\n+         * superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name.substring(name.lastIndexOf(\".\") + 1);\n+        }\n+    }\n+\n+    // End of QualifierKind class, start of QualifierKindHierarchy fields.\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    private final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}. Ignores elements/arguments (as\n+     * QualifierKind always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}. Ignores elements/arguments (as\n+     * QualifierKind always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * The mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     * hierarchy.\n+     *\n+     * @return the mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     *     hierarchy\n+     */\n+    public Map<QualifierKind, QualifierKind> getTopToPoly() {\n+        return topToPoly;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected NavigableMap<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.name);\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableNavigableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new TypeSystemError(\n+                                \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Set {@code bottom} to the given class and modify {@code directSuperMap} to add all leaves to\n+     * its super qualifier kinds. Leaves are qualifier kinds that are not super qualifier kinds of\n+     * another qualifier kind.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; side-effected by this method\n+     * @param bottom the class of the bottom qualifier or {@code null}; if {@code null}, this method\n+     *     has no effect\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        if (bottom != null) {\n+            QualifierKind bottomKind = getQualifierKind(bottom.getCanonicalName());\n+            if (bottomKind == null) {\n+                throw new TypeSystemError(\n+                        \"QualifierKindHierarchy#specifyBottom: the given bottom class, %s, is not in the hierarchy.\",\n+                        bottom.getCanonicalName());\n+            }\n+            Set<QualifierKind> currentLeafs = new TreeSet<>(allQualifierKinds());\n+            currentLeafs.remove(bottomKind);\n+            directSuperMap.forEach(\n+                    (sub, supers) -> {\n+                        currentLeafs.removeAll(supers);\n+                    });\n+            Set<QualifierKind> bottomDirectSuperQuals = directSuperMap.get(bottomKind);\n+            bottomDirectSuperQuals.addAll(currentLeafs);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifier kinds without any direct super qualifier kinds.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        directSuperMap.forEach(\n+                (qualifierKind, superQuals) -> {\n+                    if (superQuals.isEmpty()) {\n+                        tops.add(qualifierKind);\n+                    }\n+                });\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier kind of another qualifier kind.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> bottoms = new HashSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifier kinds to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#isPoly} to true and {@link\n+     * QualifierKind#top} to top for the polymophic qualifiers.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     *\n+     * @return a mapping from a top qualifier to the polymorphic qualifier in the heirarchy\n+     */\n+    protected Map<QualifierKind, QualifierKind> initializePolymorphicQualifiers() {\n+        Map<QualifierKind, QualifierKind> topToPoly = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno == null) {\n+                continue;\n+            }\n+            qualifierKind.isPoly = true;\n+            String topName = polyMetaAnno.value().getCanonicalName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkyNTQ5Mg=="}, "originalCommit": {"oid": "5f3e4c30a5248e2bfd30e05701487219cbbbed94"}, "originalPosition": 561}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNDk0OTI1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQyMjozMDowMFrOGtFSSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQyMjozMDowMFrOGtFSSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkyNTcwNA==", "bodyText": "Does the end of this for loop need an if (qualifierKind.bottom == null) test like the if (qualifierKind.top == null) above?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r449925704", "createdAt": "2020-07-05T22:30:00Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,835 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the value of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #specifyBottom(Map, Class)}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /** Whether or not this is polymorphic. */\n+        private boolean isPoly;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private Set<QualifierKind> strictSuperTypes;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private QualifierKind bottom;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = clazz.getCanonicalName().intern();\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            isPoly = false;\n+            strictSuperTypes = null;\n+            top = null;\n+            bottom = null;\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return isPoly;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean areInSameHierarchy(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Returns whether or not this qualifier kind is a subtype of or equal to {@code\n+         * superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name.substring(name.lastIndexOf(\".\") + 1);\n+        }\n+    }\n+\n+    // End of QualifierKind class, start of QualifierKindHierarchy fields.\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    private final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /**\n+     * A mapping from a top qualifier kind to the polymorphic qualifier kind in the same hierarchy.\n+     */\n+    private final Map<QualifierKind, QualifierKind> topToPoly;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}. Ignores elements/arguments (as\n+     * QualifierKind always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}. Ignores elements/arguments (as\n+     * QualifierKind always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}\n+     */\n+    public QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * The mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     * hierarchy.\n+     *\n+     * @return the mapping from a top qualifier kind to the polymorphic qualifier kind in the same\n+     *     hierarchy\n+     */\n+    public Map<QualifierKind, QualifierKind> getTopToPoly() {\n+        return topToPoly;\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        specifyBottom(directSuperMap, null);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        this.topToPoly = initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    protected void verifyHierarchy(Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly;\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected NavigableMap<@Interned String, QualifierKind> createQualifierKinds(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.name);\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableNavigableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap() {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno != null) {\n+                Set<QualifierKind> directSupers = new TreeSet<>();\n+                directSuperMap.put(qualifierKind, directSupers);\n+                for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                    String superName = superClazz.getCanonicalName();\n+                    QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                    if (superQualifier == null) {\n+                        throw new TypeSystemError(\n+                                \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                                qualifierKind,\n+                                superName,\n+                                SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                    }\n+                    directSupers.add(superQualifier);\n+                }\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * Set {@code bottom} to the given class and modify {@code directSuperMap} to add all leaves to\n+     * its super qualifier kinds. Leaves are qualifier kinds that are not super qualifier kinds of\n+     * another qualifier kind.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, override this method and call super with the bottom class. For example,\n+     *\n+     * <pre>\n+     * {@code @Override\n+     *  protected void specifyBottom(Map<QualifierKind, Set<QualifierKind>> directSuperMap, Class<? extends Annotation> bottom) {\n+     *      super.specifyBottom(directSuperMap, UnitsBottom.class);\n+     *  }\n+     * }</pre>\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; side-effected by this method\n+     * @param bottom the class of the bottom qualifier or {@code null}; if {@code null}, this method\n+     *     has no effect\n+     */\n+    protected void specifyBottom(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        if (bottom == null) {\n+            return;\n+        }\n+\n+        QualifierKind bottomKind = getQualifierKind(bottom.getCanonicalName());\n+        if (bottomKind == null) {\n+            throw new TypeSystemError(\n+                    \"QualifierKindHierarchy#specifyBottom: the given bottom class, %s, is not in the hierarchy.\",\n+                    bottom.getCanonicalName());\n+        }\n+        Set<QualifierKind> currentLeaves = new TreeSet<>(allQualifierKinds());\n+        currentLeaves.remove(bottomKind);\n+        directSuperMap.forEach(\n+                (sub, supers) -> {\n+                    currentLeaves.removeAll(supers);\n+                });\n+        Set<QualifierKind> bottomDirectSuperQuals = directSuperMap.get(bottomKind);\n+        bottomDirectSuperQuals.addAll(currentLeaves);\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifier kinds without any direct super qualifier kinds.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        directSuperMap.forEach(\n+                (qualifierKind, superQuals) -> {\n+                    if (superQuals.isEmpty()) {\n+                        tops.add(qualifierKind);\n+                    }\n+                });\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier kind of another qualifier kind.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> bottoms = new HashSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifier kinds to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#isPoly} to true and {@link\n+     * QualifierKind#top} to top for the polymophic qualifiers.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     *\n+     * @return a mapping from a top qualifier to the polymorphic qualifier in the heirarchy\n+     */\n+    protected Map<QualifierKind, QualifierKind> initializePolymorphicQualifiers() {\n+        Map<QualifierKind, QualifierKind> topToPoly = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno == null) {\n+                continue;\n+            }\n+            qualifierKind.isPoly = true;\n+            String topName = polyMetaAnno.value().getCanonicalName();\n+            if (nameToQualifierKind.containsKey(topName)) {\n+                qualifierKind.top = nameToQualifierKind.get(topName);\n+            } else if (topName.equals(Annotation.class.getCanonicalName())) {\n+                // Annotation.class is the default value of PolymorphicQualifier. If it is used,\n+                // then there must be exactly one top.\n+                if (tops.size() == 1) {\n+                    qualifierKind.top = tops.iterator().next();\n+                } else {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                }\n+            } else {\n+                throw new TypeSystemError(\n+                        \"Polymorphic qualifier %s's top, %s, is not a qualifier.\",\n+                        qualifierKind, topName);\n+            }\n+            qualifierKind.strictSuperTypes = Collections.singleton(qualifierKind.top);\n+            topToPoly.put(qualifierKind.top, qualifierKind);\n+        }\n+        return topToPoly;\n+    }\n+\n+    /**\n+     * For each qualifier kind in {@code directSuperMap}, initializes {@link\n+     * QualifierKind#strictSuperTypes}, {@link QualifierKind#top} and {@link QualifierKind#bottom}.\n+     * (Requires tops, bottoms, and polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     */\n+    protected void initializeQualifierKindFields(\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            if (!qualifierKind.isPoly) {\n+                qualifierKind.strictSuperTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;\n+                    } else if (qualifierKind.top != top) {\n+                        throw new TypeSystemError(\n+                                \"Multiple tops found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, top, qualifierKind.top);\n+                    }\n+                }\n+            }\n+            if (qualifierKind.top == null) {\n+                throw new TypeSystemError(\n+                        \"Qualifier %s isn't a subtype of any top. tops = %s\", qualifierKind, tops);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind bot : bottoms) {\n+                if (bot.top != qualifierKind.top) {\n+                    continue;\n+                }\n+                if (qualifierKind.bottom == null) {\n+                    qualifierKind.bottom = bot;\n+                } else if (qualifierKind.top != bot) {\n+                    throw new TypeSystemError(\n+                            \"Multiple bottoms found for qualifier %s. Bottoms: %s and %s.\",\n+                            qualifierKind, bot, qualifierKind.bottom);\n+                }\n+                if (qualifierKind.isPoly) {\n+                    bot.strictSuperTypes.add(qualifierKind);\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39eca38dda02486bb59214fce5b1751368b850ac"}, "originalPosition": 634}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNDk1MTQwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQyMjozMzoyMVrOGtFTUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOTo1NTo1M1rOGzfdMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkyNTk2OQ==", "bodyText": "The names \"Simple\" and \"Complex\" are not very evocative.  How about \"NoElements...\" and \"Elements...\", or \"...WithoutElements\" and \"...WithElements\"?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r449925969", "createdAt": "2020-07-05T22:33:21Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,304 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A qualifier hierarchy where no qualifiers have arguments; that is, no qualifier is represented by\n+ * an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the hierarchy.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+public class SimpleQualifierHierarchy extends QualifierHierarchy {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39eca38dda02486bb59214fce5b1751368b850ac"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgyNTAxOQ==", "bodyText": "I'm still thinking on this.\nSimpleQualifierHierarchy:\n\nNoElementsQualifierHierarchy\nQualifierHierarchyWithElements\nDefaultQualifierHierarchy (Because it's the QualifierHierarchy used by default.)\n\nComplexQualifierHierarchy:\n\nElementsQualifierHierarchy\nQualifierHierarchyWithElements\nQualifierWithValuesHierarchy", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r451825019", "createdAt": "2020-07-08T21:05:40Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,304 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A qualifier hierarchy where no qualifiers have arguments; that is, no qualifier is represented by\n+ * an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the hierarchy.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+public class SimpleQualifierHierarchy extends QualifierHierarchy {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkyNTk2OQ=="}, "originalCommit": {"oid": "39eca38dda02486bb59214fce5b1751368b850ac"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg0Mjc1Mg==", "bodyText": "The suffixed versions QualifierHierarchyWithoutElements and QualifierHierarchyWithElements read best to me, among the options you list.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r451842752", "createdAt": "2020-07-08T21:44:49Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,304 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A qualifier hierarchy where no qualifiers have arguments; that is, no qualifier is represented by\n+ * an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the hierarchy.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+public class SimpleQualifierHierarchy extends QualifierHierarchy {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkyNTk2OQ=="}, "originalCommit": {"oid": "39eca38dda02486bb59214fce5b1751368b850ac"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY0NTkzNg==", "bodyText": "QualifierHierarchyWithoutAttributes and QualifierHierarchyWithAttributes?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456645936", "createdAt": "2020-07-17T19:55:53Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,304 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A qualifier hierarchy where no qualifiers have arguments; that is, no qualifier is represented by\n+ * an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the hierarchy.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+public class SimpleQualifierHierarchy extends QualifierHierarchy {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkyNTk2OQ=="}, "originalCommit": {"oid": "39eca38dda02486bb59214fce5b1751368b850ac"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNDk1NTcxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQyMjo0MDozNFrOGtFVdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMDoxODo1NVrOGtlwpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkyNjUxOA==", "bodyText": "Is this called frequently?  If so, would it make sense to create a map, for efficiency?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r449926518", "createdAt": "2020-07-05T22:40:34Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,304 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A qualifier hierarchy where no qualifiers have arguments; that is, no qualifier is represented by\n+ * an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the hierarchy.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+public class SimpleQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** Set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** Set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /** Mapping from {@link QualifierKind} to its corresponding {@link AnnotationMirror}. */\n+    protected final Map<QualifierKind, AnnotationMirror> qualifierMap;\n+\n+    /** Set of all annotations in the hierarchy. */\n+    protected final Set<? extends AnnotationMirror> qualifiers;\n+\n+    /**\n+     * Creates a type hierarchy from the given classes.\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers for this hierarchy\n+     * @param elements element utils\n+     */\n+    public SimpleQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.qualifierMap = createAnnotationMirrors(elements);\n+        Set<AnnotationMirror> qualifiers = AnnotationUtils.createAnnotationSet();\n+        qualifiers.addAll(qualifierMap.values());\n+        this.qualifiers = Collections.unmodifiableSet(qualifiers);\n+\n+        this.tops = createTops();\n+        this.bottoms = createBottoms();\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers for this hierarchy\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates and returns a mapping from qualifier kind to an annotation mirror created from the\n+     * qualifier kind's annotation class.\n+     *\n+     * @param elements element utils\n+     * @return a mapping from qualifier kind to an annotation mirror created from the qualifier\n+     *     kind's annotation class\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createAnnotationMirrors(Elements elements) {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (kind.hasElements()) {\n+                throw new TypeSystemError(\n+                        \"SimpleQualifierHierarchy cannot be used with annotations that have elements. Found %s: \",\n+                        kind);\n+            }\n+            quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of top {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of top {@link AnnotationMirror}s.\n+     */\n+    protected Set<AnnotationMirror> createTops() {\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : qualifierMap.entrySet()) {\n+            if (entry.getKey().isTop()) {\n+                tops.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(tops);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of bottom {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of bottom {@link AnnotationMirror}s.\n+     */\n+    protected Set<AnnotationMirror> createBottoms() {\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : qualifierMap.entrySet()) {\n+            if (entry.getKey().isBottom()) {\n+                bottoms.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(bottoms);\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation.\n+     *\n+     * @param anno an annotation that is a qualifier in this hierarchy\n+     * @return the {@code QualifierKind}\n+     * @throws BugInCF if {@code anno} is not a qualifier in this hierarchy\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39eca38dda02486bb59214fce5b1751368b850ac"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ1Nzc2Nw==", "bodyText": "Yes, it's called often, but most AnnotationMirrors are instances of CheckerFrameworkAnnotationMirror.  In those cases, AnnotationUtils.annotationName returns the annotationName field.  If it's not a CheckerFrameworkAnnotationMirror, the it's an annotation from bytecode.  In those cases there are many AnnotationMirror objects for the same qualifiers, so a map isn't helpful.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r450457767", "createdAt": "2020-07-06T20:18:55Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,304 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A qualifier hierarchy where no qualifiers have arguments; that is, no qualifier is represented by\n+ * an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the hierarchy.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+public class SimpleQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** Set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** Set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /** Mapping from {@link QualifierKind} to its corresponding {@link AnnotationMirror}. */\n+    protected final Map<QualifierKind, AnnotationMirror> qualifierMap;\n+\n+    /** Set of all annotations in the hierarchy. */\n+    protected final Set<? extends AnnotationMirror> qualifiers;\n+\n+    /**\n+     * Creates a type hierarchy from the given classes.\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers for this hierarchy\n+     * @param elements element utils\n+     */\n+    public SimpleQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.qualifierMap = createAnnotationMirrors(elements);\n+        Set<AnnotationMirror> qualifiers = AnnotationUtils.createAnnotationSet();\n+        qualifiers.addAll(qualifierMap.values());\n+        this.qualifiers = Collections.unmodifiableSet(qualifiers);\n+\n+        this.tops = createTops();\n+        this.bottoms = createBottoms();\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers for this hierarchy\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates and returns a mapping from qualifier kind to an annotation mirror created from the\n+     * qualifier kind's annotation class.\n+     *\n+     * @param elements element utils\n+     * @return a mapping from qualifier kind to an annotation mirror created from the qualifier\n+     *     kind's annotation class\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createAnnotationMirrors(Elements elements) {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (kind.hasElements()) {\n+                throw new TypeSystemError(\n+                        \"SimpleQualifierHierarchy cannot be used with annotations that have elements. Found %s: \",\n+                        kind);\n+            }\n+            quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of top {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of top {@link AnnotationMirror}s.\n+     */\n+    protected Set<AnnotationMirror> createTops() {\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : qualifierMap.entrySet()) {\n+            if (entry.getKey().isTop()) {\n+                tops.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(tops);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of bottom {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of bottom {@link AnnotationMirror}s.\n+     */\n+    protected Set<AnnotationMirror> createBottoms() {\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : qualifierMap.entrySet()) {\n+            if (entry.getKey().isBottom()) {\n+                bottoms.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(bottoms);\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation.\n+     *\n+     * @param anno an annotation that is a qualifier in this hierarchy\n+     * @return the {@code QualifierKind}\n+     * @throws BugInCF if {@code anno} is not a qualifier in this hierarchy\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkyNjUxOA=="}, "originalCommit": {"oid": "39eca38dda02486bb59214fce5b1751368b850ac"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNDk2OTY4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQyMzowMzozNFrOGtFceQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNzozOTozOFrOGthAIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkyODMxMw==", "bodyText": "Should this be TypeSystemError?  Similar question about some other uses of BugInCF.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r449928313", "createdAt": "2020-07-05T23:03:34Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,380 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A qualifier hierarchy where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>Subclasses must implement the following methods when annotations have elements:\n+ *\n+ * <ul>\n+ *   <li>{@link #isSubtype(AnnotationMirror, QualifierKind, AnnotationMirror, QualifierKind)}\n+ *   <li>{@link #leastUpperBound(AnnotationMirror, QualifierKind, AnnotationMirror, QualifierKind)}\n+ *   <li>{@link #greatestLowerBound(AnnotationMirror,QualifierKind,AnnotationMirror,QualifierKind)}\n+ * </ul>\n+ *\n+ * For cases where the annotations have no elements, the {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} meta-annotation is used.\n+ *\n+ * <p>ComplexQualifierHierarchy uses a {@link QualifierKindHierarchy} to model the relationships\n+ * between qualifiers. Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to\n+ * return a subclass of QualifierKindHierarchy.\n+ */\n+public abstract class ComplexQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils} */\n+    private Elements elements;\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** A mapping from top QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> topsMap;\n+\n+    /** The set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** A mapping from bottom QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> bottomsMap;\n+\n+    /** The set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /**\n+     * A mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations do not\n+     * have elements.\n+     */\n+    protected final Map<QualifierKind, AnnotationMirror> qualifierMap;\n+\n+    /**\n+     * Creates a type hierarchy from the given classes.\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers for this hierarchy\n+     * @param elements element utils\n+     */\n+    protected ComplexQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.elements = elements;\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.topsMap = Collections.unmodifiableMap(createTops());\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        tops.addAll(topsMap.values());\n+        this.tops = Collections.unmodifiableSet(tops);\n+\n+        this.bottomsMap = Collections.unmodifiableMap(createBottoms());\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        bottoms.addAll(bottomsMap.values());\n+        this.bottoms = Collections.unmodifiableSet(bottoms);\n+        this.qualifierMap = createQualifiers();\n+\n+        for (AnnotationMirror top : tops) {\n+            // This throws an error if poly is a qualifier that has an element.\n+            getPolymorphicAnnotation(top);\n+        }\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers for this hierarchy\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations\n+     * do not have elements.\n+     *\n+     * @return the mapping\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createQualifiers() {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (!kind.hasElements()) {\n+                quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+            }\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top.\n+     *\n+     * <p>Subclasses must override this if the top annotation has elements and provides no default.\n+     *\n+     * @return a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createTops() {\n+        Map<QualifierKind, AnnotationMirror> topsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getTops()) {\n+            topsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return topsMap;\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom.\n+     *\n+     * <p>Subclasses must override this if the bottom annotation has elements and provides not\n+     * default.\n+     *\n+     * @return a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createBottoms() {\n+        Map<QualifierKind, AnnotationMirror> bottomsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getBottoms()) {\n+            bottomsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return bottomsMap;\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the given annotation.\n+     *\n+     * @param anno annotation mirror\n+     * @return the qualifier kind for the given annotation\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        return getQualifierKind(name);\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the annotation with the fully qualified name {@code name}.\n+     *\n+     * @param name fully qualified annotation name\n+     * @return the qualifier kind for the annotation with {@code name}\n+     */\n+    protected QualifierKind getQualifierKind(String name) {\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"QualifierKind not in hierarchy: %s\", name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39eca38dda02486bb59214fce5b1751368b850ac"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM3OTgwOA==", "bodyText": "No, the methods in this class are called by the Checker Framework during type checking.  So although these could be a bug in the type system, it is just as likely a bug in the Checker Framework.  (I'll check other uses of BugInCF in this file.)", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r450379808", "createdAt": "2020-07-06T17:39:38Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,380 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A qualifier hierarchy where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>Subclasses must implement the following methods when annotations have elements:\n+ *\n+ * <ul>\n+ *   <li>{@link #isSubtype(AnnotationMirror, QualifierKind, AnnotationMirror, QualifierKind)}\n+ *   <li>{@link #leastUpperBound(AnnotationMirror, QualifierKind, AnnotationMirror, QualifierKind)}\n+ *   <li>{@link #greatestLowerBound(AnnotationMirror,QualifierKind,AnnotationMirror,QualifierKind)}\n+ * </ul>\n+ *\n+ * For cases where the annotations have no elements, the {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} meta-annotation is used.\n+ *\n+ * <p>ComplexQualifierHierarchy uses a {@link QualifierKindHierarchy} to model the relationships\n+ * between qualifiers. Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to\n+ * return a subclass of QualifierKindHierarchy.\n+ */\n+public abstract class ComplexQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils} */\n+    private Elements elements;\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** A mapping from top QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> topsMap;\n+\n+    /** The set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** A mapping from bottom QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> bottomsMap;\n+\n+    /** The set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /**\n+     * A mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations do not\n+     * have elements.\n+     */\n+    protected final Map<QualifierKind, AnnotationMirror> qualifierMap;\n+\n+    /**\n+     * Creates a type hierarchy from the given classes.\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers for this hierarchy\n+     * @param elements element utils\n+     */\n+    protected ComplexQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.elements = elements;\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.topsMap = Collections.unmodifiableMap(createTops());\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        tops.addAll(topsMap.values());\n+        this.tops = Collections.unmodifiableSet(tops);\n+\n+        this.bottomsMap = Collections.unmodifiableMap(createBottoms());\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        bottoms.addAll(bottomsMap.values());\n+        this.bottoms = Collections.unmodifiableSet(bottoms);\n+        this.qualifierMap = createQualifiers();\n+\n+        for (AnnotationMirror top : tops) {\n+            // This throws an error if poly is a qualifier that has an element.\n+            getPolymorphicAnnotation(top);\n+        }\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers for this hierarchy\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations\n+     * do not have elements.\n+     *\n+     * @return the mapping\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createQualifiers() {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (!kind.hasElements()) {\n+                quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+            }\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top.\n+     *\n+     * <p>Subclasses must override this if the top annotation has elements and provides no default.\n+     *\n+     * @return a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createTops() {\n+        Map<QualifierKind, AnnotationMirror> topsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getTops()) {\n+            topsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return topsMap;\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom.\n+     *\n+     * <p>Subclasses must override this if the bottom annotation has elements and provides not\n+     * default.\n+     *\n+     * @return a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createBottoms() {\n+        Map<QualifierKind, AnnotationMirror> bottomsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getBottoms()) {\n+            bottomsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return bottomsMap;\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the given annotation.\n+     *\n+     * @param anno annotation mirror\n+     * @return the qualifier kind for the given annotation\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        return getQualifierKind(name);\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the annotation with the fully qualified name {@code name}.\n+     *\n+     * @param name fully qualified annotation name\n+     * @return the qualifier kind for the annotation with {@code name}\n+     */\n+    protected QualifierKind getQualifierKind(String name) {\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"QualifierKind not in hierarchy: %s\", name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkyODMxMw=="}, "originalCommit": {"oid": "39eca38dda02486bb59214fce5b1751368b850ac"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDk5OTM1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDo1NzoxMFrOGwFasw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDo1NzoxMFrOGwFasw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3MzU4Nw==", "bodyText": "Since this is only for elementless qualifiers, can you change the name to make that fact more clear?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r453073587", "createdAt": "2020-07-10T20:57:10Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,309 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>Subclasses must implement the following methods when annotations have elements:\n+ *\n+ * <ul>\n+ *   <li>{@link #isSubtype(AnnotationMirror, QualifierKindHierarchy.QualifierKind, AnnotationMirror,\n+ *       QualifierKindHierarchy.QualifierKind)}\n+ *   <li>{@link #leastUpperBound(AnnotationMirror, QualifierKindHierarchy.QualifierKind,\n+ *       AnnotationMirror, QualifierKindHierarchy.QualifierKind)}\n+ *   <li>{@link #greatestLowerBound(AnnotationMirror, QualifierKindHierarchy.QualifierKind,\n+ *       AnnotationMirror, QualifierKindHierarchy.QualifierKind)}\n+ * </ul>\n+ *\n+ * For cases where the annotations have no elements, the {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} meta-annotation is used.\n+ *\n+ * <p>ComplexQualifierHierarchy uses a {@link QualifierKindHierarchy} to model the relationships\n+ * between qualifiers. Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to\n+ * return a subclass of QualifierKindHierarchy.\n+ */\n+public abstract class ComplexQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils} */\n+    private Elements elements;\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** A mapping from top QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> topsMap;\n+\n+    /** The set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** A mapping from bottom QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> bottomsMap;\n+\n+    /** The set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /**\n+     * A mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations do not\n+     * have elements.\n+     */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822c53ea840c0510edf03b5b9ece14238e60200f"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNTAwMDM4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDo1NzoyOVrOGwFbSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDo1NzoyOVrOGwFbSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3MzczNg==", "bodyText": "Please make getter method and field have more similar names.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r453073736", "createdAt": "2020-07-10T20:57:29Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,309 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>Subclasses must implement the following methods when annotations have elements:\n+ *\n+ * <ul>\n+ *   <li>{@link #isSubtype(AnnotationMirror, QualifierKindHierarchy.QualifierKind, AnnotationMirror,\n+ *       QualifierKindHierarchy.QualifierKind)}\n+ *   <li>{@link #leastUpperBound(AnnotationMirror, QualifierKindHierarchy.QualifierKind,\n+ *       AnnotationMirror, QualifierKindHierarchy.QualifierKind)}\n+ *   <li>{@link #greatestLowerBound(AnnotationMirror, QualifierKindHierarchy.QualifierKind,\n+ *       AnnotationMirror, QualifierKindHierarchy.QualifierKind)}\n+ * </ul>\n+ *\n+ * For cases where the annotations have no elements, the {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} meta-annotation is used.\n+ *\n+ * <p>ComplexQualifierHierarchy uses a {@link QualifierKindHierarchy} to model the relationships\n+ * between qualifiers. Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to\n+ * return a subclass of QualifierKindHierarchy.\n+ */\n+public abstract class ComplexQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils} */\n+    private Elements elements;\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** A mapping from top QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> topsMap;\n+\n+    /** The set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** A mapping from bottom QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> bottomsMap;\n+\n+    /** The set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /**\n+     * A mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations do not\n+     * have elements.\n+     */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    protected ComplexQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.elements = elements;\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.topsMap = Collections.unmodifiableMap(createTops());\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        tops.addAll(topsMap.values());\n+        this.tops = Collections.unmodifiableSet(tops);\n+\n+        this.bottomsMap = Collections.unmodifiableMap(createBottoms());\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        bottoms.addAll(bottomsMap.values());\n+        this.bottoms = Collections.unmodifiableSet(bottoms);\n+\n+        this.kindToAnnotationMirror = createQualifiers();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822c53ea840c0510edf03b5b9ece14238e60200f"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNTAwNDE3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDo1ODo1MVrOGwFdqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDo1ODo1MVrOGwFdqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NDM0Ng==", "bodyText": "The naming of fields and methods is a bit confusing.  The createTops method does not populate the tops field, though a reader might assume that.  Can you make the field names and method names more consistent?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r453074346", "createdAt": "2020-07-10T20:58:51Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,309 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>Subclasses must implement the following methods when annotations have elements:\n+ *\n+ * <ul>\n+ *   <li>{@link #isSubtype(AnnotationMirror, QualifierKindHierarchy.QualifierKind, AnnotationMirror,\n+ *       QualifierKindHierarchy.QualifierKind)}\n+ *   <li>{@link #leastUpperBound(AnnotationMirror, QualifierKindHierarchy.QualifierKind,\n+ *       AnnotationMirror, QualifierKindHierarchy.QualifierKind)}\n+ *   <li>{@link #greatestLowerBound(AnnotationMirror, QualifierKindHierarchy.QualifierKind,\n+ *       AnnotationMirror, QualifierKindHierarchy.QualifierKind)}\n+ * </ul>\n+ *\n+ * For cases where the annotations have no elements, the {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} meta-annotation is used.\n+ *\n+ * <p>ComplexQualifierHierarchy uses a {@link QualifierKindHierarchy} to model the relationships\n+ * between qualifiers. Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to\n+ * return a subclass of QualifierKindHierarchy.\n+ */\n+public abstract class ComplexQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils} */\n+    private Elements elements;\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** A mapping from top QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> topsMap;\n+\n+    /** The set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** A mapping from bottom QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> bottomsMap;\n+\n+    /** The set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /**\n+     * A mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations do not\n+     * have elements.\n+     */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    protected ComplexQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.elements = elements;\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.topsMap = Collections.unmodifiableMap(createTops());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822c53ea840c0510edf03b5b9ece14238e60200f"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNTAwOTQxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMTowMDo0OVrOGwFg0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMjoyODoxNlrOGwHVHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NTE1NA==", "bodyText": "I expected this test to be || rather than &&.  There could be hierarchies like\n    @Top\n   /    \\\n@B(1)   @B(2)\n\nor\n@B(1)    @B(2)\n  |        |\n @C       @D", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r453075154", "createdAt": "2020-07-10T21:00:49Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,309 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>Subclasses must implement the following methods when annotations have elements:\n+ *\n+ * <ul>\n+ *   <li>{@link #isSubtype(AnnotationMirror, QualifierKindHierarchy.QualifierKind, AnnotationMirror,\n+ *       QualifierKindHierarchy.QualifierKind)}\n+ *   <li>{@link #leastUpperBound(AnnotationMirror, QualifierKindHierarchy.QualifierKind,\n+ *       AnnotationMirror, QualifierKindHierarchy.QualifierKind)}\n+ *   <li>{@link #greatestLowerBound(AnnotationMirror, QualifierKindHierarchy.QualifierKind,\n+ *       AnnotationMirror, QualifierKindHierarchy.QualifierKind)}\n+ * </ul>\n+ *\n+ * For cases where the annotations have no elements, the {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} meta-annotation is used.\n+ *\n+ * <p>ComplexQualifierHierarchy uses a {@link QualifierKindHierarchy} to model the relationships\n+ * between qualifiers. Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to\n+ * return a subclass of QualifierKindHierarchy.\n+ */\n+public abstract class ComplexQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils} */\n+    private Elements elements;\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** A mapping from top QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> topsMap;\n+\n+    /** The set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** A mapping from bottom QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> bottomsMap;\n+\n+    /** The set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /**\n+     * A mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations do not\n+     * have elements.\n+     */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    protected ComplexQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.elements = elements;\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.topsMap = Collections.unmodifiableMap(createTops());\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        tops.addAll(topsMap.values());\n+        this.tops = Collections.unmodifiableSet(tops);\n+\n+        this.bottomsMap = Collections.unmodifiableMap(createBottoms());\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        bottoms.addAll(bottomsMap.values());\n+        this.bottoms = Collections.unmodifiableSet(bottoms);\n+\n+        this.kindToAnnotationMirror = createQualifiers();\n+\n+        for (AnnotationMirror top : tops) {\n+            // This throws an error if poly is a qualifier that has an element.\n+            getPolymorphicAnnotation(top);\n+        }\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations\n+     * do not have elements.\n+     *\n+     * @return the mapping\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createQualifiers() {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (!kind.hasElements()) {\n+                quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+            }\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top and\n+     * the AnnotationMirror is top in their respective hierarchies.\n+     *\n+     * <p>This implementation works if the top annotation has no elements, or it has elements,\n+     * provides a default, and that default is the top. Otherwise, subclasses must override this.\n+     *\n+     * @return a mapping from top QualifierKind to top AnnotationMirror\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createTops() {\n+        Map<QualifierKind, AnnotationMirror> topsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getTops()) {\n+            topsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return topsMap;\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom\n+     * and the AnnotationMirror is bottom in their respective hierarchies.\n+     *\n+     * <p>This implementation works if the bottom annotation has no elements, or it has elements,\n+     * provides a default, and that default is the bottom. Otherwise, subclasses must override this.\n+     *\n+     * @return a mapping from bottom QualifierKind to bottom AnnotationMirror\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createBottoms() {\n+        Map<QualifierKind, AnnotationMirror> bottomsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getBottoms()) {\n+            bottomsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return bottomsMap;\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the given annotation.\n+     *\n+     * @param anno annotation mirror\n+     * @return the qualifier kind for the given annotation\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        return getQualifierKind(name);\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the annotation with the fully qualified name {@code name}.\n+     *\n+     * @param name fully qualified annotation name\n+     * @return the qualifier kind for the annotation with {@code name}\n+     */\n+    protected QualifierKind getQualifierKind(String name) {\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"QualifierKind not in hierarchy: %s\", name);\n+        }\n+        return kind;\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getTopAnnotations() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public AnnotationMirror getTopAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return topsMap.get(kind.getTop());\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getBottomAnnotations() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror getPolymorphicAnnotation(AnnotationMirror start) {\n+        QualifierKind polyKind = getQualifierKind(start).getPolymorphic();\n+        if (polyKind == null) {\n+            return null;\n+        }\n+        AnnotationMirror poly = kindToAnnotationMirror.get(polyKind);\n+        if (poly == null) {\n+            throw new TypeSystemError(\n+                    \"Poly %s has an element. Override ComplexQualifierHierarchy#getPolymorphicAnnotation.\",\n+                    polyKind);\n+        }\n+        return poly;\n+    }\n+\n+    @Override\n+    public boolean isPolymorphicQualifier(AnnotationMirror qualifier) {\n+        return getQualifierKind(qualifier).isPoly();\n+    }\n+\n+    @Override\n+    public AnnotationMirror getBottomAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return bottomsMap.get(kind.getBottom());\n+    }\n+\n+    @Override\n+    public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        QualifierKind subKind = getQualifierKind(subAnno);\n+        QualifierKind superKind = getQualifierKind(superAnno);\n+        if (subKind.isSubtype(superKind)) {\n+            if (superKind.hasElements() && subKind.hasElements()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822c53ea840c0510edf03b5b9ece14238e60200f"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEwNDkyNQ==", "bodyText": "I agree that such a hierarchy could exist.  (I don't know of any.)  The current implementation of ComplexQualifierHierarchy doesn't support such a hierarchy.  If we change the implementation, then all the subclasses would have to expect those cases and add boilerplate:\nif (!superKind.hasElements() || !subKind.hasElements()) {\n    return true;\n}\n\nI could add another subclass of QualifierHierarchy that allows hierarchies like the one you mentioned.  But what should it be called? I guess in general renaming ComplexQualifierHierarchy to QualifierHierarchyWithElements isn't exactly correct because it can't represent the all hierarchies with qualifiers that have elements.\nI'll continue to think on this.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r453104925", "createdAt": "2020-07-10T22:28:16Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,309 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>Subclasses must implement the following methods when annotations have elements:\n+ *\n+ * <ul>\n+ *   <li>{@link #isSubtype(AnnotationMirror, QualifierKindHierarchy.QualifierKind, AnnotationMirror,\n+ *       QualifierKindHierarchy.QualifierKind)}\n+ *   <li>{@link #leastUpperBound(AnnotationMirror, QualifierKindHierarchy.QualifierKind,\n+ *       AnnotationMirror, QualifierKindHierarchy.QualifierKind)}\n+ *   <li>{@link #greatestLowerBound(AnnotationMirror, QualifierKindHierarchy.QualifierKind,\n+ *       AnnotationMirror, QualifierKindHierarchy.QualifierKind)}\n+ * </ul>\n+ *\n+ * For cases where the annotations have no elements, the {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} meta-annotation is used.\n+ *\n+ * <p>ComplexQualifierHierarchy uses a {@link QualifierKindHierarchy} to model the relationships\n+ * between qualifiers. Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to\n+ * return a subclass of QualifierKindHierarchy.\n+ */\n+public abstract class ComplexQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils} */\n+    private Elements elements;\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** A mapping from top QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> topsMap;\n+\n+    /** The set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** A mapping from bottom QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> bottomsMap;\n+\n+    /** The set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /**\n+     * A mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations do not\n+     * have elements.\n+     */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    protected ComplexQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.elements = elements;\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.topsMap = Collections.unmodifiableMap(createTops());\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        tops.addAll(topsMap.values());\n+        this.tops = Collections.unmodifiableSet(tops);\n+\n+        this.bottomsMap = Collections.unmodifiableMap(createBottoms());\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        bottoms.addAll(bottomsMap.values());\n+        this.bottoms = Collections.unmodifiableSet(bottoms);\n+\n+        this.kindToAnnotationMirror = createQualifiers();\n+\n+        for (AnnotationMirror top : tops) {\n+            // This throws an error if poly is a qualifier that has an element.\n+            getPolymorphicAnnotation(top);\n+        }\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations\n+     * do not have elements.\n+     *\n+     * @return the mapping\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createQualifiers() {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (!kind.hasElements()) {\n+                quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+            }\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top and\n+     * the AnnotationMirror is top in their respective hierarchies.\n+     *\n+     * <p>This implementation works if the top annotation has no elements, or it has elements,\n+     * provides a default, and that default is the top. Otherwise, subclasses must override this.\n+     *\n+     * @return a mapping from top QualifierKind to top AnnotationMirror\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createTops() {\n+        Map<QualifierKind, AnnotationMirror> topsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getTops()) {\n+            topsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return topsMap;\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom\n+     * and the AnnotationMirror is bottom in their respective hierarchies.\n+     *\n+     * <p>This implementation works if the bottom annotation has no elements, or it has elements,\n+     * provides a default, and that default is the bottom. Otherwise, subclasses must override this.\n+     *\n+     * @return a mapping from bottom QualifierKind to bottom AnnotationMirror\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createBottoms() {\n+        Map<QualifierKind, AnnotationMirror> bottomsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getBottoms()) {\n+            bottomsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return bottomsMap;\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the given annotation.\n+     *\n+     * @param anno annotation mirror\n+     * @return the qualifier kind for the given annotation\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        return getQualifierKind(name);\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the annotation with the fully qualified name {@code name}.\n+     *\n+     * @param name fully qualified annotation name\n+     * @return the qualifier kind for the annotation with {@code name}\n+     */\n+    protected QualifierKind getQualifierKind(String name) {\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"QualifierKind not in hierarchy: %s\", name);\n+        }\n+        return kind;\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getTopAnnotations() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public AnnotationMirror getTopAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return topsMap.get(kind.getTop());\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getBottomAnnotations() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror getPolymorphicAnnotation(AnnotationMirror start) {\n+        QualifierKind polyKind = getQualifierKind(start).getPolymorphic();\n+        if (polyKind == null) {\n+            return null;\n+        }\n+        AnnotationMirror poly = kindToAnnotationMirror.get(polyKind);\n+        if (poly == null) {\n+            throw new TypeSystemError(\n+                    \"Poly %s has an element. Override ComplexQualifierHierarchy#getPolymorphicAnnotation.\",\n+                    polyKind);\n+        }\n+        return poly;\n+    }\n+\n+    @Override\n+    public boolean isPolymorphicQualifier(AnnotationMirror qualifier) {\n+        return getQualifierKind(qualifier).isPoly();\n+    }\n+\n+    @Override\n+    public AnnotationMirror getBottomAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return bottomsMap.get(kind.getBottom());\n+    }\n+\n+    @Override\n+    public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        QualifierKind subKind = getQualifierKind(subAnno);\n+        QualifierKind superKind = getQualifierKind(superAnno);\n+        if (subKind.isSubtype(superKind)) {\n+            if (superKind.hasElements() && subKind.hasElements()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NTE1NA=="}, "originalCommit": {"oid": "822c53ea840c0510edf03b5b9ece14238e60200f"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNTAxMDUyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMTowMToxOVrOGwFheg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMjoyOToxOFrOGwHWRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NTMyMg==", "bodyText": "I think \"are\" should be either \"at least one has\" or \"may be\".", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r453075322", "createdAt": "2020-07-10T21:01:19Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,309 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>Subclasses must implement the following methods when annotations have elements:\n+ *\n+ * <ul>\n+ *   <li>{@link #isSubtype(AnnotationMirror, QualifierKindHierarchy.QualifierKind, AnnotationMirror,\n+ *       QualifierKindHierarchy.QualifierKind)}\n+ *   <li>{@link #leastUpperBound(AnnotationMirror, QualifierKindHierarchy.QualifierKind,\n+ *       AnnotationMirror, QualifierKindHierarchy.QualifierKind)}\n+ *   <li>{@link #greatestLowerBound(AnnotationMirror, QualifierKindHierarchy.QualifierKind,\n+ *       AnnotationMirror, QualifierKindHierarchy.QualifierKind)}\n+ * </ul>\n+ *\n+ * For cases where the annotations have no elements, the {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} meta-annotation is used.\n+ *\n+ * <p>ComplexQualifierHierarchy uses a {@link QualifierKindHierarchy} to model the relationships\n+ * between qualifiers. Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to\n+ * return a subclass of QualifierKindHierarchy.\n+ */\n+public abstract class ComplexQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils} */\n+    private Elements elements;\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** A mapping from top QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> topsMap;\n+\n+    /** The set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** A mapping from bottom QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> bottomsMap;\n+\n+    /** The set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /**\n+     * A mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations do not\n+     * have elements.\n+     */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    protected ComplexQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.elements = elements;\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.topsMap = Collections.unmodifiableMap(createTops());\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        tops.addAll(topsMap.values());\n+        this.tops = Collections.unmodifiableSet(tops);\n+\n+        this.bottomsMap = Collections.unmodifiableMap(createBottoms());\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        bottoms.addAll(bottomsMap.values());\n+        this.bottoms = Collections.unmodifiableSet(bottoms);\n+\n+        this.kindToAnnotationMirror = createQualifiers();\n+\n+        for (AnnotationMirror top : tops) {\n+            // This throws an error if poly is a qualifier that has an element.\n+            getPolymorphicAnnotation(top);\n+        }\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations\n+     * do not have elements.\n+     *\n+     * @return the mapping\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createQualifiers() {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (!kind.hasElements()) {\n+                quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+            }\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top and\n+     * the AnnotationMirror is top in their respective hierarchies.\n+     *\n+     * <p>This implementation works if the top annotation has no elements, or it has elements,\n+     * provides a default, and that default is the top. Otherwise, subclasses must override this.\n+     *\n+     * @return a mapping from top QualifierKind to top AnnotationMirror\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createTops() {\n+        Map<QualifierKind, AnnotationMirror> topsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getTops()) {\n+            topsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return topsMap;\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom\n+     * and the AnnotationMirror is bottom in their respective hierarchies.\n+     *\n+     * <p>This implementation works if the bottom annotation has no elements, or it has elements,\n+     * provides a default, and that default is the bottom. Otherwise, subclasses must override this.\n+     *\n+     * @return a mapping from bottom QualifierKind to bottom AnnotationMirror\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createBottoms() {\n+        Map<QualifierKind, AnnotationMirror> bottomsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getBottoms()) {\n+            bottomsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return bottomsMap;\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the given annotation.\n+     *\n+     * @param anno annotation mirror\n+     * @return the qualifier kind for the given annotation\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        return getQualifierKind(name);\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the annotation with the fully qualified name {@code name}.\n+     *\n+     * @param name fully qualified annotation name\n+     * @return the qualifier kind for the annotation with {@code name}\n+     */\n+    protected QualifierKind getQualifierKind(String name) {\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"QualifierKind not in hierarchy: %s\", name);\n+        }\n+        return kind;\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getTopAnnotations() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public AnnotationMirror getTopAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return topsMap.get(kind.getTop());\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getBottomAnnotations() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror getPolymorphicAnnotation(AnnotationMirror start) {\n+        QualifierKind polyKind = getQualifierKind(start).getPolymorphic();\n+        if (polyKind == null) {\n+            return null;\n+        }\n+        AnnotationMirror poly = kindToAnnotationMirror.get(polyKind);\n+        if (poly == null) {\n+            throw new TypeSystemError(\n+                    \"Poly %s has an element. Override ComplexQualifierHierarchy#getPolymorphicAnnotation.\",\n+                    polyKind);\n+        }\n+        return poly;\n+    }\n+\n+    @Override\n+    public boolean isPolymorphicQualifier(AnnotationMirror qualifier) {\n+        return getQualifierKind(qualifier).isPoly();\n+    }\n+\n+    @Override\n+    public AnnotationMirror getBottomAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return bottomsMap.get(kind.getBottom());\n+    }\n+\n+    @Override\n+    public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        QualifierKind subKind = getQualifierKind(subAnno);\n+        QualifierKind superKind = getQualifierKind(superAnno);\n+        if (subKind.isSubtype(superKind)) {\n+            if (superKind.hasElements() && subKind.hasElements()) {\n+                return isSubtype(subAnno, subKind, superAnno, superKind);\n+            } else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns whether or not {@code subAnno} is a subtype of {@code superAnno}. Both {@code\n+     * subAnno} and {@code superAnno} are annotations with elements.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822c53ea840c0510edf03b5b9ece14238e60200f"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEwNTIyMA==", "bodyText": "This is the same question as #3404 (comment), so I'm going to \"resolve\" this comment in favor of that one.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r453105220", "createdAt": "2020-07-10T22:29:18Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/ComplexQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,309 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>Subclasses must implement the following methods when annotations have elements:\n+ *\n+ * <ul>\n+ *   <li>{@link #isSubtype(AnnotationMirror, QualifierKindHierarchy.QualifierKind, AnnotationMirror,\n+ *       QualifierKindHierarchy.QualifierKind)}\n+ *   <li>{@link #leastUpperBound(AnnotationMirror, QualifierKindHierarchy.QualifierKind,\n+ *       AnnotationMirror, QualifierKindHierarchy.QualifierKind)}\n+ *   <li>{@link #greatestLowerBound(AnnotationMirror, QualifierKindHierarchy.QualifierKind,\n+ *       AnnotationMirror, QualifierKindHierarchy.QualifierKind)}\n+ * </ul>\n+ *\n+ * For cases where the annotations have no elements, the {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} meta-annotation is used.\n+ *\n+ * <p>ComplexQualifierHierarchy uses a {@link QualifierKindHierarchy} to model the relationships\n+ * between qualifiers. Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to\n+ * return a subclass of QualifierKindHierarchy.\n+ */\n+public abstract class ComplexQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils} */\n+    private Elements elements;\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** A mapping from top QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> topsMap;\n+\n+    /** The set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** A mapping from bottom QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> bottomsMap;\n+\n+    /** The set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /**\n+     * A mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations do not\n+     * have elements.\n+     */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    protected ComplexQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.elements = elements;\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.topsMap = Collections.unmodifiableMap(createTops());\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        tops.addAll(topsMap.values());\n+        this.tops = Collections.unmodifiableSet(tops);\n+\n+        this.bottomsMap = Collections.unmodifiableMap(createBottoms());\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        bottoms.addAll(bottomsMap.values());\n+        this.bottoms = Collections.unmodifiableSet(bottoms);\n+\n+        this.kindToAnnotationMirror = createQualifiers();\n+\n+        for (AnnotationMirror top : tops) {\n+            // This throws an error if poly is a qualifier that has an element.\n+            getPolymorphicAnnotation(top);\n+        }\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations\n+     * do not have elements.\n+     *\n+     * @return the mapping\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createQualifiers() {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (!kind.hasElements()) {\n+                quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+            }\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is top and\n+     * the AnnotationMirror is top in their respective hierarchies.\n+     *\n+     * <p>This implementation works if the top annotation has no elements, or it has elements,\n+     * provides a default, and that default is the top. Otherwise, subclasses must override this.\n+     *\n+     * @return a mapping from top QualifierKind to top AnnotationMirror\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createTops() {\n+        Map<QualifierKind, AnnotationMirror> topsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getTops()) {\n+            topsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return topsMap;\n+    }\n+\n+    /**\n+     * Creates a mapping from QualifierKind to AnnotationMirror, where the QualifierKind is bottom\n+     * and the AnnotationMirror is bottom in their respective hierarchies.\n+     *\n+     * <p>This implementation works if the bottom annotation has no elements, or it has elements,\n+     * provides a default, and that default is the bottom. Otherwise, subclasses must override this.\n+     *\n+     * @return a mapping from bottom QualifierKind to bottom AnnotationMirror\n+     */\n+    protected Map<QualifierKind, AnnotationMirror> createBottoms() {\n+        Map<QualifierKind, AnnotationMirror> bottomsMap = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.getBottoms()) {\n+            bottomsMap.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return bottomsMap;\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the given annotation.\n+     *\n+     * @param anno annotation mirror\n+     * @return the qualifier kind for the given annotation\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        return getQualifierKind(name);\n+    }\n+\n+    /**\n+     * Returns the qualifier kind for the annotation with the fully qualified name {@code name}.\n+     *\n+     * @param name fully qualified annotation name\n+     * @return the qualifier kind for the annotation with {@code name}\n+     */\n+    protected QualifierKind getQualifierKind(String name) {\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"QualifierKind not in hierarchy: %s\", name);\n+        }\n+        return kind;\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getTopAnnotations() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public AnnotationMirror getTopAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return topsMap.get(kind.getTop());\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getBottomAnnotations() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror getPolymorphicAnnotation(AnnotationMirror start) {\n+        QualifierKind polyKind = getQualifierKind(start).getPolymorphic();\n+        if (polyKind == null) {\n+            return null;\n+        }\n+        AnnotationMirror poly = kindToAnnotationMirror.get(polyKind);\n+        if (poly == null) {\n+            throw new TypeSystemError(\n+                    \"Poly %s has an element. Override ComplexQualifierHierarchy#getPolymorphicAnnotation.\",\n+                    polyKind);\n+        }\n+        return poly;\n+    }\n+\n+    @Override\n+    public boolean isPolymorphicQualifier(AnnotationMirror qualifier) {\n+        return getQualifierKind(qualifier).isPoly();\n+    }\n+\n+    @Override\n+    public AnnotationMirror getBottomAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return bottomsMap.get(kind.getBottom());\n+    }\n+\n+    @Override\n+    public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        QualifierKind subKind = getQualifierKind(subAnno);\n+        QualifierKind superKind = getQualifierKind(superAnno);\n+        if (subKind.isSubtype(superKind)) {\n+            if (superKind.hasElements() && subKind.hasElements()) {\n+                return isSubtype(subAnno, subKind, superAnno, superKind);\n+            } else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns whether or not {@code subAnno} is a subtype of {@code superAnno}. Both {@code\n+     * subAnno} and {@code superAnno} are annotations with elements.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NTMyMg=="}, "originalCommit": {"oid": "822c53ea840c0510edf03b5b9ece14238e60200f"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODA2MjQ0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzoxNDo1MFrOGza10w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzoxNDo1MFrOGza10w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3MDMyMw==", "bodyText": "What about the other direction? If qualifier kinds are not subtypes, then is it guaranteed that the qualifiers of those kinds are not subtypes, right?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456570323", "createdAt": "2020-07-17T17:14:50Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODA3NTM2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzoxODo1M1rOGza97g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzoxODo1M1rOGza97g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3MjM5OA==", "bodyText": "Could you split this into a top-level interface and then either a top-level AbstractQualifierKind class or a nested class in AbstractQualifierKindHierarchy?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456572398", "createdAt": "2020-07-17T17:18:53Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODA4MDcwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzoyMDoyOFrOGzbBRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzoyMDoyOFrOGzbBRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3MzI1Mw==", "bodyText": "This comment seems out of date.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456573253", "createdAt": "2020-07-17T17:20:28Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private @MonotonicNonNull Set<QualifierKind> strictSuperTypes;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = annotationClassName(clazz).intern();\n+            this.poly = null;\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODA4ODg4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzoyMzowOFrOGzbGUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzoyMzowOFrOGzbGUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU3NDU0NA==", "bodyText": "Can you add a comment why this is a NavigableMap?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456574544", "createdAt": "2020-07-17T17:23:08Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private @MonotonicNonNull Set<QualifierKind> strictSuperTypes;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = annotationClassName(clazz).intern();\n+            this.poly = null;\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            //            strictSuperTypes = null;\n+            //            top = null;\n+            //            bottom = null;\n+\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            assert top != null : \"@AssumeAssertion(nullness): top must be nonnull.\";\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            assert bottom != null : \"@AssumeAssertion(nullness): bottom must be nonnull.\";\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         * belongs.\n+         *\n+         * @return the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         *     belongs\n+         */\n+        public @Nullable QualifierKind getPolymorphic() {\n+            return poly;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return this.poly == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean isInSameHierarchyAs(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Returns whether or not this qualifier kind is a subtype of or equal to {@code\n+         * superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name.substring(name.lastIndexOf(\".\") + 1);\n+        }\n+    }\n+\n+    // End of QualifierKind class, start of QualifierKindHierarchy fields.\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 254}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODE2MTI2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzo0NjowOVrOGzbyHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNzo0NjowOVrOGzbyHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU4NTc1Ng==", "bodyText": "Could you extract an interface QualifierKindHierarchy and leave the implementation details in AbstractQualifierKindHierarchy?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456585756", "createdAt": "2020-07-17T17:46:09Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODQyNDIyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOToxMTo1NVrOGzeTYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOToxMTo1NVrOGzeTYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYyNzA0MQ==", "bodyText": "I think I would add this to the individual fields. It's hard to miss here.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456627041", "createdAt": "2020-07-17T19:11:55Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODQyOTY3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOToxNDowNVrOGzeWyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOToxNDowNVrOGzeWyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYyNzkxNA==", "bodyText": "Is elements the best name for this? Would attributes be clearer?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456627914", "createdAt": "2020-07-17T19:14:05Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODQzNzcwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOToxNzowM1rOGzebtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOToxNzowM1rOGzebtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYyOTE3NA==", "bodyText": "Should the return type be @Interned?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456629174", "createdAt": "2020-07-17T19:17:03Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private @MonotonicNonNull Set<QualifierKind> strictSuperTypes;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = annotationClassName(clazz).intern();\n+            this.poly = null;\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            //            strictSuperTypes = null;\n+            //            top = null;\n+            //            bottom = null;\n+\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODQ0Mjg1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOToxODo1NVrOGzee3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOToxODo1NVrOGzee3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYyOTk4MA==", "bodyText": "Should this (and same for bottom below) throw a BugInCF? It's an error to call getTop before it was set.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456629980", "createdAt": "2020-07-17T19:18:55Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private @MonotonicNonNull Set<QualifierKind> strictSuperTypes;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = annotationClassName(clazz).intern();\n+            this.poly = null;\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            //            strictSuperTypes = null;\n+            //            top = null;\n+            //            bottom = null;\n+\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            assert top != null : \"@AssumeAssertion(nullness): top must be nonnull.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODQ0NjI3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOToyMDoxMFrOGzehFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOToyMDoxMFrOGzehFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYzMDU0OA==", "bodyText": "Add a comment when this can be null.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456630548", "createdAt": "2020-07-17T19:20:10Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private @MonotonicNonNull Set<QualifierKind> strictSuperTypes;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = annotationClassName(clazz).intern();\n+            this.poly = null;\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            //            strictSuperTypes = null;\n+            //            top = null;\n+            //            bottom = null;\n+\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            assert top != null : \"@AssumeAssertion(nullness): top must be nonnull.\";\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            assert bottom != null : \"@AssumeAssertion(nullness): bottom must be nonnull.\";\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         * belongs.\n+         *\n+         * @return the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         *     belongs", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODQ1NTAyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOToyMzozMFrOGzemeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOToyMzozMFrOGzemeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYzMTkyOQ==", "bodyText": "I'm a bit confused by the ordering of methods. Shouldn't isTop be next to getTop?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456631929", "createdAt": "2020-07-17T19:23:30Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private @MonotonicNonNull Set<QualifierKind> strictSuperTypes;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = annotationClassName(clazz).intern();\n+            this.poly = null;\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            //            strictSuperTypes = null;\n+            //            top = null;\n+            //            bottom = null;\n+\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            assert top != null : \"@AssumeAssertion(nullness): top must be nonnull.\";\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            assert bottom != null : \"@AssumeAssertion(nullness): bottom must be nonnull.\";\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         * belongs.\n+         *\n+         * @return the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         *     belongs\n+         */\n+        public @Nullable QualifierKind getPolymorphic() {\n+            return poly;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return this.poly == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODQ2MjIxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOToyNjoxNFrOGzequw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOToyNjoxNFrOGzequw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYzMzAxOQ==", "bodyText": "How about return clazz.getSimpleName()?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456633019", "createdAt": "2020-07-17T19:26:14Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private @MonotonicNonNull Set<QualifierKind> strictSuperTypes;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = annotationClassName(clazz).intern();\n+            this.poly = null;\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            //            strictSuperTypes = null;\n+            //            top = null;\n+            //            bottom = null;\n+\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            assert top != null : \"@AssumeAssertion(nullness): top must be nonnull.\";\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            assert bottom != null : \"@AssumeAssertion(nullness): bottom must be nonnull.\";\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         * belongs.\n+         *\n+         * @return the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         *     belongs\n+         */\n+        public @Nullable QualifierKind getPolymorphic() {\n+            return poly;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return this.poly == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean isInSameHierarchyAs(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Returns whether or not this qualifier kind is a subtype of or equal to {@code\n+         * superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name.substring(name.lastIndexOf(\".\") + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODQ4MTUxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOTozMzoxMFrOGze2NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOTozMzoxMFrOGze2NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYzNTk1Ng==", "bodyText": "The lub in this comment (and the glb below) should be plurals lubs/glbs to refer to the right fields.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456635956", "createdAt": "2020-07-17T19:33:10Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private @MonotonicNonNull Set<QualifierKind> strictSuperTypes;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = annotationClassName(clazz).intern();\n+            this.poly = null;\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            //            strictSuperTypes = null;\n+            //            top = null;\n+            //            bottom = null;\n+\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            assert top != null : \"@AssumeAssertion(nullness): top must be nonnull.\";\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            assert bottom != null : \"@AssumeAssertion(nullness): bottom must be nonnull.\";\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         * belongs.\n+         *\n+         * @return the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         *     belongs\n+         */\n+        public @Nullable QualifierKind getPolymorphic() {\n+            return poly;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return this.poly == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean isInSameHierarchyAs(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Returns whether or not this qualifier kind is a subtype of or equal to {@code\n+         * superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name.substring(name.lastIndexOf(\".\") + 1);\n+        }\n+    }\n+\n+    // End of QualifierKind class, start of QualifierKindHierarchy fields.\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}; or {@code null} if the qualifier\n+     * kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind always\n+     * does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lub.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 304}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODQ4OTE3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOTozNTo1NlrOGze62Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOTozNTo1NlrOGze62Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYzNzE0NQ==", "bodyText": "Can we separate the hierarchy from the builder/factory that builds it, i.e. have two classes instead of mixing these two aspects?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456637145", "createdAt": "2020-07-17T19:35:56Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private @MonotonicNonNull Set<QualifierKind> strictSuperTypes;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = annotationClassName(clazz).intern();\n+            this.poly = null;\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            //            strictSuperTypes = null;\n+            //            top = null;\n+            //            bottom = null;\n+\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            assert top != null : \"@AssumeAssertion(nullness): top must be nonnull.\";\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            assert bottom != null : \"@AssumeAssertion(nullness): bottom must be nonnull.\";\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         * belongs.\n+         *\n+         * @return the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         *     belongs\n+         */\n+        public @Nullable QualifierKind getPolymorphic() {\n+            return poly;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return this.poly == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean isInSameHierarchyAs(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Returns whether or not this qualifier kind is a subtype of or equal to {@code\n+         * superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name.substring(name.lastIndexOf(\".\") + 1);\n+        }\n+    }\n+\n+    // End of QualifierKind class, start of QualifierKindHierarchy fields.\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}; or {@code null} if the qualifier\n+     * kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind always\n+     * does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lub.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}; or {@code null} if the\n+     * qualifier kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind\n+     * always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glb.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 347}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODQ5ODUxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOTozOToyOFrOGzfArg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOTozOToyOFrOGzfArg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYzODYzOA==", "bodyText": "uses should be use.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456638638", "createdAt": "2020-07-17T19:39:28Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private @MonotonicNonNull Set<QualifierKind> strictSuperTypes;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = annotationClassName(clazz).intern();\n+            this.poly = null;\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            //            strictSuperTypes = null;\n+            //            top = null;\n+            //            bottom = null;\n+\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            assert top != null : \"@AssumeAssertion(nullness): top must be nonnull.\";\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            assert bottom != null : \"@AssumeAssertion(nullness): bottom must be nonnull.\";\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         * belongs.\n+         *\n+         * @return the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         *     belongs\n+         */\n+        public @Nullable QualifierKind getPolymorphic() {\n+            return poly;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return this.poly == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean isInSameHierarchyAs(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Returns whether or not this qualifier kind is a subtype of or equal to {@code\n+         * superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name.substring(name.lastIndexOf(\".\") + 1);\n+        }\n+    }\n+\n+    // End of QualifierKind class, start of QualifierKindHierarchy fields.\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}; or {@code null} if the qualifier\n+     * kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind always\n+     * does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lub.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}; or {@code null} if the\n+     * qualifier kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind\n+     * always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glb.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, uses this constructor. Otherwise, use the other constructor.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 366}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODUxOTQ5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOTo0Njo0OFrOGzfNjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDo1NDowMVrOG0e5uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY0MTkzMg==", "bodyText": "clazz.isAnonymousClass would be a more direct expression of the property you care about.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456641932", "createdAt": "2020-07-17T19:46:48Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private @MonotonicNonNull Set<QualifierKind> strictSuperTypes;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = annotationClassName(clazz).intern();\n+            this.poly = null;\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            //            strictSuperTypes = null;\n+            //            top = null;\n+            //            bottom = null;\n+\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            assert top != null : \"@AssumeAssertion(nullness): top must be nonnull.\";\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            assert bottom != null : \"@AssumeAssertion(nullness): bottom must be nonnull.\";\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         * belongs.\n+         *\n+         * @return the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         *     belongs\n+         */\n+        public @Nullable QualifierKind getPolymorphic() {\n+            return poly;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return this.poly == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean isInSameHierarchyAs(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Returns whether or not this qualifier kind is a subtype of or equal to {@code\n+         * superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name.substring(name.lastIndexOf(\".\") + 1);\n+        }\n+    }\n+\n+    // End of QualifierKind class, start of QualifierKindHierarchy fields.\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}; or {@code null} if the qualifier\n+     * kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind always\n+     * does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lub.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}; or {@code null} if the\n+     * qualifier kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind\n+     * always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glb.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, uses this constructor. Otherwise, use the other constructor.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     * @param bottom the bottom qualifier of this hierarchy\n+     */\n+    public QualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        setBottom(bottom, directSuperMap);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.tops\", \"this.bottoms\"})\n+    protected void verifyHierarchy(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly();\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected NavigableMap<@Interned String, QualifierKind> createQualifierKinds(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.name);\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableNavigableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    @RequiresNonNull(\"this.nameToQualifierKind\")\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap(\n+            @UnderInitialization QualifierKindHierarchy this) {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno == null) {\n+                continue;\n+            }\n+            Set<QualifierKind> directSupers = new TreeSet<>();\n+            directSuperMap.put(qualifierKind, directSupers);\n+            for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                String superName = annotationClassName(superClazz);\n+                QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                if (superQualifier == null) {\n+                    throw new TypeSystemError(\n+                            \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                            qualifierKind,\n+                            superName,\n+                            SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                }\n+                directSupers.add(superQualifier);\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * If {@code bottom} is nonnull, then this method sets bottom to the given class and modify\n+     * {@code directSuperMap} to add all leaves to its super qualifier kinds. Leaves are qualifier\n+     * kinds that are not super qualifier kinds of another qualifier kind.\n+     *\n+     * <p>If {@code bottom} is {@code null}, then this method does nothing.\n+     *\n+     * @param bottom the class of the bottom qualifer in the hierarchy\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; side-effected by this method\n+     */\n+    @RequiresNonNull(\"this.nameToQualifierKind\")\n+    private void setBottom(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            @Nullable Class<? extends Annotation> bottom,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        if (bottom == null) {\n+            return;\n+        }\n+        QualifierKind bottomKind = nameToQualifierKind.get(annotationClassName(bottom));\n+        if (bottomKind == null) {\n+            throw new TypeSystemError(\n+                    \"QualifierKindHierarchy#setBottom: the given bottom class, %s, is not in the hierarchy.\",\n+                    bottom.getCanonicalName());\n+        }\n+\n+        Set<QualifierKind> currentLeaves = new TreeSet<>(nameToQualifierKind.values());\n+        currentLeaves.remove(bottomKind);\n+        directSuperMap.forEach(\n+                (sub, supers) -> {\n+                    currentLeaves.removeAll(supers);\n+                });\n+        Set<QualifierKind> bottomDirectSuperQuals = directSuperMap.get(bottomKind);\n+        if (bottomDirectSuperQuals == null) {\n+            directSuperMap.put(bottomKind, currentLeaves);\n+        } else {\n+            bottomDirectSuperQuals.addAll(currentLeaves);\n+        }\n+    }\n+\n+    /**\n+     * Returns the canonical name of {@code clazz}. Throws a {@link TypeSystemError} if {@code\n+     * clazz} is anonymous or otherwise does not have a name.\n+     *\n+     * @param clazz annotation class\n+     * @return the canonical name of {@code clazz}\n+     */\n+    public static String annotationClassName(Class<? extends Annotation> clazz) {\n+        String name = clazz.getCanonicalName();\n+        if (name == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 547}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY4NTQzMg==", "bodyText": "I care that name is not null.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r457685432", "createdAt": "2020-07-20T20:54:01Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private @MonotonicNonNull Set<QualifierKind> strictSuperTypes;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = annotationClassName(clazz).intern();\n+            this.poly = null;\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            //            strictSuperTypes = null;\n+            //            top = null;\n+            //            bottom = null;\n+\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            assert top != null : \"@AssumeAssertion(nullness): top must be nonnull.\";\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            assert bottom != null : \"@AssumeAssertion(nullness): bottom must be nonnull.\";\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         * belongs.\n+         *\n+         * @return the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         *     belongs\n+         */\n+        public @Nullable QualifierKind getPolymorphic() {\n+            return poly;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return this.poly == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean isInSameHierarchyAs(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Returns whether or not this qualifier kind is a subtype of or equal to {@code\n+         * superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name.substring(name.lastIndexOf(\".\") + 1);\n+        }\n+    }\n+\n+    // End of QualifierKind class, start of QualifierKindHierarchy fields.\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}; or {@code null} if the qualifier\n+     * kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind always\n+     * does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lub.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}; or {@code null} if the\n+     * qualifier kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind\n+     * always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glb.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, uses this constructor. Otherwise, use the other constructor.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     * @param bottom the bottom qualifier of this hierarchy\n+     */\n+    public QualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        setBottom(bottom, directSuperMap);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.tops\", \"this.bottoms\"})\n+    protected void verifyHierarchy(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly();\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected NavigableMap<@Interned String, QualifierKind> createQualifierKinds(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.name);\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableNavigableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    @RequiresNonNull(\"this.nameToQualifierKind\")\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap(\n+            @UnderInitialization QualifierKindHierarchy this) {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno == null) {\n+                continue;\n+            }\n+            Set<QualifierKind> directSupers = new TreeSet<>();\n+            directSuperMap.put(qualifierKind, directSupers);\n+            for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                String superName = annotationClassName(superClazz);\n+                QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                if (superQualifier == null) {\n+                    throw new TypeSystemError(\n+                            \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                            qualifierKind,\n+                            superName,\n+                            SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                }\n+                directSupers.add(superQualifier);\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * If {@code bottom} is nonnull, then this method sets bottom to the given class and modify\n+     * {@code directSuperMap} to add all leaves to its super qualifier kinds. Leaves are qualifier\n+     * kinds that are not super qualifier kinds of another qualifier kind.\n+     *\n+     * <p>If {@code bottom} is {@code null}, then this method does nothing.\n+     *\n+     * @param bottom the class of the bottom qualifer in the hierarchy\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; side-effected by this method\n+     */\n+    @RequiresNonNull(\"this.nameToQualifierKind\")\n+    private void setBottom(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            @Nullable Class<? extends Annotation> bottom,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        if (bottom == null) {\n+            return;\n+        }\n+        QualifierKind bottomKind = nameToQualifierKind.get(annotationClassName(bottom));\n+        if (bottomKind == null) {\n+            throw new TypeSystemError(\n+                    \"QualifierKindHierarchy#setBottom: the given bottom class, %s, is not in the hierarchy.\",\n+                    bottom.getCanonicalName());\n+        }\n+\n+        Set<QualifierKind> currentLeaves = new TreeSet<>(nameToQualifierKind.values());\n+        currentLeaves.remove(bottomKind);\n+        directSuperMap.forEach(\n+                (sub, supers) -> {\n+                    currentLeaves.removeAll(supers);\n+                });\n+        Set<QualifierKind> bottomDirectSuperQuals = directSuperMap.get(bottomKind);\n+        if (bottomDirectSuperQuals == null) {\n+            directSuperMap.put(bottomKind, currentLeaves);\n+        } else {\n+            bottomDirectSuperQuals.addAll(currentLeaves);\n+        }\n+    }\n+\n+    /**\n+     * Returns the canonical name of {@code clazz}. Throws a {@link TypeSystemError} if {@code\n+     * clazz} is anonymous or otherwise does not have a name.\n+     *\n+     * @param clazz annotation class\n+     * @return the canonical name of {@code clazz}\n+     */\n+    public static String annotationClassName(Class<? extends Annotation> clazz) {\n+        String name = clazz.getCanonicalName();\n+        if (name == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY0MTkzMg=="}, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 547}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODUyNTk5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOTo0OToxNlrOGzfRqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDo1NDo1OFrOG0e70w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY0Mjk4Ng==", "bodyText": "This method is private, so subclasses can't override or use this method.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456642986", "createdAt": "2020-07-17T19:49:16Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private @MonotonicNonNull Set<QualifierKind> strictSuperTypes;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = annotationClassName(clazz).intern();\n+            this.poly = null;\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            //            strictSuperTypes = null;\n+            //            top = null;\n+            //            bottom = null;\n+\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            assert top != null : \"@AssumeAssertion(nullness): top must be nonnull.\";\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            assert bottom != null : \"@AssumeAssertion(nullness): bottom must be nonnull.\";\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         * belongs.\n+         *\n+         * @return the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         *     belongs\n+         */\n+        public @Nullable QualifierKind getPolymorphic() {\n+            return poly;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return this.poly == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean isInSameHierarchyAs(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Returns whether or not this qualifier kind is a subtype of or equal to {@code\n+         * superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name.substring(name.lastIndexOf(\".\") + 1);\n+        }\n+    }\n+\n+    // End of QualifierKind class, start of QualifierKindHierarchy fields.\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}; or {@code null} if the qualifier\n+     * kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind always\n+     * does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lub.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}; or {@code null} if the\n+     * qualifier kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind\n+     * always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glb.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, uses this constructor. Otherwise, use the other constructor.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     * @param bottom the bottom qualifier of this hierarchy\n+     */\n+    public QualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        setBottom(bottom, directSuperMap);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.tops\", \"this.bottoms\"})\n+    protected void verifyHierarchy(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly();\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected NavigableMap<@Interned String, QualifierKind> createQualifierKinds(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.name);\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableNavigableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    @RequiresNonNull(\"this.nameToQualifierKind\")\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap(\n+            @UnderInitialization QualifierKindHierarchy this) {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno == null) {\n+                continue;\n+            }\n+            Set<QualifierKind> directSupers = new TreeSet<>();\n+            directSuperMap.put(qualifierKind, directSupers);\n+            for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                String superName = annotationClassName(superClazz);\n+                QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                if (superQualifier == null) {\n+                    throw new TypeSystemError(\n+                            \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                            qualifierKind,\n+                            superName,\n+                            SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                }\n+                directSupers.add(superQualifier);\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * If {@code bottom} is nonnull, then this method sets bottom to the given class and modify\n+     * {@code directSuperMap} to add all leaves to its super qualifier kinds. Leaves are qualifier\n+     * kinds that are not super qualifier kinds of another qualifier kind.\n+     *\n+     * <p>If {@code bottom} is {@code null}, then this method does nothing.\n+     *\n+     * @param bottom the class of the bottom qualifer in the hierarchy\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; side-effected by this method\n+     */\n+    @RequiresNonNull(\"this.nameToQualifierKind\")\n+    private void setBottom(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            @Nullable Class<? extends Annotation> bottom,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        if (bottom == null) {\n+            return;\n+        }\n+        QualifierKind bottomKind = nameToQualifierKind.get(annotationClassName(bottom));\n+        if (bottomKind == null) {\n+            throw new TypeSystemError(\n+                    \"QualifierKindHierarchy#setBottom: the given bottom class, %s, is not in the hierarchy.\",\n+                    bottom.getCanonicalName());\n+        }\n+\n+        Set<QualifierKind> currentLeaves = new TreeSet<>(nameToQualifierKind.values());\n+        currentLeaves.remove(bottomKind);\n+        directSuperMap.forEach(\n+                (sub, supers) -> {\n+                    currentLeaves.removeAll(supers);\n+                });\n+        Set<QualifierKind> bottomDirectSuperQuals = directSuperMap.get(bottomKind);\n+        if (bottomDirectSuperQuals == null) {\n+            directSuperMap.put(bottomKind, currentLeaves);\n+        } else {\n+            bottomDirectSuperQuals.addAll(currentLeaves);\n+        }\n+    }\n+\n+    /**\n+     * Returns the canonical name of {@code clazz}. Throws a {@link TypeSystemError} if {@code\n+     * clazz} is anonymous or otherwise does not have a name.\n+     *\n+     * @param clazz annotation class\n+     * @return the canonical name of {@code clazz}\n+     */\n+    public static String annotationClassName(Class<? extends Annotation> clazz) {\n+        String name = clazz.getCanonicalName();\n+        if (name == null) {\n+            throw new TypeSystemError(\"Qualifier classes must not be anonymous.\");\n+        }\n+        return name;\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifier kinds without any direct super qualifier kinds.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 561}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY4NTk3MQ==", "bodyText": "This comment is to explain why it is private.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r457685971", "createdAt": "2020-07-20T20:54:58Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private @MonotonicNonNull Set<QualifierKind> strictSuperTypes;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = annotationClassName(clazz).intern();\n+            this.poly = null;\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            //            strictSuperTypes = null;\n+            //            top = null;\n+            //            bottom = null;\n+\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            assert top != null : \"@AssumeAssertion(nullness): top must be nonnull.\";\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            assert bottom != null : \"@AssumeAssertion(nullness): bottom must be nonnull.\";\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         * belongs.\n+         *\n+         * @return the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         *     belongs\n+         */\n+        public @Nullable QualifierKind getPolymorphic() {\n+            return poly;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return this.poly == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean isInSameHierarchyAs(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Returns whether or not this qualifier kind is a subtype of or equal to {@code\n+         * superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name.substring(name.lastIndexOf(\".\") + 1);\n+        }\n+    }\n+\n+    // End of QualifierKind class, start of QualifierKindHierarchy fields.\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}; or {@code null} if the qualifier\n+     * kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind always\n+     * does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lub.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}; or {@code null} if the\n+     * qualifier kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind\n+     * always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glb.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, uses this constructor. Otherwise, use the other constructor.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     * @param bottom the bottom qualifier of this hierarchy\n+     */\n+    public QualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        setBottom(bottom, directSuperMap);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.tops\", \"this.bottoms\"})\n+    protected void verifyHierarchy(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly();\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected NavigableMap<@Interned String, QualifierKind> createQualifierKinds(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.name);\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableNavigableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    @RequiresNonNull(\"this.nameToQualifierKind\")\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap(\n+            @UnderInitialization QualifierKindHierarchy this) {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno == null) {\n+                continue;\n+            }\n+            Set<QualifierKind> directSupers = new TreeSet<>();\n+            directSuperMap.put(qualifierKind, directSupers);\n+            for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                String superName = annotationClassName(superClazz);\n+                QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                if (superQualifier == null) {\n+                    throw new TypeSystemError(\n+                            \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                            qualifierKind,\n+                            superName,\n+                            SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                }\n+                directSupers.add(superQualifier);\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * If {@code bottom} is nonnull, then this method sets bottom to the given class and modify\n+     * {@code directSuperMap} to add all leaves to its super qualifier kinds. Leaves are qualifier\n+     * kinds that are not super qualifier kinds of another qualifier kind.\n+     *\n+     * <p>If {@code bottom} is {@code null}, then this method does nothing.\n+     *\n+     * @param bottom the class of the bottom qualifer in the hierarchy\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; side-effected by this method\n+     */\n+    @RequiresNonNull(\"this.nameToQualifierKind\")\n+    private void setBottom(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            @Nullable Class<? extends Annotation> bottom,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        if (bottom == null) {\n+            return;\n+        }\n+        QualifierKind bottomKind = nameToQualifierKind.get(annotationClassName(bottom));\n+        if (bottomKind == null) {\n+            throw new TypeSystemError(\n+                    \"QualifierKindHierarchy#setBottom: the given bottom class, %s, is not in the hierarchy.\",\n+                    bottom.getCanonicalName());\n+        }\n+\n+        Set<QualifierKind> currentLeaves = new TreeSet<>(nameToQualifierKind.values());\n+        currentLeaves.remove(bottomKind);\n+        directSuperMap.forEach(\n+                (sub, supers) -> {\n+                    currentLeaves.removeAll(supers);\n+                });\n+        Set<QualifierKind> bottomDirectSuperQuals = directSuperMap.get(bottomKind);\n+        if (bottomDirectSuperQuals == null) {\n+            directSuperMap.put(bottomKind, currentLeaves);\n+        } else {\n+            bottomDirectSuperQuals.addAll(currentLeaves);\n+        }\n+    }\n+\n+    /**\n+     * Returns the canonical name of {@code clazz}. Throws a {@link TypeSystemError} if {@code\n+     * clazz} is anonymous or otherwise does not have a name.\n+     *\n+     * @param clazz annotation class\n+     * @return the canonical name of {@code clazz}\n+     */\n+    public static String annotationClassName(Class<? extends Annotation> clazz) {\n+        String name = clazz.getCanonicalName();\n+        if (name == null) {\n+            throw new TypeSystemError(\"Qualifier classes must not be anonymous.\");\n+        }\n+        return name;\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifier kinds without any direct super qualifier kinds.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY0Mjk4Ng=="}, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 561}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODUzODQyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOTo1MzozOVrOGzfZZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNjozNTo0MFrOG4VDbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY0NDk2Ng==", "bodyText": "For a few methods I was wondering why they are protected and not private. Should findLowestQualifiers be listed in the class documentation as an extension point? Or should it be private? Same for highest later.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456644966", "createdAt": "2020-07-17T19:53:39Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private @MonotonicNonNull Set<QualifierKind> strictSuperTypes;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = annotationClassName(clazz).intern();\n+            this.poly = null;\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            //            strictSuperTypes = null;\n+            //            top = null;\n+            //            bottom = null;\n+\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            assert top != null : \"@AssumeAssertion(nullness): top must be nonnull.\";\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            assert bottom != null : \"@AssumeAssertion(nullness): bottom must be nonnull.\";\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         * belongs.\n+         *\n+         * @return the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         *     belongs\n+         */\n+        public @Nullable QualifierKind getPolymorphic() {\n+            return poly;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return this.poly == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean isInSameHierarchyAs(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Returns whether or not this qualifier kind is a subtype of or equal to {@code\n+         * superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name.substring(name.lastIndexOf(\".\") + 1);\n+        }\n+    }\n+\n+    // End of QualifierKind class, start of QualifierKindHierarchy fields.\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}; or {@code null} if the qualifier\n+     * kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind always\n+     * does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lub.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}; or {@code null} if the\n+     * qualifier kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind\n+     * always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glb.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, uses this constructor. Otherwise, use the other constructor.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     * @param bottom the bottom qualifier of this hierarchy\n+     */\n+    public QualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        setBottom(bottom, directSuperMap);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.tops\", \"this.bottoms\"})\n+    protected void verifyHierarchy(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly();\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected NavigableMap<@Interned String, QualifierKind> createQualifierKinds(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.name);\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableNavigableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    @RequiresNonNull(\"this.nameToQualifierKind\")\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap(\n+            @UnderInitialization QualifierKindHierarchy this) {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno == null) {\n+                continue;\n+            }\n+            Set<QualifierKind> directSupers = new TreeSet<>();\n+            directSuperMap.put(qualifierKind, directSupers);\n+            for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                String superName = annotationClassName(superClazz);\n+                QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                if (superQualifier == null) {\n+                    throw new TypeSystemError(\n+                            \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                            qualifierKind,\n+                            superName,\n+                            SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                }\n+                directSupers.add(superQualifier);\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * If {@code bottom} is nonnull, then this method sets bottom to the given class and modify\n+     * {@code directSuperMap} to add all leaves to its super qualifier kinds. Leaves are qualifier\n+     * kinds that are not super qualifier kinds of another qualifier kind.\n+     *\n+     * <p>If {@code bottom} is {@code null}, then this method does nothing.\n+     *\n+     * @param bottom the class of the bottom qualifer in the hierarchy\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; side-effected by this method\n+     */\n+    @RequiresNonNull(\"this.nameToQualifierKind\")\n+    private void setBottom(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            @Nullable Class<? extends Annotation> bottom,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        if (bottom == null) {\n+            return;\n+        }\n+        QualifierKind bottomKind = nameToQualifierKind.get(annotationClassName(bottom));\n+        if (bottomKind == null) {\n+            throw new TypeSystemError(\n+                    \"QualifierKindHierarchy#setBottom: the given bottom class, %s, is not in the hierarchy.\",\n+                    bottom.getCanonicalName());\n+        }\n+\n+        Set<QualifierKind> currentLeaves = new TreeSet<>(nameToQualifierKind.values());\n+        currentLeaves.remove(bottomKind);\n+        directSuperMap.forEach(\n+                (sub, supers) -> {\n+                    currentLeaves.removeAll(supers);\n+                });\n+        Set<QualifierKind> bottomDirectSuperQuals = directSuperMap.get(bottomKind);\n+        if (bottomDirectSuperQuals == null) {\n+            directSuperMap.put(bottomKind, currentLeaves);\n+        } else {\n+            bottomDirectSuperQuals.addAll(currentLeaves);\n+        }\n+    }\n+\n+    /**\n+     * Returns the canonical name of {@code clazz}. Throws a {@link TypeSystemError} if {@code\n+     * clazz} is anonymous or otherwise does not have a name.\n+     *\n+     * @param clazz annotation class\n+     * @return the canonical name of {@code clazz}\n+     */\n+    public static String annotationClassName(Class<? extends Annotation> clazz) {\n+        String name = clazz.getCanonicalName();\n+        if (name == null) {\n+            throw new TypeSystemError(\"Qualifier classes must not be anonymous.\");\n+        }\n+        return name;\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifier kinds without any direct super qualifier kinds.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        directSuperMap.forEach(\n+                (qualifierKind, superQuals) -> {\n+                    if (superQuals.isEmpty()) {\n+                        tops.add(qualifierKind);\n+                    }\n+                });\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier kind of another qualifier kind.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> bottoms = new HashSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifier kinds to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#poly} and {@link QualifierKind#top} for\n+     * the polymorphic qualifiers. Set {@link QualifierKind#poly} for the top qualifiers.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.tops\"})\n+    protected void initializePolymorphicQualifiers(\n+            @UnderInitialization QualifierKindHierarchy this) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno == null) {\n+                continue;\n+            }\n+            qualifierKind.poly = qualifierKind;\n+            String topName = annotationClassName(polyMetaAnno.value());\n+            if (nameToQualifierKind.containsKey(topName)) {\n+                qualifierKind.top = nameToQualifierKind.get(topName);\n+            } else if (topName.equals(Annotation.class.getCanonicalName())) {\n+                // Annotation.class is the default value of PolymorphicQualifier. If it is used,\n+                // then there must be exactly one top.\n+                if (tops.size() == 1) {\n+                    qualifierKind.top = tops.iterator().next();\n+                } else {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                }\n+            } else {\n+                throw new TypeSystemError(\n+                        \"Polymorphic qualifier %s's top, %s, is not a qualifier.\",\n+                        qualifierKind, topName);\n+            }\n+            qualifierKind.strictSuperTypes = Collections.singleton(qualifierKind.top);\n+            qualifierKind.top.poly = qualifierKind;\n+        }\n+    }\n+\n+    /**\n+     * For each qualifier kind in {@code directSuperMap}, initializes {@link\n+     * QualifierKind#strictSuperTypes}, {@link QualifierKind#top}, {@link QualifierKind#bottom}, and\n+     * {@link QualifierKind#poly}. (Requires tops, bottoms, and polymorphicQualifiers to be\n+     * initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.tops\", \"this.bottoms\"})\n+    protected void initializeQualifierKindFields(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : directSuperMap.keySet()) {\n+            if (!qualifierKind.isPoly()) {\n+                qualifierKind.strictSuperTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;\n+                    } else if (qualifierKind.top != top) {\n+                        throw new TypeSystemError(\n+                                \"Multiple tops found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, top, qualifierKind.top);\n+                    }\n+                }\n+            }\n+            if (qualifierKind.top == null) {\n+                throw new TypeSystemError(\n+                        \"Qualifier %s isn't a subtype of any top. tops = %s\", qualifierKind, tops);\n+            }\n+            qualifierKind.poly = qualifierKind.top.poly;\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind bot : bottoms) {\n+                if (bot.top != qualifierKind.top) {\n+                    continue;\n+                }\n+                if (qualifierKind.bottom == null) {\n+                    qualifierKind.bottom = bot;\n+                } else if (qualifierKind.top != bot) {\n+                    throw new TypeSystemError(\n+                            \"Multiple bottoms found for qualifier %s. Bottoms: %s and %s.\",\n+                            qualifierKind, bot, qualifierKind.bottom);\n+                }\n+                if (qualifierKind.isPoly()) {\n+                    assert bot.strictSuperTypes != null\n+                            : \"@AssumeAssertion(nullness):strictSuperTypes should be nonnull.\";\n+                    bot.strictSuperTypes.add(qualifierKind);\n+                }\n+            }\n+            if (qualifierKind.bottom == null) {\n+                throw new TypeSystemError(\n+                        \"Cannot find a bottom qualifier for %s. bottoms = %s\",\n+                        qualifierKind, bottoms);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the set of all qualifier kinds that are a strict supertype of {@code qualifierKind}.\n+     *\n+     * @param qualifierKind the qualifier kind whose super types should be returned\n+     * @param directSuperMap directSuperMap\n+     * @return the set of all qualifier kinds that are a strict supertype of {@code qualifierKind}\n+     */\n+    private Set<QualifierKind> findAllTheSupers(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            @KeyFor(\"#2\") QualifierKind qualifierKind,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Queue<QualifierKind> queue = new ArrayDeque<>(directSuperMap.get(qualifierKind));\n+        Set<QualifierKind> allSupers = new TreeSet<>(directSuperMap.get(qualifierKind));\n+        Set<QualifierKind> visited = new HashSet<>();\n+        while (!queue.isEmpty()) {\n+            QualifierKind superQualKind = queue.remove();\n+            if (superQualKind == qualifierKind) {\n+                throw new TypeSystemError(\"Cycle in hierarchy: %s\", qualifierKind);\n+            }\n+            if (visited.contains(superQualKind)) {\n+                continue;\n+            }\n+            visited.add(superQualKind);\n+            if (superQualKind.isPoly()) {\n+                continue;\n+            }\n+            if (directSuperMap.containsKey(superQualKind)) {\n+                Set<QualifierKind> superSuperQuals = directSuperMap.get(superQualKind);\n+                queue.addAll(superSuperQuals);\n+                allSupers.addAll(superSuperQuals);\n+            } else {\n+                throw new TypeSystemError(\n+                        \"Found a super qualifier kind not a key in the directSuperMap. Found: %s\",\n+                        superQualKind);\n+            }\n+        }\n+        return allSupers;\n+    }\n+\n+    /**\n+     * Creates the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of\n+     * kind1 and kind2.\n+     *\n+     * @return a mapping of lubs\n+     */\n+    @RequiresNonNull(\"this.nameToQualifierKind\")\n+    protected Map<QualifierKind, Map<QualifierKind, QualifierKind>> createLubsMap(\n+            @UnderInitialization QualifierKindHierarchy this) {\n+        Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs = new HashMap<>();\n+        for (QualifierKind qual1 : nameToQualifierKind.values()) {\n+            for (QualifierKind qual2 : nameToQualifierKind.values()) {\n+                if (qual1.top != qual2.top) {\n+                    continue;\n+                }\n+                QualifierKind lub = findLub(qual1, qual2);\n+                addToMapOfMap(lubs, qual1, qual2, lub, \"lub\");\n+                addToMapOfMap(lubs, qual2, qual1, lub, \"lub\");\n+            }\n+        }\n+        return lubs;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code qual1} and {@code qual2}.\n+     *\n+     * @param qual1 a qualifier kind\n+     * @param qual2 a qualifier kind\n+     * @return the least upper bound of {@code qual1} and {@code qual2}\n+     */\n+    private QualifierKind findLub(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            QualifierKind qual1,\n+            QualifierKind qual2) {\n+        if (qual1 == qual2) {\n+            return qual1;\n+        } else if (qual1.isSubtype(qual2)) {\n+            return qual2;\n+        } else if (qual2.isSubtype(qual1)) {\n+            return qual1;\n+        }\n+        // strictSuperTypes should be nonnull by this point.\n+        @SuppressWarnings(\"nullness:argument.type.incompatible\")\n+        Set<QualifierKind> allSuperTypes = new TreeSet<>(qual1.strictSuperTypes);\n+        // strictSuperTypes should be nonnull by this point.\n+        @SuppressWarnings(\"nullness:assignment.type.incompatible\")\n+        @NonNull Set<QualifierKind> qual2StrictSuperTypes = qual2.strictSuperTypes;\n+        allSuperTypes.retainAll(qual2StrictSuperTypes);\n+        Set<QualifierKind> lubs = findLowestQualifiers(allSuperTypes);\n+        if (lubs.size() != 1) {\n+            throw new TypeSystemError(\n+                    \"Not exactly 1 lub for %s and %s. Found lubs: [%s].\",\n+                    qual1, qual2, SystemUtil.join(\", \", lubs));\n+        }\n+        QualifierKind lub = lubs.iterator().next();\n+        if (lub.isPoly() && !qual1.isPoly() && !qual2.isPoly()) {\n+            throw new TypeSystemError(\n+                    \"Lub can't be poly: lub: %s, qual1: %s, qual2: %s.\", lub, qual1, qual2);\n+        }\n+        return lub;\n+    }\n+\n+    /**\n+     * Returns the lowest qualifiers in the passed set.\n+     *\n+     * @param qualifierKinds a set of qualifiers\n+     * @return the lowest qualifiers in the passed set\n+     */\n+    protected static Set<QualifierKind> findLowestQualifiers(Set<QualifierKind> qualifierKinds) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 805}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcxODM4Mw==", "bodyText": "findLowestQualifiers is protected because it is used by the Units Checker.  It's static, so it's not an extension point.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r461718383", "createdAt": "2020-07-28T16:35:40Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,920 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.SystemUtil;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * This class holds information about the subtyping relationships between kinds of qualifiers. A\n+ * \"kind\" of qualifier is its annotation class and is represented by the {@link QualifierKind}\n+ * class. If a type system has more than one hierarchy, information about all hierarchies are stored\n+ * in this class.\n+ *\n+ * <p>The qualifier kind subtyping relationship may be an over-approximation of the qualifier\n+ * subtyping relationship, for qualifiers that have elements/arguments. In other words, if a\n+ * qualifier kind is a subtype of another qualifier kind, then qualifiers of those kinds may or may\n+ * not be subtypes, depending on the values of any elements of the qualifiers.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * This class is used by {@link SimpleQualifierHierarchy} and {@link ComplexQualifierHierarchy} to\n+ * implement methods that compare {@link javax.lang.model.element.AnnotationMirror}s, such as {@link\n+ * org.checkerframework.framework.type.QualifierHierarchy#isSubtype(AnnotationMirror,\n+ * AnnotationMirror)}.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierKindHierarchy {\n+\n+    /**\n+     * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+     * annotation class, then they have the same qualifier kind. Two qualifiers can have the same\n+     * \"kind\" of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+     * {@code @IndexFor(\"b\")}.\n+     *\n+     * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+     * {@link QualifierKind}s.\n+     *\n+     * <p>Exactly one qualifier kind is created for each annotation class.\n+     */\n+    // The private non-final fields of this class are set while creating the QualifierKindHierarchy.\n+    @AnnotatedFor(\"nullness\")\n+    public static @Interned class QualifierKind implements Comparable<QualifierKind> {\n+\n+        /** The canonical name of the annotation class of this. */\n+        private final @Interned String name;\n+\n+        /** The annotation class for this. */\n+        private final Class<? extends Annotation> clazz;\n+\n+        /** The top of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind top;\n+\n+        /** The bottom of the hierarchy to which this belongs. */\n+        private @MonotonicNonNull QualifierKind bottom;\n+\n+        /** The polymorphic qualifier of the hierarchy to which this belongs. */\n+        private @Nullable QualifierKind poly;\n+\n+        /** Whether or not this has elements. */\n+        private final boolean hasElements;\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier kind of this. Does not include\n+         * this qualifier kind itself.\n+         */\n+        private @MonotonicNonNull Set<QualifierKind> strictSuperTypes;\n+\n+        /**\n+         * Creates a {@link QualifierKind} for the given annotation class.\n+         *\n+         * @param clazz annotation class for a qualifier\n+         */\n+        private QualifierKind(Class<? extends Annotation> clazz) {\n+            this.clazz = clazz;\n+            this.hasElements = clazz.getDeclaredMethods().length != 0;\n+            this.name = annotationClassName(clazz).intern();\n+            this.poly = null;\n+            // These non-final fields are set by QualifierKindHierarchy.\n+            // Give them dummy values here, because the Java compiler requires it.\n+            //            strictSuperTypes = null;\n+            //            top = null;\n+            //            bottom = null;\n+\n+        }\n+\n+        /**\n+         * Returns the canonical name of the annotation class of this.\n+         *\n+         * @return the canonical name of the annotation class of this\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * Returns the annotation class for this.\n+         *\n+         * @return the annotation class for this\n+         */\n+        public Class<? extends Annotation> getAnnotationClass() {\n+            return clazz;\n+        }\n+\n+        /**\n+         * Returns the top qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the top qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getTop() {\n+            assert top != null : \"@AssumeAssertion(nullness): top must be nonnull.\";\n+            return top;\n+        }\n+\n+        /**\n+         * Returns the bottom qualifier kind of the hierarchy to which this qualifier kind belongs.\n+         *\n+         * @return the bottom qualifier kind of the hierarchy to which this qualifier kind belongs\n+         */\n+        public QualifierKind getBottom() {\n+            assert bottom != null : \"@AssumeAssertion(nullness): bottom must be nonnull.\";\n+            return bottom;\n+        }\n+\n+        /**\n+         * Returns the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         * belongs.\n+         *\n+         * @return the polymorphic qualifier kind of the hierarchy to which this qualifier kind\n+         *     belongs\n+         */\n+        public @Nullable QualifierKind getPolymorphic() {\n+            return poly;\n+        }\n+\n+        /**\n+         * Returns whether or not the annotation class this qualifier kind represents has elements.\n+         *\n+         * @return true if the annotation class this qualifier kind represents has elements\n+         */\n+        public boolean hasElements() {\n+            return hasElements;\n+        }\n+\n+        /**\n+         * Returns whether or not this is polymorphic.\n+         *\n+         * @return true if this is polymorphic\n+         */\n+        public boolean isPoly() {\n+            return this.poly == this;\n+        }\n+\n+        /**\n+         * All the qualifier kinds that are a strict super qualifier of this qualifier. Does not\n+         * include this qualifier kind itself.\n+         *\n+         * @return all the qualifier kinds that are a strict super qualifier of this qualifier\n+         */\n+        public Set<QualifierKind> getStrictSuperTypes() {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return strictSuperTypes;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the top qualifier of its hierarchy.\n+         *\n+         * @return true if this is the top qualifier of its hierarchy\n+         */\n+        public boolean isTop() {\n+            return this.top == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this is the bottom qualifier of its hierarchy.\n+         *\n+         * @return true if this is the bottom qualifier of its hierarchy\n+         */\n+        public boolean isBottom() {\n+            return this.bottom == this;\n+        }\n+\n+        /**\n+         * Returns whether or not this and {@code other} are in the same hierarchy.\n+         *\n+         * @param other a qualifier kind\n+         * @return true if this and {@code other} are in the same hierarchy\n+         */\n+        public boolean isInSameHierarchyAs(QualifierKind other) {\n+            return this.top == other.top;\n+        }\n+\n+        /**\n+         * Returns whether or not this qualifier kind is a subtype of or equal to {@code\n+         * superQualKind}.\n+         *\n+         * @param superQualKind other qualifier kind\n+         * @return true if this qualifier kind is a subtype of or equal to {@code superQualKind}\n+         */\n+        public boolean isSubtype(QualifierKind superQualKind) {\n+            assert strictSuperTypes != null\n+                    : \"@AssumeAssertion(nullness): strictSuperTypes must be nonnull.\";\n+            return this == superQualKind || strictSuperTypes.contains(superQualKind);\n+        }\n+\n+        @Override\n+        public int compareTo(QualifierKind o) {\n+            return this.name.compareTo(o.name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name.substring(name.lastIndexOf(\".\") + 1);\n+        }\n+    }\n+\n+    // End of QualifierKind class, start of QualifierKindHierarchy fields.\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final NavigableMap<@Interned String, QualifierKind> nameToQualifierKind;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<QualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<QualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    /**\n+     * Returns the qualifier kinds that are the top qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the top qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    /**\n+     * Returns the qualifier kinds that are the bottom qualifier in their hierarchies.\n+     *\n+     * @return the qualifier kinds that are the bottom qualifier in their hierarchies\n+     */\n+    public Set<QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code q1} and {@code q2}; or {@code null} if the qualifier\n+     * kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind always\n+     * does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the least upper bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lub.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code q1} and {@code q2}; or {@code null} if the\n+     * qualifier kinds are not in the same hierarchy. Ignores elements/arguments (as QualifierKind\n+     * always does).\n+     *\n+     * @param q1 a qualifier kind\n+     * @param q2 a qualifier kind\n+     * @return the greatest lower bound of {@code q1} and {@code q2}; {@code null} if the qualifier\n+     *     kinds are not in the same hierarchy\n+     */\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glb.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    /**\n+     * Returns a collection of all {@link QualifierKind}s sorted in ascending order.\n+     *\n+     * @return a collection of all {@link QualifierKind}s sorted in ascending order\n+     */\n+    public Collection<QualifierKind> allQualifierKinds() {\n+        return nameToQualifierKind.values();\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation class name or null if one does not\n+     * exist.\n+     *\n+     * @param name canonical name of an annotation class\n+     * @return the {@link QualifierKind} for the given annotation class name or null if one does not\n+     *     exist\n+     */\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    /// <editor-fold desc=\"Initialize hierarchy\">\n+    /// Methods that initialize the hierarchy; only called at object initialization.\n+    ///\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public QualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link QualifierKindHierarchy}. Also, creates and initializes all its qualifier\n+     * kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, uses this constructor. Otherwise, use the other constructor.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     * @param bottom the bottom qualifier of this hierarchy\n+     */\n+    public QualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = createDirectSuperMap();\n+        setBottom(bottom, directSuperMap);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+    /**\n+     * Verifies that the {@link QualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.tops\", \"this.bottoms\"})\n+    protected void verifyHierarchy(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            boolean isPoly = qualifierKind.isPoly();\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, SystemUtil.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    SystemUtil.join(\", \", tops), SystemUtil.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected NavigableMap<@Interned String, QualifierKind> createQualifierKinds(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, QualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned QualifierKind qualifierKind = new QualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.name)) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.name);\n+            }\n+            nameToQualifierKind.put(qualifierKind.name, qualifierKind);\n+        }\n+        return Collections.unmodifiableNavigableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    @RequiresNonNull(\"this.nameToQualifierKind\")\n+    protected Map<QualifierKind, Set<QualifierKind>> createDirectSuperMap(\n+            @UnderInitialization QualifierKindHierarchy this) {\n+        Map<QualifierKind, Set<QualifierKind>> directSuperMap = new TreeMap<>();\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            SubtypeOf subtypeOfMetaAnno = qualifierKind.clazz.getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno == null) {\n+                continue;\n+            }\n+            Set<QualifierKind> directSupers = new TreeSet<>();\n+            directSuperMap.put(qualifierKind, directSupers);\n+            for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                String superName = annotationClassName(superClazz);\n+                QualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                if (superQualifier == null) {\n+                    throw new TypeSystemError(\n+                            \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                            qualifierKind,\n+                            superName,\n+                            SystemUtil.join(\", \", nameToQualifierKind.values()));\n+                }\n+                directSupers.add(superQualifier);\n+            }\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * If {@code bottom} is nonnull, then this method sets bottom to the given class and modify\n+     * {@code directSuperMap} to add all leaves to its super qualifier kinds. Leaves are qualifier\n+     * kinds that are not super qualifier kinds of another qualifier kind.\n+     *\n+     * <p>If {@code bottom} is {@code null}, then this method does nothing.\n+     *\n+     * @param bottom the class of the bottom qualifer in the hierarchy\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; side-effected by this method\n+     */\n+    @RequiresNonNull(\"this.nameToQualifierKind\")\n+    private void setBottom(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            @Nullable Class<? extends Annotation> bottom,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        if (bottom == null) {\n+            return;\n+        }\n+        QualifierKind bottomKind = nameToQualifierKind.get(annotationClassName(bottom));\n+        if (bottomKind == null) {\n+            throw new TypeSystemError(\n+                    \"QualifierKindHierarchy#setBottom: the given bottom class, %s, is not in the hierarchy.\",\n+                    bottom.getCanonicalName());\n+        }\n+\n+        Set<QualifierKind> currentLeaves = new TreeSet<>(nameToQualifierKind.values());\n+        currentLeaves.remove(bottomKind);\n+        directSuperMap.forEach(\n+                (sub, supers) -> {\n+                    currentLeaves.removeAll(supers);\n+                });\n+        Set<QualifierKind> bottomDirectSuperQuals = directSuperMap.get(bottomKind);\n+        if (bottomDirectSuperQuals == null) {\n+            directSuperMap.put(bottomKind, currentLeaves);\n+        } else {\n+            bottomDirectSuperQuals.addAll(currentLeaves);\n+        }\n+    }\n+\n+    /**\n+     * Returns the canonical name of {@code clazz}. Throws a {@link TypeSystemError} if {@code\n+     * clazz} is anonymous or otherwise does not have a name.\n+     *\n+     * @param clazz annotation class\n+     * @return the canonical name of {@code clazz}\n+     */\n+    public static String annotationClassName(Class<? extends Annotation> clazz) {\n+        String name = clazz.getCanonicalName();\n+        if (name == null) {\n+            throw new TypeSystemError(\"Qualifier classes must not be anonymous.\");\n+        }\n+        return name;\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifier kinds without any direct super qualifier kinds.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createTopsSet(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> tops = new TreeSet<>();\n+        directSuperMap.forEach(\n+                (qualifierKind, superQuals) -> {\n+                    if (superQuals.isEmpty()) {\n+                        tops.add(qualifierKind);\n+                    }\n+                });\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier kind of another qualifier kind.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<QualifierKind> createBottomsSet(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Set<QualifierKind> bottoms = new HashSet<>(directSuperMap.keySet());\n+        for (Set<QualifierKind> superKinds : directSuperMap.values()) {\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifier kinds to\n+     * polymorphicQualifiers. Also sets {@link QualifierKind#poly} and {@link QualifierKind#top} for\n+     * the polymorphic qualifiers. Set {@link QualifierKind#poly} for the top qualifiers.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.tops\"})\n+    protected void initializePolymorphicQualifiers(\n+            @UnderInitialization QualifierKindHierarchy this) {\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno == null) {\n+                continue;\n+            }\n+            qualifierKind.poly = qualifierKind;\n+            String topName = annotationClassName(polyMetaAnno.value());\n+            if (nameToQualifierKind.containsKey(topName)) {\n+                qualifierKind.top = nameToQualifierKind.get(topName);\n+            } else if (topName.equals(Annotation.class.getCanonicalName())) {\n+                // Annotation.class is the default value of PolymorphicQualifier. If it is used,\n+                // then there must be exactly one top.\n+                if (tops.size() == 1) {\n+                    qualifierKind.top = tops.iterator().next();\n+                } else {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                            qualifierKind, SystemUtil.join(\", \", tops));\n+                }\n+            } else {\n+                throw new TypeSystemError(\n+                        \"Polymorphic qualifier %s's top, %s, is not a qualifier.\",\n+                        qualifierKind, topName);\n+            }\n+            qualifierKind.strictSuperTypes = Collections.singleton(qualifierKind.top);\n+            qualifierKind.top.poly = qualifierKind;\n+        }\n+    }\n+\n+    /**\n+     * For each qualifier kind in {@code directSuperMap}, initializes {@link\n+     * QualifierKind#strictSuperTypes}, {@link QualifierKind#top}, {@link QualifierKind#bottom}, and\n+     * {@link QualifierKind#poly}. (Requires tops, bottoms, and polymorphicQualifiers to be\n+     * initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.tops\", \"this.bottoms\"})\n+    protected void initializeQualifierKindFields(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        for (QualifierKind qualifierKind : directSuperMap.keySet()) {\n+            if (!qualifierKind.isPoly()) {\n+                qualifierKind.strictSuperTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;\n+                    } else if (qualifierKind.top != top) {\n+                        throw new TypeSystemError(\n+                                \"Multiple tops found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, top, qualifierKind.top);\n+                    }\n+                }\n+            }\n+            if (qualifierKind.top == null) {\n+                throw new TypeSystemError(\n+                        \"Qualifier %s isn't a subtype of any top. tops = %s\", qualifierKind, tops);\n+            }\n+            qualifierKind.poly = qualifierKind.top.poly;\n+        }\n+        for (QualifierKind qualifierKind : nameToQualifierKind.values()) {\n+            for (QualifierKind bot : bottoms) {\n+                if (bot.top != qualifierKind.top) {\n+                    continue;\n+                }\n+                if (qualifierKind.bottom == null) {\n+                    qualifierKind.bottom = bot;\n+                } else if (qualifierKind.top != bot) {\n+                    throw new TypeSystemError(\n+                            \"Multiple bottoms found for qualifier %s. Bottoms: %s and %s.\",\n+                            qualifierKind, bot, qualifierKind.bottom);\n+                }\n+                if (qualifierKind.isPoly()) {\n+                    assert bot.strictSuperTypes != null\n+                            : \"@AssumeAssertion(nullness):strictSuperTypes should be nonnull.\";\n+                    bot.strictSuperTypes.add(qualifierKind);\n+                }\n+            }\n+            if (qualifierKind.bottom == null) {\n+                throw new TypeSystemError(\n+                        \"Cannot find a bottom qualifier for %s. bottoms = %s\",\n+                        qualifierKind, bottoms);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the set of all qualifier kinds that are a strict supertype of {@code qualifierKind}.\n+     *\n+     * @param qualifierKind the qualifier kind whose super types should be returned\n+     * @param directSuperMap directSuperMap\n+     * @return the set of all qualifier kinds that are a strict supertype of {@code qualifierKind}\n+     */\n+    private Set<QualifierKind> findAllTheSupers(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            @KeyFor(\"#2\") QualifierKind qualifierKind,\n+            Map<QualifierKind, Set<QualifierKind>> directSuperMap) {\n+        Queue<QualifierKind> queue = new ArrayDeque<>(directSuperMap.get(qualifierKind));\n+        Set<QualifierKind> allSupers = new TreeSet<>(directSuperMap.get(qualifierKind));\n+        Set<QualifierKind> visited = new HashSet<>();\n+        while (!queue.isEmpty()) {\n+            QualifierKind superQualKind = queue.remove();\n+            if (superQualKind == qualifierKind) {\n+                throw new TypeSystemError(\"Cycle in hierarchy: %s\", qualifierKind);\n+            }\n+            if (visited.contains(superQualKind)) {\n+                continue;\n+            }\n+            visited.add(superQualKind);\n+            if (superQualKind.isPoly()) {\n+                continue;\n+            }\n+            if (directSuperMap.containsKey(superQualKind)) {\n+                Set<QualifierKind> superSuperQuals = directSuperMap.get(superQualKind);\n+                queue.addAll(superSuperQuals);\n+                allSupers.addAll(superSuperQuals);\n+            } else {\n+                throw new TypeSystemError(\n+                        \"Found a super qualifier kind not a key in the directSuperMap. Found: %s\",\n+                        superQualKind);\n+            }\n+        }\n+        return allSupers;\n+    }\n+\n+    /**\n+     * Creates the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of\n+     * kind1 and kind2.\n+     *\n+     * @return a mapping of lubs\n+     */\n+    @RequiresNonNull(\"this.nameToQualifierKind\")\n+    protected Map<QualifierKind, Map<QualifierKind, QualifierKind>> createLubsMap(\n+            @UnderInitialization QualifierKindHierarchy this) {\n+        Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs = new HashMap<>();\n+        for (QualifierKind qual1 : nameToQualifierKind.values()) {\n+            for (QualifierKind qual2 : nameToQualifierKind.values()) {\n+                if (qual1.top != qual2.top) {\n+                    continue;\n+                }\n+                QualifierKind lub = findLub(qual1, qual2);\n+                addToMapOfMap(lubs, qual1, qual2, lub, \"lub\");\n+                addToMapOfMap(lubs, qual2, qual1, lub, \"lub\");\n+            }\n+        }\n+        return lubs;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code qual1} and {@code qual2}.\n+     *\n+     * @param qual1 a qualifier kind\n+     * @param qual2 a qualifier kind\n+     * @return the least upper bound of {@code qual1} and {@code qual2}\n+     */\n+    private QualifierKind findLub(\n+            @UnderInitialization QualifierKindHierarchy this,\n+            QualifierKind qual1,\n+            QualifierKind qual2) {\n+        if (qual1 == qual2) {\n+            return qual1;\n+        } else if (qual1.isSubtype(qual2)) {\n+            return qual2;\n+        } else if (qual2.isSubtype(qual1)) {\n+            return qual1;\n+        }\n+        // strictSuperTypes should be nonnull by this point.\n+        @SuppressWarnings(\"nullness:argument.type.incompatible\")\n+        Set<QualifierKind> allSuperTypes = new TreeSet<>(qual1.strictSuperTypes);\n+        // strictSuperTypes should be nonnull by this point.\n+        @SuppressWarnings(\"nullness:assignment.type.incompatible\")\n+        @NonNull Set<QualifierKind> qual2StrictSuperTypes = qual2.strictSuperTypes;\n+        allSuperTypes.retainAll(qual2StrictSuperTypes);\n+        Set<QualifierKind> lubs = findLowestQualifiers(allSuperTypes);\n+        if (lubs.size() != 1) {\n+            throw new TypeSystemError(\n+                    \"Not exactly 1 lub for %s and %s. Found lubs: [%s].\",\n+                    qual1, qual2, SystemUtil.join(\", \", lubs));\n+        }\n+        QualifierKind lub = lubs.iterator().next();\n+        if (lub.isPoly() && !qual1.isPoly() && !qual2.isPoly()) {\n+            throw new TypeSystemError(\n+                    \"Lub can't be poly: lub: %s, qual1: %s, qual2: %s.\", lub, qual1, qual2);\n+        }\n+        return lub;\n+    }\n+\n+    /**\n+     * Returns the lowest qualifiers in the passed set.\n+     *\n+     * @param qualifierKinds a set of qualifiers\n+     * @return the lowest qualifiers in the passed set\n+     */\n+    protected static Set<QualifierKind> findLowestQualifiers(Set<QualifierKind> qualifierKinds) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY0NDk2Ng=="}, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 805}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODU1MzM1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxOTo1OTowN1rOGzfi0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNjo0MDo0N1rOG4VPpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY0NzM3OQ==", "bodyText": "Can we turn this into an interface?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456647379", "createdAt": "2020-07-17T19:59:07Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -5,25 +5,37 @@\n import java.util.Set;\n import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.type.TypeKind;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n import org.checkerframework.javacutil.AnnotationUtils;\n import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n \n /**\n- * Represents a type qualifier hierarchy.\n+ * Represents multiple type qualifier hierarchies. {@link #getWidth} gives the number of hierarchies\n+ * that this object represents. Each hierarchy has its own top and bottom, and subtyping\n+ * relationships exist only within each hierarchy.\n  *\n- * <p>All method parameter annotations need to be type qualifiers recognized within this hierarchy.\n+ * <p>Note the distinction in terminology between a qualifier hierarchy, which has one top and one\n+ * bottom, and a {@code QualifierHierarchy}, which represents multiple qualifier hierarchies.\n  *\n- * <p>This assumes that any particular annotated type in a program is annotated with at least one\n- * qualifier from the hierarchy.\n+ * <p>All type annotations need to be type qualifiers recognized within this hierarchy.\n+ *\n+ * <p>This assumes that every annotated type in a program is annotated with exactly one qualifier\n+ * from each hierarchy.\n  */\n+@AnnotatedFor(\"nullness\")\n public abstract class QualifierHierarchy {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTcyMTUxMA==", "bodyText": "I did this in #3445.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r461721510", "createdAt": "2020-07-28T16:40:47Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/QualifierHierarchy.java", "diffHunk": "@@ -5,25 +5,37 @@\n import java.util.Set;\n import javax.lang.model.element.AnnotationMirror;\n import javax.lang.model.type.TypeKind;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n import org.checkerframework.javacutil.AnnotationUtils;\n import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.SystemUtil;\n \n /**\n- * Represents a type qualifier hierarchy.\n+ * Represents multiple type qualifier hierarchies. {@link #getWidth} gives the number of hierarchies\n+ * that this object represents. Each hierarchy has its own top and bottom, and subtyping\n+ * relationships exist only within each hierarchy.\n  *\n- * <p>All method parameter annotations need to be type qualifiers recognized within this hierarchy.\n+ * <p>Note the distinction in terminology between a qualifier hierarchy, which has one top and one\n+ * bottom, and a {@code QualifierHierarchy}, which represents multiple qualifier hierarchies.\n  *\n- * <p>This assumes that any particular annotated type in a program is annotated with at least one\n- * qualifier from the hierarchy.\n+ * <p>All type annotations need to be type qualifiers recognized within this hierarchy.\n+ *\n+ * <p>This assumes that every annotated type in a program is annotated with exactly one qualifier\n+ * from each hierarchy.\n  */\n+@AnnotatedFor(\"nullness\")\n public abstract class QualifierHierarchy {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY0NzM3OQ=="}, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODYwMDgwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDoxNzoxM1rOGzf__Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNjo1Njo1NVrOG3rO1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1NDg0NQ==", "bodyText": "Is this a TypeSystemError?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456654845", "createdAt": "2020-07-17T20:17:13Z", "author": {"login": "wmdietl"}, "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where no qualifier has arguments; that is, no qualifier is\n+ * represented by an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the subtyping relationships.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class SimpleQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** Set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** Set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /** Mapping from {@link QualifierKind} to its corresponding {@link AnnotationMirror}. */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;\n+\n+    /** Set of all annotations in all the hierarchies. */\n+    protected final Set<? extends AnnotationMirror> qualifiers;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    public SimpleQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.kindToAnnotationMirror = createAnnotationMirrors(elements);\n+        Set<AnnotationMirror> qualifiers = AnnotationUtils.createAnnotationSet();\n+        qualifiers.addAll(kindToAnnotationMirror.values());\n+        this.qualifiers = Collections.unmodifiableSet(qualifiers);\n+\n+        this.tops = createTops();\n+        this.bottoms = createBottoms();\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            @UnderInitialization SimpleQualifierHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates and returns a mapping from qualifier kind to an annotation mirror created from the\n+     * qualifier kind's annotation class.\n+     *\n+     * @param elements element utils\n+     * @return a mapping from qualifier kind to its annotation mirror\n+     */\n+    @RequiresNonNull(\"this.qualifierKindHierarchy\")\n+    protected Map<QualifierKind, AnnotationMirror> createAnnotationMirrors(\n+            @UnderInitialization SimpleQualifierHierarchy this, Elements elements) {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (kind.hasElements()) {\n+                throw new TypeSystemError(\n+                        \"SimpleQualifierHierarchy cannot be used with annotations that have elements. Found %s: \",\n+                        kind);\n+            }\n+            quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of top {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of top {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createTops(@UnderInitialization SimpleQualifierHierarchy this) {\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isTop()) {\n+                tops.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(tops);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of bottom {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of bottom {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createBottoms(\n+            @UnderInitialization SimpleQualifierHierarchy this) {\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isBottom()) {\n+                bottoms.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(bottoms);\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation.\n+     *\n+     * @param anno an annotation that is a qualifier in this\n+     * @return the {@code QualifierKind}\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"Annotation not in hierarchy: %s\", anno);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAzMzE3NQ==", "bodyText": "The framework itself could call this method with an incorrect annotation, so it could be a bug in the framework.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r461033175", "createdAt": "2020-07-27T16:56:55Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/SimpleQualifierHierarchy.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierKindHierarchy.QualifierKind;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where no qualifier has arguments; that is, no qualifier is\n+ * represented by an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the subtyping relationships.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class SimpleQualifierHierarchy extends QualifierHierarchy {\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** Set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** Set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /** Mapping from {@link QualifierKind} to its corresponding {@link AnnotationMirror}. */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;\n+\n+    /** Set of all annotations in all the hierarchies. */\n+    protected final Set<? extends AnnotationMirror> qualifiers;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    public SimpleQualifierHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.kindToAnnotationMirror = createAnnotationMirrors(elements);\n+        Set<AnnotationMirror> qualifiers = AnnotationUtils.createAnnotationSet();\n+        qualifiers.addAll(kindToAnnotationMirror.values());\n+        this.qualifiers = Collections.unmodifiableSet(qualifiers);\n+\n+        this.tops = createTops();\n+        this.bottoms = createBottoms();\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            @UnderInitialization SimpleQualifierHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new QualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates and returns a mapping from qualifier kind to an annotation mirror created from the\n+     * qualifier kind's annotation class.\n+     *\n+     * @param elements element utils\n+     * @return a mapping from qualifier kind to its annotation mirror\n+     */\n+    @RequiresNonNull(\"this.qualifierKindHierarchy\")\n+    protected Map<QualifierKind, AnnotationMirror> createAnnotationMirrors(\n+            @UnderInitialization SimpleQualifierHierarchy this, Elements elements) {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (kind.hasElements()) {\n+                throw new TypeSystemError(\n+                        \"SimpleQualifierHierarchy cannot be used with annotations that have elements. Found %s: \",\n+                        kind);\n+            }\n+            quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of top {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of top {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createTops(@UnderInitialization SimpleQualifierHierarchy this) {\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isTop()) {\n+                tops.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(tops);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of bottom {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of bottom {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createBottoms(\n+            @UnderInitialization SimpleQualifierHierarchy this) {\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isBottom()) {\n+                bottoms.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(bottoms);\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation.\n+     *\n+     * @param anno an annotation that is a qualifier in this\n+     * @return the {@code QualifierKind}\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"Annotation not in hierarchy: %s\", anno);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1NDg0NQ=="}, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODYwNzgzOnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/fenum/FenumAnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMDoxOTo0NlrOGzgD7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMjowNDozOVrOG8cPYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1NTg1Mg==", "bodyText": "Should these now be TypeSystemErrors?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r456655852", "createdAt": "2020-07-17T20:19:46Z", "author": {"login": "wmdietl"}, "path": "checker/src/main/java/org/checkerframework/checker/fenum/FenumAnnotatedTypeFactory.java", "diffHunk": "@@ -77,37 +93,78 @@ public FenumAnnotatedTypeFactory(BaseTypeChecker checker) {\n     }\n \n     @Override\n-    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n-        return new FenumQualifierHierarchy(factory);\n+    public QualifierHierarchy createQualifierHierarchy() {\n+        return new FenumQualifierHierarchy(getSupportedTypeQualifiers(), elements);\n     }\n \n-    protected class FenumQualifierHierarchy extends GraphQualifierHierarchy {\n+    /** Fenum qualifier hierarchy */\n+    protected class FenumQualifierHierarchy extends ComplexQualifierHierarchy {\n \n-        /* The user is expected to introduce additional fenum annotations.\n-         * These annotations are declared to be subtypes of FenumTop, using the\n-         * @SubtypeOf annotation.\n-         * However, there is no way to declare that it is a supertype of Bottom.\n-         * Therefore, we use the constructor of GraphQualifierHierarchy that allows\n-         * us to set a dedicated bottom qualifier.\n+        /** QualifierKind for {@link Fenum} qualifier. */\n+        private final QualifierKind FENUM_KIND;\n+\n+        /**\n+         * Creates FenumQualifierHierarchy.\n+         *\n+         * @param qualifierClasses qualifier classes\n+         * @param elements element utils\n          */\n-        public FenumQualifierHierarchy(MultiGraphFactory factory) {\n-            super(factory, FENUM_BOTTOM);\n+        public FenumQualifierHierarchy(\n+                Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+            super(qualifierClasses, elements);\n+            this.FENUM_KIND =\n+                    this.qualifierKindHierarchy.getQualifierKind(Fenum.class.getCanonicalName());\n         }\n \n         @Override\n-        public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n-            if (AnnotationUtils.areSameByName(superAnno, FENUM)\n-                    && AnnotationUtils.areSameByName(subAnno, FENUM)) {\n-                return AnnotationUtils.areSame(superAnno, subAnno);\n-            }\n-            // Ignore annotation values to ensure that annotation is in supertype map.\n-            if (AnnotationUtils.areSameByName(superAnno, FENUM)) {\n-                superAnno = FENUM;\n+        protected QualifierKindHierarchy createQualifierKindHierarchy(\n+                @UnderInitialization FenumQualifierHierarchy this,\n+                Collection<Class<? extends Annotation>> qualifierClasses) {\n+            return new QualifierKindHierarchy(qualifierClasses, FenumBottom.class);\n+        }\n+\n+        @Override\n+        protected boolean isSubtype(\n+                AnnotationMirror subAnno,\n+                QualifierKind subKind,\n+                AnnotationMirror superAnno,\n+                QualifierKind superKind) {\n+            return AnnotationUtils.areSame(subAnno, superAnno);\n+        }\n+\n+        @Override\n+        protected AnnotationMirror leastUpperBound(\n+                AnnotationMirror a1,\n+                QualifierKind qual1,\n+                AnnotationMirror a2,\n+                QualifierKind qual2) {\n+            if (qual1 == FENUM_KIND && qual2 == FENUM_KIND) {\n+                if (AnnotationUtils.areSame(a1, a2)) {\n+                    return a1;\n+                }\n+                return FENUM_TOP;\n+            } else if (qual1 == FENUM_KIND) {\n+                return a1;\n+            } else if (qual2 == FENUM_KIND) {\n+                return a2;\n             }\n-            if (AnnotationUtils.areSameByName(subAnno, FENUM)) {\n-                subAnno = FENUM;\n+            throw new BugInCF(\"Unexpected QualifierKinds %s %s\", qual1, qual2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1MDM4NQ==", "bodyText": "Ping.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r465950385", "createdAt": "2020-08-05T19:22:25Z", "author": {"login": "wmdietl"}, "path": "checker/src/main/java/org/checkerframework/checker/fenum/FenumAnnotatedTypeFactory.java", "diffHunk": "@@ -77,37 +93,78 @@ public FenumAnnotatedTypeFactory(BaseTypeChecker checker) {\n     }\n \n     @Override\n-    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n-        return new FenumQualifierHierarchy(factory);\n+    public QualifierHierarchy createQualifierHierarchy() {\n+        return new FenumQualifierHierarchy(getSupportedTypeQualifiers(), elements);\n     }\n \n-    protected class FenumQualifierHierarchy extends GraphQualifierHierarchy {\n+    /** Fenum qualifier hierarchy */\n+    protected class FenumQualifierHierarchy extends ComplexQualifierHierarchy {\n \n-        /* The user is expected to introduce additional fenum annotations.\n-         * These annotations are declared to be subtypes of FenumTop, using the\n-         * @SubtypeOf annotation.\n-         * However, there is no way to declare that it is a supertype of Bottom.\n-         * Therefore, we use the constructor of GraphQualifierHierarchy that allows\n-         * us to set a dedicated bottom qualifier.\n+        /** QualifierKind for {@link Fenum} qualifier. */\n+        private final QualifierKind FENUM_KIND;\n+\n+        /**\n+         * Creates FenumQualifierHierarchy.\n+         *\n+         * @param qualifierClasses qualifier classes\n+         * @param elements element utils\n          */\n-        public FenumQualifierHierarchy(MultiGraphFactory factory) {\n-            super(factory, FENUM_BOTTOM);\n+        public FenumQualifierHierarchy(\n+                Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+            super(qualifierClasses, elements);\n+            this.FENUM_KIND =\n+                    this.qualifierKindHierarchy.getQualifierKind(Fenum.class.getCanonicalName());\n         }\n \n         @Override\n-        public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n-            if (AnnotationUtils.areSameByName(superAnno, FENUM)\n-                    && AnnotationUtils.areSameByName(subAnno, FENUM)) {\n-                return AnnotationUtils.areSame(superAnno, subAnno);\n-            }\n-            // Ignore annotation values to ensure that annotation is in supertype map.\n-            if (AnnotationUtils.areSameByName(superAnno, FENUM)) {\n-                superAnno = FENUM;\n+        protected QualifierKindHierarchy createQualifierKindHierarchy(\n+                @UnderInitialization FenumQualifierHierarchy this,\n+                Collection<Class<? extends Annotation>> qualifierClasses) {\n+            return new QualifierKindHierarchy(qualifierClasses, FenumBottom.class);\n+        }\n+\n+        @Override\n+        protected boolean isSubtype(\n+                AnnotationMirror subAnno,\n+                QualifierKind subKind,\n+                AnnotationMirror superAnno,\n+                QualifierKind superKind) {\n+            return AnnotationUtils.areSame(subAnno, superAnno);\n+        }\n+\n+        @Override\n+        protected AnnotationMirror leastUpperBound(\n+                AnnotationMirror a1,\n+                QualifierKind qual1,\n+                AnnotationMirror a2,\n+                QualifierKind qual2) {\n+            if (qual1 == FENUM_KIND && qual2 == FENUM_KIND) {\n+                if (AnnotationUtils.areSame(a1, a2)) {\n+                    return a1;\n+                }\n+                return FENUM_TOP;\n+            } else if (qual1 == FENUM_KIND) {\n+                return a1;\n+            } else if (qual2 == FENUM_KIND) {\n+                return a2;\n             }\n-            if (AnnotationUtils.areSameByName(subAnno, FENUM)) {\n-                subAnno = FENUM;\n+            throw new BugInCF(\"Unexpected QualifierKinds %s %s\", qual1, qual2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1NTg1Mg=="}, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzMDQzNA==", "bodyText": "This could be a bug in QualifierKindHierarchy or ComplexQualifierHierarchy, so it should stay a BugInCF.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r466030434", "createdAt": "2020-08-05T22:04:39Z", "author": {"login": "smillst"}, "path": "checker/src/main/java/org/checkerframework/checker/fenum/FenumAnnotatedTypeFactory.java", "diffHunk": "@@ -77,37 +93,78 @@ public FenumAnnotatedTypeFactory(BaseTypeChecker checker) {\n     }\n \n     @Override\n-    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n-        return new FenumQualifierHierarchy(factory);\n+    public QualifierHierarchy createQualifierHierarchy() {\n+        return new FenumQualifierHierarchy(getSupportedTypeQualifiers(), elements);\n     }\n \n-    protected class FenumQualifierHierarchy extends GraphQualifierHierarchy {\n+    /** Fenum qualifier hierarchy */\n+    protected class FenumQualifierHierarchy extends ComplexQualifierHierarchy {\n \n-        /* The user is expected to introduce additional fenum annotations.\n-         * These annotations are declared to be subtypes of FenumTop, using the\n-         * @SubtypeOf annotation.\n-         * However, there is no way to declare that it is a supertype of Bottom.\n-         * Therefore, we use the constructor of GraphQualifierHierarchy that allows\n-         * us to set a dedicated bottom qualifier.\n+        /** QualifierKind for {@link Fenum} qualifier. */\n+        private final QualifierKind FENUM_KIND;\n+\n+        /**\n+         * Creates FenumQualifierHierarchy.\n+         *\n+         * @param qualifierClasses qualifier classes\n+         * @param elements element utils\n          */\n-        public FenumQualifierHierarchy(MultiGraphFactory factory) {\n-            super(factory, FENUM_BOTTOM);\n+        public FenumQualifierHierarchy(\n+                Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+            super(qualifierClasses, elements);\n+            this.FENUM_KIND =\n+                    this.qualifierKindHierarchy.getQualifierKind(Fenum.class.getCanonicalName());\n         }\n \n         @Override\n-        public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n-            if (AnnotationUtils.areSameByName(superAnno, FENUM)\n-                    && AnnotationUtils.areSameByName(subAnno, FENUM)) {\n-                return AnnotationUtils.areSame(superAnno, subAnno);\n-            }\n-            // Ignore annotation values to ensure that annotation is in supertype map.\n-            if (AnnotationUtils.areSameByName(superAnno, FENUM)) {\n-                superAnno = FENUM;\n+        protected QualifierKindHierarchy createQualifierKindHierarchy(\n+                @UnderInitialization FenumQualifierHierarchy this,\n+                Collection<Class<? extends Annotation>> qualifierClasses) {\n+            return new QualifierKindHierarchy(qualifierClasses, FenumBottom.class);\n+        }\n+\n+        @Override\n+        protected boolean isSubtype(\n+                AnnotationMirror subAnno,\n+                QualifierKind subKind,\n+                AnnotationMirror superAnno,\n+                QualifierKind superKind) {\n+            return AnnotationUtils.areSame(subAnno, superAnno);\n+        }\n+\n+        @Override\n+        protected AnnotationMirror leastUpperBound(\n+                AnnotationMirror a1,\n+                QualifierKind qual1,\n+                AnnotationMirror a2,\n+                QualifierKind qual2) {\n+            if (qual1 == FENUM_KIND && qual2 == FENUM_KIND) {\n+                if (AnnotationUtils.areSame(a1, a2)) {\n+                    return a1;\n+                }\n+                return FENUM_TOP;\n+            } else if (qual1 == FENUM_KIND) {\n+                return a1;\n+            } else if (qual2 == FENUM_KIND) {\n+                return a2;\n             }\n-            if (AnnotationUtils.areSameByName(subAnno, FENUM)) {\n-                subAnno = FENUM;\n+            throw new BugInCF(\"Unexpected QualifierKinds %s %s\", qual1, qual2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1NTg1Mg=="}, "originalCommit": {"oid": "40df51fae85c8077ccec0d278dc670de937c74c2"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDI3MzM3OnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/fenum/FenumAnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxOToyMjoxM1rOG8XWUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMjowMzozN1rOG8cNxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1MDI4OA==", "bodyText": "I don't understand this. If a1 is Fenum, but a2 is not Fenum, we could still have that a2 is FenumTop. Then, shouldn't the LUB be FenumTop?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r465950288", "createdAt": "2020-08-05T19:22:13Z", "author": {"login": "wmdietl"}, "path": "checker/src/main/java/org/checkerframework/checker/fenum/FenumAnnotatedTypeFactory.java", "diffHunk": "@@ -77,37 +94,78 @@ public FenumAnnotatedTypeFactory(BaseTypeChecker checker) {\n     }\n \n     @Override\n-    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n-        return new FenumQualifierHierarchy(factory);\n+    public QualifierHierarchy createQualifierHierarchy() {\n+        return new FenumQualifierHierarchy(getSupportedTypeQualifiers(), elements);\n     }\n \n-    protected class FenumQualifierHierarchy extends GraphQualifierHierarchy {\n+    /** Fenum qualifier hierarchy */\n+    protected class FenumQualifierHierarchy extends ComplexQualifierHierarchy {\n \n-        /* The user is expected to introduce additional fenum annotations.\n-         * These annotations are declared to be subtypes of FenumTop, using the\n-         * @SubtypeOf annotation.\n-         * However, there is no way to declare that it is a supertype of Bottom.\n-         * Therefore, we use the constructor of GraphQualifierHierarchy that allows\n-         * us to set a dedicated bottom qualifier.\n+        /** QualifierKind for {@link Fenum} qualifier. */\n+        private final QualifierKind FENUM_KIND;\n+\n+        /**\n+         * Creates FenumQualifierHierarchy.\n+         *\n+         * @param qualifierClasses qualifier classes\n+         * @param elements element utils\n          */\n-        public FenumQualifierHierarchy(MultiGraphFactory factory) {\n-            super(factory, FENUM_BOTTOM);\n+        public FenumQualifierHierarchy(\n+                Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+            super(qualifierClasses, elements);\n+            this.FENUM_KIND =\n+                    this.qualifierKindHierarchy.getQualifierKind(Fenum.class.getCanonicalName());\n         }\n \n         @Override\n-        public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n-            if (AnnotationUtils.areSameByName(superAnno, FENUM)\n-                    && AnnotationUtils.areSameByName(subAnno, FENUM)) {\n-                return AnnotationUtils.areSame(superAnno, subAnno);\n-            }\n-            // Ignore annotation values to ensure that annotation is in supertype map.\n-            if (AnnotationUtils.areSameByName(superAnno, FENUM)) {\n-                superAnno = FENUM;\n+        protected QualifierKindHierarchy createQualifierKindHierarchy(\n+                @UnderInitialization FenumQualifierHierarchy this,\n+                Collection<Class<? extends Annotation>> qualifierClasses) {\n+            return new DefaultQualifierKindHierarchy(qualifierClasses, FenumBottom.class);\n+        }\n+\n+        @Override\n+        protected boolean isSubtype(\n+                AnnotationMirror subAnno,\n+                QualifierKind subKind,\n+                AnnotationMirror superAnno,\n+                QualifierKind superKind) {\n+            return AnnotationUtils.areSame(subAnno, superAnno);\n+        }\n+\n+        @Override\n+        protected AnnotationMirror leastUpperBound(\n+                AnnotationMirror a1,\n+                QualifierKind qual1,\n+                AnnotationMirror a2,\n+                QualifierKind qual2) {\n+            if (qual1 == FENUM_KIND && qual2 == FENUM_KIND) {\n+                if (AnnotationUtils.areSame(a1, a2)) {\n+                    return a1;\n+                }\n+                return FENUM_TOP;\n+            } else if (qual1 == FENUM_KIND) {\n+                return a1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6220acbe3db8f91d334ef7abb0848ee48175a619"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzMDAyMw==", "bodyText": "This method is only called when the LUB of the two QualifierKinds is a QualifierKind that has elements.  The LUB(@Fenum(\"a\"), @FenumTop) is @FenumTop, so this method isn't called. I improved the documentation on the super class for this method.  It wasn't clear enough.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r466030023", "createdAt": "2020-08-05T22:03:37Z", "author": {"login": "smillst"}, "path": "checker/src/main/java/org/checkerframework/checker/fenum/FenumAnnotatedTypeFactory.java", "diffHunk": "@@ -77,37 +94,78 @@ public FenumAnnotatedTypeFactory(BaseTypeChecker checker) {\n     }\n \n     @Override\n-    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n-        return new FenumQualifierHierarchy(factory);\n+    public QualifierHierarchy createQualifierHierarchy() {\n+        return new FenumQualifierHierarchy(getSupportedTypeQualifiers(), elements);\n     }\n \n-    protected class FenumQualifierHierarchy extends GraphQualifierHierarchy {\n+    /** Fenum qualifier hierarchy */\n+    protected class FenumQualifierHierarchy extends ComplexQualifierHierarchy {\n \n-        /* The user is expected to introduce additional fenum annotations.\n-         * These annotations are declared to be subtypes of FenumTop, using the\n-         * @SubtypeOf annotation.\n-         * However, there is no way to declare that it is a supertype of Bottom.\n-         * Therefore, we use the constructor of GraphQualifierHierarchy that allows\n-         * us to set a dedicated bottom qualifier.\n+        /** QualifierKind for {@link Fenum} qualifier. */\n+        private final QualifierKind FENUM_KIND;\n+\n+        /**\n+         * Creates FenumQualifierHierarchy.\n+         *\n+         * @param qualifierClasses qualifier classes\n+         * @param elements element utils\n          */\n-        public FenumQualifierHierarchy(MultiGraphFactory factory) {\n-            super(factory, FENUM_BOTTOM);\n+        public FenumQualifierHierarchy(\n+                Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+            super(qualifierClasses, elements);\n+            this.FENUM_KIND =\n+                    this.qualifierKindHierarchy.getQualifierKind(Fenum.class.getCanonicalName());\n         }\n \n         @Override\n-        public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n-            if (AnnotationUtils.areSameByName(superAnno, FENUM)\n-                    && AnnotationUtils.areSameByName(subAnno, FENUM)) {\n-                return AnnotationUtils.areSame(superAnno, subAnno);\n-            }\n-            // Ignore annotation values to ensure that annotation is in supertype map.\n-            if (AnnotationUtils.areSameByName(superAnno, FENUM)) {\n-                superAnno = FENUM;\n+        protected QualifierKindHierarchy createQualifierKindHierarchy(\n+                @UnderInitialization FenumQualifierHierarchy this,\n+                Collection<Class<? extends Annotation>> qualifierClasses) {\n+            return new DefaultQualifierKindHierarchy(qualifierClasses, FenumBottom.class);\n+        }\n+\n+        @Override\n+        protected boolean isSubtype(\n+                AnnotationMirror subAnno,\n+                QualifierKind subKind,\n+                AnnotationMirror superAnno,\n+                QualifierKind superKind) {\n+            return AnnotationUtils.areSame(subAnno, superAnno);\n+        }\n+\n+        @Override\n+        protected AnnotationMirror leastUpperBound(\n+                AnnotationMirror a1,\n+                QualifierKind qual1,\n+                AnnotationMirror a2,\n+                QualifierKind qual2) {\n+            if (qual1 == FENUM_KIND && qual2 == FENUM_KIND) {\n+                if (AnnotationUtils.areSame(a1, a2)) {\n+                    return a1;\n+                }\n+                return FENUM_TOP;\n+            } else if (qual1 == FENUM_KIND) {\n+                return a1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1MDI4OA=="}, "originalCommit": {"oid": "6220acbe3db8f91d334ef7abb0848ee48175a619"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDE4NTI3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKind.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMjo0NTozMFrOHFImTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMjo0NTozMFrOHFImTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE0NTgwNw==", "bodyText": "This statement doesn't seem right to me.  Are they like enum elements?  or is the set of all QualifierKinds like an enum?\nNit: \"there\" => \"they\"", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475145807", "createdAt": "2020-08-22T22:45:30Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierKind.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+\n+/**\n+ * Represents a kind of qualifier, which is an annotation class. If two qualifiers use the same\n+ * annotation class, then they have the same qualifier kind. Two qualifiers can have the same \"kind\"\n+ * of qualifier but not be the same qualifier; an example is {@code @IndexFor(\"a\")} and\n+ * {@code @IndexFor(\"b\")}.\n+ *\n+ * <p>A {@code QualifierKind} holds information about the relationship between itself and other\n+ * {@link QualifierKind}s.\n+ *\n+ * <p>Exactly one qualifier kind is created for each annotation class.\n+ *\n+ * <p>QualifierKinds are like an enum in that there are immutable after initialization and only a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5a8d18461a6aed1b9e6c6e82ddac969bf777518"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDE5NDQ4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzowMTozMFrOHFIqeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzowMTozMFrOHFIqeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE0Njg3Mg==", "bodyText": "If this comment would be correct, could you add it?\n// qualifierKind has no @SubtypeOf: it must be top or polymorphic", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475146872", "createdAt": "2020-08-22T23:01:30Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,802 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.plumelib.util.UtilPlume;\n+\n+/**\n+ * This is the default implementation of {@link QualifierKindHierarchy}.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * {@link DefaultQualifierKindHierarchy.DefaultQualifierKind} is the implementation used for {@link\n+ * QualifierKind} by this class.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class DefaultQualifierKindHierarchy implements QualifierKindHierarchy {\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final Map<@Interned String, DefaultQualifierKind> nameToQualifierKind;\n+\n+    /** A list of all {@link QualifierKind}s sorted in ascending order. */\n+    protected final List<DefaultQualifierKind> qualifierKinds;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    @Override\n+    public Set<? extends QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public Set<? extends QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lubs.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glbs.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    public List<? extends QualifierKind> allQualifierKinds() {\n+        return qualifierKinds;\n+    }\n+\n+    @Override\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, use this constructor. Otherwise, use the other constructor.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     * @param bottom the bottom qualifier of this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        this.qualifierKinds = new ArrayList<>(nameToQualifierKind.values());\n+        Collections.sort(qualifierKinds);\n+\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap =\n+                createDirectSuperMap();\n+        setBottom(bottom, directSuperMap);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link DefaultQualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    @RequiresNonNull({\"this.qualifierKinds\", \"this.tops\", \"this.bottoms\"})\n+    protected void verifyHierarchy(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            boolean isPoly = qualifierKind.isPoly();\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.%n\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, UtilPlume.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, UtilPlume.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    UtilPlume.join(\", \", tops), UtilPlume.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, DefaultQualifierKind> createQualifierKinds(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, DefaultQualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned DefaultQualifierKind qualifierKind = new DefaultQualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.getName())) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.getName());\n+            }\n+            nameToQualifierKind.put(qualifierKind.getName(), qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\"})\n+    protected Map<DefaultQualifierKind, Set<DefaultQualifierKind>> createDirectSuperMap(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap = new TreeMap<>();\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            SubtypeOf subtypeOfMetaAnno =\n+                    qualifierKind.getAnnotationClass().getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno == null) {\n+                continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5a8d18461a6aed1b9e6c6e82ddac969bf777518"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDE5NjYzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzowNToyOFrOHFIrdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzowNToyOFrOHFIrdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE0NzEyNQ==", "bodyText": "This contract is a bit confusing.  I suggest requiring that bottom is not null.  (See comment elsewhere.)", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475147125", "createdAt": "2020-08-22T23:05:28Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,802 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.plumelib.util.UtilPlume;\n+\n+/**\n+ * This is the default implementation of {@link QualifierKindHierarchy}.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * {@link DefaultQualifierKindHierarchy.DefaultQualifierKind} is the implementation used for {@link\n+ * QualifierKind} by this class.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class DefaultQualifierKindHierarchy implements QualifierKindHierarchy {\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final Map<@Interned String, DefaultQualifierKind> nameToQualifierKind;\n+\n+    /** A list of all {@link QualifierKind}s sorted in ascending order. */\n+    protected final List<DefaultQualifierKind> qualifierKinds;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    @Override\n+    public Set<? extends QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public Set<? extends QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lubs.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glbs.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    public List<? extends QualifierKind> allQualifierKinds() {\n+        return qualifierKinds;\n+    }\n+\n+    @Override\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, use this constructor. Otherwise, use the other constructor.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     * @param bottom the bottom qualifier of this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        this.qualifierKinds = new ArrayList<>(nameToQualifierKind.values());\n+        Collections.sort(qualifierKinds);\n+\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap =\n+                createDirectSuperMap();\n+        setBottom(bottom, directSuperMap);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link DefaultQualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    @RequiresNonNull({\"this.qualifierKinds\", \"this.tops\", \"this.bottoms\"})\n+    protected void verifyHierarchy(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            boolean isPoly = qualifierKind.isPoly();\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, UtilPlume.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, UtilPlume.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    UtilPlume.join(\", \", tops), UtilPlume.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, DefaultQualifierKind> createQualifierKinds(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, DefaultQualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned DefaultQualifierKind qualifierKind = new DefaultQualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.getName())) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.getName());\n+            }\n+            nameToQualifierKind.put(qualifierKind.getName(), qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\"})\n+    protected Map<DefaultQualifierKind, Set<DefaultQualifierKind>> createDirectSuperMap(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap = new TreeMap<>();\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            SubtypeOf subtypeOfMetaAnno =\n+                    qualifierKind.getAnnotationClass().getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno == null) {\n+                continue;\n+            }\n+            Set<DefaultQualifierKind> directSupers = new TreeSet<>();\n+            for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                String superName = QualifierKindHierarchy.annotationClassName(superClazz);\n+                DefaultQualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                if (superQualifier == null) {\n+                    throw new TypeSystemError(\n+                            \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                            qualifierKind, superName, UtilPlume.join(\", \", qualifierKinds));\n+                }\n+                directSupers.add(superQualifier);\n+            }\n+            directSuperMap.put(qualifierKind, directSupers);\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * If {@code bottom} is non-null, then this method sets bottom to the given class and modifies", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 265}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDE5Njc2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzowNTozOFrOHFIrgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzowNTozOFrOHFIrgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE0NzEzOQ==", "bodyText": "And not polymorphic?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475147139", "createdAt": "2020-08-22T23:05:38Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,802 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.plumelib.util.UtilPlume;\n+\n+/**\n+ * This is the default implementation of {@link QualifierKindHierarchy}.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * {@link DefaultQualifierKindHierarchy.DefaultQualifierKind} is the implementation used for {@link\n+ * QualifierKind} by this class.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class DefaultQualifierKindHierarchy implements QualifierKindHierarchy {\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final Map<@Interned String, DefaultQualifierKind> nameToQualifierKind;\n+\n+    /** A list of all {@link QualifierKind}s sorted in ascending order. */\n+    protected final List<DefaultQualifierKind> qualifierKinds;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    @Override\n+    public Set<? extends QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public Set<? extends QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lubs.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glbs.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    public List<? extends QualifierKind> allQualifierKinds() {\n+        return qualifierKinds;\n+    }\n+\n+    @Override\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, use this constructor. Otherwise, use the other constructor.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     * @param bottom the bottom qualifier of this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        this.qualifierKinds = new ArrayList<>(nameToQualifierKind.values());\n+        Collections.sort(qualifierKinds);\n+\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap =\n+                createDirectSuperMap();\n+        setBottom(bottom, directSuperMap);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link DefaultQualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    @RequiresNonNull({\"this.qualifierKinds\", \"this.tops\", \"this.bottoms\"})\n+    protected void verifyHierarchy(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            boolean isPoly = qualifierKind.isPoly();\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, UtilPlume.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, UtilPlume.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    UtilPlume.join(\", \", tops), UtilPlume.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, DefaultQualifierKind> createQualifierKinds(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, DefaultQualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned DefaultQualifierKind qualifierKind = new DefaultQualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.getName())) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.getName());\n+            }\n+            nameToQualifierKind.put(qualifierKind.getName(), qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\"})\n+    protected Map<DefaultQualifierKind, Set<DefaultQualifierKind>> createDirectSuperMap(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap = new TreeMap<>();\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            SubtypeOf subtypeOfMetaAnno =\n+                    qualifierKind.getAnnotationClass().getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno == null) {\n+                continue;\n+            }\n+            Set<DefaultQualifierKind> directSupers = new TreeSet<>();\n+            for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                String superName = QualifierKindHierarchy.annotationClassName(superClazz);\n+                DefaultQualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                if (superQualifier == null) {\n+                    throw new TypeSystemError(\n+                            \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                            qualifierKind, superName, UtilPlume.join(\", \", qualifierKinds));\n+                }\n+                directSupers.add(superQualifier);\n+            }\n+            directSuperMap.put(qualifierKind, directSupers);\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * If {@code bottom} is non-null, then this method sets bottom to the given class and modifies\n+     * {@code directSuperMap} to add all leaves to its super qualifier kinds. Leaves are qualifier\n+     * kinds that are not super qualifier kinds of another qualifier kind.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 267}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDE5ODc3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzowOTo0NVrOHFIscw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxNTozMToxN1rOHGdueA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE0NzM3OQ==", "bodyText": "Is a null return value always indicative of an error?  If so, should this throw?  That is what QualifierHierarchyWithElements does.  (The inconsistency is a bit surprising.)", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475147379", "createdAt": "2020-08-22T23:09:45Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,802 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.plumelib.util.UtilPlume;\n+\n+/**\n+ * This is the default implementation of {@link QualifierKindHierarchy}.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * {@link DefaultQualifierKindHierarchy.DefaultQualifierKind} is the implementation used for {@link\n+ * QualifierKind} by this class.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class DefaultQualifierKindHierarchy implements QualifierKindHierarchy {\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final Map<@Interned String, DefaultQualifierKind> nameToQualifierKind;\n+\n+    /** A list of all {@link QualifierKind}s sorted in ascending order. */\n+    protected final List<DefaultQualifierKind> qualifierKinds;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    @Override\n+    public Set<? extends QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public Set<? extends QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lubs.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glbs.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    public List<? extends QualifierKind> allQualifierKinds() {\n+        return qualifierKinds;\n+    }\n+\n+    @Override\n+    public @Nullable QualifierKind getQualifierKind(String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg5NTc2Nw==", "bodyText": "No, this method could be used to check if an annotation is a qualifier in this hierarchy.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475895767", "createdAt": "2020-08-24T21:09:26Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,802 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.plumelib.util.UtilPlume;\n+\n+/**\n+ * This is the default implementation of {@link QualifierKindHierarchy}.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * {@link DefaultQualifierKindHierarchy.DefaultQualifierKind} is the implementation used for {@link\n+ * QualifierKind} by this class.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class DefaultQualifierKindHierarchy implements QualifierKindHierarchy {\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final Map<@Interned String, DefaultQualifierKind> nameToQualifierKind;\n+\n+    /** A list of all {@link QualifierKind}s sorted in ascending order. */\n+    protected final List<DefaultQualifierKind> qualifierKinds;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    @Override\n+    public Set<? extends QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public Set<? extends QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lubs.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glbs.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    public List<? extends QualifierKind> allQualifierKinds() {\n+        return qualifierKinds;\n+    }\n+\n+    @Override\n+    public @Nullable QualifierKind getQualifierKind(String name) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE0NzM3OQ=="}, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0MDUzNg==", "bodyText": "My comment was a bit unclear, sorry.  I was asking whether it is ever used that way in the current code.  If not, maybe it could throw the exception to simplify all current clients.  (That would require creating a different method if we ever come up with a client that needs to do just a check.)", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r476540536", "createdAt": "2020-08-25T15:31:17Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,802 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.plumelib.util.UtilPlume;\n+\n+/**\n+ * This is the default implementation of {@link QualifierKindHierarchy}.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * {@link DefaultQualifierKindHierarchy.DefaultQualifierKind} is the implementation used for {@link\n+ * QualifierKind} by this class.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class DefaultQualifierKindHierarchy implements QualifierKindHierarchy {\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final Map<@Interned String, DefaultQualifierKind> nameToQualifierKind;\n+\n+    /** A list of all {@link QualifierKind}s sorted in ascending order. */\n+    protected final List<DefaultQualifierKind> qualifierKinds;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    @Override\n+    public Set<? extends QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public Set<? extends QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lubs.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glbs.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    public List<? extends QualifierKind> allQualifierKinds() {\n+        return qualifierKinds;\n+    }\n+\n+    @Override\n+    public @Nullable QualifierKind getQualifierKind(String name) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE0NzM3OQ=="}, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDIwMTU5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzoxNDoyN1rOHFItuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzoxNDoyN1rOHFItuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE0NzcwNw==", "bodyText": "bottom is nullable, but it is not documented what a null value means.\nI suggest refactoring so that there are two public constructors, like the two current ones but all formal parameters are non-null.\nAdd a private constructor that they both call.  The private constructor may need a Void dummy argument to distinguish it from one of the public ones.  That is ugly, but less ugly than the current design which exposes an implementation detail to users and doesn't catch incorrect calls that pass null.\nOnly one of the public constructors will call setBottom, so setBottom can have non-null formal parameters and its contract is simplified.  (It's confusing to see setBottom called with null; I had to look up what it does in that case.)", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475147707", "createdAt": "2020-08-22T23:14:27Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,802 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.plumelib.util.UtilPlume;\n+\n+/**\n+ * This is the default implementation of {@link QualifierKindHierarchy}.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * {@link DefaultQualifierKindHierarchy.DefaultQualifierKind} is the implementation used for {@link\n+ * QualifierKind} by this class.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class DefaultQualifierKindHierarchy implements QualifierKindHierarchy {\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final Map<@Interned String, DefaultQualifierKind> nameToQualifierKind;\n+\n+    /** A list of all {@link QualifierKind}s sorted in ascending order. */\n+    protected final List<DefaultQualifierKind> qualifierKinds;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    @Override\n+    public Set<? extends QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public Set<? extends QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lubs.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glbs.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    public List<? extends QualifierKind> allQualifierKinds() {\n+        return qualifierKinds;\n+    }\n+\n+    @Override\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, use this constructor. Otherwise, use the other constructor.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     * @param bottom the bottom qualifier of this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            @Nullable Class<? extends Annotation> bottom) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDIwNDUxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzoxOToyNFrOHFIvGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzoxOToyNFrOHFIvGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE0ODA1Nw==", "bodyText": "Could you make the comment a cross-reference, to make the comment more informative?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475148057", "createdAt": "2020-08-22T23:19:24Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,802 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.plumelib.util.UtilPlume;\n+\n+/**\n+ * This is the default implementation of {@link QualifierKindHierarchy}.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * {@link DefaultQualifierKindHierarchy.DefaultQualifierKind} is the implementation used for {@link\n+ * QualifierKind} by this class.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class DefaultQualifierKindHierarchy implements QualifierKindHierarchy {\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final Map<@Interned String, DefaultQualifierKind> nameToQualifierKind;\n+\n+    /** A list of all {@link QualifierKind}s sorted in ascending order. */\n+    protected final List<DefaultQualifierKind> qualifierKinds;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    @Override\n+    public Set<? extends QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public Set<? extends QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lubs.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glbs.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    public List<? extends QualifierKind> allQualifierKinds() {\n+        return qualifierKinds;\n+    }\n+\n+    @Override\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, use this constructor. Otherwise, use the other constructor.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     * @param bottom the bottom qualifier of this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        this.qualifierKinds = new ArrayList<>(nameToQualifierKind.values());\n+        Collections.sort(qualifierKinds);\n+\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap =\n+                createDirectSuperMap();\n+        setBottom(bottom, directSuperMap);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link DefaultQualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    @RequiresNonNull({\"this.qualifierKinds\", \"this.tops\", \"this.bottoms\"})\n+    protected void verifyHierarchy(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            boolean isPoly = qualifierKind.isPoly();\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, UtilPlume.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, UtilPlume.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    UtilPlume.join(\", \", tops), UtilPlume.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, DefaultQualifierKind> createQualifierKinds(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, DefaultQualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned DefaultQualifierKind qualifierKind = new DefaultQualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.getName())) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.getName());\n+            }\n+            nameToQualifierKind.put(qualifierKind.getName(), qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\"})\n+    protected Map<DefaultQualifierKind, Set<DefaultQualifierKind>> createDirectSuperMap(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap = new TreeMap<>();\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            SubtypeOf subtypeOfMetaAnno =\n+                    qualifierKind.getAnnotationClass().getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno == null) {\n+                continue;\n+            }\n+            Set<DefaultQualifierKind> directSupers = new TreeSet<>();\n+            for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                String superName = QualifierKindHierarchy.annotationClassName(superClazz);\n+                DefaultQualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                if (superQualifier == null) {\n+                    throw new TypeSystemError(\n+                            \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                            qualifierKind, superName, UtilPlume.join(\", \", qualifierKinds));\n+                }\n+                directSupers.add(superQualifier);\n+            }\n+            directSuperMap.put(qualifierKind, directSupers);\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * If {@code bottom} is non-null, then this method sets bottom to the given class and modifies\n+     * {@code directSuperMap} to add all leaves to its super qualifier kinds. Leaves are qualifier\n+     * kinds that are not super qualifier kinds of another qualifier kind.\n+     *\n+     * <p>If {@code bottom} is {@code null}, then this method does nothing.\n+     *\n+     * @param bottom the class of the bottom qualifer in the hierarchy\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; side-effected by this method\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\"})\n+    private void setBottom(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            @Nullable Class<? extends Annotation> bottom,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        if (bottom == null) {\n+            return;\n+        }\n+        DefaultQualifierKind bottomKind =\n+                nameToQualifierKind.get(QualifierKindHierarchy.annotationClassName(bottom));\n+        if (bottomKind == null) {\n+            throw new TypeSystemError(\n+                    \"QualifierKindHierarchy#setBottom: the given bottom class, %s, is not in the hierarchy.\",\n+                    bottom.getCanonicalName());\n+        }\n+\n+        Set<DefaultQualifierKind> currentLeaves = new TreeSet<>(qualifierKinds);\n+        currentLeaves.remove(bottomKind);\n+        directSuperMap.forEach((sub, supers) -> currentLeaves.removeAll(supers));\n+        Set<DefaultQualifierKind> bottomDirectSuperQuals = directSuperMap.get(bottomKind);\n+        if (bottomDirectSuperQuals == null) {\n+            directSuperMap.put(bottomKind, currentLeaves);\n+        } else {\n+            bottomDirectSuperQuals.addAll(currentLeaves);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifier kinds without any direct super qualifier kinds.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<DefaultQualifierKind> createTopsSet(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Set<DefaultQualifierKind> tops = new TreeSet<>();\n+        directSuperMap.forEach(\n+                (qualifierKind, superQuals) -> {\n+                    if (superQuals.isEmpty()) {\n+                        tops.add(qualifierKind);\n+                    }\n+                });\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier kind of another qualifier kind.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<DefaultQualifierKind> createBottomsSet(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Set<DefaultQualifierKind> bottoms = new HashSet<>(directSuperMap.keySet());\n+        for (Set<DefaultQualifierKind> superKinds : directSuperMap.values()) {\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifier kinds to\n+     * polymorphicQualifiers. Also sets {@link DefaultQualifierKind#poly} and {@link\n+     * DefaultQualifierKind#top} for the polymorphic qualifiers. Set {@link\n+     * DefaultQualifierKind#poly} for the top qualifiers.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\", \"this.tops\"})\n+    protected void initializePolymorphicQualifiers(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno == null) {\n+                continue;\n+            }\n+            qualifierKind.poly = qualifierKind;\n+            String topName = QualifierKindHierarchy.annotationClassName(polyMetaAnno.value());\n+            if (nameToQualifierKind.containsKey(topName)) {\n+                qualifierKind.top = nameToQualifierKind.get(topName);\n+            } else if (topName.equals(Annotation.class.getCanonicalName())) {\n+                // Annotation.class is the default value of PolymorphicQualifier. If it is used,\n+                // then there must be exactly one top.\n+                if (tops.size() == 1) {\n+                    qualifierKind.top = tops.iterator().next();\n+                } else {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                            qualifierKind, UtilPlume.join(\", \", tops));\n+                }\n+            } else {\n+                throw new TypeSystemError(\n+                        \"Polymorphic qualifier %s's top, %s, is not a qualifier.\",\n+                        qualifierKind, topName);\n+            }\n+            qualifierKind.strictSuperTypes = Collections.singleton(qualifierKind.top);\n+            qualifierKind.top.poly = qualifierKind;\n+        }\n+    }\n+\n+    /**\n+     * For each qualifier kind in {@code directSuperMap}, initializes {@link\n+     * DefaultQualifierKind#strictSuperTypes}, {@link DefaultQualifierKind#top}, {@link\n+     * DefaultQualifierKind#bottom}, and {@link DefaultQualifierKind#poly}. (Requires tops, bottoms,\n+     * and polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     */\n+    @RequiresNonNull({\"this.qualifierKinds\", \"this.tops\", \"this.bottoms\"})\n+    protected void initializeQualifierKindFields(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        for (DefaultQualifierKind qualifierKind : directSuperMap.keySet()) {\n+            if (!qualifierKind.isPoly()) {\n+                qualifierKind.strictSuperTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            for (DefaultQualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;\n+                    } else if (qualifierKind.top != top) {\n+                        throw new TypeSystemError(\n+                                \"Multiple tops found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, top, qualifierKind.top);\n+                    }\n+                }\n+            }\n+            if (qualifierKind.top == null) {\n+                throw new TypeSystemError(\n+                        \"Qualifier %s isn't a subtype of any top. tops = %s\", qualifierKind, tops);\n+            }\n+            qualifierKind.poly = qualifierKind.top.poly;\n+        }\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            for (DefaultQualifierKind bot : bottoms) {\n+                if (bot.top != qualifierKind.top) {\n+                    continue;\n+                }\n+                if (qualifierKind.bottom == null) {\n+                    qualifierKind.bottom = bot;\n+                } else if (qualifierKind.top != bot) {\n+                    throw new TypeSystemError(\n+                            \"Multiple bottoms found for qualifier %s. Bottoms: %s and %s.\",\n+                            qualifierKind, bot, qualifierKind.bottom);\n+                }\n+                if (qualifierKind.isPoly()) {\n+                    assert bot.strictSuperTypes != null\n+                            : \"@AssumeAssertion(nullness):strictSuperTypes should be nonnull.\";\n+                    bot.strictSuperTypes.add(qualifierKind);\n+                }\n+            }\n+            if (qualifierKind.bottom == null) {\n+                throw new TypeSystemError(\n+                        \"Cannot find a bottom qualifier for %s. bottoms = %s\",\n+                        qualifierKind, bottoms);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the set of all qualifier kinds that are a strict supertype of {@code qualifierKind}.\n+     *\n+     * @param qualifierKind the qualifier kind whose super types should be returned\n+     * @param directSuperMap directSuperMap", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 452}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDIwNTY5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzoyMTowN1rOHFIvow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzoyMTowN1rOHFIvow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE0ODE5NQ==", "bodyText": "Since add returns a boolean, you could use it instead of contains, to make the code slightly shorter and slightly more efficient.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475148195", "createdAt": "2020-08-22T23:21:07Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,802 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.plumelib.util.UtilPlume;\n+\n+/**\n+ * This is the default implementation of {@link QualifierKindHierarchy}.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * {@link DefaultQualifierKindHierarchy.DefaultQualifierKind} is the implementation used for {@link\n+ * QualifierKind} by this class.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class DefaultQualifierKindHierarchy implements QualifierKindHierarchy {\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final Map<@Interned String, DefaultQualifierKind> nameToQualifierKind;\n+\n+    /** A list of all {@link QualifierKind}s sorted in ascending order. */\n+    protected final List<DefaultQualifierKind> qualifierKinds;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    @Override\n+    public Set<? extends QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public Set<? extends QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lubs.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glbs.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    public List<? extends QualifierKind> allQualifierKinds() {\n+        return qualifierKinds;\n+    }\n+\n+    @Override\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, use this constructor. Otherwise, use the other constructor.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     * @param bottom the bottom qualifier of this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        this.qualifierKinds = new ArrayList<>(nameToQualifierKind.values());\n+        Collections.sort(qualifierKinds);\n+\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap =\n+                createDirectSuperMap();\n+        setBottom(bottom, directSuperMap);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link DefaultQualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    @RequiresNonNull({\"this.qualifierKinds\", \"this.tops\", \"this.bottoms\"})\n+    protected void verifyHierarchy(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            boolean isPoly = qualifierKind.isPoly();\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, UtilPlume.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, UtilPlume.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    UtilPlume.join(\", \", tops), UtilPlume.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, DefaultQualifierKind> createQualifierKinds(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, DefaultQualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned DefaultQualifierKind qualifierKind = new DefaultQualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.getName())) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.getName());\n+            }\n+            nameToQualifierKind.put(qualifierKind.getName(), qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\"})\n+    protected Map<DefaultQualifierKind, Set<DefaultQualifierKind>> createDirectSuperMap(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap = new TreeMap<>();\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            SubtypeOf subtypeOfMetaAnno =\n+                    qualifierKind.getAnnotationClass().getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno == null) {\n+                continue;\n+            }\n+            Set<DefaultQualifierKind> directSupers = new TreeSet<>();\n+            for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                String superName = QualifierKindHierarchy.annotationClassName(superClazz);\n+                DefaultQualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                if (superQualifier == null) {\n+                    throw new TypeSystemError(\n+                            \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                            qualifierKind, superName, UtilPlume.join(\", \", qualifierKinds));\n+                }\n+                directSupers.add(superQualifier);\n+            }\n+            directSuperMap.put(qualifierKind, directSupers);\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * If {@code bottom} is non-null, then this method sets bottom to the given class and modifies\n+     * {@code directSuperMap} to add all leaves to its super qualifier kinds. Leaves are qualifier\n+     * kinds that are not super qualifier kinds of another qualifier kind.\n+     *\n+     * <p>If {@code bottom} is {@code null}, then this method does nothing.\n+     *\n+     * @param bottom the class of the bottom qualifer in the hierarchy\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; side-effected by this method\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\"})\n+    private void setBottom(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            @Nullable Class<? extends Annotation> bottom,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        if (bottom == null) {\n+            return;\n+        }\n+        DefaultQualifierKind bottomKind =\n+                nameToQualifierKind.get(QualifierKindHierarchy.annotationClassName(bottom));\n+        if (bottomKind == null) {\n+            throw new TypeSystemError(\n+                    \"QualifierKindHierarchy#setBottom: the given bottom class, %s, is not in the hierarchy.\",\n+                    bottom.getCanonicalName());\n+        }\n+\n+        Set<DefaultQualifierKind> currentLeaves = new TreeSet<>(qualifierKinds);\n+        currentLeaves.remove(bottomKind);\n+        directSuperMap.forEach((sub, supers) -> currentLeaves.removeAll(supers));\n+        Set<DefaultQualifierKind> bottomDirectSuperQuals = directSuperMap.get(bottomKind);\n+        if (bottomDirectSuperQuals == null) {\n+            directSuperMap.put(bottomKind, currentLeaves);\n+        } else {\n+            bottomDirectSuperQuals.addAll(currentLeaves);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifier kinds without any direct super qualifier kinds.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<DefaultQualifierKind> createTopsSet(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Set<DefaultQualifierKind> tops = new TreeSet<>();\n+        directSuperMap.forEach(\n+                (qualifierKind, superQuals) -> {\n+                    if (superQuals.isEmpty()) {\n+                        tops.add(qualifierKind);\n+                    }\n+                });\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier kind of another qualifier kind.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<DefaultQualifierKind> createBottomsSet(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Set<DefaultQualifierKind> bottoms = new HashSet<>(directSuperMap.keySet());\n+        for (Set<DefaultQualifierKind> superKinds : directSuperMap.values()) {\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifier kinds to\n+     * polymorphicQualifiers. Also sets {@link DefaultQualifierKind#poly} and {@link\n+     * DefaultQualifierKind#top} for the polymorphic qualifiers. Set {@link\n+     * DefaultQualifierKind#poly} for the top qualifiers.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\", \"this.tops\"})\n+    protected void initializePolymorphicQualifiers(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno == null) {\n+                continue;\n+            }\n+            qualifierKind.poly = qualifierKind;\n+            String topName = QualifierKindHierarchy.annotationClassName(polyMetaAnno.value());\n+            if (nameToQualifierKind.containsKey(topName)) {\n+                qualifierKind.top = nameToQualifierKind.get(topName);\n+            } else if (topName.equals(Annotation.class.getCanonicalName())) {\n+                // Annotation.class is the default value of PolymorphicQualifier. If it is used,\n+                // then there must be exactly one top.\n+                if (tops.size() == 1) {\n+                    qualifierKind.top = tops.iterator().next();\n+                } else {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                            qualifierKind, UtilPlume.join(\", \", tops));\n+                }\n+            } else {\n+                throw new TypeSystemError(\n+                        \"Polymorphic qualifier %s's top, %s, is not a qualifier.\",\n+                        qualifierKind, topName);\n+            }\n+            qualifierKind.strictSuperTypes = Collections.singleton(qualifierKind.top);\n+            qualifierKind.top.poly = qualifierKind;\n+        }\n+    }\n+\n+    /**\n+     * For each qualifier kind in {@code directSuperMap}, initializes {@link\n+     * DefaultQualifierKind#strictSuperTypes}, {@link DefaultQualifierKind#top}, {@link\n+     * DefaultQualifierKind#bottom}, and {@link DefaultQualifierKind#poly}. (Requires tops, bottoms,\n+     * and polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     */\n+    @RequiresNonNull({\"this.qualifierKinds\", \"this.tops\", \"this.bottoms\"})\n+    protected void initializeQualifierKindFields(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        for (DefaultQualifierKind qualifierKind : directSuperMap.keySet()) {\n+            if (!qualifierKind.isPoly()) {\n+                qualifierKind.strictSuperTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            for (DefaultQualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;\n+                    } else if (qualifierKind.top != top) {\n+                        throw new TypeSystemError(\n+                                \"Multiple tops found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, top, qualifierKind.top);\n+                    }\n+                }\n+            }\n+            if (qualifierKind.top == null) {\n+                throw new TypeSystemError(\n+                        \"Qualifier %s isn't a subtype of any top. tops = %s\", qualifierKind, tops);\n+            }\n+            qualifierKind.poly = qualifierKind.top.poly;\n+        }\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            for (DefaultQualifierKind bot : bottoms) {\n+                if (bot.top != qualifierKind.top) {\n+                    continue;\n+                }\n+                if (qualifierKind.bottom == null) {\n+                    qualifierKind.bottom = bot;\n+                } else if (qualifierKind.top != bot) {\n+                    throw new TypeSystemError(\n+                            \"Multiple bottoms found for qualifier %s. Bottoms: %s and %s.\",\n+                            qualifierKind, bot, qualifierKind.bottom);\n+                }\n+                if (qualifierKind.isPoly()) {\n+                    assert bot.strictSuperTypes != null\n+                            : \"@AssumeAssertion(nullness):strictSuperTypes should be nonnull.\";\n+                    bot.strictSuperTypes.add(qualifierKind);\n+                }\n+            }\n+            if (qualifierKind.bottom == null) {\n+                throw new TypeSystemError(\n+                        \"Cannot find a bottom qualifier for %s. bottoms = %s\",\n+                        qualifierKind, bottoms);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the set of all qualifier kinds that are a strict supertype of {@code qualifierKind}.\n+     *\n+     * @param qualifierKind the qualifier kind whose super types should be returned\n+     * @param directSuperMap directSuperMap\n+     * @return the set of all qualifier kinds that are a strict supertype of {@code qualifierKind}\n+     */\n+    private Set<QualifierKind> findAllTheSupers(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            @KeyFor(\"#2\") QualifierKind qualifierKind,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Queue<DefaultQualifierKind> queue = new ArrayDeque<>(directSuperMap.get(qualifierKind));\n+        Set<QualifierKind> allSupers = new TreeSet<>(directSuperMap.get(qualifierKind));\n+        Set<DefaultQualifierKind> visited = new HashSet<>();\n+        while (!queue.isEmpty()) {\n+            DefaultQualifierKind superQualKind = queue.remove();\n+            if (superQualKind == qualifierKind) {\n+                throw new TypeSystemError(\"Cycle in hierarchy: %s\", qualifierKind);\n+            }\n+            if (visited.contains(superQualKind)) {\n+                continue;\n+            }\n+            visited.add(superQualKind);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 470}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDIwNzg2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzoyNToyMlrOHFIwvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMDowMDo1M1rOHGnsEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE0ODQ3OQ==", "bodyText": "Can you use allSupers and eliminate the visited variable?  It seems that the two collections will contain the same contents after the first iteration.\nA possible fly in the ointment is the special treatment of polymorphic qualifiers.  Is it treated specially for the purposes of direct super types?  If so, should that be documented?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475148479", "createdAt": "2020-08-22T23:25:22Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,802 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.plumelib.util.UtilPlume;\n+\n+/**\n+ * This is the default implementation of {@link QualifierKindHierarchy}.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * {@link DefaultQualifierKindHierarchy.DefaultQualifierKind} is the implementation used for {@link\n+ * QualifierKind} by this class.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class DefaultQualifierKindHierarchy implements QualifierKindHierarchy {\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final Map<@Interned String, DefaultQualifierKind> nameToQualifierKind;\n+\n+    /** A list of all {@link QualifierKind}s sorted in ascending order. */\n+    protected final List<DefaultQualifierKind> qualifierKinds;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    @Override\n+    public Set<? extends QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public Set<? extends QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lubs.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glbs.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    public List<? extends QualifierKind> allQualifierKinds() {\n+        return qualifierKinds;\n+    }\n+\n+    @Override\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, use this constructor. Otherwise, use the other constructor.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     * @param bottom the bottom qualifier of this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        this.qualifierKinds = new ArrayList<>(nameToQualifierKind.values());\n+        Collections.sort(qualifierKinds);\n+\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap =\n+                createDirectSuperMap();\n+        setBottom(bottom, directSuperMap);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link DefaultQualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    @RequiresNonNull({\"this.qualifierKinds\", \"this.tops\", \"this.bottoms\"})\n+    protected void verifyHierarchy(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            boolean isPoly = qualifierKind.isPoly();\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, UtilPlume.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, UtilPlume.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    UtilPlume.join(\", \", tops), UtilPlume.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, DefaultQualifierKind> createQualifierKinds(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, DefaultQualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned DefaultQualifierKind qualifierKind = new DefaultQualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.getName())) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.getName());\n+            }\n+            nameToQualifierKind.put(qualifierKind.getName(), qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\"})\n+    protected Map<DefaultQualifierKind, Set<DefaultQualifierKind>> createDirectSuperMap(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap = new TreeMap<>();\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            SubtypeOf subtypeOfMetaAnno =\n+                    qualifierKind.getAnnotationClass().getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno == null) {\n+                continue;\n+            }\n+            Set<DefaultQualifierKind> directSupers = new TreeSet<>();\n+            for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                String superName = QualifierKindHierarchy.annotationClassName(superClazz);\n+                DefaultQualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                if (superQualifier == null) {\n+                    throw new TypeSystemError(\n+                            \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                            qualifierKind, superName, UtilPlume.join(\", \", qualifierKinds));\n+                }\n+                directSupers.add(superQualifier);\n+            }\n+            directSuperMap.put(qualifierKind, directSupers);\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * If {@code bottom} is non-null, then this method sets bottom to the given class and modifies\n+     * {@code directSuperMap} to add all leaves to its super qualifier kinds. Leaves are qualifier\n+     * kinds that are not super qualifier kinds of another qualifier kind.\n+     *\n+     * <p>If {@code bottom} is {@code null}, then this method does nothing.\n+     *\n+     * @param bottom the class of the bottom qualifer in the hierarchy\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; side-effected by this method\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\"})\n+    private void setBottom(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            @Nullable Class<? extends Annotation> bottom,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        if (bottom == null) {\n+            return;\n+        }\n+        DefaultQualifierKind bottomKind =\n+                nameToQualifierKind.get(QualifierKindHierarchy.annotationClassName(bottom));\n+        if (bottomKind == null) {\n+            throw new TypeSystemError(\n+                    \"QualifierKindHierarchy#setBottom: the given bottom class, %s, is not in the hierarchy.\",\n+                    bottom.getCanonicalName());\n+        }\n+\n+        Set<DefaultQualifierKind> currentLeaves = new TreeSet<>(qualifierKinds);\n+        currentLeaves.remove(bottomKind);\n+        directSuperMap.forEach((sub, supers) -> currentLeaves.removeAll(supers));\n+        Set<DefaultQualifierKind> bottomDirectSuperQuals = directSuperMap.get(bottomKind);\n+        if (bottomDirectSuperQuals == null) {\n+            directSuperMap.put(bottomKind, currentLeaves);\n+        } else {\n+            bottomDirectSuperQuals.addAll(currentLeaves);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifier kinds without any direct super qualifier kinds.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<DefaultQualifierKind> createTopsSet(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Set<DefaultQualifierKind> tops = new TreeSet<>();\n+        directSuperMap.forEach(\n+                (qualifierKind, superQuals) -> {\n+                    if (superQuals.isEmpty()) {\n+                        tops.add(qualifierKind);\n+                    }\n+                });\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier kind of another qualifier kind.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<DefaultQualifierKind> createBottomsSet(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Set<DefaultQualifierKind> bottoms = new HashSet<>(directSuperMap.keySet());\n+        for (Set<DefaultQualifierKind> superKinds : directSuperMap.values()) {\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifier kinds to\n+     * polymorphicQualifiers. Also sets {@link DefaultQualifierKind#poly} and {@link\n+     * DefaultQualifierKind#top} for the polymorphic qualifiers. Set {@link\n+     * DefaultQualifierKind#poly} for the top qualifiers.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\", \"this.tops\"})\n+    protected void initializePolymorphicQualifiers(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno == null) {\n+                continue;\n+            }\n+            qualifierKind.poly = qualifierKind;\n+            String topName = QualifierKindHierarchy.annotationClassName(polyMetaAnno.value());\n+            if (nameToQualifierKind.containsKey(topName)) {\n+                qualifierKind.top = nameToQualifierKind.get(topName);\n+            } else if (topName.equals(Annotation.class.getCanonicalName())) {\n+                // Annotation.class is the default value of PolymorphicQualifier. If it is used,\n+                // then there must be exactly one top.\n+                if (tops.size() == 1) {\n+                    qualifierKind.top = tops.iterator().next();\n+                } else {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                            qualifierKind, UtilPlume.join(\", \", tops));\n+                }\n+            } else {\n+                throw new TypeSystemError(\n+                        \"Polymorphic qualifier %s's top, %s, is not a qualifier.\",\n+                        qualifierKind, topName);\n+            }\n+            qualifierKind.strictSuperTypes = Collections.singleton(qualifierKind.top);\n+            qualifierKind.top.poly = qualifierKind;\n+        }\n+    }\n+\n+    /**\n+     * For each qualifier kind in {@code directSuperMap}, initializes {@link\n+     * DefaultQualifierKind#strictSuperTypes}, {@link DefaultQualifierKind#top}, {@link\n+     * DefaultQualifierKind#bottom}, and {@link DefaultQualifierKind#poly}. (Requires tops, bottoms,\n+     * and polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     */\n+    @RequiresNonNull({\"this.qualifierKinds\", \"this.tops\", \"this.bottoms\"})\n+    protected void initializeQualifierKindFields(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        for (DefaultQualifierKind qualifierKind : directSuperMap.keySet()) {\n+            if (!qualifierKind.isPoly()) {\n+                qualifierKind.strictSuperTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            for (DefaultQualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;\n+                    } else if (qualifierKind.top != top) {\n+                        throw new TypeSystemError(\n+                                \"Multiple tops found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, top, qualifierKind.top);\n+                    }\n+                }\n+            }\n+            if (qualifierKind.top == null) {\n+                throw new TypeSystemError(\n+                        \"Qualifier %s isn't a subtype of any top. tops = %s\", qualifierKind, tops);\n+            }\n+            qualifierKind.poly = qualifierKind.top.poly;\n+        }\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            for (DefaultQualifierKind bot : bottoms) {\n+                if (bot.top != qualifierKind.top) {\n+                    continue;\n+                }\n+                if (qualifierKind.bottom == null) {\n+                    qualifierKind.bottom = bot;\n+                } else if (qualifierKind.top != bot) {\n+                    throw new TypeSystemError(\n+                            \"Multiple bottoms found for qualifier %s. Bottoms: %s and %s.\",\n+                            qualifierKind, bot, qualifierKind.bottom);\n+                }\n+                if (qualifierKind.isPoly()) {\n+                    assert bot.strictSuperTypes != null\n+                            : \"@AssumeAssertion(nullness):strictSuperTypes should be nonnull.\";\n+                    bot.strictSuperTypes.add(qualifierKind);\n+                }\n+            }\n+            if (qualifierKind.bottom == null) {\n+                throw new TypeSystemError(\n+                        \"Cannot find a bottom qualifier for %s. bottoms = %s\",\n+                        qualifierKind, bottoms);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the set of all qualifier kinds that are a strict supertype of {@code qualifierKind}.\n+     *\n+     * @param qualifierKind the qualifier kind whose super types should be returned\n+     * @param directSuperMap directSuperMap\n+     * @return the set of all qualifier kinds that are a strict supertype of {@code qualifierKind}\n+     */\n+    private Set<QualifierKind> findAllTheSupers(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            @KeyFor(\"#2\") QualifierKind qualifierKind,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Queue<DefaultQualifierKind> queue = new ArrayDeque<>(directSuperMap.get(qualifierKind));\n+        Set<QualifierKind> allSupers = new TreeSet<>(directSuperMap.get(qualifierKind));\n+        Set<DefaultQualifierKind> visited = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 461}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYyOTc2MA==", "bodyText": "I don't think so. A QualifierKind is added to visited once its super qualifier kinds have been added to allSupers.  T allSupers contains QualifierKinds whose super qualifier kinds have not yet been added to allSupers.   But maybe I'm misunderstanding your comment.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r476629760", "createdAt": "2020-08-25T17:46:40Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,802 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.plumelib.util.UtilPlume;\n+\n+/**\n+ * This is the default implementation of {@link QualifierKindHierarchy}.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * {@link DefaultQualifierKindHierarchy.DefaultQualifierKind} is the implementation used for {@link\n+ * QualifierKind} by this class.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class DefaultQualifierKindHierarchy implements QualifierKindHierarchy {\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final Map<@Interned String, DefaultQualifierKind> nameToQualifierKind;\n+\n+    /** A list of all {@link QualifierKind}s sorted in ascending order. */\n+    protected final List<DefaultQualifierKind> qualifierKinds;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    @Override\n+    public Set<? extends QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public Set<? extends QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lubs.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glbs.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    public List<? extends QualifierKind> allQualifierKinds() {\n+        return qualifierKinds;\n+    }\n+\n+    @Override\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, use this constructor. Otherwise, use the other constructor.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     * @param bottom the bottom qualifier of this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        this.qualifierKinds = new ArrayList<>(nameToQualifierKind.values());\n+        Collections.sort(qualifierKinds);\n+\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap =\n+                createDirectSuperMap();\n+        setBottom(bottom, directSuperMap);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link DefaultQualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    @RequiresNonNull({\"this.qualifierKinds\", \"this.tops\", \"this.bottoms\"})\n+    protected void verifyHierarchy(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            boolean isPoly = qualifierKind.isPoly();\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, UtilPlume.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, UtilPlume.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    UtilPlume.join(\", \", tops), UtilPlume.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, DefaultQualifierKind> createQualifierKinds(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, DefaultQualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned DefaultQualifierKind qualifierKind = new DefaultQualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.getName())) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.getName());\n+            }\n+            nameToQualifierKind.put(qualifierKind.getName(), qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\"})\n+    protected Map<DefaultQualifierKind, Set<DefaultQualifierKind>> createDirectSuperMap(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap = new TreeMap<>();\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            SubtypeOf subtypeOfMetaAnno =\n+                    qualifierKind.getAnnotationClass().getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno == null) {\n+                continue;\n+            }\n+            Set<DefaultQualifierKind> directSupers = new TreeSet<>();\n+            for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                String superName = QualifierKindHierarchy.annotationClassName(superClazz);\n+                DefaultQualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                if (superQualifier == null) {\n+                    throw new TypeSystemError(\n+                            \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                            qualifierKind, superName, UtilPlume.join(\", \", qualifierKinds));\n+                }\n+                directSupers.add(superQualifier);\n+            }\n+            directSuperMap.put(qualifierKind, directSupers);\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * If {@code bottom} is non-null, then this method sets bottom to the given class and modifies\n+     * {@code directSuperMap} to add all leaves to its super qualifier kinds. Leaves are qualifier\n+     * kinds that are not super qualifier kinds of another qualifier kind.\n+     *\n+     * <p>If {@code bottom} is {@code null}, then this method does nothing.\n+     *\n+     * @param bottom the class of the bottom qualifer in the hierarchy\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; side-effected by this method\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\"})\n+    private void setBottom(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            @Nullable Class<? extends Annotation> bottom,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        if (bottom == null) {\n+            return;\n+        }\n+        DefaultQualifierKind bottomKind =\n+                nameToQualifierKind.get(QualifierKindHierarchy.annotationClassName(bottom));\n+        if (bottomKind == null) {\n+            throw new TypeSystemError(\n+                    \"QualifierKindHierarchy#setBottom: the given bottom class, %s, is not in the hierarchy.\",\n+                    bottom.getCanonicalName());\n+        }\n+\n+        Set<DefaultQualifierKind> currentLeaves = new TreeSet<>(qualifierKinds);\n+        currentLeaves.remove(bottomKind);\n+        directSuperMap.forEach((sub, supers) -> currentLeaves.removeAll(supers));\n+        Set<DefaultQualifierKind> bottomDirectSuperQuals = directSuperMap.get(bottomKind);\n+        if (bottomDirectSuperQuals == null) {\n+            directSuperMap.put(bottomKind, currentLeaves);\n+        } else {\n+            bottomDirectSuperQuals.addAll(currentLeaves);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifier kinds without any direct super qualifier kinds.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<DefaultQualifierKind> createTopsSet(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Set<DefaultQualifierKind> tops = new TreeSet<>();\n+        directSuperMap.forEach(\n+                (qualifierKind, superQuals) -> {\n+                    if (superQuals.isEmpty()) {\n+                        tops.add(qualifierKind);\n+                    }\n+                });\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier kind of another qualifier kind.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<DefaultQualifierKind> createBottomsSet(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Set<DefaultQualifierKind> bottoms = new HashSet<>(directSuperMap.keySet());\n+        for (Set<DefaultQualifierKind> superKinds : directSuperMap.values()) {\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifier kinds to\n+     * polymorphicQualifiers. Also sets {@link DefaultQualifierKind#poly} and {@link\n+     * DefaultQualifierKind#top} for the polymorphic qualifiers. Set {@link\n+     * DefaultQualifierKind#poly} for the top qualifiers.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\", \"this.tops\"})\n+    protected void initializePolymorphicQualifiers(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno == null) {\n+                continue;\n+            }\n+            qualifierKind.poly = qualifierKind;\n+            String topName = QualifierKindHierarchy.annotationClassName(polyMetaAnno.value());\n+            if (nameToQualifierKind.containsKey(topName)) {\n+                qualifierKind.top = nameToQualifierKind.get(topName);\n+            } else if (topName.equals(Annotation.class.getCanonicalName())) {\n+                // Annotation.class is the default value of PolymorphicQualifier. If it is used,\n+                // then there must be exactly one top.\n+                if (tops.size() == 1) {\n+                    qualifierKind.top = tops.iterator().next();\n+                } else {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                            qualifierKind, UtilPlume.join(\", \", tops));\n+                }\n+            } else {\n+                throw new TypeSystemError(\n+                        \"Polymorphic qualifier %s's top, %s, is not a qualifier.\",\n+                        qualifierKind, topName);\n+            }\n+            qualifierKind.strictSuperTypes = Collections.singleton(qualifierKind.top);\n+            qualifierKind.top.poly = qualifierKind;\n+        }\n+    }\n+\n+    /**\n+     * For each qualifier kind in {@code directSuperMap}, initializes {@link\n+     * DefaultQualifierKind#strictSuperTypes}, {@link DefaultQualifierKind#top}, {@link\n+     * DefaultQualifierKind#bottom}, and {@link DefaultQualifierKind#poly}. (Requires tops, bottoms,\n+     * and polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     */\n+    @RequiresNonNull({\"this.qualifierKinds\", \"this.tops\", \"this.bottoms\"})\n+    protected void initializeQualifierKindFields(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        for (DefaultQualifierKind qualifierKind : directSuperMap.keySet()) {\n+            if (!qualifierKind.isPoly()) {\n+                qualifierKind.strictSuperTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            for (DefaultQualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;\n+                    } else if (qualifierKind.top != top) {\n+                        throw new TypeSystemError(\n+                                \"Multiple tops found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, top, qualifierKind.top);\n+                    }\n+                }\n+            }\n+            if (qualifierKind.top == null) {\n+                throw new TypeSystemError(\n+                        \"Qualifier %s isn't a subtype of any top. tops = %s\", qualifierKind, tops);\n+            }\n+            qualifierKind.poly = qualifierKind.top.poly;\n+        }\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            for (DefaultQualifierKind bot : bottoms) {\n+                if (bot.top != qualifierKind.top) {\n+                    continue;\n+                }\n+                if (qualifierKind.bottom == null) {\n+                    qualifierKind.bottom = bot;\n+                } else if (qualifierKind.top != bot) {\n+                    throw new TypeSystemError(\n+                            \"Multiple bottoms found for qualifier %s. Bottoms: %s and %s.\",\n+                            qualifierKind, bot, qualifierKind.bottom);\n+                }\n+                if (qualifierKind.isPoly()) {\n+                    assert bot.strictSuperTypes != null\n+                            : \"@AssumeAssertion(nullness):strictSuperTypes should be nonnull.\";\n+                    bot.strictSuperTypes.add(qualifierKind);\n+                }\n+            }\n+            if (qualifierKind.bottom == null) {\n+                throw new TypeSystemError(\n+                        \"Cannot find a bottom qualifier for %s. bottoms = %s\",\n+                        qualifierKind, bottoms);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the set of all qualifier kinds that are a strict supertype of {@code qualifierKind}.\n+     *\n+     * @param qualifierKind the qualifier kind whose super types should be returned\n+     * @param directSuperMap directSuperMap\n+     * @return the set of all qualifier kinds that are a strict supertype of {@code qualifierKind}\n+     */\n+    private Set<QualifierKind> findAllTheSupers(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            @KeyFor(\"#2\") QualifierKind qualifierKind,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Queue<DefaultQualifierKind> queue = new ArrayDeque<>(directSuperMap.get(qualifierKind));\n+        Set<QualifierKind> allSupers = new TreeSet<>(directSuperMap.get(qualifierKind));\n+        Set<DefaultQualifierKind> visited = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE0ODQ3OQ=="}, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 461}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcwMzc2Mg==", "bodyText": "The code as is works, but I was wondering if it could be simplified.  Maybe a comment about the relationship between the variables is enough to help people understand the code.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r476703762", "createdAt": "2020-08-25T20:00:53Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,802 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.plumelib.util.UtilPlume;\n+\n+/**\n+ * This is the default implementation of {@link QualifierKindHierarchy}.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * {@link DefaultQualifierKindHierarchy.DefaultQualifierKind} is the implementation used for {@link\n+ * QualifierKind} by this class.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class DefaultQualifierKindHierarchy implements QualifierKindHierarchy {\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final Map<@Interned String, DefaultQualifierKind> nameToQualifierKind;\n+\n+    /** A list of all {@link QualifierKind}s sorted in ascending order. */\n+    protected final List<DefaultQualifierKind> qualifierKinds;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    @Override\n+    public Set<? extends QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public Set<? extends QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lubs.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glbs.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    public List<? extends QualifierKind> allQualifierKinds() {\n+        return qualifierKinds;\n+    }\n+\n+    @Override\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, use this constructor. Otherwise, use the other constructor.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     * @param bottom the bottom qualifier of this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        this.qualifierKinds = new ArrayList<>(nameToQualifierKind.values());\n+        Collections.sort(qualifierKinds);\n+\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap =\n+                createDirectSuperMap();\n+        setBottom(bottom, directSuperMap);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link DefaultQualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    @RequiresNonNull({\"this.qualifierKinds\", \"this.tops\", \"this.bottoms\"})\n+    protected void verifyHierarchy(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            boolean isPoly = qualifierKind.isPoly();\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, UtilPlume.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, UtilPlume.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    UtilPlume.join(\", \", tops), UtilPlume.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, DefaultQualifierKind> createQualifierKinds(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, DefaultQualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned DefaultQualifierKind qualifierKind = new DefaultQualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.getName())) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.getName());\n+            }\n+            nameToQualifierKind.put(qualifierKind.getName(), qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\"})\n+    protected Map<DefaultQualifierKind, Set<DefaultQualifierKind>> createDirectSuperMap(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap = new TreeMap<>();\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            SubtypeOf subtypeOfMetaAnno =\n+                    qualifierKind.getAnnotationClass().getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno == null) {\n+                continue;\n+            }\n+            Set<DefaultQualifierKind> directSupers = new TreeSet<>();\n+            for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                String superName = QualifierKindHierarchy.annotationClassName(superClazz);\n+                DefaultQualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                if (superQualifier == null) {\n+                    throw new TypeSystemError(\n+                            \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                            qualifierKind, superName, UtilPlume.join(\", \", qualifierKinds));\n+                }\n+                directSupers.add(superQualifier);\n+            }\n+            directSuperMap.put(qualifierKind, directSupers);\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * If {@code bottom} is non-null, then this method sets bottom to the given class and modifies\n+     * {@code directSuperMap} to add all leaves to its super qualifier kinds. Leaves are qualifier\n+     * kinds that are not super qualifier kinds of another qualifier kind.\n+     *\n+     * <p>If {@code bottom} is {@code null}, then this method does nothing.\n+     *\n+     * @param bottom the class of the bottom qualifer in the hierarchy\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; side-effected by this method\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\"})\n+    private void setBottom(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            @Nullable Class<? extends Annotation> bottom,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        if (bottom == null) {\n+            return;\n+        }\n+        DefaultQualifierKind bottomKind =\n+                nameToQualifierKind.get(QualifierKindHierarchy.annotationClassName(bottom));\n+        if (bottomKind == null) {\n+            throw new TypeSystemError(\n+                    \"QualifierKindHierarchy#setBottom: the given bottom class, %s, is not in the hierarchy.\",\n+                    bottom.getCanonicalName());\n+        }\n+\n+        Set<DefaultQualifierKind> currentLeaves = new TreeSet<>(qualifierKinds);\n+        currentLeaves.remove(bottomKind);\n+        directSuperMap.forEach((sub, supers) -> currentLeaves.removeAll(supers));\n+        Set<DefaultQualifierKind> bottomDirectSuperQuals = directSuperMap.get(bottomKind);\n+        if (bottomDirectSuperQuals == null) {\n+            directSuperMap.put(bottomKind, currentLeaves);\n+        } else {\n+            bottomDirectSuperQuals.addAll(currentLeaves);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifier kinds without any direct super qualifier kinds.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<DefaultQualifierKind> createTopsSet(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Set<DefaultQualifierKind> tops = new TreeSet<>();\n+        directSuperMap.forEach(\n+                (qualifierKind, superQuals) -> {\n+                    if (superQuals.isEmpty()) {\n+                        tops.add(qualifierKind);\n+                    }\n+                });\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier kind of another qualifier kind.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<DefaultQualifierKind> createBottomsSet(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Set<DefaultQualifierKind> bottoms = new HashSet<>(directSuperMap.keySet());\n+        for (Set<DefaultQualifierKind> superKinds : directSuperMap.values()) {\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifier kinds to\n+     * polymorphicQualifiers. Also sets {@link DefaultQualifierKind#poly} and {@link\n+     * DefaultQualifierKind#top} for the polymorphic qualifiers. Set {@link\n+     * DefaultQualifierKind#poly} for the top qualifiers.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\", \"this.tops\"})\n+    protected void initializePolymorphicQualifiers(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno == null) {\n+                continue;\n+            }\n+            qualifierKind.poly = qualifierKind;\n+            String topName = QualifierKindHierarchy.annotationClassName(polyMetaAnno.value());\n+            if (nameToQualifierKind.containsKey(topName)) {\n+                qualifierKind.top = nameToQualifierKind.get(topName);\n+            } else if (topName.equals(Annotation.class.getCanonicalName())) {\n+                // Annotation.class is the default value of PolymorphicQualifier. If it is used,\n+                // then there must be exactly one top.\n+                if (tops.size() == 1) {\n+                    qualifierKind.top = tops.iterator().next();\n+                } else {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                            qualifierKind, UtilPlume.join(\", \", tops));\n+                }\n+            } else {\n+                throw new TypeSystemError(\n+                        \"Polymorphic qualifier %s's top, %s, is not a qualifier.\",\n+                        qualifierKind, topName);\n+            }\n+            qualifierKind.strictSuperTypes = Collections.singleton(qualifierKind.top);\n+            qualifierKind.top.poly = qualifierKind;\n+        }\n+    }\n+\n+    /**\n+     * For each qualifier kind in {@code directSuperMap}, initializes {@link\n+     * DefaultQualifierKind#strictSuperTypes}, {@link DefaultQualifierKind#top}, {@link\n+     * DefaultQualifierKind#bottom}, and {@link DefaultQualifierKind#poly}. (Requires tops, bottoms,\n+     * and polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     */\n+    @RequiresNonNull({\"this.qualifierKinds\", \"this.tops\", \"this.bottoms\"})\n+    protected void initializeQualifierKindFields(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        for (DefaultQualifierKind qualifierKind : directSuperMap.keySet()) {\n+            if (!qualifierKind.isPoly()) {\n+                qualifierKind.strictSuperTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            for (DefaultQualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;\n+                    } else if (qualifierKind.top != top) {\n+                        throw new TypeSystemError(\n+                                \"Multiple tops found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, top, qualifierKind.top);\n+                    }\n+                }\n+            }\n+            if (qualifierKind.top == null) {\n+                throw new TypeSystemError(\n+                        \"Qualifier %s isn't a subtype of any top. tops = %s\", qualifierKind, tops);\n+            }\n+            qualifierKind.poly = qualifierKind.top.poly;\n+        }\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            for (DefaultQualifierKind bot : bottoms) {\n+                if (bot.top != qualifierKind.top) {\n+                    continue;\n+                }\n+                if (qualifierKind.bottom == null) {\n+                    qualifierKind.bottom = bot;\n+                } else if (qualifierKind.top != bot) {\n+                    throw new TypeSystemError(\n+                            \"Multiple bottoms found for qualifier %s. Bottoms: %s and %s.\",\n+                            qualifierKind, bot, qualifierKind.bottom);\n+                }\n+                if (qualifierKind.isPoly()) {\n+                    assert bot.strictSuperTypes != null\n+                            : \"@AssumeAssertion(nullness):strictSuperTypes should be nonnull.\";\n+                    bot.strictSuperTypes.add(qualifierKind);\n+                }\n+            }\n+            if (qualifierKind.bottom == null) {\n+                throw new TypeSystemError(\n+                        \"Cannot find a bottom qualifier for %s. bottoms = %s\",\n+                        qualifierKind, bottoms);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the set of all qualifier kinds that are a strict supertype of {@code qualifierKind}.\n+     *\n+     * @param qualifierKind the qualifier kind whose super types should be returned\n+     * @param directSuperMap directSuperMap\n+     * @return the set of all qualifier kinds that are a strict supertype of {@code qualifierKind}\n+     */\n+    private Set<QualifierKind> findAllTheSupers(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            @KeyFor(\"#2\") QualifierKind qualifierKind,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Queue<DefaultQualifierKind> queue = new ArrayDeque<>(directSuperMap.get(qualifierKind));\n+        Set<QualifierKind> allSupers = new TreeSet<>(directSuperMap.get(qualifierKind));\n+        Set<DefaultQualifierKind> visited = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE0ODQ3OQ=="}, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 461}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDIxNjM5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzo0MDoyOFrOHFI0tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzo0MDoyOFrOHFI0tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE0OTQ5NA==", "bodyText": "It's not clear what \"initialized\" means.  Later comments say \"set while creating\".  Could you make the comments consistent?  It would be good to avoid JVM jargon, if possible.  I think that this means until after the corresponding DefaultQualifierKindHierarchy has been created.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475149494", "createdAt": "2020-08-22T23:40:28Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/DefaultQualifierKindHierarchy.java", "diffHunk": "@@ -0,0 +1,802 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.interning.qual.Interned;\n+import org.checkerframework.checker.nullness.qual.KeyFor;\n+import org.checkerframework.checker.nullness.qual.MonotonicNonNull;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+import org.plumelib.util.UtilPlume;\n+\n+/**\n+ * This is the default implementation of {@link QualifierKindHierarchy}.\n+ *\n+ * <p>By default, the subtyping information and information about polymorphic qualifiers is read\n+ * from meta-annotations on the annotation classes. This information is used to infer further\n+ * information such as top and bottom qualifiers. Subclasses can override the following methods to\n+ * change this behavior:\n+ *\n+ * <ul>\n+ *   <li>{@link #createQualifierKinds(Collection)}\n+ *   <li>{@link #createDirectSuperMap()}\n+ *   <li>{@link #initializePolymorphicQualifiers()}\n+ *   <li>{@link #initializeQualifierKindFields(Map)}\n+ *   <li>{@link #createLubsMap()}\n+ *   <li>{@link #createGlbsMap()}\n+ * </ul>\n+ *\n+ * {@link DefaultQualifierKindHierarchy.DefaultQualifierKind} is the implementation used for {@link\n+ * QualifierKind} by this class.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class DefaultQualifierKindHierarchy implements QualifierKindHierarchy {\n+\n+    /**\n+     * A mapping from canonical name of a qualifier class to the QualifierKind object representing\n+     * that class.\n+     */\n+    protected final Map<@Interned String, DefaultQualifierKind> nameToQualifierKind;\n+\n+    /** A list of all {@link QualifierKind}s sorted in ascending order. */\n+    protected final List<DefaultQualifierKind> qualifierKinds;\n+\n+    /** All the qualifier kinds that are the top qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> tops;\n+\n+    /** All the qualifier kinds that are the bottom qualifier in their hierarchy. */\n+    private final Set<DefaultQualifierKind> bottoms;\n+\n+    /**\n+     * Holds the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs;\n+\n+    /**\n+     * Holds the glb of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the glb of kind1\n+     * and kind2.\n+     */\n+    private final Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs;\n+\n+    @Override\n+    public Set<? extends QualifierKind> getTops() {\n+        return tops;\n+    }\n+\n+    @Override\n+    public Set<? extends QualifierKind> getBottoms() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in lubs.\n+    public @Nullable QualifierKind leastUpperBound(QualifierKind q1, QualifierKind q2) {\n+        return lubs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"nullness:dereference.of.nullable\") // All QualifierKinds are keys in glbs.\n+    public @Nullable QualifierKind greatestLowerBound(QualifierKind q1, QualifierKind q2) {\n+        return glbs.get(q1).get(q2);\n+    }\n+\n+    @Override\n+    public List<? extends QualifierKind> allQualifierKinds() {\n+        return qualifierKinds;\n+    }\n+\n+    @Override\n+    public @Nullable QualifierKind getQualifierKind(String name) {\n+        return nameToQualifierKind.get(name);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(Collection<Class<? extends Annotation>> qualifierClasses) {\n+        this(qualifierClasses, null);\n+    }\n+\n+    /**\n+     * Creates a {@link DefaultQualifierKindHierarchy}. Also, creates and initializes all its\n+     * qualifier kinds.\n+     *\n+     * <p>For some type systems, qualifiers may be added at run time, so the {@link SubtypeOf}\n+     * meta-annotation on the bottom qualifier class cannot specify all other qualifiers. For those\n+     * type systems, use this constructor. Otherwise, use the other constructor.\n+     *\n+     * @param qualifierClasses all the classes of qualifiers supported by this hierarchy\n+     * @param bottom the bottom qualifier of this hierarchy\n+     */\n+    public DefaultQualifierKindHierarchy(\n+            Collection<Class<? extends Annotation>> qualifierClasses,\n+            @Nullable Class<? extends Annotation> bottom) {\n+        this.nameToQualifierKind = createQualifierKinds(qualifierClasses);\n+        this.qualifierKinds = new ArrayList<>(nameToQualifierKind.values());\n+        Collections.sort(qualifierKinds);\n+\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap =\n+                createDirectSuperMap();\n+        setBottom(bottom, directSuperMap);\n+        this.tops = createTopsSet(directSuperMap);\n+        this.bottoms = createBottomsSet(directSuperMap);\n+        initializePolymorphicQualifiers();\n+        initializeQualifierKindFields(directSuperMap);\n+        this.lubs = createLubsMap();\n+        this.glbs = createGlbsMap();\n+\n+        verifyHierarchy(directSuperMap);\n+    }\n+\n+    /**\n+     * Verifies that the {@link DefaultQualifierKindHierarchy} is a valid hierarchy.\n+     *\n+     * @param directSuperMap mapping from qualifier to its direct supertypes; used to verify that a\n+     *     polymorphic annotation does not have a {@link SubtypeOf} meta-annotation\n+     * @throws TypeSystemError if the hierarchy isn't valid\n+     */\n+    @RequiresNonNull({\"this.qualifierKinds\", \"this.tops\", \"this.bottoms\"})\n+    protected void verifyHierarchy(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            boolean isPoly = qualifierKind.isPoly();\n+            boolean hasSubtypeOfAnno = directSuperMap.containsKey(qualifierKind);\n+            if (isPoly && hasSubtypeOfAnno) {\n+                // Polymorphic qualifiers with upper and lower bounds are currently not supported.\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: \"\n+                                + qualifierKind\n+                                + \" is polymorphic and specifies super qualifiers.%n\"\n+                                + \"Remove the @PolymorphicQualifier or @SubtypeOf annotation from it.\");\n+            } else if (!isPoly && !hasSubtypeOfAnno) {\n+                throw new TypeSystemError(\n+                        \"AnnotatedTypeFactory: %s does not specify its super qualifiers.%n\"\n+                                + \"Add an @SubtypeOf or @PolymorphicQualifier annotation to it,%n\"\n+                                + \"or if it is an alias, exclude it from `createSupportedTypeQualifiers()`.\",\n+                        qualifierKind);\n+            } else if (isPoly) {\n+                if (qualifierKind.top == null) {\n+                    throw new TypeSystemError(\n+                            \"PolymorphicQualifier, %s, has to specify a type hierarchy in its @PolymorphicQualifier meta-annotation, if more than one exists; top types: [%s].\",\n+                            qualifierKind, UtilPlume.join(\", \", tops));\n+                } else if (!tops.contains(qualifierKind.top)) {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s has invalid top %s. Top qualifiers: %s\",\n+                            qualifierKind, qualifierKind.top, UtilPlume.join(\", \", tops));\n+                }\n+            }\n+        }\n+\n+        if (bottoms.size() != tops.size()) {\n+            throw new TypeSystemError(\n+                    \"Number of tops not equal to number of bottoms: Tops: [%s] Bottoms: [%s]\",\n+                    UtilPlume.join(\", \", tops), UtilPlume.join(\", \", bottoms));\n+        }\n+    }\n+\n+    /**\n+     * Creates all QualifierKind objects for the given qualifier classes and adds them to\n+     * qualifierClassMap. This method does not initialize all fields in the {@link QualifierKind};\n+     * that is done by {@link #initializeQualifierKindFields(Map)}.\n+     *\n+     * @param qualifierClasses classes of annotations that are type qualifiers\n+     * @return a mapping from the canonical name of an annotation class to {@link QualifierKind}\n+     */\n+    protected Map<@Interned String, DefaultQualifierKind> createQualifierKinds(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        TreeMap<@Interned String, DefaultQualifierKind> nameToQualifierKind = new TreeMap<>();\n+        for (Class<? extends Annotation> clazz : qualifierClasses) {\n+            @SuppressWarnings(\"interning\") // uniqueness is tested immediately below\n+            @Interned DefaultQualifierKind qualifierKind = new DefaultQualifierKind(clazz);\n+            if (nameToQualifierKind.containsKey(qualifierKind.getName())) {\n+                throw new TypeSystemError(\"Duplicate QualifierKind \" + qualifierKind.getName());\n+            }\n+            nameToQualifierKind.put(qualifierKind.getName(), qualifierKind);\n+        }\n+        return Collections.unmodifiableMap(nameToQualifierKind);\n+    }\n+\n+    /**\n+     * Creates a mapping from a {@link QualifierKind} to a set of its direct super qualifier kinds.\n+     * The direct super qualifier kinds do not contain the qualifier itself. This mapping is used by\n+     * {@link #createBottomsSet(Map)}, {@link #createTopsSet(Map)}, and {@link\n+     * #initializeQualifierKindFields(Map)}.\n+     *\n+     * <p>This implementation uses the {@link SubtypeOf} meta-annotation. Subclasses may override\n+     * this method to create the direct super map some other way.\n+     *\n+     * <p>Note that this method is called from the constructor when only {@link\n+     * #nameToQualifierKind} has been initialized. This method is not static, so it can be\n+     * overridden by subclasses.\n+     *\n+     * @return a mapping from each {@link QualifierKind} to a set of its direct super qualifiers\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\"})\n+    protected Map<DefaultQualifierKind, Set<DefaultQualifierKind>> createDirectSuperMap(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap = new TreeMap<>();\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            SubtypeOf subtypeOfMetaAnno =\n+                    qualifierKind.getAnnotationClass().getAnnotation(SubtypeOf.class);\n+            if (subtypeOfMetaAnno == null) {\n+                continue;\n+            }\n+            Set<DefaultQualifierKind> directSupers = new TreeSet<>();\n+            for (Class<? extends Annotation> superClazz : subtypeOfMetaAnno.value()) {\n+                String superName = QualifierKindHierarchy.annotationClassName(superClazz);\n+                DefaultQualifierKind superQualifier = nameToQualifierKind.get(superName);\n+                if (superQualifier == null) {\n+                    throw new TypeSystemError(\n+                            \"%s @Subtype argument %s isn't in the hierarchy. Qualifiers: [%s]\",\n+                            qualifierKind, superName, UtilPlume.join(\", \", qualifierKinds));\n+                }\n+                directSupers.add(superQualifier);\n+            }\n+            directSuperMap.put(qualifierKind, directSupers);\n+        }\n+        return directSuperMap;\n+    }\n+\n+    /**\n+     * If {@code bottom} is non-null, then this method sets bottom to the given class and modifies\n+     * {@code directSuperMap} to add all leaves to its super qualifier kinds. Leaves are qualifier\n+     * kinds that are not super qualifier kinds of another qualifier kind.\n+     *\n+     * <p>If {@code bottom} is {@code null}, then this method does nothing.\n+     *\n+     * @param bottom the class of the bottom qualifer in the hierarchy\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifiers; side-effected by this method\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\"})\n+    private void setBottom(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            @Nullable Class<? extends Annotation> bottom,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        if (bottom == null) {\n+            return;\n+        }\n+        DefaultQualifierKind bottomKind =\n+                nameToQualifierKind.get(QualifierKindHierarchy.annotationClassName(bottom));\n+        if (bottomKind == null) {\n+            throw new TypeSystemError(\n+                    \"QualifierKindHierarchy#setBottom: the given bottom class, %s, is not in the hierarchy.\",\n+                    bottom.getCanonicalName());\n+        }\n+\n+        Set<DefaultQualifierKind> currentLeaves = new TreeSet<>(qualifierKinds);\n+        currentLeaves.remove(bottomKind);\n+        directSuperMap.forEach((sub, supers) -> currentLeaves.removeAll(supers));\n+        Set<DefaultQualifierKind> bottomDirectSuperQuals = directSuperMap.get(bottomKind);\n+        if (bottomDirectSuperQuals == null) {\n+            directSuperMap.put(bottomKind, currentLeaves);\n+        } else {\n+            bottomDirectSuperQuals.addAll(currentLeaves);\n+        }\n+    }\n+\n+    /**\n+     * Creates the set of top {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifier kinds without any direct super qualifier kinds.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of top {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap to change the tops and not this method,\n+    // because other methods expect the directSuperMap to be complete.\n+    private Set<DefaultQualifierKind> createTopsSet(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Set<DefaultQualifierKind> tops = new TreeSet<>();\n+        directSuperMap.forEach(\n+                (qualifierKind, superQuals) -> {\n+                    if (superQuals.isEmpty()) {\n+                        tops.add(qualifierKind);\n+                    }\n+                });\n+        return tops;\n+    }\n+\n+    /**\n+     * Creates the set of bottom {@link QualifierKind}s by searching {@code directSuperMap} for\n+     * qualifiers that are not a direct super qualifier kind of another qualifier kind.\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     * @return the set of bottom {@link QualifierKind}s\n+     */\n+    // Subclasses should override createDirectSuperMap or specifyBottom to change the bottoms and\n+    // not this method, because other methods expect the directSuperMap to be complete.\n+    private Set<DefaultQualifierKind> createBottomsSet(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Set<DefaultQualifierKind> bottoms = new HashSet<>(directSuperMap.keySet());\n+        for (Set<DefaultQualifierKind> superKinds : directSuperMap.values()) {\n+            bottoms.removeAll(superKinds);\n+        }\n+        return bottoms;\n+    }\n+\n+    /**\n+     * Iterates over all the qualifier kinds and adds all polymorphic qualifier kinds to\n+     * polymorphicQualifiers. Also sets {@link DefaultQualifierKind#poly} and {@link\n+     * DefaultQualifierKind#top} for the polymorphic qualifiers. Set {@link\n+     * DefaultQualifierKind#poly} for the top qualifiers.\n+     *\n+     * <p>Requires that tops has been initialized.\n+     */\n+    @RequiresNonNull({\"this.nameToQualifierKind\", \"this.qualifierKinds\", \"this.tops\"})\n+    protected void initializePolymorphicQualifiers(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            Class<? extends Annotation> clazz = qualifierKind.getAnnotationClass();\n+            PolymorphicQualifier polyMetaAnno = clazz.getAnnotation(PolymorphicQualifier.class);\n+            if (polyMetaAnno == null) {\n+                continue;\n+            }\n+            qualifierKind.poly = qualifierKind;\n+            String topName = QualifierKindHierarchy.annotationClassName(polyMetaAnno.value());\n+            if (nameToQualifierKind.containsKey(topName)) {\n+                qualifierKind.top = nameToQualifierKind.get(topName);\n+            } else if (topName.equals(Annotation.class.getCanonicalName())) {\n+                // Annotation.class is the default value of PolymorphicQualifier. If it is used,\n+                // then there must be exactly one top.\n+                if (tops.size() == 1) {\n+                    qualifierKind.top = tops.iterator().next();\n+                } else {\n+                    throw new TypeSystemError(\n+                            \"Polymorphic qualifier %s did not specify a top annotation class. Tops: [%s]\",\n+                            qualifierKind, UtilPlume.join(\", \", tops));\n+                }\n+            } else {\n+                throw new TypeSystemError(\n+                        \"Polymorphic qualifier %s's top, %s, is not a qualifier.\",\n+                        qualifierKind, topName);\n+            }\n+            qualifierKind.strictSuperTypes = Collections.singleton(qualifierKind.top);\n+            qualifierKind.top.poly = qualifierKind;\n+        }\n+    }\n+\n+    /**\n+     * For each qualifier kind in {@code directSuperMap}, initializes {@link\n+     * DefaultQualifierKind#strictSuperTypes}, {@link DefaultQualifierKind#top}, {@link\n+     * DefaultQualifierKind#bottom}, and {@link DefaultQualifierKind#poly}. (Requires tops, bottoms,\n+     * and polymorphicQualifiers to be initialized.)\n+     *\n+     * @param directSuperMap a mapping from a {@link QualifierKind} to a set of its direct super\n+     *     qualifier kinds; created by {@link #createDirectSuperMap()}\n+     */\n+    @RequiresNonNull({\"this.qualifierKinds\", \"this.tops\", \"this.bottoms\"})\n+    protected void initializeQualifierKindFields(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        for (DefaultQualifierKind qualifierKind : directSuperMap.keySet()) {\n+            if (!qualifierKind.isPoly()) {\n+                qualifierKind.strictSuperTypes = findAllTheSupers(qualifierKind, directSuperMap);\n+            }\n+        }\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            for (DefaultQualifierKind top : tops) {\n+                if (qualifierKind.isSubtype(top)) {\n+                    if (qualifierKind.top == null) {\n+                        qualifierKind.top = top;\n+                    } else if (qualifierKind.top != top) {\n+                        throw new TypeSystemError(\n+                                \"Multiple tops found for qualifier %s. Tops: %s and %s.\",\n+                                qualifierKind, top, qualifierKind.top);\n+                    }\n+                }\n+            }\n+            if (qualifierKind.top == null) {\n+                throw new TypeSystemError(\n+                        \"Qualifier %s isn't a subtype of any top. tops = %s\", qualifierKind, tops);\n+            }\n+            qualifierKind.poly = qualifierKind.top.poly;\n+        }\n+        for (DefaultQualifierKind qualifierKind : qualifierKinds) {\n+            for (DefaultQualifierKind bot : bottoms) {\n+                if (bot.top != qualifierKind.top) {\n+                    continue;\n+                }\n+                if (qualifierKind.bottom == null) {\n+                    qualifierKind.bottom = bot;\n+                } else if (qualifierKind.top != bot) {\n+                    throw new TypeSystemError(\n+                            \"Multiple bottoms found for qualifier %s. Bottoms: %s and %s.\",\n+                            qualifierKind, bot, qualifierKind.bottom);\n+                }\n+                if (qualifierKind.isPoly()) {\n+                    assert bot.strictSuperTypes != null\n+                            : \"@AssumeAssertion(nullness):strictSuperTypes should be nonnull.\";\n+                    bot.strictSuperTypes.add(qualifierKind);\n+                }\n+            }\n+            if (qualifierKind.bottom == null) {\n+                throw new TypeSystemError(\n+                        \"Cannot find a bottom qualifier for %s. bottoms = %s\",\n+                        qualifierKind, bottoms);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the set of all qualifier kinds that are a strict supertype of {@code qualifierKind}.\n+     *\n+     * @param qualifierKind the qualifier kind whose super types should be returned\n+     * @param directSuperMap directSuperMap\n+     * @return the set of all qualifier kinds that are a strict supertype of {@code qualifierKind}\n+     */\n+    private Set<QualifierKind> findAllTheSupers(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            @KeyFor(\"#2\") QualifierKind qualifierKind,\n+            Map<DefaultQualifierKind, Set<DefaultQualifierKind>> directSuperMap) {\n+        Queue<DefaultQualifierKind> queue = new ArrayDeque<>(directSuperMap.get(qualifierKind));\n+        Set<QualifierKind> allSupers = new TreeSet<>(directSuperMap.get(qualifierKind));\n+        Set<DefaultQualifierKind> visited = new HashSet<>();\n+        while (!queue.isEmpty()) {\n+            DefaultQualifierKind superQualKind = queue.remove();\n+            if (superQualKind == qualifierKind) {\n+                throw new TypeSystemError(\"Cycle in hierarchy: %s\", qualifierKind);\n+            }\n+            if (visited.contains(superQualKind)) {\n+                continue;\n+            }\n+            visited.add(superQualKind);\n+            if (superQualKind.isPoly()) {\n+                continue;\n+            }\n+            if (directSuperMap.containsKey(superQualKind)) {\n+                Set<DefaultQualifierKind> superSuperQuals = directSuperMap.get(superQualKind);\n+                queue.addAll(superSuperQuals);\n+                allSupers.addAll(superSuperQuals);\n+            } else {\n+                throw new TypeSystemError(\n+                        \"Found a super qualifier kind not a key in the directSuperMap. Found: %s\",\n+                        superQualKind);\n+            }\n+        }\n+        return allSupers;\n+    }\n+\n+    /**\n+     * Creates the lub of qualifier kinds. {@code lubs.get(kind1).get(kind2)} returns the lub of\n+     * kind1 and kind2.\n+     *\n+     * @return a mapping of lubs\n+     */\n+    @RequiresNonNull(\"this.qualifierKinds\")\n+    protected Map<QualifierKind, Map<QualifierKind, QualifierKind>> createLubsMap(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        Map<QualifierKind, Map<QualifierKind, QualifierKind>> lubs = new HashMap<>();\n+        for (QualifierKind qual1 : qualifierKinds) {\n+            for (QualifierKind qual2 : qualifierKinds) {\n+                if (qual1.getTop() != qual2.getTop()) {\n+                    continue;\n+                }\n+                QualifierKind lub = findLub(qual1, qual2);\n+                addToMapOfMap(lubs, qual1, qual2, lub, \"lub\");\n+                addToMapOfMap(lubs, qual2, qual1, lub, \"lub\");\n+            }\n+        }\n+        return lubs;\n+    }\n+\n+    /**\n+     * Returns the least upper bound of {@code qual1} and {@code qual2}.\n+     *\n+     * @param qual1 a qualifier kind\n+     * @param qual2 a qualifier kind\n+     * @return the least upper bound of {@code qual1} and {@code qual2}\n+     */\n+    private QualifierKind findLub(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            QualifierKind qual1,\n+            QualifierKind qual2) {\n+        if (qual1 == qual2) {\n+            return qual1;\n+        } else if (qual1.isSubtype(qual2)) {\n+            return qual2;\n+        } else if (qual2.isSubtype(qual1)) {\n+            return qual1;\n+        }\n+        // strictSuperTypes should be nonnull by this point.\n+        @SuppressWarnings(\"nullness:argument.type.incompatible\")\n+        Set<QualifierKind> allSuperTypes = new TreeSet<>(qual1.getStrictSuperTypes());\n+        // strictSuperTypes should be nonnull by this point.\n+        @SuppressWarnings(\"nullness:assignment.type.incompatible\")\n+        @NonNull Set<? extends QualifierKind> qual2StrictSuperTypes = qual2.getStrictSuperTypes();\n+        allSuperTypes.retainAll(qual2StrictSuperTypes);\n+        Set<? extends QualifierKind> lubs = findLowestQualifiers(allSuperTypes);\n+        if (lubs.size() != 1) {\n+            throw new TypeSystemError(\n+                    \"Not exactly 1 lub for %s and %s. Found lubs: [%s].\",\n+                    qual1, qual2, UtilPlume.join(\", \", lubs));\n+        }\n+        QualifierKind lub = lubs.iterator().next();\n+        if (lub.isPoly() && !qual1.isPoly() && !qual2.isPoly()) {\n+            throw new TypeSystemError(\n+                    \"Lub can't be poly: lub: %s, qual1: %s, qual2: %s.\", lub, qual1, qual2);\n+        }\n+        return lub;\n+    }\n+\n+    /**\n+     * Returns the lowest qualifiers in the passed set.\n+     *\n+     * @param qualifierKinds a set of qualifiers\n+     * @return the lowest qualifiers in the passed set\n+     */\n+    protected static Set<QualifierKind> findLowestQualifiers(Set<QualifierKind> qualifierKinds) {\n+        Set<QualifierKind> lowestQualifiers = new TreeSet<>(qualifierKinds);\n+        for (QualifierKind a1 : qualifierKinds) {\n+            lowestQualifiers.removeIf(a2 -> a1 != a2 && a1.isSubtype(a2));\n+        }\n+        return lowestQualifiers;\n+    }\n+\n+    /**\n+     * Creates the glb of qualifier kinds. {@code glbs.get(kind1).get(kind2)} returns the glb of\n+     * kind1 and kind2.\n+     *\n+     * @return a mapping of glb\n+     */\n+    @RequiresNonNull(\"this.qualifierKinds\")\n+    protected Map<QualifierKind, Map<QualifierKind, QualifierKind>> createGlbsMap(\n+            @UnderInitialization DefaultQualifierKindHierarchy this) {\n+        Map<QualifierKind, Map<QualifierKind, QualifierKind>> glbs = new TreeMap<>();\n+        for (QualifierKind qual1 : qualifierKinds) {\n+            for (QualifierKind qual2 : qualifierKinds) {\n+                if (qual1.getTop() != qual2.getTop()) {\n+                    continue;\n+                }\n+                QualifierKind glb = findGlb(qual1, qual2);\n+                addToMapOfMap(glbs, qual1, qual2, glb, \"glb\");\n+                addToMapOfMap(glbs, qual2, qual1, glb, \"glb\");\n+            }\n+        }\n+        return glbs;\n+    }\n+\n+    /**\n+     * Returns the greatest lower bound of {@code qual1} and {@code qual2}.\n+     *\n+     * @param qual1 a qualifier kind\n+     * @param qual2 a qualifier kind\n+     * @return the greatest lower bound of {@code qual1} and {@code qual2}\n+     */\n+    @RequiresNonNull(\"this.qualifierKinds\")\n+    private QualifierKind findGlb(\n+            @UnderInitialization DefaultQualifierKindHierarchy this,\n+            QualifierKind qual1,\n+            QualifierKind qual2) {\n+        if (qual1 == qual2) {\n+            return qual1;\n+        } else if (qual1.isSubtype(qual2)) {\n+            return qual1;\n+        } else if (qual2.isSubtype(qual1)) {\n+            return qual2;\n+        }\n+        Set<QualifierKind> allSubTypes = new TreeSet<>();\n+        for (QualifierKind qualifierKind : qualifierKinds) {\n+            if (qualifierKind.isSubtype(qual1) && qualifierKind.isSubtype(qual2)) {\n+                allSubTypes.add(qualifierKind);\n+            }\n+        }\n+        Set<QualifierKind> glbs = findHighestQualifiers(allSubTypes);\n+        if (glbs.size() != 1) {\n+            throw new TypeSystemError(\n+                    \"Not exactly 1 glb for %s and %s. Found glbs: [%s].\",\n+                    qual1, qual2, UtilPlume.join(\", \", glbs));\n+        }\n+        QualifierKind glb = glbs.iterator().next();\n+        if (glb.isPoly() && !qual1.isPoly() && !qual2.isPoly()) {\n+            throw new TypeSystemError(\n+                    \"GLB can't be poly: lub: %s, qual1: %s, qual2: %s.\", glb, qual1, qual2);\n+        }\n+        return glb;\n+    }\n+\n+    /**\n+     * Returns the highest qualifiers in the passed set.\n+     *\n+     * @param qualifierKinds a set of qualifiers\n+     * @return the highest qualifiers in the passed set\n+     */\n+    protected static Set<QualifierKind> findHighestQualifiers(Set<QualifierKind> qualifierKinds) {\n+        Set<QualifierKind> lowestQualifiers = new TreeSet<>(qualifierKinds);\n+        for (QualifierKind a1 : qualifierKinds) {\n+            lowestQualifiers.removeIf(a2 -> a1 != a2 && a2.isSubtype(a1));\n+        }\n+        return lowestQualifiers;\n+    }\n+\n+    /**\n+     * Add Key: qual1, Value: (Key: qual2, Value: value) to {@code map}. If already in map, throw an\n+     * exception if value is different.\n+     *\n+     * @param map mapping\n+     * @param qual1 the first qualifier kind\n+     * @param qual2 the second qualifier kind\n+     * @param value the value to add\n+     * @param error \"lub\" or \"glb\"; used only for error messages\n+     */\n+    private static void addToMapOfMap(\n+            Map<QualifierKind, Map<QualifierKind, QualifierKind>> map,\n+            QualifierKind qual1,\n+            QualifierKind qual2,\n+            QualifierKind value,\n+            String error) {\n+        Map<QualifierKind, QualifierKind> qual1Map =\n+                map.computeIfAbsent(qual1, k -> new HashMap<>());\n+        QualifierKind existingValue = qual1Map.get(qual2);\n+        if (existingValue == null) {\n+            qual1Map.put(qual2, value);\n+        } else {\n+            if (existingValue != value) {\n+                throw new TypeSystemError(\n+                        \"Multiple %s for qualifiers %s and %s. Found map %s and %s\",\n+                        error, qual1, qual2, value, existingValue);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * The default implementation of {@link QualifierKind}.\n+     *\n+     * <p>The fields in this class that refer to {@link QualifierKind}s are initialized by {@link\n+     * DefaultQualifierKindHierarchy}. So the getter methods for these fields should not be called\n+     * until after {@code DefaultQualifierKindHierarchy} is initialized.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 674}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDIxNzMyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithElements.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzo0MTo0MlrOHFI1JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzo0MTo0MlrOHFI1JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE0OTYwNQ==", "bodyText": "How about a comment here such as\n// The following fields duplicate information in qualifierKindHierarchy, but using AnnotationMirrors instead of QualifierKinds.\n\n?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475149605", "createdAt": "2020-08-22T23:41:42Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithElements.java", "diffHunk": "@@ -0,0 +1,230 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>For cases where the annotations have no elements, the {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} meta-annotation is used.\n+ *\n+ * <p>QualifierHierarchyWithElements uses a {@link QualifierKindHierarchy} to model the\n+ * relationships between qualifiers. Subclasses can override {@link\n+ * #createQualifierKindHierarchy(Collection)} to return a subclass of QualifierKindHierarchy.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public abstract class QualifierHierarchyWithElements implements QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils} */\n+    private Elements elements;\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDIxODYwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithElements.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzo0NDoxM1rOHFI1vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzo0NDoxM1rOHFI1vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE0OTc1OA==", "bodyText": "The following 3 lines are used repeatedly.  How about adding an override of AnnotationUtils.createAnnotationSet() that takes a collection (or more likely an iterable) as an argument and returns an unmodifiable set?  Then you can use it here and elsewhere.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475149758", "createdAt": "2020-08-22T23:44:13Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithElements.java", "diffHunk": "@@ -0,0 +1,230 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>For cases where the annotations have no elements, the {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} meta-annotation is used.\n+ *\n+ * <p>QualifierHierarchyWithElements uses a {@link QualifierKindHierarchy} to model the\n+ * relationships between qualifiers. Subclasses can override {@link\n+ * #createQualifierKindHierarchy(Collection)} to return a subclass of QualifierKindHierarchy.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public abstract class QualifierHierarchyWithElements implements QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils} */\n+    private Elements elements;\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** A mapping from top QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> topsMap;\n+\n+    /** The set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** A mapping from bottom QualifierKinds to their corresponding AnnotationMirror. */\n+    protected final Map<QualifierKind, AnnotationMirror> bottomsMap;\n+\n+    /** The set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /**\n+     * A mapping from QualifierKind to AnnotationMirror for all qualifiers whose annotations do not\n+     * have elements.\n+     */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToElementLessQualifier;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses class of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    protected QualifierHierarchyWithElements(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.elements = elements;\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.topsMap = Collections.unmodifiableMap(createTopsMap());\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDIyMTA5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithoutElements.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzo0ODo0NlrOHFI22A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzo0ODo0NlrOHFI22A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1MDA0MA==", "bodyText": "I am curious why this does not use qualifierKindHierarchy.getTops().  The implementation in QualifierHierarchyWithElements does so and it would be good to keep the implementations in sync to the extent possible.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475150040", "createdAt": "2020-08-22T23:48:46Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithoutElements.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where no qualifier has arguments; that is, no qualifier is\n+ * represented by an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the subtyping relationships.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierHierarchyWithoutElements implements QualifierHierarchy {\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** Set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** Set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /** Mapping from {@link QualifierKind} to its corresponding {@link AnnotationMirror}. */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;\n+\n+    /** Set of all annotations in all the hierarchies. */\n+    protected final Set<? extends AnnotationMirror> qualifiers;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    public QualifierHierarchyWithoutElements(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.kindToAnnotationMirror = createAnnotationMirrors(elements);\n+        Set<AnnotationMirror> qualifiers = AnnotationUtils.createAnnotationSet();\n+        qualifiers.addAll(kindToAnnotationMirror.values());\n+        this.qualifiers = Collections.unmodifiableSet(qualifiers);\n+\n+        this.tops = createTops();\n+        this.bottoms = createBottoms();\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            @UnderInitialization QualifierHierarchyWithoutElements this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new DefaultQualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates and returns a mapping from qualifier kind to an annotation mirror created from the\n+     * qualifier kind's annotation class.\n+     *\n+     * @param elements element utils\n+     * @return a mapping from qualifier kind to its annotation mirror\n+     */\n+    @RequiresNonNull(\"this.qualifierKindHierarchy\")\n+    protected Map<QualifierKind, AnnotationMirror> createAnnotationMirrors(\n+            @UnderInitialization QualifierHierarchyWithoutElements this, Elements elements) {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (kind.hasElements()) {\n+                throw new TypeSystemError(\n+                        \"QualifierHierarchyWithoutElements cannot be used with annotations that have elements. Found %s: \",\n+                        kind);\n+            }\n+            quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of top {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of top {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createTops(\n+            @UnderInitialization QualifierHierarchyWithoutElements this) {\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDIyMTU4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithoutElements.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzo0OTozMVrOHFI3Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzo0OTozMVrOHFI3Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1MDA5OA==", "bodyText": "Why doesn't this use qualifierKindHierarchy.getBottoms()?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475150098", "createdAt": "2020-08-22T23:49:31Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithoutElements.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where no qualifier has arguments; that is, no qualifier is\n+ * represented by an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the subtyping relationships.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierHierarchyWithoutElements implements QualifierHierarchy {\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** Set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** Set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /** Mapping from {@link QualifierKind} to its corresponding {@link AnnotationMirror}. */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;\n+\n+    /** Set of all annotations in all the hierarchies. */\n+    protected final Set<? extends AnnotationMirror> qualifiers;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    public QualifierHierarchyWithoutElements(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.kindToAnnotationMirror = createAnnotationMirrors(elements);\n+        Set<AnnotationMirror> qualifiers = AnnotationUtils.createAnnotationSet();\n+        qualifiers.addAll(kindToAnnotationMirror.values());\n+        this.qualifiers = Collections.unmodifiableSet(qualifiers);\n+\n+        this.tops = createTops();\n+        this.bottoms = createBottoms();\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            @UnderInitialization QualifierHierarchyWithoutElements this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new DefaultQualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates and returns a mapping from qualifier kind to an annotation mirror created from the\n+     * qualifier kind's annotation class.\n+     *\n+     * @param elements element utils\n+     * @return a mapping from qualifier kind to its annotation mirror\n+     */\n+    @RequiresNonNull(\"this.qualifierKindHierarchy\")\n+    protected Map<QualifierKind, AnnotationMirror> createAnnotationMirrors(\n+            @UnderInitialization QualifierHierarchyWithoutElements this, Elements elements) {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (kind.hasElements()) {\n+                throw new TypeSystemError(\n+                        \"QualifierHierarchyWithoutElements cannot be used with annotations that have elements. Found %s: \",\n+                        kind);\n+            }\n+            quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of top {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of top {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createTops(\n+            @UnderInitialization QualifierHierarchyWithoutElements this) {\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isTop()) {\n+                tops.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(tops);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of bottom {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of bottom {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createBottoms(\n+            @UnderInitialization QualifierHierarchyWithoutElements this) {\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDIyNjYzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithoutElements.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzo1ODozMVrOHFI5WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMzo1ODozMVrOHFI5WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1MDY4MQ==", "bodyText": "It was slightly confusing that the following two methods appear in the opposite order in this file as they do in the superclass QualifierHierarchy.\nIt would also be nice to document (probably in QualifierHierarchy why both methods exist.  There are only two implementations of each method, and in each case one of the methods delegates to the other.  The naming seems arbitrary -- at least, the difference in names does not convey to me the difference in semantics, and I fear other programmers will be equally confused about which method they should use in a particular circumstance.  So clarifying that for clients would be helpful too.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475150681", "createdAt": "2020-08-22T23:58:31Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithoutElements.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where no qualifier has arguments; that is, no qualifier is\n+ * represented by an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the subtyping relationships.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierHierarchyWithoutElements implements QualifierHierarchy {\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** Set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** Set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /** Mapping from {@link QualifierKind} to its corresponding {@link AnnotationMirror}. */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;\n+\n+    /** Set of all annotations in all the hierarchies. */\n+    protected final Set<? extends AnnotationMirror> qualifiers;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    public QualifierHierarchyWithoutElements(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.kindToAnnotationMirror = createAnnotationMirrors(elements);\n+        Set<AnnotationMirror> qualifiers = AnnotationUtils.createAnnotationSet();\n+        qualifiers.addAll(kindToAnnotationMirror.values());\n+        this.qualifiers = Collections.unmodifiableSet(qualifiers);\n+\n+        this.tops = createTops();\n+        this.bottoms = createBottoms();\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            @UnderInitialization QualifierHierarchyWithoutElements this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new DefaultQualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates and returns a mapping from qualifier kind to an annotation mirror created from the\n+     * qualifier kind's annotation class.\n+     *\n+     * @param elements element utils\n+     * @return a mapping from qualifier kind to its annotation mirror\n+     */\n+    @RequiresNonNull(\"this.qualifierKindHierarchy\")\n+    protected Map<QualifierKind, AnnotationMirror> createAnnotationMirrors(\n+            @UnderInitialization QualifierHierarchyWithoutElements this, Elements elements) {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (kind.hasElements()) {\n+                throw new TypeSystemError(\n+                        \"QualifierHierarchyWithoutElements cannot be used with annotations that have elements. Found %s: \",\n+                        kind);\n+            }\n+            quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of top {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of top {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createTops(\n+            @UnderInitialization QualifierHierarchyWithoutElements this) {\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isTop()) {\n+                tops.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(tops);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of bottom {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of bottom {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createBottoms(\n+            @UnderInitialization QualifierHierarchyWithoutElements this) {\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isBottom()) {\n+                bottoms.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(bottoms);\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation.\n+     *\n+     * @param anno an annotation that is a qualifier in this\n+     * @return the {@code QualifierKind}\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"Annotation not in hierarchy: %s\", anno);\n+        }\n+        return kind;\n+    }\n+\n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDIyODE1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithoutElements.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMDowMDo0NlrOHFI6DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxOTo1OToyNlrOHGno_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1MDg2MA==", "bodyText": "This if statement isn't actually needed.  (Or, are you leaving it in as a matter of style?)\nSame comment applies to the following method.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475150860", "createdAt": "2020-08-23T00:00:46Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithoutElements.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where no qualifier has arguments; that is, no qualifier is\n+ * represented by an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the subtyping relationships.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierHierarchyWithoutElements implements QualifierHierarchy {\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** Set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** Set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /** Mapping from {@link QualifierKind} to its corresponding {@link AnnotationMirror}. */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;\n+\n+    /** Set of all annotations in all the hierarchies. */\n+    protected final Set<? extends AnnotationMirror> qualifiers;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    public QualifierHierarchyWithoutElements(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.kindToAnnotationMirror = createAnnotationMirrors(elements);\n+        Set<AnnotationMirror> qualifiers = AnnotationUtils.createAnnotationSet();\n+        qualifiers.addAll(kindToAnnotationMirror.values());\n+        this.qualifiers = Collections.unmodifiableSet(qualifiers);\n+\n+        this.tops = createTops();\n+        this.bottoms = createBottoms();\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            @UnderInitialization QualifierHierarchyWithoutElements this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new DefaultQualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates and returns a mapping from qualifier kind to an annotation mirror created from the\n+     * qualifier kind's annotation class.\n+     *\n+     * @param elements element utils\n+     * @return a mapping from qualifier kind to its annotation mirror\n+     */\n+    @RequiresNonNull(\"this.qualifierKindHierarchy\")\n+    protected Map<QualifierKind, AnnotationMirror> createAnnotationMirrors(\n+            @UnderInitialization QualifierHierarchyWithoutElements this, Elements elements) {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (kind.hasElements()) {\n+                throw new TypeSystemError(\n+                        \"QualifierHierarchyWithoutElements cannot be used with annotations that have elements. Found %s: \",\n+                        kind);\n+            }\n+            quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of top {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of top {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createTops(\n+            @UnderInitialization QualifierHierarchyWithoutElements this) {\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isTop()) {\n+                tops.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(tops);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of bottom {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of bottom {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createBottoms(\n+            @UnderInitialization QualifierHierarchyWithoutElements this) {\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isBottom()) {\n+                bottoms.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(bottoms);\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation.\n+     *\n+     * @param anno an annotation that is a qualifier in this\n+     * @return the {@code QualifierKind}\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"Annotation not in hierarchy: %s\", anno);\n+        }\n+        return kind;\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror findAnnotationInHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror top) {\n+        return findAnnotationInSameHierarchy(annos, top);\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {\n+        QualifierKind kind = getQualifierKind(annotationMirror);\n+        for (AnnotationMirror candidate : annos) {\n+            QualifierKind candidateKind = getQualifierKind(candidate);\n+            if (candidateKind.isInSameHierarchyAs(kind)) {\n+                return candidate;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getTopAnnotations() {\n+        return tops;\n+    }\n+\n+    @Override\n+    // Every QualifierKind is a key in kindToAnnotationMirror.\n+    @SuppressWarnings(\"nullness:return.type.incompatible\")\n+    public AnnotationMirror getTopAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return kindToAnnotationMirror.get(kind.getTop());\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getBottomAnnotations() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    // Every QualifierKind is a key in kindToAnnotationMirror.\n+    @SuppressWarnings(\"nullness:return.type.incompatible\")\n+    public AnnotationMirror getBottomAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return kindToAnnotationMirror.get(kind.getBottom());\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror getPolymorphicAnnotation(AnnotationMirror start) {\n+        QualifierKind poly = getQualifierKind(start).getPolymorphic();\n+        if (poly == null) {\n+            return null;\n+        }\n+        return kindToAnnotationMirror.get(poly);\n+    }\n+\n+    @Override\n+    public boolean isPolymorphicQualifier(AnnotationMirror qualifier) {\n+        return getQualifierKind(qualifier).isPoly();\n+    }\n+\n+    @Override\n+    public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        QualifierKind subKind = getQualifierKind(subAnno);\n+        QualifierKind superKind = getQualifierKind(superAnno);\n+        return subKind.isSubtype(superKind);\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2) {\n+        QualifierKind qual1 = getQualifierKind(a1);\n+        QualifierKind qual2 = getQualifierKind(a2);\n+\n+        QualifierKind lub = qualifierKindHierarchy.leastUpperBound(qual1, qual2);\n+        if (lub == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3MDA3MQ==", "bodyText": "qualifierKindHierarchy.leastUpperBound(qual1, qual2) returns null if the qualifier kinds are not in the same hierarchy. For example, qual1 is @NonNull and qual2 is @Initialized.  (So the if statement is required.)", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475870071", "createdAt": "2020-08-24T20:19:41Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithoutElements.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where no qualifier has arguments; that is, no qualifier is\n+ * represented by an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the subtyping relationships.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierHierarchyWithoutElements implements QualifierHierarchy {\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** Set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** Set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /** Mapping from {@link QualifierKind} to its corresponding {@link AnnotationMirror}. */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;\n+\n+    /** Set of all annotations in all the hierarchies. */\n+    protected final Set<? extends AnnotationMirror> qualifiers;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    public QualifierHierarchyWithoutElements(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.kindToAnnotationMirror = createAnnotationMirrors(elements);\n+        Set<AnnotationMirror> qualifiers = AnnotationUtils.createAnnotationSet();\n+        qualifiers.addAll(kindToAnnotationMirror.values());\n+        this.qualifiers = Collections.unmodifiableSet(qualifiers);\n+\n+        this.tops = createTops();\n+        this.bottoms = createBottoms();\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            @UnderInitialization QualifierHierarchyWithoutElements this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new DefaultQualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates and returns a mapping from qualifier kind to an annotation mirror created from the\n+     * qualifier kind's annotation class.\n+     *\n+     * @param elements element utils\n+     * @return a mapping from qualifier kind to its annotation mirror\n+     */\n+    @RequiresNonNull(\"this.qualifierKindHierarchy\")\n+    protected Map<QualifierKind, AnnotationMirror> createAnnotationMirrors(\n+            @UnderInitialization QualifierHierarchyWithoutElements this, Elements elements) {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (kind.hasElements()) {\n+                throw new TypeSystemError(\n+                        \"QualifierHierarchyWithoutElements cannot be used with annotations that have elements. Found %s: \",\n+                        kind);\n+            }\n+            quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of top {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of top {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createTops(\n+            @UnderInitialization QualifierHierarchyWithoutElements this) {\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isTop()) {\n+                tops.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(tops);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of bottom {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of bottom {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createBottoms(\n+            @UnderInitialization QualifierHierarchyWithoutElements this) {\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isBottom()) {\n+                bottoms.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(bottoms);\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation.\n+     *\n+     * @param anno an annotation that is a qualifier in this\n+     * @return the {@code QualifierKind}\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"Annotation not in hierarchy: %s\", anno);\n+        }\n+        return kind;\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror findAnnotationInHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror top) {\n+        return findAnnotationInSameHierarchy(annos, top);\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {\n+        QualifierKind kind = getQualifierKind(annotationMirror);\n+        for (AnnotationMirror candidate : annos) {\n+            QualifierKind candidateKind = getQualifierKind(candidate);\n+            if (candidateKind.isInSameHierarchyAs(kind)) {\n+                return candidate;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getTopAnnotations() {\n+        return tops;\n+    }\n+\n+    @Override\n+    // Every QualifierKind is a key in kindToAnnotationMirror.\n+    @SuppressWarnings(\"nullness:return.type.incompatible\")\n+    public AnnotationMirror getTopAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return kindToAnnotationMirror.get(kind.getTop());\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getBottomAnnotations() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    // Every QualifierKind is a key in kindToAnnotationMirror.\n+    @SuppressWarnings(\"nullness:return.type.incompatible\")\n+    public AnnotationMirror getBottomAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return kindToAnnotationMirror.get(kind.getBottom());\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror getPolymorphicAnnotation(AnnotationMirror start) {\n+        QualifierKind poly = getQualifierKind(start).getPolymorphic();\n+        if (poly == null) {\n+            return null;\n+        }\n+        return kindToAnnotationMirror.get(poly);\n+    }\n+\n+    @Override\n+    public boolean isPolymorphicQualifier(AnnotationMirror qualifier) {\n+        return getQualifierKind(qualifier).isPoly();\n+    }\n+\n+    @Override\n+    public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        QualifierKind subKind = getQualifierKind(subAnno);\n+        QualifierKind superKind = getQualifierKind(superAnno);\n+        return subKind.isSubtype(superKind);\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2) {\n+        QualifierKind qual1 = getQualifierKind(a1);\n+        QualifierKind qual2 = getQualifierKind(a2);\n+\n+        QualifierKind lub = qualifierKindHierarchy.leastUpperBound(qual1, qual2);\n+        if (lub == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1MDg2MA=="}, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU0MzEzNw==", "bodyText": "I agree that lub may be null.\nMy point is that kindToAnnotationMirror.get(lub) evaluates to null if lub is null, so the code will behave the same if this if statement is removed.\nI'm OK with leaving it in if you prefer it as a matter of style.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r476543137", "createdAt": "2020-08-25T15:34:51Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithoutElements.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where no qualifier has arguments; that is, no qualifier is\n+ * represented by an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the subtyping relationships.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierHierarchyWithoutElements implements QualifierHierarchy {\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** Set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** Set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /** Mapping from {@link QualifierKind} to its corresponding {@link AnnotationMirror}. */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;\n+\n+    /** Set of all annotations in all the hierarchies. */\n+    protected final Set<? extends AnnotationMirror> qualifiers;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    public QualifierHierarchyWithoutElements(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.kindToAnnotationMirror = createAnnotationMirrors(elements);\n+        Set<AnnotationMirror> qualifiers = AnnotationUtils.createAnnotationSet();\n+        qualifiers.addAll(kindToAnnotationMirror.values());\n+        this.qualifiers = Collections.unmodifiableSet(qualifiers);\n+\n+        this.tops = createTops();\n+        this.bottoms = createBottoms();\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            @UnderInitialization QualifierHierarchyWithoutElements this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new DefaultQualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates and returns a mapping from qualifier kind to an annotation mirror created from the\n+     * qualifier kind's annotation class.\n+     *\n+     * @param elements element utils\n+     * @return a mapping from qualifier kind to its annotation mirror\n+     */\n+    @RequiresNonNull(\"this.qualifierKindHierarchy\")\n+    protected Map<QualifierKind, AnnotationMirror> createAnnotationMirrors(\n+            @UnderInitialization QualifierHierarchyWithoutElements this, Elements elements) {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (kind.hasElements()) {\n+                throw new TypeSystemError(\n+                        \"QualifierHierarchyWithoutElements cannot be used with annotations that have elements. Found %s: \",\n+                        kind);\n+            }\n+            quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of top {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of top {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createTops(\n+            @UnderInitialization QualifierHierarchyWithoutElements this) {\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isTop()) {\n+                tops.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(tops);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of bottom {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of bottom {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createBottoms(\n+            @UnderInitialization QualifierHierarchyWithoutElements this) {\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isBottom()) {\n+                bottoms.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(bottoms);\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation.\n+     *\n+     * @param anno an annotation that is a qualifier in this\n+     * @return the {@code QualifierKind}\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"Annotation not in hierarchy: %s\", anno);\n+        }\n+        return kind;\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror findAnnotationInHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror top) {\n+        return findAnnotationInSameHierarchy(annos, top);\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {\n+        QualifierKind kind = getQualifierKind(annotationMirror);\n+        for (AnnotationMirror candidate : annos) {\n+            QualifierKind candidateKind = getQualifierKind(candidate);\n+            if (candidateKind.isInSameHierarchyAs(kind)) {\n+                return candidate;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getTopAnnotations() {\n+        return tops;\n+    }\n+\n+    @Override\n+    // Every QualifierKind is a key in kindToAnnotationMirror.\n+    @SuppressWarnings(\"nullness:return.type.incompatible\")\n+    public AnnotationMirror getTopAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return kindToAnnotationMirror.get(kind.getTop());\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getBottomAnnotations() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    // Every QualifierKind is a key in kindToAnnotationMirror.\n+    @SuppressWarnings(\"nullness:return.type.incompatible\")\n+    public AnnotationMirror getBottomAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return kindToAnnotationMirror.get(kind.getBottom());\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror getPolymorphicAnnotation(AnnotationMirror start) {\n+        QualifierKind poly = getQualifierKind(start).getPolymorphic();\n+        if (poly == null) {\n+            return null;\n+        }\n+        return kindToAnnotationMirror.get(poly);\n+    }\n+\n+    @Override\n+    public boolean isPolymorphicQualifier(AnnotationMirror qualifier) {\n+        return getQualifierKind(qualifier).isPoly();\n+    }\n+\n+    @Override\n+    public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        QualifierKind subKind = getQualifierKind(subAnno);\n+        QualifierKind superKind = getQualifierKind(superAnno);\n+        return subKind.isSubtype(superKind);\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2) {\n+        QualifierKind qual1 = getQualifierKind(a1);\n+        QualifierKind qual2 = getQualifierKind(a2);\n+\n+        QualifierKind lub = qualifierKindHierarchy.leastUpperBound(qual1, qual2);\n+        if (lub == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1MDg2MA=="}, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2OTU3OA==", "bodyText": "My point is that kindToAnnotationMirror.get(lub) evaluates to null if lub is null, so the code will behave the same if this if statement is removed.\n\nkindToAnnotationMirror will throw a NullPointerException if get is called with a null argument.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r476569578", "createdAt": "2020-08-25T16:13:23Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithoutElements.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where no qualifier has arguments; that is, no qualifier is\n+ * represented by an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the subtyping relationships.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierHierarchyWithoutElements implements QualifierHierarchy {\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** Set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** Set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /** Mapping from {@link QualifierKind} to its corresponding {@link AnnotationMirror}. */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;\n+\n+    /** Set of all annotations in all the hierarchies. */\n+    protected final Set<? extends AnnotationMirror> qualifiers;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    public QualifierHierarchyWithoutElements(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.kindToAnnotationMirror = createAnnotationMirrors(elements);\n+        Set<AnnotationMirror> qualifiers = AnnotationUtils.createAnnotationSet();\n+        qualifiers.addAll(kindToAnnotationMirror.values());\n+        this.qualifiers = Collections.unmodifiableSet(qualifiers);\n+\n+        this.tops = createTops();\n+        this.bottoms = createBottoms();\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            @UnderInitialization QualifierHierarchyWithoutElements this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new DefaultQualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates and returns a mapping from qualifier kind to an annotation mirror created from the\n+     * qualifier kind's annotation class.\n+     *\n+     * @param elements element utils\n+     * @return a mapping from qualifier kind to its annotation mirror\n+     */\n+    @RequiresNonNull(\"this.qualifierKindHierarchy\")\n+    protected Map<QualifierKind, AnnotationMirror> createAnnotationMirrors(\n+            @UnderInitialization QualifierHierarchyWithoutElements this, Elements elements) {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (kind.hasElements()) {\n+                throw new TypeSystemError(\n+                        \"QualifierHierarchyWithoutElements cannot be used with annotations that have elements. Found %s: \",\n+                        kind);\n+            }\n+            quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of top {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of top {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createTops(\n+            @UnderInitialization QualifierHierarchyWithoutElements this) {\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isTop()) {\n+                tops.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(tops);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of bottom {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of bottom {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createBottoms(\n+            @UnderInitialization QualifierHierarchyWithoutElements this) {\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isBottom()) {\n+                bottoms.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(bottoms);\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation.\n+     *\n+     * @param anno an annotation that is a qualifier in this\n+     * @return the {@code QualifierKind}\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"Annotation not in hierarchy: %s\", anno);\n+        }\n+        return kind;\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror findAnnotationInHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror top) {\n+        return findAnnotationInSameHierarchy(annos, top);\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {\n+        QualifierKind kind = getQualifierKind(annotationMirror);\n+        for (AnnotationMirror candidate : annos) {\n+            QualifierKind candidateKind = getQualifierKind(candidate);\n+            if (candidateKind.isInSameHierarchyAs(kind)) {\n+                return candidate;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getTopAnnotations() {\n+        return tops;\n+    }\n+\n+    @Override\n+    // Every QualifierKind is a key in kindToAnnotationMirror.\n+    @SuppressWarnings(\"nullness:return.type.incompatible\")\n+    public AnnotationMirror getTopAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return kindToAnnotationMirror.get(kind.getTop());\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getBottomAnnotations() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    // Every QualifierKind is a key in kindToAnnotationMirror.\n+    @SuppressWarnings(\"nullness:return.type.incompatible\")\n+    public AnnotationMirror getBottomAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return kindToAnnotationMirror.get(kind.getBottom());\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror getPolymorphicAnnotation(AnnotationMirror start) {\n+        QualifierKind poly = getQualifierKind(start).getPolymorphic();\n+        if (poly == null) {\n+            return null;\n+        }\n+        return kindToAnnotationMirror.get(poly);\n+    }\n+\n+    @Override\n+    public boolean isPolymorphicQualifier(AnnotationMirror qualifier) {\n+        return getQualifierKind(qualifier).isPoly();\n+    }\n+\n+    @Override\n+    public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        QualifierKind subKind = getQualifierKind(subAnno);\n+        QualifierKind superKind = getQualifierKind(superAnno);\n+        return subKind.isSubtype(superKind);\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2) {\n+        QualifierKind qual1 = getQualifierKind(a1);\n+        QualifierKind qual2 = getQualifierKind(a2);\n+\n+        QualifierKind lub = qualifierKindHierarchy.leastUpperBound(qual1, qual2);\n+        if (lub == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1MDg2MA=="}, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcwMjk3Mg==", "bodyText": "OK.  Thanks for clarifying my misunderstanding.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r476702972", "createdAt": "2020-08-25T19:59:26Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithoutElements.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where no qualifier has arguments; that is, no qualifier is\n+ * represented by an annotation with elements. The meta-annotation {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} specifies the subtyping relationships.\n+ *\n+ * <p>It uses a {@link QualifierKindHierarchy} to model the relationships between qualifiers.\n+ * Subclasses can override {@link #createQualifierKindHierarchy(Collection)} to return a subclass of\n+ * QualifierKindHierarchy.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public class QualifierHierarchyWithoutElements implements QualifierHierarchy {\n+\n+    /** {@link QualifierKindHierarchy}. */\n+    protected final QualifierKindHierarchy qualifierKindHierarchy;\n+\n+    /** Set of top annotation mirrors. */\n+    protected final Set<AnnotationMirror> tops;\n+\n+    /** Set of bottom annotation mirrors. */\n+    protected final Set<AnnotationMirror> bottoms;\n+\n+    /** Mapping from {@link QualifierKind} to its corresponding {@link AnnotationMirror}. */\n+    protected final Map<QualifierKind, AnnotationMirror> kindToAnnotationMirror;\n+\n+    /** Set of all annotations in all the hierarchies. */\n+    protected final Set<? extends AnnotationMirror> qualifiers;\n+\n+    /**\n+     * Creates a QualifierHierarchy from the given classes.\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @param elements element utils\n+     */\n+    public QualifierHierarchyWithoutElements(\n+            Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+        this.qualifierKindHierarchy = createQualifierKindHierarchy(qualifierClasses);\n+\n+        this.kindToAnnotationMirror = createAnnotationMirrors(elements);\n+        Set<AnnotationMirror> qualifiers = AnnotationUtils.createAnnotationSet();\n+        qualifiers.addAll(kindToAnnotationMirror.values());\n+        this.qualifiers = Collections.unmodifiableSet(qualifiers);\n+\n+        this.tops = createTops();\n+        this.bottoms = createBottoms();\n+    }\n+\n+    /**\n+     * Create the {@link QualifierKindHierarchy}. (Subclasses may override to return a subclass of\n+     * QualifierKindHierarchy.)\n+     *\n+     * @param qualifierClasses classes of annotations that are the qualifiers\n+     * @return the newly created qualifier kind hierarchy\n+     */\n+    protected QualifierKindHierarchy createQualifierKindHierarchy(\n+            @UnderInitialization QualifierHierarchyWithoutElements this,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        return new DefaultQualifierKindHierarchy(qualifierClasses);\n+    }\n+\n+    /**\n+     * Creates and returns a mapping from qualifier kind to an annotation mirror created from the\n+     * qualifier kind's annotation class.\n+     *\n+     * @param elements element utils\n+     * @return a mapping from qualifier kind to its annotation mirror\n+     */\n+    @RequiresNonNull(\"this.qualifierKindHierarchy\")\n+    protected Map<QualifierKind, AnnotationMirror> createAnnotationMirrors(\n+            @UnderInitialization QualifierHierarchyWithoutElements this, Elements elements) {\n+        Map<QualifierKind, AnnotationMirror> quals = new TreeMap<>();\n+        for (QualifierKind kind : qualifierKindHierarchy.allQualifierKinds()) {\n+            if (kind.hasElements()) {\n+                throw new TypeSystemError(\n+                        \"QualifierHierarchyWithoutElements cannot be used with annotations that have elements. Found %s: \",\n+                        kind);\n+            }\n+            quals.put(kind, AnnotationBuilder.fromClass(elements, kind.getAnnotationClass()));\n+        }\n+        return Collections.unmodifiableMap(quals);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of top {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of top {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createTops(\n+            @UnderInitialization QualifierHierarchyWithoutElements this) {\n+        Set<AnnotationMirror> tops = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isTop()) {\n+                tops.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(tops);\n+    }\n+\n+    /**\n+     * Creates and returns the unmodifiable set of bottom {@link AnnotationMirror}s.\n+     *\n+     * @return the unmodifiable set of bottom {@link AnnotationMirror}s\n+     */\n+    @RequiresNonNull(\"this.kindToAnnotationMirror\")\n+    protected Set<AnnotationMirror> createBottoms(\n+            @UnderInitialization QualifierHierarchyWithoutElements this) {\n+        Set<AnnotationMirror> bottoms = AnnotationUtils.createAnnotationSet();\n+        for (Map.Entry<QualifierKind, AnnotationMirror> entry : kindToAnnotationMirror.entrySet()) {\n+            if (entry.getKey().isBottom()) {\n+                bottoms.add(entry.getValue());\n+            }\n+        }\n+        return Collections.unmodifiableSet(bottoms);\n+    }\n+\n+    /**\n+     * Returns the {@link QualifierKind} for the given annotation.\n+     *\n+     * @param anno an annotation that is a qualifier in this\n+     * @return the {@code QualifierKind}\n+     */\n+    protected QualifierKind getQualifierKind(AnnotationMirror anno) {\n+        String name = AnnotationUtils.annotationName(anno);\n+        QualifierKind kind = qualifierKindHierarchy.getQualifierKind(name);\n+        if (kind == null) {\n+            throw new BugInCF(\"Annotation not in hierarchy: %s\", anno);\n+        }\n+        return kind;\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror findAnnotationInHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror top) {\n+        return findAnnotationInSameHierarchy(annos, top);\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror findAnnotationInSameHierarchy(\n+            Collection<? extends AnnotationMirror> annos, AnnotationMirror annotationMirror) {\n+        QualifierKind kind = getQualifierKind(annotationMirror);\n+        for (AnnotationMirror candidate : annos) {\n+            QualifierKind candidateKind = getQualifierKind(candidate);\n+            if (candidateKind.isInSameHierarchyAs(kind)) {\n+                return candidate;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getTopAnnotations() {\n+        return tops;\n+    }\n+\n+    @Override\n+    // Every QualifierKind is a key in kindToAnnotationMirror.\n+    @SuppressWarnings(\"nullness:return.type.incompatible\")\n+    public AnnotationMirror getTopAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return kindToAnnotationMirror.get(kind.getTop());\n+    }\n+\n+    @Override\n+    public Set<? extends AnnotationMirror> getBottomAnnotations() {\n+        return bottoms;\n+    }\n+\n+    @Override\n+    // Every QualifierKind is a key in kindToAnnotationMirror.\n+    @SuppressWarnings(\"nullness:return.type.incompatible\")\n+    public AnnotationMirror getBottomAnnotation(AnnotationMirror start) {\n+        QualifierKind kind = getQualifierKind(start);\n+        return kindToAnnotationMirror.get(kind.getBottom());\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror getPolymorphicAnnotation(AnnotationMirror start) {\n+        QualifierKind poly = getQualifierKind(start).getPolymorphic();\n+        if (poly == null) {\n+            return null;\n+        }\n+        return kindToAnnotationMirror.get(poly);\n+    }\n+\n+    @Override\n+    public boolean isPolymorphicQualifier(AnnotationMirror qualifier) {\n+        return getQualifierKind(qualifier).isPoly();\n+    }\n+\n+    @Override\n+    public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        QualifierKind subKind = getQualifierKind(subAnno);\n+        QualifierKind superKind = getQualifierKind(superAnno);\n+        return subKind.isSubtype(superKind);\n+    }\n+\n+    @Override\n+    public @Nullable AnnotationMirror leastUpperBound(AnnotationMirror a1, AnnotationMirror a2) {\n+        QualifierKind qual1 = getQualifierKind(a1);\n+        QualifierKind qual2 = getQualifierKind(a2);\n+\n+        QualifierKind lub = qualifierKindHierarchy.leastUpperBound(qual1, qual2);\n+        if (lub == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1MDg2MA=="}, "originalCommit": {"oid": "ac5cc418e7217eff12d4b389e7e6e2e354e7947c"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDIzMTQyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyMostlyWithoutElements.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMDowNjoxNVrOHFI7fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMDoyMToyMVrOHJTaRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1MTIzMA==", "bodyText": "Does it have to be \"most\"?  I think there are benefits if at least two (maybe at least one?) qualifiers have no elements/arguments.  Can you be more specific about when this class should be used?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475151230", "createdAt": "2020-08-23T00:06:15Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyMostlyWithoutElements.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+\n+/**\n+ * A {@link QualifierHierarchy} where qualifiers may be represented by annotations with elements,\n+ * but most of the qualifiers do not have elements. In contrast to {@link", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe2ac1771e2e885784e2a4318587591596d92b0a"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxNzI1Mw==", "bodyText": "I don't really have any more specific advice.  When I was convert all of the MultiGraphHierarchy subclass to one of the new classes, I only used this class when all but 1 or 2 qualifiers have elements.  Otherwise, it was easier to use QualifierHierarchyWithElements and write out all cases.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r479517253", "createdAt": "2020-08-28T20:21:21Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyMostlyWithoutElements.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+\n+/**\n+ * A {@link QualifierHierarchy} where qualifiers may be represented by annotations with elements,\n+ * but most of the qualifiers do not have elements. In contrast to {@link", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1MTIzMA=="}, "originalCommit": {"oid": "fe2ac1771e2e885784e2a4318587591596d92b0a"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDI2ODc2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithElements.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMToxMDozOFrOHFJL_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMDoyMjo0NFrOHJTcVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1NTQ1Mw==", "bodyText": "The following fields, and some code, is duplicated or nearly so in the three QualifierHierarchy*.java implementations of the QualifierHierarchy interface.  I wonder whether it would make sense to create an abstract base class to avoid the code duplication.\nThis would reduce overall code duplication but would make it necessary to look at two classes (the abstract base class and its subclass) rather than one, to understand any particular implementation.  So, I am torn about this, but slightly inclined.  What do you think?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475155453", "createdAt": "2020-08-23T01:10:38Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithElements.java", "diffHunk": "@@ -0,0 +1,230 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>For cases where the annotations have no elements, the {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} meta-annotation is used.\n+ *\n+ * <p>QualifierHierarchyWithElements uses a {@link QualifierKindHierarchy} to model the\n+ * relationships between qualifiers. Subclasses can override {@link\n+ * #createQualifierKindHierarchy(Collection)} to return a subclass of QualifierKindHierarchy.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public abstract class QualifierHierarchyWithElements implements QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils}. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75064a73459074d90521fb73de0611a7678e1971"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTUxNzc4Mw==", "bodyText": "I think it's better to keep them separate.  In the past, we had many bugs where we assumed that qualifiers did not have elements, but they did.  If we have a single abstract class, we might make the same mistakes again.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r479517783", "createdAt": "2020-08-28T20:22:44Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/QualifierHierarchyWithElements.java", "diffHunk": "@@ -0,0 +1,230 @@\n+package org.checkerframework.framework.util;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n+import org.checkerframework.checker.initialization.qual.UnderInitialization;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.checker.nullness.qual.RequiresNonNull;\n+import org.checkerframework.framework.qual.AnnotatedFor;\n+import org.checkerframework.framework.type.QualifierHierarchy;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypeSystemError;\n+\n+/**\n+ * A {@link QualifierHierarchy} where qualifiers may be represented by annotations with elements.\n+ *\n+ * <p>For cases where the annotations have no elements, the {@link\n+ * org.checkerframework.framework.qual.SubtypeOf} meta-annotation is used.\n+ *\n+ * <p>QualifierHierarchyWithElements uses a {@link QualifierKindHierarchy} to model the\n+ * relationships between qualifiers. Subclasses can override {@link\n+ * #createQualifierKindHierarchy(Collection)} to return a subclass of QualifierKindHierarchy.\n+ */\n+@AnnotatedFor(\"nullness\")\n+public abstract class QualifierHierarchyWithElements implements QualifierHierarchy {\n+\n+    /** {@link org.checkerframework.javacutil.ElementUtils}. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE1NTQ1Mw=="}, "originalCommit": {"oid": "75064a73459074d90521fb73de0611a7678e1971"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDMzNTQxOnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/nullness/NullnessAnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMzowMzoyNVrOHFJpjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxODoxNTo1MVrOHGkLaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE2MzAyMw==", "bodyText": "Should the two isInSameHierarchy calls always return the same value?  Or is it OK if they return different values?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475163023", "createdAt": "2020-08-23T03:03:25Z", "author": {"login": "mernst"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/NullnessAnnotatedTypeFactory.java", "diffHunk": "@@ -577,30 +578,59 @@ protected boolean hasFieldInvariantAnnotation(\n     }\n \n     @Override\n-    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n-        return new NullnessQualifierHierarchy(factory, (Object[]) null);\n+    public QualifierHierarchy createQualifierHierarchy() {\n+        return new NullnessQualifierHierarchy();\n     }\n \n+    /** NullnessQualifierHierarchy */\n     protected class NullnessQualifierHierarchy extends InitializationQualifierHierarchy {\n \n-        public NullnessQualifierHierarchy(MultiGraphFactory f, Object[] arg) {\n-            super(f, arg);\n+        /** Qualifier kind for {@link Nullable} annotation. */\n+        private final QualifierKind NULLABLE;\n+\n+        /** Creates NullnessQualifierHierarchy. */\n+        public NullnessQualifierHierarchy() {\n+            super();\n+            NULLABLE = getQualifierKind(NullnessAnnotatedTypeFactory.this.NULLABLE);\n+        }\n+\n+        @Override\n+        protected boolean isSubtypeWithElements(\n+                AnnotationMirror subAnno,\n+                QualifierKind subKind,\n+                AnnotationMirror superAnno,\n+                QualifierKind superKind) {\n+            if (!subKind.isInSameHierarchyAs(NULLABLE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75064a73459074d90521fb73de0611a7678e1971"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY0NjI0OA==", "bodyText": "isSubtypeWithElements is only called when the subKind is a sub qualifier kind of superKind. (I just added that fact to the documentation.)  So the calls never return the different values.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r476646248", "createdAt": "2020-08-25T18:15:51Z", "author": {"login": "smillst"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/NullnessAnnotatedTypeFactory.java", "diffHunk": "@@ -577,30 +578,59 @@ protected boolean hasFieldInvariantAnnotation(\n     }\n \n     @Override\n-    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n-        return new NullnessQualifierHierarchy(factory, (Object[]) null);\n+    public QualifierHierarchy createQualifierHierarchy() {\n+        return new NullnessQualifierHierarchy();\n     }\n \n+    /** NullnessQualifierHierarchy */\n     protected class NullnessQualifierHierarchy extends InitializationQualifierHierarchy {\n \n-        public NullnessQualifierHierarchy(MultiGraphFactory f, Object[] arg) {\n-            super(f, arg);\n+        /** Qualifier kind for {@link Nullable} annotation. */\n+        private final QualifierKind NULLABLE;\n+\n+        /** Creates NullnessQualifierHierarchy. */\n+        public NullnessQualifierHierarchy() {\n+            super();\n+            NULLABLE = getQualifierKind(NullnessAnnotatedTypeFactory.this.NULLABLE);\n+        }\n+\n+        @Override\n+        protected boolean isSubtypeWithElements(\n+                AnnotationMirror subAnno,\n+                QualifierKind subKind,\n+                AnnotationMirror superAnno,\n+                QualifierKind superKind) {\n+            if (!subKind.isInSameHierarchyAs(NULLABLE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE2MzAyMw=="}, "originalCommit": {"oid": "75064a73459074d90521fb73de0611a7678e1971"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDM0MDQxOnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/regex/RegexAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMzoxMjowMFrOHFJrwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMzoxMjowMFrOHFJrwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE2MzU4Ng==", "bodyText": "I find the comparison style that puts a constant on the lhs and a variable on the rhs looks funny.\nThat is, I dislike \"if (4 == x || 5 == x)\" and I prefer \"if (x == 4 || x == 5)\".  I don't have a great reason for my preference, except that is the way that we speak in English.  Is there a reason that you chose this order of arguments to ==?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475163586", "createdAt": "2020-08-23T03:12:00Z", "author": {"login": "mernst"}, "path": "checker/src/main/java/org/checkerframework/checker/regex/RegexAnnotatedTypeFactory.java", "diffHunk": "@@ -163,35 +169,95 @@ public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n      * subtype of {@code @Regex(1)}. All regex annotations are subtypes of {@code @Regex}, which has\n      * a default value of 0.\n      */\n-    private final class RegexQualifierHierarchy extends GraphQualifierHierarchy {\n+    private final class RegexQualifierHierarchy extends QualifierHierarchyMostlyWithoutElements {\n \n-        public RegexQualifierHierarchy(MultiGraphFactory f, AnnotationMirror bottom) {\n-            super(f, bottom);\n+        /** Regex Qualifier Kind. */\n+        private final QualifierKind REGEX_KIND;\n+        /** PartialRegex Qualifier Kind. */\n+        private final QualifierKind PARTIALREGEX_KIND;\n+        /**\n+         * Creates a RegexQualifierHierarchy from the given classes.\n+         *\n+         * @param qualifierClasses classes of annotations that are the qualifiers for this hierarchy\n+         * @param elements element utils\n+         */\n+        private RegexQualifierHierarchy(\n+                Collection<Class<? extends Annotation>> qualifierClasses, Elements elements) {\n+            super(qualifierClasses, elements);\n+            REGEX_KIND = getQualifierKind(REGEX);\n+            PARTIALREGEX_KIND = getQualifierKind(PARTIALREGEX);\n         }\n \n         @Override\n-        public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n-            if (AnnotationUtils.areSameByName(subAnno, REGEX)\n-                    && AnnotationUtils.areSameByName(superAnno, REGEX)) {\n+        protected boolean isSubtypeWithElements(\n+                AnnotationMirror subAnno,\n+                QualifierKind subKind,\n+                AnnotationMirror superAnno,\n+                QualifierKind superKind) {\n+            if (REGEX_KIND == subKind && REGEX_KIND == superKind) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75064a73459074d90521fb73de0611a7678e1971"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDM0NTYzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/value/ValueQualifierHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMzoyMToxOVrOHFJuIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMzoyMToxOVrOHFJuIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE2NDE5NQ==", "bodyText": "This is clever, but it is also surprising.  I would prefer to use a more straightforward coding pattern even if it is a bit more verbose.\nThe more verbose version will also probably be more efficient, because it can use two identity comparisons on interned strings.  The switch version always creates a new string, computes its hash code, and goes through every character if the hash code matches one of the cases -- none of which is necessary with the more verbose version.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475164195", "createdAt": "2020-08-23T03:21:19Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/value/ValueQualifierHierarchy.java", "diffHunk": "@@ -1,94 +1,147 @@\n package org.checkerframework.common.value;\n \n+import java.lang.annotation.Annotation;\n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.List;\n import java.util.TreeSet;\n import javax.lang.model.element.AnnotationMirror;\n import org.checkerframework.common.value.util.Range;\n-import org.checkerframework.framework.util.MultiGraphQualifierHierarchy;\n+import org.checkerframework.framework.util.QualifierHierarchyWithElements;\n import org.checkerframework.javacutil.AnnotationBuilder;\n import org.checkerframework.javacutil.AnnotationUtils;\n \n /** The qualifier hierarchy for the Value type system. */\n-final class ValueQualifierHierarchy extends MultiGraphQualifierHierarchy {\n+final class ValueQualifierHierarchy extends QualifierHierarchyWithElements {\n \n     /** The type factory to use. */\n-    final ValueAnnotatedTypeFactory atypeFactory;\n+    private final ValueAnnotatedTypeFactory atypeFactory;\n \n-    /** @param factory the MultiGraphFactory to use to construct this */\n-    public ValueQualifierHierarchy(\n-            MultiGraphFactory factory, ValueAnnotatedTypeFactory atypeFactory) {\n-        super(factory);\n+    /**\n+     * Creates a ValueQualifierHierarchy from the given classes.\n+     *\n+     * @param atypeFactory ValueAnnotatedTypeFactory\n+     * @param qualifierClasses classes of annotations that are the qualifiers for this hierarchy\n+     */\n+    ValueQualifierHierarchy(\n+            ValueAnnotatedTypeFactory atypeFactory,\n+            Collection<Class<? extends Annotation>> qualifierClasses) {\n+        super(qualifierClasses, atypeFactory.getElementUtils());\n         this.atypeFactory = atypeFactory;\n     }\n \n     /**\n-     * Computes greatest lower bound of a @StringVal annotation with another value checker\n-     * annotation.\n+     * Computes subtyping as per the subtyping in the qualifier hierarchy structure unless both\n+     * annotations are Value. In this case, subAnno is a subtype of superAnno iff superAnno contains\n+     * at least every element of subAnno.\n      *\n-     * @param stringValAnno annotation of type @StringVal\n-     * @param otherAnno annotation from the value checker hierarchy\n-     * @return greatest lower bound of {@code stringValAnno} and {@code otherAnno}\n+     * @return true if subAnno is a subtype of superAnno, false otherwise\n      */\n-    private AnnotationMirror glbOfStringVal(\n-            AnnotationMirror stringValAnno, AnnotationMirror otherAnno) {\n-        List<String> values = ValueAnnotatedTypeFactory.getStringValues(stringValAnno);\n-        switch (AnnotationUtils.annotationName(otherAnno)) {\n-            case ValueAnnotatedTypeFactory.STRINGVAL_NAME:\n-                // Intersection of value lists\n-                List<String> otherValues = ValueAnnotatedTypeFactory.getStringValues(otherAnno);\n-                values.retainAll(otherValues);\n-                break;\n-            case ValueAnnotatedTypeFactory.ARRAYLEN_NAME:\n-                // Retain strings of correct lengths\n-                List<Integer> otherLengths = ValueAnnotatedTypeFactory.getArrayLength(otherAnno);\n-                ArrayList<String> result = new ArrayList<>();\n-                for (String s : values) {\n-                    if (otherLengths.contains(s.length())) {\n-                        result.add(s);\n+    @Override\n+    public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n+        subAnno = atypeFactory.convertSpecialIntRangeToStandardIntRange(subAnno);\n+        superAnno = atypeFactory.convertSpecialIntRangeToStandardIntRange(superAnno);\n+        String subQual = AnnotationUtils.annotationName(subAnno);\n+        if (subQual.equals(ValueAnnotatedTypeFactory.UNKNOWN_NAME)) {\n+            superAnno = atypeFactory.convertToUnknown(superAnno);\n+        }\n+        String superQual = AnnotationUtils.annotationName(superAnno);\n+        if (superQual.equals(ValueAnnotatedTypeFactory.UNKNOWN_NAME)\n+                || subQual.equals(ValueAnnotatedTypeFactory.BOTTOMVAL_NAME)) {\n+            return true;\n+        } else if (superQual.equals(ValueAnnotatedTypeFactory.BOTTOMVAL_NAME)\n+                || subQual.equals(ValueAnnotatedTypeFactory.UNKNOWN_NAME)) {\n+            return false;\n+        } else if (superQual.equals(ValueAnnotatedTypeFactory.POLY_NAME)) {\n+            return subQual.equals(ValueAnnotatedTypeFactory.POLY_NAME);\n+        } else if (subQual.equals(ValueAnnotatedTypeFactory.POLY_NAME)) {\n+            return false;\n+        } else if (superQual.equals(subQual)) {\n+            // Same type, so might be subtype\n+            if (subQual.equals(ValueAnnotatedTypeFactory.INTRANGE_NAME)\n+                    || subQual.equals(ValueAnnotatedTypeFactory.ARRAYLENRANGE_NAME)) {\n+                // Special case for range-based annotations\n+                Range superRange = ValueAnnotatedTypeFactory.getRange(superAnno);\n+                Range subRange = ValueAnnotatedTypeFactory.getRange(subAnno);\n+                return superRange.contains(subRange);\n+            } else {\n+                List<Object> superValues =\n+                        AnnotationUtils.getElementValueArray(\n+                                superAnno, \"value\", Object.class, true);\n+                List<Object> subValues =\n+                        AnnotationUtils.getElementValueArray(subAnno, \"value\", Object.class, true);\n+                return superValues.containsAll(subValues);\n+            }\n+        }\n+        switch (superQual + subQual) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75064a73459074d90521fb73de0611a7678e1971"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDM0OTg4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMzoyODoxMlrOHFJwCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMzoyODoxMlrOHFJwCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE2NDY4Mw==", "bodyText": "Or QualifierHierarchyMostlyWithoutElements?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475164683", "createdAt": "2020-08-23T03:28:12Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -773,11 +681,32 @@ protected static QualifierHierarchy createQualifierHierarchy(\n      * @return the {@link QualifierHierarchy} for this checker\n      */\n     public final QualifierHierarchy getQualifierHierarchy() {\n-        // if (qualHierarchy == null)\n-        //    qualHierarchy = createQualifierHierarchy();\n         return qualHierarchy;\n     }\n \n+    /**\n+     * To continue to use a subclass of {@link\n+     * org.checkerframework.framework.util.MultiGraphQualifierHierarchy} or {@link\n+     * org.checkerframework.framework.util.GraphQualifierHierarchy}, override this method so that it\n+     * returns a new instance of the subclass. Then override {@link #createQualifierHierarchy()} so\n+     * that it returns the result of a call to {@link\n+     * org.checkerframework.framework.util.MultiGraphQualifierHierarchy#createMultiGraphQualifierHierarchy(AnnotatedTypeFactory)}.\n+     *\n+     * @param factory MultiGraphFactory\n+     * @return QualifierHierarchy\n+     * @deprecated Use either {@link\n+     *     org.checkerframework.framework.util.QualifierHierarchyWithElements} or {@link\n+     *     QualifierHierarchyWithoutElements} instead. This method will be removed in a future", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75064a73459074d90521fb73de0611a7678e1971"}, "originalPosition": 173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDM1MjE1OnYy", "diffSide": "RIGHT", "path": "framework/src/test/java/testlib/util/FlowTestAnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMzozMTo0OVrOHFJxEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMDo0MDowM1rOHF1czg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE2NDk0NA==", "bodyText": "It is bad style to use Unqualified as the top annotation.  Can we create a new annotation to use here instead of using Unqualified.class?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475164944", "createdAt": "2020-08-23T03:31:49Z", "author": {"login": "mernst"}, "path": "framework/src/test/java/testlib/util/FlowTestAnnotatedTypeFactory.java", "diffHunk": "@@ -2,37 +2,42 @@\n \n import java.lang.annotation.Annotation;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.HashSet;\n import java.util.Set;\n import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n import org.checkerframework.common.basetype.BaseTypeChecker;\n import org.checkerframework.common.subtyping.qual.Bottom;\n import org.checkerframework.common.subtyping.qual.Unqualified;\n import org.checkerframework.framework.qual.TypeUseLocation;\n import org.checkerframework.framework.type.QualifierHierarchy;\n-import org.checkerframework.framework.util.GraphQualifierHierarchy;\n-import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.framework.util.DefaultQualifierKindHierarchy;\n+import org.checkerframework.framework.util.QualifierHierarchyMostlyWithoutElements;\n+import org.checkerframework.framework.util.QualifierKind;\n+import org.checkerframework.framework.util.QualifierKindHierarchy;\n import org.checkerframework.framework.util.defaults.QualifierDefaults;\n import org.checkerframework.javacutil.AnnotationBuilder;\n import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n \n public class FlowTestAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n-    protected final AnnotationMirror VALUE, BOTTOM;\n+    protected final AnnotationMirror VALUE, BOTTOM, TOP;\n \n     public FlowTestAnnotatedTypeFactory(BaseTypeChecker checker) {\n         super(checker, true);\n         VALUE = AnnotationBuilder.fromClass(elements, Value.class);\n         BOTTOM = AnnotationBuilder.fromClass(elements, Bottom.class);\n+        TOP = AnnotationBuilder.fromClass(elements, Unqualified.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75064a73459074d90521fb73de0611a7678e1971"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg4MDY1NA==", "bodyText": "That would be better to do in a separate pull request.", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475880654", "createdAt": "2020-08-24T20:40:03Z", "author": {"login": "smillst"}, "path": "framework/src/test/java/testlib/util/FlowTestAnnotatedTypeFactory.java", "diffHunk": "@@ -2,37 +2,42 @@\n \n import java.lang.annotation.Annotation;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.HashSet;\n import java.util.Set;\n import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.util.Elements;\n import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n import org.checkerframework.common.basetype.BaseTypeChecker;\n import org.checkerframework.common.subtyping.qual.Bottom;\n import org.checkerframework.common.subtyping.qual.Unqualified;\n import org.checkerframework.framework.qual.TypeUseLocation;\n import org.checkerframework.framework.type.QualifierHierarchy;\n-import org.checkerframework.framework.util.GraphQualifierHierarchy;\n-import org.checkerframework.framework.util.MultiGraphQualifierHierarchy.MultiGraphFactory;\n+import org.checkerframework.framework.util.DefaultQualifierKindHierarchy;\n+import org.checkerframework.framework.util.QualifierHierarchyMostlyWithoutElements;\n+import org.checkerframework.framework.util.QualifierKind;\n+import org.checkerframework.framework.util.QualifierKindHierarchy;\n import org.checkerframework.framework.util.defaults.QualifierDefaults;\n import org.checkerframework.javacutil.AnnotationBuilder;\n import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n \n public class FlowTestAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n-    protected final AnnotationMirror VALUE, BOTTOM;\n+    protected final AnnotationMirror VALUE, BOTTOM, TOP;\n \n     public FlowTestAnnotatedTypeFactory(BaseTypeChecker checker) {\n         super(checker, true);\n         VALUE = AnnotationBuilder.fromClass(elements, Value.class);\n         BOTTOM = AnnotationBuilder.fromClass(elements, Bottom.class);\n+        TOP = AnnotationBuilder.fromClass(elements, Unqualified.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE2NDk0NA=="}, "originalCommit": {"oid": "75064a73459074d90521fb73de0611a7678e1971"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDM1MjI5OnYy", "diffSide": "RIGHT", "path": "framework/src/test/java/testlib/util/FlowTestAnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMzozMjoxMlrOHFJxIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMzozMjoxMlrOHFJxIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE2NDk2MA==", "bodyText": "Should this be reverted?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475164960", "createdAt": "2020-08-23T03:32:12Z", "author": {"login": "mernst"}, "path": "framework/src/test/java/testlib/util/FlowTestAnnotatedTypeFactory.java", "diffHunk": "@@ -47,13 +52,25 @@ protected void addCheckedCodeDefaults(QualifierDefaults defs) {\n     }\n \n     @Override\n-    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n-        return new FlowQualifierHierarchy(factory, BOTTOM);\n+    @SuppressWarnings(\"deprecation\") // TODO: REVERT: Just testing backward compatibility.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75064a73459074d90521fb73de0611a7678e1971"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDM1MjMzOnYy", "diffSide": "RIGHT", "path": "framework/src/test/java/testlib/util/FlowTestAnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMzozMjoyMlrOHFJxKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMzozMjoyMlrOHFJxKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE2NDk2OA==", "bodyText": "Should this be reverted?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475164968", "createdAt": "2020-08-23T03:32:22Z", "author": {"login": "mernst"}, "path": "framework/src/test/java/testlib/util/FlowTestAnnotatedTypeFactory.java", "diffHunk": "@@ -47,13 +52,25 @@ protected void addCheckedCodeDefaults(QualifierDefaults defs) {\n     }\n \n     @Override\n-    public QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory) {\n-        return new FlowQualifierHierarchy(factory, BOTTOM);\n+    @SuppressWarnings(\"deprecation\") // TODO: REVERT: Just testing backward compatibility.\n+    public QualifierHierarchy createQualifierHierarchy() {\n+        return org.checkerframework.framework.util.MultiGraphQualifierHierarchy\n+                .createMultiGraphQualifierHierarchy(this);\n     }\n \n-    class FlowQualifierHierarchy extends GraphQualifierHierarchy {\n+    @Override\n+    @SuppressWarnings(\"deprecation\") // TODO: REVERT: Just testing backward compatibility.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75064a73459074d90521fb73de0611a7678e1971"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MDM1NzA5OnYy", "diffSide": "RIGHT", "path": "framework/src/test/java/testlib/util/FlowTestAnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMzo0MDozMlrOHFJzPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QwMzo0MDozMlrOHFJzPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTE2NTUwMw==", "bodyText": "Should this commented code be deleted?", "url": "https://github.com/typetools/checker-framework/pull/3404#discussion_r475165503", "createdAt": "2020-08-23T03:40:32Z", "author": {"login": "mernst"}, "path": "framework/src/test/java/testlib/util/FlowTestAnnotatedTypeFactory.java", "diffHunk": "@@ -72,4 +89,83 @@ public boolean isSubtype(AnnotationMirror subAnno, AnnotationMirror superAnno) {\n             return super.isSubtype(subAnno, superAnno);\n         }\n     }\n+\n+    //    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75064a73459074d90521fb73de0611a7678e1971"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1718, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}