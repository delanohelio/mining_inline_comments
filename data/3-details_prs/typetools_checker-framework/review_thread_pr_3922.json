{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1Nzc1NzU4", "number": 3922, "reviewThreads": {"totalCount": 121, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMTowMDoxNFrOGS4oOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xMlQyMToyMDowNVrOGVDS_w==", "hasNextPage": false, "hasPreviousPage": true}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNDU1MzUzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMTowMDoxNFrOJ6EvkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMTowMDoxNFrOJ6EvkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg3NDg5Ng==", "bodyText": "I don't understand this @param.  Could you clarify?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664874896", "createdAt": "2021-07-06T21:00:14Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -516,25 +548,48 @@ protected boolean visitTypeArgs(\n             : AnnotationUtils.getElementValueArray(\n                 covariantAnno, covariantValueElement, Integer.class);\n \n-    for (int i = 0; i < supertypeTypeArgs.size(); i++) {\n-      final AnnotatedTypeMirror superTypeArg = supertypeTypeArgs.get(i);\n-      final AnnotatedTypeMirror subTypeArg = subtypeTypeArgs.get(i);\n-      final boolean covariant = covariantArgIndexes != null && covariantArgIndexes.contains(i);\n-\n-      boolean result = isContainedBy(subTypeArg, superTypeArg, covariant);\n+    // JLS 11: 4.10.2. Subtyping among Class and Interface Types\n+    // 4th paragraph, bullet 2\n+    if (isContainedMany(subtype.getTypeArguments(), supertypeTypeArgs, covariantArgIndexes)) {\n+      return true;\n+    }\n+    // 5th paragraph:\n+    // Instead of calling isSubtype with the captured type, just check for containment.\n+    AnnotatedDeclaredType capturedSubtype =\n+        (AnnotatedDeclaredType) subtype.atypeFactory.applyCaptureConversion(subtype);\n+    return isContainedMany(\n+        capturedSubtype.getTypeArguments(), supertypeTypeArgs, covariantArgIndexes);\n+  }\n \n-      if (!result) {\n+  /**\n+   * Calls {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} on the two\n+   * lists of type arguments. Returns true if every type argument in {@code supertypeTypeArgs}\n+   * contains the type argument at the same index in {@code subtypeTypeArgs}.\n+   *\n+   * @param subtypeTypeArgs subtype arguments\n+   * @param supertypeTypeArgs supertype arguments\n+   * @param covariantArgIndexes with the type argument is covariant", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0642850ddca3bab4eaddcdfe204605b0dd05b0a8"}, "originalPosition": 308}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNDU1OTQwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMTowMTo1N1rOJ6EzFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMTowMTo1N1rOJ6EzFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg3NTc5Nw==", "bodyText": "Above, line 815/888 says \"// subtype and supertype are uses of the same type parameter\".  If that is true, why cannot this line be just return true;?  Maybe a comment would help to clarify.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664875797", "createdAt": "2021-07-06T21:01:57Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -821,19 +894,21 @@ public Boolean visitTypevar_Typevar(\n         // as the bounds are the same.\n         return isPrimarySubtype(subtype, supertype);\n \n-      } else if (!subtypeHasAnno && !supertypeHasAnno && areEqualInHierarchy(subtype, supertype)) {\n+      } else if (!subtypeHasAnno && !supertypeHasAnno) {\n         // two unannotated uses of the same type parameter are of the same type\n-        return true;\n-\n-      } else if (subtype.getUpperBound().getKind() == TypeKind.INTERSECTION) {\n-        // This case happens when a type has an intersection bound.  e.g.,\n-        // T extends A & B\n-        //\n-        // And one use of the type has an annotation and the other does not. e.g.,\n-        // @X T xt = ...;  T t = ..;\n-        // xt = t;\n-        //\n-        return visit(subtype.getUpperBound(), supertype.getLowerBound(), null);\n+        return areEqualInHierarchy(subtype, supertype);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0642850ddca3bab4eaddcdfe204605b0dd05b0a8"}, "originalPosition": 499}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNDU3MDY2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMTowNTowNFrOJ6E5kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wN1QxNDoxNTowMlrOJ6lqQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg3NzQ1OA==", "bodyText": "I don't understand what \"will combine to isValid\" means.  Could you reword?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664877458", "createdAt": "2021-07-06T21:05:04Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -981,60 +1068,76 @@ protected boolean visitIntersectionSubtype(\n    * @param supertype a type that might be a supertype\n    * @return true if {@code subtype} is a subtype of {@code supertype}\n    */\n-  protected boolean visitTypevarSupertype(\n+  protected boolean visitType_Typevar(\n       AnnotatedTypeMirror subtype, AnnotatedTypeVariable supertype) {\n     return isSubtypeCaching(subtype, supertype.getLowerBound());\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitType_Typevar will combine to isValid the subtypes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0642850ddca3bab4eaddcdfe204605b0dd05b0a8"}, "originalPosition": 640}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTQxNDIxMQ==", "bodyText": "I don't understand this comment either.  I deleted it.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r665414211", "createdAt": "2021-07-07T14:15:02Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -981,60 +1068,76 @@ protected boolean visitIntersectionSubtype(\n    * @param supertype a type that might be a supertype\n    * @return true if {@code subtype} is a subtype of {@code supertype}\n    */\n-  protected boolean visitTypevarSupertype(\n+  protected boolean visitType_Typevar(\n       AnnotatedTypeMirror subtype, AnnotatedTypeVariable supertype) {\n     return isSubtypeCaching(subtype, supertype.getLowerBound());\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitType_Typevar will combine to isValid the subtypes", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg3NzQ1OA=="}, "originalCommit": {"oid": "0642850ddca3bab4eaddcdfe204605b0dd05b0a8"}, "originalPosition": 640}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNDU3Mzc0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMTowNTo1MVrOJ6E7PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMTowNTo1MVrOJ6E7PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg3Nzg4NA==", "bodyText": "It's surprising to see supertype used here when the assignment is all about subtypes.  Can you use subtype here instead of superttype?  If not, why?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664877884", "createdAt": "2021-07-06T21:05:51Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -981,60 +1068,76 @@ protected boolean visitIntersectionSubtype(\n    * @param supertype a type that might be a supertype\n    * @return true if {@code subtype} is a subtype of {@code supertype}\n    */\n-  protected boolean visitTypevarSupertype(\n+  protected boolean visitType_Typevar(\n       AnnotatedTypeMirror subtype, AnnotatedTypeVariable supertype) {\n     return isSubtypeCaching(subtype, supertype.getLowerBound());\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitType_Typevar will combine to isValid the subtypes\n    * upper bound against the supertypes lower bound.\n    */\n-  protected boolean visitTypevarSubtype(\n+  protected boolean visitTypevar_Type(\n       AnnotatedTypeVariable subtype, AnnotatedTypeMirror supertype) {\n-    AnnotatedTypeMirror upperBound = subtype.getUpperBound();\n-    if (TypesUtils.isBoxedPrimitive(upperBound.getUnderlyingType())\n+    AnnotatedTypeMirror subtypeUpperBound = subtype.getUpperBound();\n+    if (TypesUtils.isBoxedPrimitive(subtypeUpperBound.getUnderlyingType())\n         && supertype instanceof AnnotatedPrimitiveType) {\n-      upperBound = supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) upperBound);\n+      subtypeUpperBound =\n+          supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) subtypeUpperBound);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0642850ddca3bab4eaddcdfe204605b0dd05b0a8"}, "originalPosition": 653}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNDU4NzIyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMTowOToyM1rOJ6FDAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMTowOToyM1rOJ6FDAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg3OTg3NQ==", "bodyText": "I'm not sure how this related no the code below, which is conditional.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664879875", "createdAt": "2021-07-06T21:09:23Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -981,60 +1071,77 @@ protected boolean visitIntersectionSubtype(\n    * @param supertype a type that might be a supertype\n    * @return true if {@code subtype} is a subtype of {@code supertype}\n    */\n-  protected boolean visitTypevarSupertype(\n+  protected boolean visitType_Typevar(\n       AnnotatedTypeMirror subtype, AnnotatedTypeVariable supertype) {\n     return isSubtypeCaching(subtype, supertype.getLowerBound());\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitType_Typevar will combine to isValid the subtypes\n    * upper bound against the supertypes lower bound.\n    */\n-  protected boolean visitTypevarSubtype(\n+  protected boolean visitTypevar_Type(\n       AnnotatedTypeVariable subtype, AnnotatedTypeMirror supertype) {\n-    AnnotatedTypeMirror upperBound = subtype.getUpperBound();\n-    if (TypesUtils.isBoxedPrimitive(upperBound.getUnderlyingType())\n+    AnnotatedTypeMirror subtypeUpperBound = subtype.getUpperBound();\n+    if (TypesUtils.isBoxedPrimitive(subtypeUpperBound.getUnderlyingType())\n         && supertype instanceof AnnotatedPrimitiveType) {\n-      upperBound = supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) upperBound);\n+      subtypeUpperBound =\n+          supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) subtypeUpperBound);\n     }\n     if (supertype.getKind() == TypeKind.DECLARED\n         && TypesUtils.getTypeElement(supertype.getUnderlyingType()).getKind()\n             == ElementKind.INTERFACE) {\n-      // Make sure the upper bound is no wildcard or type variable\n-      while (upperBound.getKind() == TypeKind.TYPEVAR\n-          || upperBound.getKind() == TypeKind.WILDCARD) {\n-        if (upperBound.getKind() == TypeKind.TYPEVAR) {\n-          upperBound = ((AnnotatedTypeVariable) upperBound).getUpperBound();\n-        }\n-        if (upperBound.getKind() == TypeKind.WILDCARD) {\n-          upperBound = ((AnnotatedWildcardType) upperBound).getExtendsBound();\n-        }\n-      }\n-      // If the supertype is an interface, only compare the primary annotations.\n+      // The supertype is an interface.\n+      subtypeUpperBound = getNonWildcardOrTypeVarUpperBound(subtypeUpperBound);\n+      // Only compare the primary annotations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2de7a95d3a4f0ca73753a02307993fa038f0de2e"}, "originalPosition": 674}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNDU4ODI2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMTowOTo0M1rOJ6FDpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wN1QxNDoxOTozOFrOJ6l62Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg4MDAzNg==", "bodyText": "Is \"the actual type argument\" the same as subtype?  (I think not, but I'm not sure what it is.)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664880036", "createdAt": "2021-07-06T21:09:43Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -981,60 +1071,77 @@ protected boolean visitIntersectionSubtype(\n    * @param supertype a type that might be a supertype\n    * @return true if {@code subtype} is a subtype of {@code supertype}\n    */\n-  protected boolean visitTypevarSupertype(\n+  protected boolean visitType_Typevar(\n       AnnotatedTypeMirror subtype, AnnotatedTypeVariable supertype) {\n     return isSubtypeCaching(subtype, supertype.getLowerBound());\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitType_Typevar will combine to isValid the subtypes\n    * upper bound against the supertypes lower bound.\n    */\n-  protected boolean visitTypevarSubtype(\n+  protected boolean visitTypevar_Type(\n       AnnotatedTypeVariable subtype, AnnotatedTypeMirror supertype) {\n-    AnnotatedTypeMirror upperBound = subtype.getUpperBound();\n-    if (TypesUtils.isBoxedPrimitive(upperBound.getUnderlyingType())\n+    AnnotatedTypeMirror subtypeUpperBound = subtype.getUpperBound();\n+    if (TypesUtils.isBoxedPrimitive(subtypeUpperBound.getUnderlyingType())\n         && supertype instanceof AnnotatedPrimitiveType) {\n-      upperBound = supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) upperBound);\n+      subtypeUpperBound =\n+          supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) subtypeUpperBound);\n     }\n     if (supertype.getKind() == TypeKind.DECLARED\n         && TypesUtils.getTypeElement(supertype.getUnderlyingType()).getKind()\n             == ElementKind.INTERFACE) {\n-      // Make sure the upper bound is no wildcard or type variable\n-      while (upperBound.getKind() == TypeKind.TYPEVAR\n-          || upperBound.getKind() == TypeKind.WILDCARD) {\n-        if (upperBound.getKind() == TypeKind.TYPEVAR) {\n-          upperBound = ((AnnotatedTypeVariable) upperBound).getUpperBound();\n-        }\n-        if (upperBound.getKind() == TypeKind.WILDCARD) {\n-          upperBound = ((AnnotatedWildcardType) upperBound).getExtendsBound();\n-        }\n-      }\n-      // If the supertype is an interface, only compare the primary annotations.\n+      // The supertype is an interface.\n+      subtypeUpperBound = getNonWildcardOrTypeVarUpperBound(subtypeUpperBound);\n+      // Only compare the primary annotations.\n       // The actual type argument could implement the interface and the bound of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2de7a95d3a4f0ca73753a02307993fa038f0de2e"}, "originalPosition": 675}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTQxODQ1Nw==", "bodyText": "I don't understand this comment either. I deleted it.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r665418457", "createdAt": "2021-07-07T14:19:38Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -981,60 +1071,77 @@ protected boolean visitIntersectionSubtype(\n    * @param supertype a type that might be a supertype\n    * @return true if {@code subtype} is a subtype of {@code supertype}\n    */\n-  protected boolean visitTypevarSupertype(\n+  protected boolean visitType_Typevar(\n       AnnotatedTypeMirror subtype, AnnotatedTypeVariable supertype) {\n     return isSubtypeCaching(subtype, supertype.getLowerBound());\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitType_Typevar will combine to isValid the subtypes\n    * upper bound against the supertypes lower bound.\n    */\n-  protected boolean visitTypevarSubtype(\n+  protected boolean visitTypevar_Type(\n       AnnotatedTypeVariable subtype, AnnotatedTypeMirror supertype) {\n-    AnnotatedTypeMirror upperBound = subtype.getUpperBound();\n-    if (TypesUtils.isBoxedPrimitive(upperBound.getUnderlyingType())\n+    AnnotatedTypeMirror subtypeUpperBound = subtype.getUpperBound();\n+    if (TypesUtils.isBoxedPrimitive(subtypeUpperBound.getUnderlyingType())\n         && supertype instanceof AnnotatedPrimitiveType) {\n-      upperBound = supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) upperBound);\n+      subtypeUpperBound =\n+          supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) subtypeUpperBound);\n     }\n     if (supertype.getKind() == TypeKind.DECLARED\n         && TypesUtils.getTypeElement(supertype.getUnderlyingType()).getKind()\n             == ElementKind.INTERFACE) {\n-      // Make sure the upper bound is no wildcard or type variable\n-      while (upperBound.getKind() == TypeKind.TYPEVAR\n-          || upperBound.getKind() == TypeKind.WILDCARD) {\n-        if (upperBound.getKind() == TypeKind.TYPEVAR) {\n-          upperBound = ((AnnotatedTypeVariable) upperBound).getUpperBound();\n-        }\n-        if (upperBound.getKind() == TypeKind.WILDCARD) {\n-          upperBound = ((AnnotatedWildcardType) upperBound).getExtendsBound();\n-        }\n-      }\n-      // If the supertype is an interface, only compare the primary annotations.\n+      // The supertype is an interface.\n+      subtypeUpperBound = getNonWildcardOrTypeVarUpperBound(subtypeUpperBound);\n+      // Only compare the primary annotations.\n       // The actual type argument could implement the interface and the bound of", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg4MDAzNg=="}, "originalCommit": {"oid": "2de7a95d3a4f0ca73753a02307993fa038f0de2e"}, "originalPosition": 675}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNDU5MTU1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMToxMDozOVrOJ6FFnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wN1QxNDoxOTo0M1rOJ6l7Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg4MDU0MA==", "bodyText": "What is \"the type variable\"?  Is it subtype?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664880540", "createdAt": "2021-07-06T21:10:39Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -981,60 +1071,77 @@ protected boolean visitIntersectionSubtype(\n    * @param supertype a type that might be a supertype\n    * @return true if {@code subtype} is a subtype of {@code supertype}\n    */\n-  protected boolean visitTypevarSupertype(\n+  protected boolean visitType_Typevar(\n       AnnotatedTypeMirror subtype, AnnotatedTypeVariable supertype) {\n     return isSubtypeCaching(subtype, supertype.getLowerBound());\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitType_Typevar will combine to isValid the subtypes\n    * upper bound against the supertypes lower bound.\n    */\n-  protected boolean visitTypevarSubtype(\n+  protected boolean visitTypevar_Type(\n       AnnotatedTypeVariable subtype, AnnotatedTypeMirror supertype) {\n-    AnnotatedTypeMirror upperBound = subtype.getUpperBound();\n-    if (TypesUtils.isBoxedPrimitive(upperBound.getUnderlyingType())\n+    AnnotatedTypeMirror subtypeUpperBound = subtype.getUpperBound();\n+    if (TypesUtils.isBoxedPrimitive(subtypeUpperBound.getUnderlyingType())\n         && supertype instanceof AnnotatedPrimitiveType) {\n-      upperBound = supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) upperBound);\n+      subtypeUpperBound =\n+          supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) subtypeUpperBound);\n     }\n     if (supertype.getKind() == TypeKind.DECLARED\n         && TypesUtils.getTypeElement(supertype.getUnderlyingType()).getKind()\n             == ElementKind.INTERFACE) {\n-      // Make sure the upper bound is no wildcard or type variable\n-      while (upperBound.getKind() == TypeKind.TYPEVAR\n-          || upperBound.getKind() == TypeKind.WILDCARD) {\n-        if (upperBound.getKind() == TypeKind.TYPEVAR) {\n-          upperBound = ((AnnotatedTypeVariable) upperBound).getUpperBound();\n-        }\n-        if (upperBound.getKind() == TypeKind.WILDCARD) {\n-          upperBound = ((AnnotatedWildcardType) upperBound).getExtendsBound();\n-        }\n-      }\n-      // If the supertype is an interface, only compare the primary annotations.\n+      // The supertype is an interface.\n+      subtypeUpperBound = getNonWildcardOrTypeVarUpperBound(subtypeUpperBound);\n+      // Only compare the primary annotations.\n       // The actual type argument could implement the interface and the bound of\n       // the type variable must not implement the interface.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2de7a95d3a4f0ca73753a02307993fa038f0de2e"}, "originalPosition": 676}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTQxODUzNA==", "bodyText": "I don't understand this comment either. I deleted it.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r665418534", "createdAt": "2021-07-07T14:19:43Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -981,60 +1071,77 @@ protected boolean visitIntersectionSubtype(\n    * @param supertype a type that might be a supertype\n    * @return true if {@code subtype} is a subtype of {@code supertype}\n    */\n-  protected boolean visitTypevarSupertype(\n+  protected boolean visitType_Typevar(\n       AnnotatedTypeMirror subtype, AnnotatedTypeVariable supertype) {\n     return isSubtypeCaching(subtype, supertype.getLowerBound());\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitType_Typevar will combine to isValid the subtypes\n    * upper bound against the supertypes lower bound.\n    */\n-  protected boolean visitTypevarSubtype(\n+  protected boolean visitTypevar_Type(\n       AnnotatedTypeVariable subtype, AnnotatedTypeMirror supertype) {\n-    AnnotatedTypeMirror upperBound = subtype.getUpperBound();\n-    if (TypesUtils.isBoxedPrimitive(upperBound.getUnderlyingType())\n+    AnnotatedTypeMirror subtypeUpperBound = subtype.getUpperBound();\n+    if (TypesUtils.isBoxedPrimitive(subtypeUpperBound.getUnderlyingType())\n         && supertype instanceof AnnotatedPrimitiveType) {\n-      upperBound = supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) upperBound);\n+      subtypeUpperBound =\n+          supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) subtypeUpperBound);\n     }\n     if (supertype.getKind() == TypeKind.DECLARED\n         && TypesUtils.getTypeElement(supertype.getUnderlyingType()).getKind()\n             == ElementKind.INTERFACE) {\n-      // Make sure the upper bound is no wildcard or type variable\n-      while (upperBound.getKind() == TypeKind.TYPEVAR\n-          || upperBound.getKind() == TypeKind.WILDCARD) {\n-        if (upperBound.getKind() == TypeKind.TYPEVAR) {\n-          upperBound = ((AnnotatedTypeVariable) upperBound).getUpperBound();\n-        }\n-        if (upperBound.getKind() == TypeKind.WILDCARD) {\n-          upperBound = ((AnnotatedWildcardType) upperBound).getExtendsBound();\n-        }\n-      }\n-      // If the supertype is an interface, only compare the primary annotations.\n+      // The supertype is an interface.\n+      subtypeUpperBound = getNonWildcardOrTypeVarUpperBound(subtypeUpperBound);\n+      // Only compare the primary annotations.\n       // The actual type argument could implement the interface and the bound of\n       // the type variable must not implement the interface.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDg4MDU0MA=="}, "originalCommit": {"oid": "2de7a95d3a4f0ca73753a02307993fa038f0de2e"}, "originalPosition": 676}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNDk0ODg4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMzoxMzoyNVrOJ6ITrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMzoxMzoyNVrOJ6ITrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzMzI5Mw==", "bodyText": "It looks like there is a typo on this line.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664933293", "createdAt": "2021-07-06T23:13:25Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -355,7 +365,53 @@ public Void visitDeclared(AnnotatedDeclaredType type, Tree tree) {\n     return null;\n   }\n \n-  private Pair<ParameterizedTypeTree, AnnotatedDeclaredType> extractParameterizedTypeTree(\n+  /**\n+   * Visits the type parameters of a class tree.\n+   *\n+   * @param type type of {@code tree}\n+   * @param tree a class tree\n+   */\n+  protected void visitClassTypeParameters(AnnotatedDeclaredType type, ClassTree tree) {\n+    for (int i = 0, size = type.getTypeArguments().size(); i < size; i++) {\n+      AnnotatedTypeVariable typeParameter = (AnnotatedTypeVariable) type.getTypeArguments().get(i);\n+      TypeParameterTree typeParameterTree = tree.getTypeParameters().get(i);\n+      scan(typeParameter, typeParameterTree);\n+    }\n+  }\n+\n+  /**\n+   * Visits type parameters .bounds", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6ed70557e0da60a5a4f92cf13374349a3907f19"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNDk1MTQwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMzoxNDozM1rOJ6IVIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wN1QxNDoyOTozMlrOJ6mgBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzMzY2Ng==", "bodyText": "These variable names are confusingly similar, given that one is from getTypeArguments and the other is from getTypeParameters.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664933666", "createdAt": "2021-07-06T23:14:33Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -355,7 +365,53 @@ public Void visitDeclared(AnnotatedDeclaredType type, Tree tree) {\n     return null;\n   }\n \n-  private Pair<ParameterizedTypeTree, AnnotatedDeclaredType> extractParameterizedTypeTree(\n+  /**\n+   * Visits the type parameters of a class tree.\n+   *\n+   * @param type type of {@code tree}\n+   * @param tree a class tree\n+   */\n+  protected void visitClassTypeParameters(AnnotatedDeclaredType type, ClassTree tree) {\n+    for (int i = 0, size = type.getTypeArguments().size(); i < size; i++) {\n+      AnnotatedTypeVariable typeParameter = (AnnotatedTypeVariable) type.getTypeArguments().get(i);\n+      TypeParameterTree typeParameterTree = tree.getTypeParameters().get(i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6ed70557e0da60a5a4f92cf13374349a3907f19"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTQyNzk3NQ==", "bodyText": "typeParameter is the annotated type of typeParameterTree.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r665427975", "createdAt": "2021-07-07T14:29:32Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -355,7 +365,53 @@ public Void visitDeclared(AnnotatedDeclaredType type, Tree tree) {\n     return null;\n   }\n \n-  private Pair<ParameterizedTypeTree, AnnotatedDeclaredType> extractParameterizedTypeTree(\n+  /**\n+   * Visits the type parameters of a class tree.\n+   *\n+   * @param type type of {@code tree}\n+   * @param tree a class tree\n+   */\n+  protected void visitClassTypeParameters(AnnotatedDeclaredType type, ClassTree tree) {\n+    for (int i = 0, size = type.getTypeArguments().size(); i < size; i++) {\n+      AnnotatedTypeVariable typeParameter = (AnnotatedTypeVariable) type.getTypeArguments().get(i);\n+      TypeParameterTree typeParameterTree = tree.getTypeParameters().get(i);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzMzY2Ng=="}, "originalCommit": {"oid": "a6ed70557e0da60a5a4f92cf13374349a3907f19"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNDk1NTczOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMzoxNjoxMVrOJ6IXmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMzoxNjoxMVrOJ6IXmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzNDI5Nw==", "bodyText": "This is actually a type variable.  That is a type, but the comment could be more specific, and perhaps the variable name too.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664934297", "createdAt": "2021-07-06T23:16:11Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -355,7 +365,53 @@ public Void visitDeclared(AnnotatedDeclaredType type, Tree tree) {\n     return null;\n   }\n \n-  private Pair<ParameterizedTypeTree, AnnotatedDeclaredType> extractParameterizedTypeTree(\n+  /**\n+   * Visits the type parameters of a class tree.\n+   *\n+   * @param type type of {@code tree}\n+   * @param tree a class tree\n+   */\n+  protected void visitClassTypeParameters(AnnotatedDeclaredType type, ClassTree tree) {\n+    for (int i = 0, size = type.getTypeArguments().size(); i < size; i++) {\n+      AnnotatedTypeVariable typeParameter = (AnnotatedTypeVariable) type.getTypeArguments().get(i);\n+      TypeParameterTree typeParameterTree = tree.getTypeParameters().get(i);\n+      scan(typeParameter, typeParameterTree);\n+    }\n+  }\n+\n+  /**\n+   * Visits type parameters .bounds\n+   *\n+   * @param typeParameter type of {@code typeParameterTree}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6ed70557e0da60a5a4f92cf13374349a3907f19"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNDk2MjU1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMzoxOTowOFrOJ6IbgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMzoxOTowOFrOJ6IbgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzNTI5Nw==", "bodyText": "I think that here and in the method above, this is only used as a location for error reporting.  If so, that might be helpful to state.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664935297", "createdAt": "2021-07-06T23:19:08Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeValidator.java", "diffHunk": "@@ -355,7 +365,53 @@ public Void visitDeclared(AnnotatedDeclaredType type, Tree tree) {\n     return null;\n   }\n \n-  private Pair<ParameterizedTypeTree, AnnotatedDeclaredType> extractParameterizedTypeTree(\n+  /**\n+   * Visits the type parameters of a class tree.\n+   *\n+   * @param type type of {@code tree}\n+   * @param tree a class tree\n+   */\n+  protected void visitClassTypeParameters(AnnotatedDeclaredType type, ClassTree tree) {\n+    for (int i = 0, size = type.getTypeArguments().size(); i < size; i++) {\n+      AnnotatedTypeVariable typeParameter = (AnnotatedTypeVariable) type.getTypeArguments().get(i);\n+      TypeParameterTree typeParameterTree = tree.getTypeParameters().get(i);\n+      scan(typeParameter, typeParameterTree);\n+    }\n+  }\n+\n+  /**\n+   * Visits type parameters .bounds\n+   *\n+   * @param typeParameter type of {@code typeParameterTree}\n+   * @param typeParameterTree a type parameter tree", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6ed70557e0da60a5a4f92cf13374349a3907f19"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNDk3Njg0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMzoyNTowOVrOJ6Ijdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMzoyNTowOVrOJ6Ijdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzNzMzNQ==", "bodyText": "Does this test the tree (as the comment states), or does it just use the tree for error reporting?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664937335", "createdAt": "2021-07-06T23:25:09Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "diffHunk": "@@ -4490,7 +4475,7 @@ public boolean validateTypeOf(Tree tree) {\n \n   /**\n    * Tests whether the type and corresponding type tree is a valid type, and emits an error if that", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63259e90bd1fdb1281d5749efd43fc679c18bf48"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNDk4MDQ4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMzoyNjo1NlrOJ6Ilhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMzoyNjo1NlrOJ6Ilhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzNzg2Mg==", "bodyText": "For efficiency, could break; after this statement, since the inner loop is now done.\nOr, to make this code clearer at the cost of a helper method, define a method to find the type corresponding to tree im.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664937862", "createdAt": "2021-07-06T23:26:56Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "diffHunk": "@@ -525,13 +525,22 @@ public void processClassTree(ClassTree classTree) {\n \n     Tree ext = classTree.getExtendsClause();\n     if (ext != null) {\n-      validateTypeOf(ext);\n+      for (AnnotatedDeclaredType superType : classType.directSupertypes()) {\n+        if (superType.getUnderlyingType().asElement().getKind().isClass()) {\n+          validateType(ext, superType);\n+        }\n+      }\n     }\n \n     List<? extends Tree> impls = classTree.getImplementsClause();\n     if (impls != null) {\n       for (Tree im : impls) {\n-        validateTypeOf(im);\n+        for (AnnotatedDeclaredType superType : classType.directSupertypes()) {\n+          if (superType.getUnderlyingType().asElement().getKind().isInterface()\n+              && types.isSameType(superType.getUnderlyingType(), TreeUtils.typeOf(im))) {\n+            validateType(im, superType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63259e90bd1fdb1281d5749efd43fc679c18bf48"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNDk4NTg1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMzoyOTowM1rOJ6Iojg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMzoyOTowM1rOJ6Iojg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzODYzOA==", "bodyText": "What situation is this testing for?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664938638", "createdAt": "2021-07-06T23:29:03Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "diffHunk": "@@ -1378,21 +1387,17 @@ protected void checkConditionalPostcondition(\n \n   @Override\n   public Void visitTypeParameter(TypeParameterTree node, Void p) {\n-    validateTypeOf(node);\n-    // Check the bounds here and not with every TypeParameterTree.\n-    // For the latter, we only need to check annotations on the type variable itself.\n-    // Why isn't this covered by the super call?\n-    for (Tree tpb : node.getBounds()) {\n-      validateTypeOf(tpb);\n-    }\n-\n     if (node.getBounds().size() > 1) {\n       // The upper bound of the type parameter is an intersection\n       AnnotatedTypeVariable type =\n           (AnnotatedTypeVariable) atypeFactory.getAnnotatedTypeFromTypeTree(node);\n       AnnotatedIntersectionType intersection = (AnnotatedIntersectionType) type.getUpperBound();\n       checkExplicitAnnotationsOnIntersectionBounds(intersection, node.getBounds());\n     }\n+    if (TreeUtils.isClassTree(getCurrentPath().getParentPath().getLeaf())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63259e90bd1fdb1281d5749efd43fc679c18bf48"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNDk4Nzg1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMzoyOTo1N1rOJ6Iptw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wNlQyMzoyOTo1N1rOJ6Iptw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDkzODkzNQ==", "bodyText": "Could you clarify \"made within\"?  I think I know what you mean, but I had to think about this phrase when I encountered it.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664938935", "createdAt": "2021-07-06T23:29:57Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/common/basetype/BaseTypeVisitor.java", "diffHunk": "@@ -3056,20 +3061,16 @@ protected void checkTypeArguments(\n       AnnotatedTypeParameterBounds bounds = paramBounds.get(i);\n       AnnotatedTypeMirror typeArg = typeargs.get(i);\n \n-      if (isIgnoredUninferredWildcard(bounds.getUpperBound())\n-          || isIgnoredUninferredWildcard(typeArg)) {\n+      if (typeArg.getKind() == TypeKind.WILDCARD) {\n+        // Even if the wildcard is outside the bound, it is made within the bound during", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63259e90bd1fdb1281d5749efd43fc679c18bf48"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNTI1MDE2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeMirror.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wN1QwMTozNToyMFrOJ6K_tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wN1QwMTozNToyMFrOJ6K_tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk3NzMzMw==", "bodyText": "I don't understand the \"If\" here.  Is this a fact that is true, or will it be tested, or does something else depend on it?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664977333", "createdAt": "2021-07-07T01:35:20Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeMirror.java", "diffHunk": "@@ -920,9 +922,32 @@ public AnnotatedDeclaredType asUse() {\n       }\n       AnnotatedDeclaredType result = this.shallowCopy(true);\n       result.declaration = false;\n+      if (this.enclosingType != null) {\n+        result.enclosingType = this.enclosingType.asUse();\n+      }\n       // setTypeArguments calls asUse on all the new type arguments.\n       result.setTypeArguments(typeArgs);\n \n+      // If \"this\" is a type declaration with a type variable that references itself, i.e. MyClass<T", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f8c3aaac4c37cca593eb32492564507bc875782"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNTI1MjgxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeMirror.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wN1QwMTozNjozM1rOJ6LBSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wN1QwMTozNjozM1rOJ6LBSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk3NzczNg==", "bodyText": "Please fill the paragraph, or add line breaks where appropriate.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664977736", "createdAt": "2021-07-07T01:36:33Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeMirror.java", "diffHunk": "@@ -920,9 +922,32 @@ public AnnotatedDeclaredType asUse() {\n       }\n       AnnotatedDeclaredType result = this.shallowCopy(true);\n       result.declaration = false;\n+      if (this.enclosingType != null) {\n+        result.enclosingType = this.enclosingType.asUse();\n+      }\n       // setTypeArguments calls asUse on all the new type arguments.\n       result.setTypeArguments(typeArgs);\n \n+      // If \"this\" is a type declaration with a type variable that references itself, i.e. MyClass<T\n+      // extends List<T>>.\n+      // The type variable is a declaration, i.e. the first T, but the reference to the type\n+      // variable is a use, i.e the second T.  When", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f8c3aaac4c37cca593eb32492564507bc875782"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNTI3Njk3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/typeannotator/PropagationTypeAnnotator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wN1QwMTo0ODoyMVrOJ6LPeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wN1QwMTo0ODoyMVrOJ6LPeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk4MTM3MA==", "bodyText": "I'm confused by the formal parameter names wildcard and parent.  The fact that wildcard is a wildcard is not used by this method.  I'm also not clear why the type is named parent; what is it a parent of, or what is that trying to convey?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664981370", "createdAt": "2021-07-07T01:48:21Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/typeannotator/PropagationTypeAnnotator.java", "diffHunk": "@@ -207,26 +207,16 @@ private void applyAnnosFromBound(\n    */\n   private Element getTypeParamFromEnclosingClass(\n       final @FindDistinct AnnotatedWildcardType wildcard, final AnnotatedDeclaredType parent) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f8c3aaac4c37cca593eb32492564507bc875782"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNTMzOTc3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/AnnotatedTypes.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wN1QwMjoxNDowNlrOJ6L0cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wN1QwMjoxNDowNlrOJ6L0cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk5MDgzNA==", "bodyText": "I suggest making these assertions (here and 2 lines down) into if (...) throw new BugInCF(), so we get earlier notification of problems.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664990834", "createdAt": "2021-07-07T02:14:06Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/AnnotatedTypes.java", "diffHunk": "@@ -768,6 +760,103 @@ public static AnnotatedTypeMirror leastUpperBound(\n     return new AtmLubVisitor(atypeFactory).lub(type1, type2, lubTypeMirror);\n   }\n \n+  /**\n+   * Returns the glb of two annotated types.\n+   *\n+   * @param atypeFactory AnnotatedTypeFactory\n+   * @param type1 annotated type\n+   * @param type2 annotated type\n+   * @return the glb of type1 and type2\n+   */\n+  public static AnnotatedTypeMirror greatestLowerBound(\n+      AnnotatedTypeFactory atypeFactory, AnnotatedTypeMirror type1, AnnotatedTypeMirror type2) {\n+    Types types = atypeFactory.types;\n+    if (types.isSubtype(type1.getUnderlyingType(), type2.getUnderlyingType())) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type1, type2);\n+    } else if (types.isSubtype(type2.getUnderlyingType(), type1.getUnderlyingType())) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type2, type1);\n+    }\n+\n+    TypeMirror glbJava =\n+        TypesUtils.greatestLowerBound(\n+            type1.getUnderlyingType(), type2.getUnderlyingType(), atypeFactory.getProcessingEnv());\n+\n+    if (types.isSameType(type1.getUnderlyingType(), glbJava)) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type1, type2);\n+    } else if (types.isSameType(type2.getUnderlyingType(), glbJava)) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type2, type1);\n+    }\n+\n+    if (glbJava.getKind() != TypeKind.INTERSECTION) {\n+      // If one type isn't a subtype of the other, then GLB must be an intersection.\n+      throw new BugInCF(\n+          \"AnnotatedTypes#greatestLowerBound: unexpected java type: %s. type1: %s, type2: %s\",\n+          glbJava, type1, type2);\n+    }\n+    QualifierHierarchy qualifierHierarchy = atypeFactory.getQualifierHierarchy();\n+    Set<AnnotationMirror> setA =\n+        AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, type1);\n+    Set<AnnotationMirror> setB =\n+        AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, type2);\n+    Set<? extends AnnotationMirror> glbAnno = qualifierHierarchy.greatestLowerBounds(setA, setB);\n+\n+    AnnotatedIntersectionType glb =\n+        (AnnotatedIntersectionType) AnnotatedTypeMirror.createType(glbJava, atypeFactory, false);\n+\n+    for (AnnotatedTypeMirror bound : glb.getBounds()) {\n+      if (types.isSameType(bound.getUnderlyingType(), type1.getUnderlyingType())) {\n+        atypeFactory.replaceAnnotations(type1, bound);\n+      } else if (types.isSameType(bound.getUnderlyingType(), type2.getUnderlyingType())) {\n+        atypeFactory.replaceAnnotations(type2, bound);\n+      } else {\n+        throw new BugInCF(\n+            \"Neither %s nor %s is one of the intersection bounds in %s. Bound: %s\",\n+            type1, type2, bound, glb);\n+      }\n+    }\n+\n+    glb.addAnnotations(glbAnno);\n+    return glb;\n+  }\n+\n+  /**\n+   * Returns the annotated greatest lower bound of {@code subtype} and {@code supertype}, where the\n+   * underlying java types are in a subtyping relationship.\n+   *\n+   * @param qualifierHierarchy QualifierHierarchy\n+   * @param subtype annotated types whose underlying type is a subtype of {@code supertype}\n+   * @param supertype annotated types whose underlying type is a supertype of {@code subtype}\n+   * @return the annotated greatest lower bound of {@code subtype} and {@code supertype}\n+   */\n+  private static AnnotatedTypeMirror glbSubtype(\n+      QualifierHierarchy qualifierHierarchy,\n+      AnnotatedTypeMirror subtype,\n+      AnnotatedTypeMirror supertype) {\n+    AnnotatedTypeMirror glb = subtype.deepCopy();\n+    glb.clearAnnotations();\n+\n+    for (AnnotationMirror top : qualifierHierarchy.getTopAnnotations()) {\n+      AnnotationMirror subAnno = subtype.getAnnotationInHierarchy(top);\n+      AnnotationMirror superAnno = supertype.getAnnotationInHierarchy(top);\n+      if (subAnno != null && superAnno != null) {\n+        glb.addAnnotation(qualifierHierarchy.greatestLowerBound(subAnno, superAnno));\n+      } else if (subAnno == null && superAnno == null) {\n+        assert subtype.getKind() == TypeKind.TYPEVAR && supertype.getKind() == TypeKind.TYPEVAR;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f8c3aaac4c37cca593eb32492564507bc875782"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIyNTM4NTE2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/AnnotatedTypes.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wN1QwMjozNDo1OFrOJ6MOiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wN1QyMjo1OTozOFrOJ66qnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk5NzUxMg==", "bodyText": "This method only manipulates the primary annotations.  The result might not be a subtype of the argument supertype (because of annotations other than primary annotations).  (This seems possible at the third and fourth call sites.)  Is this a bug or intended behavior?  Or is it impossible?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r664997512", "createdAt": "2021-07-07T02:34:58Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/AnnotatedTypes.java", "diffHunk": "@@ -768,6 +760,103 @@ public static AnnotatedTypeMirror leastUpperBound(\n     return new AtmLubVisitor(atypeFactory).lub(type1, type2, lubTypeMirror);\n   }\n \n+  /**\n+   * Returns the glb of two annotated types.\n+   *\n+   * @param atypeFactory the AnnotatedTypeFactory\n+   * @param type1 annotated type\n+   * @param type2 annotated type\n+   * @return the glb of type1 and type2\n+   */\n+  public static AnnotatedTypeMirror greatestLowerBound(\n+      AnnotatedTypeFactory atypeFactory, AnnotatedTypeMirror type1, AnnotatedTypeMirror type2) {\n+    Types types = atypeFactory.types;\n+    if (types.isSubtype(type1.getUnderlyingType(), type2.getUnderlyingType())) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type1, type2);\n+    } else if (types.isSubtype(type2.getUnderlyingType(), type1.getUnderlyingType())) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type2, type1);\n+    }\n+\n+    TypeMirror glbJava =\n+        TypesUtils.greatestLowerBound(\n+            type1.getUnderlyingType(), type2.getUnderlyingType(), atypeFactory.getProcessingEnv());\n+\n+    if (types.isSameType(type1.getUnderlyingType(), glbJava)) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type1, type2);\n+    } else if (types.isSameType(type2.getUnderlyingType(), glbJava)) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type2, type1);\n+    }\n+\n+    if (glbJava.getKind() != TypeKind.INTERSECTION) {\n+      // If one type isn't a subtype of the other, then GLB must be an intersection.\n+      throw new BugInCF(\n+          \"AnnotatedTypes#greatestLowerBound: unexpected java type: %s. type1: %s, type2: %s\",\n+          glbJava, type1, type2);\n+    }\n+    QualifierHierarchy qualifierHierarchy = atypeFactory.getQualifierHierarchy();\n+    Set<AnnotationMirror> setA =\n+        AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, type1);\n+    Set<AnnotationMirror> setB =\n+        AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, type2);\n+    Set<? extends AnnotationMirror> glbAnno = qualifierHierarchy.greatestLowerBounds(setA, setB);\n+\n+    AnnotatedIntersectionType glb =\n+        (AnnotatedIntersectionType) AnnotatedTypeMirror.createType(glbJava, atypeFactory, false);\n+\n+    for (AnnotatedTypeMirror bound : glb.getBounds()) {\n+      if (types.isSameType(bound.getUnderlyingType(), type1.getUnderlyingType())) {\n+        atypeFactory.replaceAnnotations(type1, bound);\n+      } else if (types.isSameType(bound.getUnderlyingType(), type2.getUnderlyingType())) {\n+        atypeFactory.replaceAnnotations(type2, bound);\n+      } else {\n+        throw new BugInCF(\n+            \"Neither %s nor %s is one of the intersection bounds in %s. Bound: %s\",\n+            type1, type2, bound, glb);\n+      }\n+    }\n+\n+    glb.addAnnotations(glbAnno);\n+    return glb;\n+  }\n+\n+  /**\n+   * Returns the annotated greatest lower bound of {@code subtype} and {@code supertype}, where the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aefddea73160ccd452666f40f76b110e62ec5c71"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NTc1ODM2NQ==", "bodyText": "This is the intended behavior.  I've renamed greatestLowerBound to annotatedGLB and added a comment explaining the algorithm.   However, there is a missing error related to this.  See checker/tests/nullness/WildcardGLB.java.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r665758365", "createdAt": "2021-07-07T22:59:38Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/AnnotatedTypes.java", "diffHunk": "@@ -768,6 +760,103 @@ public static AnnotatedTypeMirror leastUpperBound(\n     return new AtmLubVisitor(atypeFactory).lub(type1, type2, lubTypeMirror);\n   }\n \n+  /**\n+   * Returns the glb of two annotated types.\n+   *\n+   * @param atypeFactory the AnnotatedTypeFactory\n+   * @param type1 annotated type\n+   * @param type2 annotated type\n+   * @return the glb of type1 and type2\n+   */\n+  public static AnnotatedTypeMirror greatestLowerBound(\n+      AnnotatedTypeFactory atypeFactory, AnnotatedTypeMirror type1, AnnotatedTypeMirror type2) {\n+    Types types = atypeFactory.types;\n+    if (types.isSubtype(type1.getUnderlyingType(), type2.getUnderlyingType())) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type1, type2);\n+    } else if (types.isSubtype(type2.getUnderlyingType(), type1.getUnderlyingType())) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type2, type1);\n+    }\n+\n+    TypeMirror glbJava =\n+        TypesUtils.greatestLowerBound(\n+            type1.getUnderlyingType(), type2.getUnderlyingType(), atypeFactory.getProcessingEnv());\n+\n+    if (types.isSameType(type1.getUnderlyingType(), glbJava)) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type1, type2);\n+    } else if (types.isSameType(type2.getUnderlyingType(), glbJava)) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type2, type1);\n+    }\n+\n+    if (glbJava.getKind() != TypeKind.INTERSECTION) {\n+      // If one type isn't a subtype of the other, then GLB must be an intersection.\n+      throw new BugInCF(\n+          \"AnnotatedTypes#greatestLowerBound: unexpected java type: %s. type1: %s, type2: %s\",\n+          glbJava, type1, type2);\n+    }\n+    QualifierHierarchy qualifierHierarchy = atypeFactory.getQualifierHierarchy();\n+    Set<AnnotationMirror> setA =\n+        AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, type1);\n+    Set<AnnotationMirror> setB =\n+        AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, type2);\n+    Set<? extends AnnotationMirror> glbAnno = qualifierHierarchy.greatestLowerBounds(setA, setB);\n+\n+    AnnotatedIntersectionType glb =\n+        (AnnotatedIntersectionType) AnnotatedTypeMirror.createType(glbJava, atypeFactory, false);\n+\n+    for (AnnotatedTypeMirror bound : glb.getBounds()) {\n+      if (types.isSameType(bound.getUnderlyingType(), type1.getUnderlyingType())) {\n+        atypeFactory.replaceAnnotations(type1, bound);\n+      } else if (types.isSameType(bound.getUnderlyingType(), type2.getUnderlyingType())) {\n+        atypeFactory.replaceAnnotations(type2, bound);\n+      } else {\n+        throw new BugInCF(\n+            \"Neither %s nor %s is one of the intersection bounds in %s. Bound: %s\",\n+            type1, type2, bound, glb);\n+      }\n+    }\n+\n+    glb.addAnnotations(glbAnno);\n+    return glb;\n+  }\n+\n+  /**\n+   * Returns the annotated greatest lower bound of {@code subtype} and {@code supertype}, where the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2NDk5NzUxMg=="}, "originalCommit": {"oid": "aefddea73160ccd452666f40f76b110e62ec5c71"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDI0NzI3Mjk1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/util/AnnotatedTypes.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xMlQyMToyMDowNVrOJ9TouA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xMlQyMToyMDowNVrOJ9TouA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODI2NDYzMg==", "bodyText": "I think this handles cases 1, 2, and 3: anytime the two types have a subtyping relationship.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r668264632", "createdAt": "2021-07-12T21:20:05Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/util/AnnotatedTypes.java", "diffHunk": "@@ -768,6 +760,138 @@ public static AnnotatedTypeMirror leastUpperBound(\n     return new AtmLubVisitor(atypeFactory).lub(type1, type2, lubTypeMirror);\n   }\n \n+  /**\n+   * Returns the \"annotated greatest lower bound\" of {@code type1} and {@code type2}.\n+   *\n+   * <p>Suppose that there is an expression e with annotated type T. The underlying type of T must\n+   * be the same as javac's type for e. (This is a requirement of the Checker Framework.) As a\n+   * corollary, when computing a glb of atype1 and atype2, it is required that\n+   * underlyingType(cfGLB(atype1, atype2) == glb(javacGLB(underlyingType(atype1),\n+   * underlyingType(atype2)). Because of this requirement, the return value of this method (the\n+   * \"annotated GLB\") may not be a subtype of one of the types.\n+   *\n+   * <p>The \"annotated greatest lower bound\" is defined as follows:\n+   *\n+   * <ol>\n+   *   <li>If the underlying type of {@code type1} and {@code type2} are the same, then return a\n+   *       copy of {@code type1} whose primary annotations are the greatest lower bound of the\n+   *       primary annotations on {@code type1} and {@code type2}.\n+   *   <li>If the underlying type of {@code type1} is a subtype of the underlying type of {@code\n+   *       type2}, then return a copy of {@code type1} whose primary annotations are the greatest\n+   *       lower bound of the primary annotations on {@code type1} and {@code type2}.\n+   *   <li>If the underlying type of {@code type1} is a supertype of the underlying type of {@code\n+   *       type2}, then return a copy of {@code type2} whose primary annotations are the greatest\n+   *       lower bound of the primary annotations on {@code type1} and {@code type2}.\n+   *   <li>If the underlying type of {@code type1} and {@code type2} are not in a subtyping\n+   *       relationship, then return an annotated intersection type whose bounds are {@code type1}\n+   *       and {@code type2}.\n+   * </ol>\n+   *\n+   * @param atypeFactory the AnnotatedTypeFactory\n+   * @param type1 annotated type\n+   * @param type2 annotated type\n+   * @return the annotated glb of type1 and type2\n+   */\n+  public static AnnotatedTypeMirror annotatedGLB(\n+      AnnotatedTypeFactory atypeFactory, AnnotatedTypeMirror type1, AnnotatedTypeMirror type2) {\n+    Types types = atypeFactory.types;\n+    if (types.isSubtype(type1.getUnderlyingType(), type2.getUnderlyingType())) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type1, type2);\n+    } else if (types.isSubtype(type2.getUnderlyingType(), type1.getUnderlyingType())) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type2, type1);\n+    }\n+\n+    TypeMirror glbJava =\n+        TypesUtils.greatestLowerBound(\n+            type1.getUnderlyingType(), type2.getUnderlyingType(), atypeFactory.getProcessingEnv());\n+\n+    if (types.isSameType(type1.getUnderlyingType(), glbJava)) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type1, type2);\n+    } else if (types.isSameType(type2.getUnderlyingType(), glbJava)) {\n+      return glbSubtype(atypeFactory.getQualifierHierarchy(), type2, type1);\n+    }\n+\n+    if (glbJava.getKind() != TypeKind.INTERSECTION) {\n+      // If one type isn't a subtype of the other, then GLB must be an intersection.\n+      throw new BugInCF(\n+          \"AnnotatedTypes#annotatedGLB: expected intersection, got [%s] %s. \"\n+              + \"type1: %s, type2: %s\",\n+          glbJava.getKind(), glbJava, type1, type2);\n+    }\n+    QualifierHierarchy qualifierHierarchy = atypeFactory.getQualifierHierarchy();\n+    Set<AnnotationMirror> set1 =\n+        AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, type1);\n+    Set<AnnotationMirror> set2 =\n+        AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, type2);\n+    Set<? extends AnnotationMirror> glbAnno = qualifierHierarchy.greatestLowerBounds(set1, set2);\n+\n+    AnnotatedIntersectionType glb =\n+        (AnnotatedIntersectionType) AnnotatedTypeMirror.createType(glbJava, atypeFactory, false);\n+\n+    List<AnnotatedTypeMirror> newBounds = new ArrayList<>(2);\n+    for (AnnotatedTypeMirror bound : glb.getBounds()) {\n+      if (types.isSameType(bound.getUnderlyingType(), type1.getUnderlyingType())) {\n+        newBounds.add(type1.deepCopy());\n+      } else if (types.isSameType(bound.getUnderlyingType(), type2.getUnderlyingType())) {\n+        newBounds.add(type2.deepCopy());\n+      } else {\n+        throw new BugInCF(\n+            \"Neither %s nor %s is one of the intersection bounds in %s. Bound: %s\",\n+            type1, type2, bound, glb);\n+      }\n+    }\n+\n+    glb.setBounds(newBounds);\n+    glb.addAnnotations(glbAnno);\n+    return glb;\n+  }\n+\n+  /**\n+   * Returns the annotated greatest lower bound of {@code subtype} and {@code supertype}, where the\n+   * underlying Java types are in a subtyping relationship.\n+   *\n+   * <p>This handles cases 2 and 3 mentioned in the Javadoc of {@link", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dfab48650e736a433e393ac77b6985a5552a41c"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNjgzMDM3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzoxODoyMVrOH4XoEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzoxODoyMVrOH4XoEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2OTM5NA==", "bodyText": "This test looks wrong to me.  I think the && should be ||.\nHowever, I would rewrite it to correspond closely to the Javadoc comment @code type} and {@code typeMirror} must both be declared types.:\n        if (!(type.getKind() == TypeKind.DECLARED && typeMirror.getKind() == TypeKind.DECLARED)) {\n            return false;\n\t}\nI think a closer correspondence between the Javadoc and the code makes the code easier to understand.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528869394", "createdAt": "2020-11-23T17:18:21Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 338}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNjgzOTAxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzoyMDoyMVrOH4XtWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzoyMDoyMVrOH4XtWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3MDc0Nw==", "bodyText": "The first and fourth disjuncts logically belong to the third bullet point in the Javadoc.  Please make this if statement be just about the second bullet point, and put the first and fourth disjuncts afterward, together with the for statement that addresses the third bullet point.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528870747", "createdAt": "2020-11-23T17:20:21Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 343}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNjg0MTIwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzoyMDo1MFrOH4XuuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzoyMDo1MFrOH4XuuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3MTA5Ng==", "bodyText": "Can capturedTypeMirror be null?  It is not annotated as @Nullable.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528871096", "createdAt": "2020-11-23T17:20:50Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || typeToCapture.wasRaw()\n+                || typeToCapture.containsUninferredTypeArguments()\n+                || (capturedTypeMirror != null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 346}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNjg0NTk3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzoyMTo1OFrOH4XxuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzoyMTo1OFrOH4XxuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3MTg2NA==", "bodyText": "What is the distinction between these two variables, which have the same Map type?  Does the comment apply to just one of them or to both?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528871864", "createdAt": "2020-11-23T17:21:58Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || typeToCapture.wasRaw()\n+                || typeToCapture.containsUninferredTypeArguments()\n+                || (capturedTypeMirror != null\n+                        && capturedTypeMirror.getTypeArguments().size()\n+                                != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // Create a mapping from type variables in typeDeclaration to type arguments.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArguments = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 414}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNjg0OTI5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzoyMjo0N1rOH4XzsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzoyMjo0N1rOH4XzsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3MjM2OA==", "bodyText": "Please make the naming preCapturedArg and capturedTypeArg more consistent, probably by renaming preCapturedArg to preCapturedTypeArg.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528872368", "createdAt": "2020-11-23T17:22:47Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || typeToCapture.wasRaw()\n+                || typeToCapture.containsUninferredTypeArguments()\n+                || (capturedTypeMirror != null\n+                        && capturedTypeMirror.getTypeArguments().size()\n+                                != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // Create a mapping from type variables in typeDeclaration to type arguments.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArguments = new HashMap<>();\n+        Map<TypeVariable, AnnotatedTypeMirror> captureToAnnotatedCapture = new HashMap<>();\n+        for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+            TypeVariable typeVar =\n+                    (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+            AnnotatedTypeMirror preCapturedArg = typeToCapture.getTypeArguments().get(i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 419}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNjg2MTk3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzoyNTo0NlrOH4X7ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxODo0MzozM1rOH4as_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3NDM0MQ==", "bodyText": "Sometimes a variable named capture refers to a TypeMirror (example: captureToAnnotatedCapture).  Other times it refers to an AnnotatedTypeMirror, as here.\nI think the code will be clearer to read if there is a naming convention to distinguish them.  Maybe you can use a prefix or suffix:\n\n\"a\" vs \"\"\n\"a\" vs \"tm\"\n\"atm\" vs \"tm\"\nmaybe you can come up with a better convention.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528874341", "createdAt": "2020-11-23T17:25:46Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || typeToCapture.wasRaw()\n+                || typeToCapture.containsUninferredTypeArguments()\n+                || (capturedTypeMirror != null\n+                        && capturedTypeMirror.getTypeArguments().size()\n+                                != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // Create a mapping from type variables in typeDeclaration to type arguments.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArguments = new HashMap<>();\n+        Map<TypeVariable, AnnotatedTypeMirror> captureToAnnotatedCapture = new HashMap<>();\n+        for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+            TypeVariable typeVar =\n+                    (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+            AnnotatedTypeMirror preCapturedArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 420}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkxOTgwNw==", "bodyText": "I used \"\" vs \"TypeMirror\".  There weren't that mak", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528919807", "createdAt": "2020-11-23T18:43:33Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || typeToCapture.wasRaw()\n+                || typeToCapture.containsUninferredTypeArguments()\n+                || (capturedTypeMirror != null\n+                        && capturedTypeMirror.getTypeArguments().size()\n+                                != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // Create a mapping from type variables in typeDeclaration to type arguments.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArguments = new HashMap<>();\n+        Map<TypeVariable, AnnotatedTypeMirror> captureToAnnotatedCapture = new HashMap<>();\n+        for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+            TypeVariable typeVar =\n+                    (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+            AnnotatedTypeMirror preCapturedArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3NDM0MQ=="}, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 420}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNjg2NTE4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzoyNjozNFrOH4X9Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzoyNjozNFrOH4X9Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3NDgzOQ==", "bodyText": "How is typeDeclaration modified?  (Via aliasing?)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528874839", "createdAt": "2020-11-23T17:26:34Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || typeToCapture.wasRaw()\n+                || typeToCapture.containsUninferredTypeArguments()\n+                || (capturedTypeMirror != null\n+                        && capturedTypeMirror.getTypeArguments().size()\n+                                != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // Create a mapping from type variables in typeDeclaration to type arguments.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArguments = new HashMap<>();\n+        Map<TypeVariable, AnnotatedTypeMirror> captureToAnnotatedCapture = new HashMap<>();\n+        for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+            TypeVariable typeVar =\n+                    (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+            AnnotatedTypeMirror preCapturedArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+            if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())\n+                    && preCapturedArg.getKind() == TypeKind.WILDCARD) {\n+                // The type argument is a captured type. Use the type argument from the newly\n+                // created and yet-to-be annotated captureType. (The annotations are added as part\n+                // of capturing the wildcard.)\n+                typeVarToTypeArguments.put(typeVar, capturedTypeArg);\n+                // Also, add a mapping from the captured type mirror to the annotated captured\n+                // type, so that if one captured type refers to another, the correct annotated type\n+                // is used.\n+                captureToAnnotatedCapture.put(\n+                        ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+                        capturedTypeArg);\n+            } else {\n+                // The type argument is not a captured type. Use the type argument from\n+                // typeToCapture, which is fully-annotated.\n+                typeVarToTypeArguments.put(typeVar, preCapturedArg);\n+            }\n+        }\n+\n+        // Use the mapping above to substitute the type variables in capturedType and\n+        // typeDeclaration.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 441}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNjg5MjgyOnYy", "diffSide": "RIGHT", "path": "javacutil/src/main/java/org/checkerframework/javacutil/TypesUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzozMzozN1rOH4YOeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzozMzozN1rOH4YOeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3OTIyNg==", "bodyText": "Does this need to be public?  It feels like a helper method.\nAlso, I don't find the name free particularly evocative.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528879226", "createdAt": "2020-11-23T17:33:37Z", "author": {"login": "mernst"}, "path": "javacutil/src/main/java/org/checkerframework/javacutil/TypesUtils.java", "diffHunk": "@@ -879,4 +893,65 @@ public static TypeMirror substitute(\n                 com.sun.tools.javac.util.List.from(newP),\n                 com.sun.tools.javac.util.List.from(newT));\n     }\n+\n+    /**\n+     * Returns a fresh type variable, a captued typed, for {@code typeMirror}, if {@code typeMirror}\n+     * is a wildcard. If it is not a wildcard, {@code typeMirror} is returned\n+     *\n+     * @param typeMirror some type\n+     * @param env processing environment\n+     * @return a fresh type variable if {@code typeMirror} is a wildcard, or {@code type mirror}\n+     */\n+    public static TypeMirror freshTypeVariable(TypeMirror typeMirror, ProcessingEnvironment env) {\n+        JavacProcessingEnvironment javacEnv = (JavacProcessingEnvironment) env;\n+        com.sun.tools.javac.code.Types types =\n+                com.sun.tools.javac.code.Types.instance(javacEnv.getContext());\n+        return types.freshTypeVariables(com.sun.tools.javac.util.List.of((Type) typeMirror)).head;\n+    }\n+\n+    /**\n+     * Returns the list of type variables such that a type variable in the list only references type\n+     * variables at a lower index than itself.\n+     *\n+     * @param collection a collection of type variables\n+     * @param types types\n+     * @return the list of type variables such that a type variable in the list only references type\n+     *     variables at a lower index than itself\n+     */\n+    public static List<TypeVariable> order(Collection<TypeVariable> collection, Types types) {\n+        List<TypeVariable> list = new ArrayList<>(collection);\n+        List<TypeVariable> ordered = new ArrayList<>();\n+        while (!list.isEmpty()) {\n+            TypeVariable free = free(list, types);\n+            list.remove(free);\n+            ordered.add(free);\n+        }\n+        return ordered;\n+    }\n+\n+    /**\n+     * Returns the first TypeVariable in {@code collection} that does not contain any other type in\n+     * the collection, but maybe its self.\n+     *\n+     * @param collection a collection of type variables\n+     * @param types types\n+     * @return the first TypeVariable in {@code collection} that does not contain any other type in\n+     *     the collection, but maybe its self\n+     */\n+    @SuppressWarnings(\"interning:not.interned\") // must be the same object from collection\n+    public static TypeVariable free(Collection<? extends TypeVariable> collection, Types types) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNjkwMjE2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzozNTo1M1rOH4YT-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzozNTo1M1rOH4YT-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg4MDYzNQ==", "bodyText": "What is the distinction between typeArg and annoTypeArg?  Both are AnnotatedTypeMirrors.  Their names only reference their type, not their semantics or content.  Can you rename them?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528880635", "createdAt": "2020-11-23T17:35:53Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || typeToCapture.wasRaw()\n+                || typeToCapture.containsUninferredTypeArguments()\n+                || (capturedTypeMirror != null\n+                        && capturedTypeMirror.getTypeArguments().size()\n+                                != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // Create a mapping from type variables in typeDeclaration to type arguments.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArguments = new HashMap<>();\n+        Map<TypeVariable, AnnotatedTypeMirror> captureToAnnotatedCapture = new HashMap<>();\n+        for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+            TypeVariable typeVar =\n+                    (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+            AnnotatedTypeMirror preCapturedArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+            if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())\n+                    && preCapturedArg.getKind() == TypeKind.WILDCARD) {\n+                // The type argument is a captured type. Use the type argument from the newly\n+                // created and yet-to-be annotated captureType. (The annotations are added as part\n+                // of capturing the wildcard.)\n+                typeVarToTypeArguments.put(typeVar, capturedTypeArg);\n+                // Also, add a mapping from the captured type mirror to the annotated captured\n+                // type, so that if one captured type refers to another, the correct annotated type\n+                // is used.\n+                captureToAnnotatedCapture.put(\n+                        ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+                        capturedTypeArg);\n+            } else {\n+                // The type argument is not a captured type. Use the type argument from\n+                // typeToCapture, which is fully-annotated.\n+                typeVarToTypeArguments.put(typeVar, preCapturedArg);\n+            }\n+        }\n+\n+        // Use the mapping above to substitute the type variables in capturedType and\n+        // typeDeclaration.\n+        capturedType =\n+                (AnnotatedDeclaredType)\n+                        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+                                typeVarToTypeArguments, capturedType);\n+\n+        // Loop through the type arguments and set the annotations of each captured type.\n+        List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>(typeToCapture.typeArgs);\n+        List<TypeVariable> orderToCapture =\n+                TypesUtils.order(captureToAnnotatedCapture.keySet(), types);\n+        for (TypeVariable capture : orderToCapture) {\n+            AnnotatedTypeMirror typeArg = captureToAnnotatedCapture.get(capture);\n+            int i = capturedTypeMirror.getTypeArguments().indexOf(capture);\n+            AnnotatedTypeMirror annoTypeArg = typeToCapture.getTypeArguments().get(i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 454}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNjkwMzgzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzozNjoyMFrOH4YU-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxNzozNjoyMFrOH4YU-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg4MDg4OQ==", "bodyText": "This Javadoc comment isn't descriptive, especially since the next formal parameter has the same type.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528880889", "createdAt": "2020-11-23T17:36:20Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,202 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (type.getKind() != TypeKind.DECLARED && typeMirror.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || typeToCapture.wasRaw()\n+                || typeToCapture.containsUninferredTypeArguments()\n+                || (capturedTypeMirror != null\n+                        && capturedTypeMirror.getTypeArguments().size()\n+                                != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // Create a mapping from type variables in typeDeclaration to type arguments.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArguments = new HashMap<>();\n+        Map<TypeVariable, AnnotatedTypeMirror> captureToAnnotatedCapture = new HashMap<>();\n+        for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+            TypeVariable typeVar =\n+                    (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+            AnnotatedTypeMirror preCapturedArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+            if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())\n+                    && preCapturedArg.getKind() == TypeKind.WILDCARD) {\n+                // The type argument is a captured type. Use the type argument from the newly\n+                // created and yet-to-be annotated captureType. (The annotations are added as part\n+                // of capturing the wildcard.)\n+                typeVarToTypeArguments.put(typeVar, capturedTypeArg);\n+                // Also, add a mapping from the captured type mirror to the annotated captured\n+                // type, so that if one captured type refers to another, the correct annotated type\n+                // is used.\n+                captureToAnnotatedCapture.put(\n+                        ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+                        capturedTypeArg);\n+            } else {\n+                // The type argument is not a captured type. Use the type argument from\n+                // typeToCapture, which is fully-annotated.\n+                typeVarToTypeArguments.put(typeVar, preCapturedArg);\n+            }\n+        }\n+\n+        // Use the mapping above to substitute the type variables in capturedType and\n+        // typeDeclaration.\n+        capturedType =\n+                (AnnotatedDeclaredType)\n+                        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+                                typeVarToTypeArguments, capturedType);\n+\n+        // Loop through the type arguments and set the annotations of each captured type.\n+        List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>(typeToCapture.typeArgs);\n+        List<TypeVariable> orderToCapture =\n+                TypesUtils.order(captureToAnnotatedCapture.keySet(), types);\n+        for (TypeVariable capture : orderToCapture) {\n+            AnnotatedTypeMirror typeArg = captureToAnnotatedCapture.get(capture);\n+            int i = capturedTypeMirror.getTypeArguments().indexOf(capture);\n+            AnnotatedTypeMirror annoTypeArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeVariable typeVariable =\n+                    (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+            captureWildcard(\n+                    typeVarToTypeArguments,\n+                    captureToAnnotatedCapture,\n+                    (AnnotatedWildcardType) annoTypeArg,\n+                    typeVariable,\n+                    (AnnotatedTypeVariable) typeArg);\n+            newTypeArgs.remove(i);\n+            newTypeArgs.add(i, typeArg);\n+        }\n+        capturedType.setTypeArguments(newTypeArgs);\n+\n+        capturedType.addAnnotations(typeToCapture.getAnnotations());\n+        return capturedType;\n+    }\n+\n+    /**\n+     * Set the annotated bounds for fresh type variable {@code capturedArg}, so that it is the\n+     * capture of {@code wildcard}.\n+     *\n+     * @param argMapping substitution", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "485d269a1ba61151dc2141963f559d38fac50fc8"}, "originalPosition": 476}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzM3MTY1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTo0MzowN1rOH4ct5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTo0MzowN1rOH4ct5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1MjgwNg==", "bodyText": "One field is named lower, but this one uses Super.  I suggest making them consistent.  I would use \"lower\" rather than \"super\".", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528952806", "createdAt": "2020-11-23T19:43:07Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -267,97 +268,176 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Representation of a wildcard or captured wildcared so that {@link AnnotatedWildcardType} and\n+     * {@link AnnotatedTypeVariable} that are captured types, may be used interchangeably.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has a super bound that is not the null type. */\n+        protected final boolean hasSuperBound;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5eca70ca42da8b40dcf0edcd905d8951473889"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzM3NjA1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTo0NDoyNVrOH4cwdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxOTo0NDoyNVrOH4cwdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk1MzQ2MQ==", "bodyText": "Why is this field needed?  Can't clients just use the value of lower?  I would expect all methods to do the right thing when passed a null type (that is, a type with kind TypeKind.NULL).", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528953461", "createdAt": "2020-11-23T19:44:25Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -267,97 +268,176 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Representation of a wildcard or captured wildcared so that {@link AnnotatedWildcardType} and\n+     * {@link AnnotatedTypeVariable} that are captured types, may be used interchangeably.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has a super bound that is not the null type. */\n+        protected final boolean hasSuperBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasSuperBound = lower.getKind() != TypeKind.NULL;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d5eca70ca42da8b40dcf0edcd905d8951473889"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzQ0MTQ5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDowMjo0NVrOH4dXmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNDoyNzoyNVrOH5DVtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2MzQ4Mg==", "bodyText": "Does this need to be protected, or can it be public?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528963482", "createdAt": "2020-11-23T20:02:45Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -267,97 +268,176 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has a super bound that is not the null type. */\n+        protected final boolean hasSuperBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasSuperBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-     * Containment is described in <a\n+     * Containment is formally described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             typeargVisitHistory.add(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            typeargVisitHistory.add(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            typeargVisitHistory.add(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        typeargVisitHistory.add(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        typeargVisitHistory.add(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n+     * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n+     * Containment is described in <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n+     * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f382e9ff2f2786a0d490d7f71d4e01e28c0ee30"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU4NTU4OA==", "bodyText": "I could make it public, but there isn't much point.  Clients of DefaultTypeHierarchy access it via the interface TypeHierarchy whose only method is isSubtype.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r529585588", "createdAt": "2020-11-24T14:27:25Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -267,97 +268,176 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has a super bound that is not the null type. */\n+        protected final boolean hasSuperBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasSuperBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-     * Containment is described in <a\n+     * Containment is formally described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             typeargVisitHistory.add(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            typeargVisitHistory.add(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            typeargVisitHistory.add(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        typeargVisitHistory.add(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        typeargVisitHistory.add(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n+     * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n+     * Containment is described in <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n+     * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2MzQ4Mg=="}, "originalCommit": {"oid": "8f382e9ff2f2786a0d490d7f71d4e01e28c0ee30"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzQ0NDE3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDowMzo0MFrOH4dZZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDowMzo0MFrOH4dZZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2Mzk0MQ==", "bodyText": "Rather than repeating this, I would refer to isContainedBy().  You might be able to reduce the size of the previous paragraph too.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528963941", "createdAt": "2020-11-23T20:03:40Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -267,97 +268,176 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has a super bound that is not the null type. */\n+        protected final boolean hasSuperBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasSuperBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-     * Containment is described in <a\n+     * Containment is formally described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             typeargVisitHistory.add(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            typeargVisitHistory.add(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            typeargVisitHistory.add(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        typeargVisitHistory.add(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        typeargVisitHistory.add(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f382e9ff2f2786a0d490d7f71d4e01e28c0ee30"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzQ3MTU1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoxMTo0OFrOH4dpfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoxMTo0OFrOH4dpfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2ODA2MQ==", "bodyText": "I don't understand the logic of the next 7 lines.\nOne question is why there is a special case that depends on hasSuperBound.  I think that the lower bound will be the null type, and I would expect all the tests to work properly for such a type.\nIt would also be helpful to state the algorithm you are following.\nI think it's something like this:\nIf Outside is not a wildcard:\n  require equality\n  return\n\nif Inside is not a wildcard:\n  Inside must be the appropriate one of Outside's bounds\n  return\n\nlet Outside = ? super Lo extends Uo\nlet Inside = ? super Li extends Ui\nrequire Ui <: Uo\n        Lo <: Li\n\n(which is itself just a simplification of the first 5 bullet points in the containment algorithm of JLS 4.5.1) plus special cases for contravariance that I have not written down.  Is the algorithm as I stated it correct or incorrect?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528968061", "createdAt": "2020-11-23T20:11:48Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -267,97 +268,176 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has a super bound that is not the null type. */\n+        protected final boolean hasSuperBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasSuperBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-     * Containment is described in <a\n+     * Containment is formally described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             typeargVisitHistory.add(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            typeargVisitHistory.add(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            typeargVisitHistory.add(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        typeargVisitHistory.add(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        typeargVisitHistory.add(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n+     * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n+     * Containment is described in <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n+     * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasSuperBound && !outside.hasSuperBound) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f382e9ff2f2786a0d490d7f71d4e01e28c0ee30"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzQ3NTIwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoxMjo1MlrOH4drow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoxMjo1MlrOH4drow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2ODYxMQ==", "bodyText": "I cannot follow this comment.  Is glb the same as annos?  Please define \"lowest bound\".  (I see what it is from the code, but clarifying the intent will help to ensure that the two are consistent.)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528968611", "createdAt": "2020-11-23T20:12:52Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -267,97 +268,176 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has a super bound that is not the null type. */\n+        protected final boolean hasSuperBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasSuperBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-     * Containment is described in <a\n+     * Containment is formally described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             typeargVisitHistory.add(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            typeargVisitHistory.add(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            typeargVisitHistory.add(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        typeargVisitHistory.add(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        typeargVisitHistory.add(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n+     * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n+     * Containment is described in <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n+     * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasSuperBound && !outside.hasSuperBound) {\n+                return (canBeCovariant || isSubtype(outside.lower, insideBoundType.lower))\n+                        && isContainedByBoundType(insideBoundType.upper, outside, canBeCovariant);\n+            } else if (outside.hasSuperBound\n+                    || TypesUtils.isObject(outside.upper.getUnderlyingType())) {\n+                return (canBeCovariant || isSubtype(insideBoundType.upper, outside.upper))\n+                        && isContainedByBoundType(insideBoundType.lower, outside, canBeCovariant);\n             }\n-            outsideUpperBound = ((AnnotatedWildcardType) outsideUpperBound).getExtendsBound();\n         }\n \n-        AnnotatedTypeMirror castedInside =\n-                AnnotatedTypes.castedAsSuper(inside.atypeFactory, inside, outsideUpperBound);\n-        if (!isSubtypeCaching(castedInside, outsideUpperBound)) {\n-            return false;\n+        if (BoundType.isBoundType(outside.upper)) {\n+            BoundType outsideUpper = new BoundType(outside.upper);\n+            Set<AnnotationMirror> setA =\n+                    AnnotatedTypes.findEffectiveLowerBoundAnnotations(\n+                            qualifierHierarchy, outsideUpper.lower);\n+            Set<AnnotationMirror> setB =\n+                    AnnotatedTypes.findEffectiveLowerBoundAnnotations(\n+                            qualifierHierarchy, outside.lower);\n+            Set<? extends AnnotationMirror> glb =\n+                    qualifierHierarchy.greatestLowerBounds(setA, setB);\n+            addToLowestBound(outside.lower, glb);\n+            return isContainedByBoundType(inside, outsideUpper, canBeCovariant);\n+        } else if (BoundType.isBoundType(outside.lower)) {\n+            BoundType outsideLower = new BoundType(outside.lower);\n+            return isContainedByBoundType(inside, outsideLower, canBeCovariant);\n+        } else {\n+            if (canBeCovariant) {\n+                if (outside.hasSuperBound) {\n+                    return isSubtype(outside.lower, inside);\n+                } else {\n+                    return isSubtype(inside, outside.upper);\n+                }\n+            }\n+            return isSubtype(outside.lower, inside) && isSubtype(inside, outside.upper);\n         }\n+    }\n \n-        if (outside.getKind() == TypeKind.WILDCARD\n-                && outsideLowerBound.getKind() == TypeKind.TYPEVAR) {\n-            // tests/all-systems/Issue1991.java crashes without this.\n-            return true;\n+    /**\n+     * Add {@code glb} to the lowest bound of {@code type}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f382e9ff2f2786a0d490d7f71d4e01e28c0ee30"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNzQ3NjUwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoxMzoyMFrOH4dsbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QyMDoxMzoyMFrOH4dsbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODk2ODgxNA==", "bodyText": "Please add Javadoc to this method, which is used by your code.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r528968814", "createdAt": "2020-11-23T20:13:20Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -267,97 +268,176 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has a super bound that is not the null type. */\n+        protected final boolean hasSuperBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasSuperBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-     * Containment is described in <a\n+     * Containment is formally described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             typeargVisitHistory.add(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            typeargVisitHistory.add(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            typeargVisitHistory.add(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = typeargVisitHistory.result(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        typeargVisitHistory.add(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        typeargVisitHistory.add(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n+     * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n+     * Containment is described in <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n+     * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasSuperBound && !outside.hasSuperBound) {\n+                return (canBeCovariant || isSubtype(outside.lower, insideBoundType.lower))\n+                        && isContainedByBoundType(insideBoundType.upper, outside, canBeCovariant);\n+            } else if (outside.hasSuperBound\n+                    || TypesUtils.isObject(outside.upper.getUnderlyingType())) {\n+                return (canBeCovariant || isSubtype(insideBoundType.upper, outside.upper))\n+                        && isContainedByBoundType(insideBoundType.lower, outside, canBeCovariant);\n             }\n-            outsideUpperBound = ((AnnotatedWildcardType) outsideUpperBound).getExtendsBound();\n         }\n \n-        AnnotatedTypeMirror castedInside =\n-                AnnotatedTypes.castedAsSuper(inside.atypeFactory, inside, outsideUpperBound);\n-        if (!isSubtypeCaching(castedInside, outsideUpperBound)) {\n-            return false;\n+        if (BoundType.isBoundType(outside.upper)) {\n+            BoundType outsideUpper = new BoundType(outside.upper);\n+            Set<AnnotationMirror> setA =\n+                    AnnotatedTypes.findEffectiveLowerBoundAnnotations(\n+                            qualifierHierarchy, outsideUpper.lower);\n+            Set<AnnotationMirror> setB =\n+                    AnnotatedTypes.findEffectiveLowerBoundAnnotations(\n+                            qualifierHierarchy, outside.lower);\n+            Set<? extends AnnotationMirror> glb =\n+                    qualifierHierarchy.greatestLowerBounds(setA, setB);\n+            addToLowestBound(outside.lower, glb);\n+            return isContainedByBoundType(inside, outsideUpper, canBeCovariant);\n+        } else if (BoundType.isBoundType(outside.lower)) {\n+            BoundType outsideLower = new BoundType(outside.lower);\n+            return isContainedByBoundType(inside, outsideLower, canBeCovariant);\n+        } else {\n+            if (canBeCovariant) {\n+                if (outside.hasSuperBound) {\n+                    return isSubtype(outside.lower, inside);\n+                } else {\n+                    return isSubtype(inside, outside.upper);\n+                }\n+            }\n+            return isSubtype(outside.lower, inside) && isSubtype(inside, outside.upper);\n         }\n+    }\n \n-        if (outside.getKind() == TypeKind.WILDCARD\n-                && outsideLowerBound.getKind() == TypeKind.TYPEVAR) {\n-            // tests/all-systems/Issue1991.java crashes without this.\n-            return true;\n+    /**\n+     * Add {@code glb} to the lowest bound of {@code type}.\n+     *\n+     * @param type annotated type\n+     * @param annos annotations\n+     */\n+    private void addToLowestBound(AnnotatedTypeMirror type, Set<? extends AnnotationMirror> annos) {\n+        AnnotatedTypeMirror lowestBound = type;\n+        while (lowestBound.getKind() == TypeKind.TYPEVAR\n+                || lowestBound.getKind() == TypeKind.WILDCARD) {\n+            switch (lowestBound.getKind()) {\n+                case TYPEVAR:\n+                    lowestBound = ((AnnotatedTypeVariable) lowestBound).getLowerBound();\n+                    break;\n+                case WILDCARD:\n+                    lowestBound = ((AnnotatedWildcardType) lowestBound).getSuperBound();\n+                    break;\n+                default:\n+                    // not reachable\n+            }\n         }\n-        return canBeCovariant || isSubtypeCaching(outsideLowerBound, inside);\n+        lowestBound.replaceAnnotations(annos);\n     }\n \n     private boolean ignoreUninferredTypeArgument(AnnotatedTypeMirror type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f382e9ff2f2786a0d490d7f71d4e01e28c0ee30"}, "originalPosition": 250}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODIzMTAyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMDozMTo0M1rOH4kxwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMDozMTo0M1rOH4kxwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4NDg2NA==", "bodyText": "Why are both of these tested?  I would expect them to have the same value.  Should there be an assertion that the two boolean values are the same?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r529084864", "createdAt": "2020-11-24T00:31:43Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,203 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!(type.getKind() == TypeKind.DECLARED && typeMirror.getKind() == TypeKind.DECLARED)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e37fdf2c9f21f60e2044cbd0ad158c854df4fddd"}, "originalPosition": 338}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODIzMzIyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMDozMjozOVrOH4kzDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMDozMjozOVrOH4kzDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4NTE5OQ==", "bodyText": "Why is this size comparison necessary as part of the test?  I think that if it is true, there is some corruption.  Should you change this into an assertion?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r529085199", "createdAt": "2020-11-24T00:32:39Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,203 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!(type.getKind() == TypeKind.DECLARED && typeMirror.getKind() == TypeKind.DECLARED)) {\n+            return false;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.wasRaw() || typeToCapture.containsUninferredTypeArguments()) {\n+            return false;\n+        }\n+\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || (capturedTypeMirror.getTypeArguments().size()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e37fdf2c9f21f60e2044cbd0ad158c854df4fddd"}, "originalPosition": 349}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODI1NzY0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMDo0Mzo0MVrOH4lBzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNDo0ODoxN1rOH5ES4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4ODk3NQ==", "bodyText": "The map's key type is TypeVariable which is a subclass of TypeMirror.  Can you be more specific than \"type mirror\"?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r529088975", "createdAt": "2020-11-24T00:43:41Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,203 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!(type.getKind() == TypeKind.DECLARED && typeMirror.getKind() == TypeKind.DECLARED)) {\n+            return false;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.wasRaw() || typeToCapture.containsUninferredTypeArguments()) {\n+            return false;\n+        }\n+\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || (capturedTypeMirror.getTypeArguments().size()\n+                        != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // A mapping from type variable to its type argument in the captured type.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArgument = new HashMap<>();\n+        // A mapping from the captured type to the annotated captured type.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeMirrorToCapture = new HashMap<>();\n+        for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+            TypeVariable typeVarTypeMirror =\n+                    (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+            AnnotatedTypeMirror uncapturedTypeArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+            if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())\n+                    && uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+                // The type argument is a captured type. Use the type argument from the newly\n+                // created and yet-to-be annotated captureType. (The annotations are added as part\n+                // of capturing the wildcard.)\n+                typeVarToTypeArgument.put(typeVarTypeMirror, capturedTypeArg);\n+                // Also, add a mapping from the captured type mirror to the annotated captured\n+                // type, so that if one captured type refers to another, the correct annotated type\n+                // is used.\n+                typeMirrorToCapture.put(\n+                        ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+                        capturedTypeArg);\n+            } else {\n+                // The type argument is not a captured type. Use the type argument from\n+                // typeToCapture, which is fully-annotated.\n+                typeVarToTypeArgument.put(typeVarTypeMirror, uncapturedTypeArg);\n+            }\n+        }\n+\n+        // Use the mapping above to substitute the type variables in capturedType.\n+        capturedType =\n+                (AnnotatedDeclaredType)\n+                        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+                                typeVarToTypeArgument, capturedType);\n+\n+        // Loop through the type arguments and set the annotations of each captured type.\n+        List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>(typeToCapture.typeArgs);\n+        List<TypeVariable> orderToCapture = TypesUtils.order(typeMirrorToCapture.keySet(), types);\n+        for (TypeVariable capture : orderToCapture) {\n+            AnnotatedTypeMirror capturedTypeArg = typeMirrorToCapture.get(capture);\n+            int i = capturedTypeMirror.getTypeArguments().indexOf(capture);\n+            AnnotatedTypeMirror uncapturedTypeArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeVariable typeVariable =\n+                    (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+            captureWildcard(\n+                    typeVarToTypeArgument,\n+                    typeMirrorToCapture,\n+                    (AnnotatedWildcardType) uncapturedTypeArg,\n+                    typeVariable,\n+                    (AnnotatedTypeVariable) capturedTypeArg);\n+            newTypeArgs.remove(i);\n+            newTypeArgs.add(i, capturedTypeArg);\n+        }\n+        capturedType.setTypeArguments(newTypeArgs);\n+\n+        capturedType.addAnnotations(typeToCapture.getAnnotations());\n+        return capturedType;\n+    }\n+\n+    /**\n+     * Set the annotated bounds for fresh type variable {@code capturedArg}, so that it is the\n+     * capture of {@code wildcard}.\n+     *\n+     * @param argMapping mapping from type variable to its type argument\n+     * @param captureToAnnotatedCapture mapping from captured type mirror to captured annotated type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e37fdf2c9f21f60e2044cbd0ad158c854df4fddd"}, "originalPosition": 478}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYwMTI1MQ==", "bodyText": "It says \"captured type mirror\", not just \"type mirror\".", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r529601251", "createdAt": "2020-11-24T14:48:17Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,203 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!(type.getKind() == TypeKind.DECLARED && typeMirror.getKind() == TypeKind.DECLARED)) {\n+            return false;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.wasRaw() || typeToCapture.containsUninferredTypeArguments()) {\n+            return false;\n+        }\n+\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || (capturedTypeMirror.getTypeArguments().size()\n+                        != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // A mapping from type variable to its type argument in the captured type.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArgument = new HashMap<>();\n+        // A mapping from the captured type to the annotated captured type.\n+        Map<TypeVariable, AnnotatedTypeMirror> typeMirrorToCapture = new HashMap<>();\n+        for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+            TypeVariable typeVarTypeMirror =\n+                    (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+            AnnotatedTypeMirror uncapturedTypeArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+            if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())\n+                    && uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+                // The type argument is a captured type. Use the type argument from the newly\n+                // created and yet-to-be annotated captureType. (The annotations are added as part\n+                // of capturing the wildcard.)\n+                typeVarToTypeArgument.put(typeVarTypeMirror, capturedTypeArg);\n+                // Also, add a mapping from the captured type mirror to the annotated captured\n+                // type, so that if one captured type refers to another, the correct annotated type\n+                // is used.\n+                typeMirrorToCapture.put(\n+                        ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+                        capturedTypeArg);\n+            } else {\n+                // The type argument is not a captured type. Use the type argument from\n+                // typeToCapture, which is fully-annotated.\n+                typeVarToTypeArgument.put(typeVarTypeMirror, uncapturedTypeArg);\n+            }\n+        }\n+\n+        // Use the mapping above to substitute the type variables in capturedType.\n+        capturedType =\n+                (AnnotatedDeclaredType)\n+                        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+                                typeVarToTypeArgument, capturedType);\n+\n+        // Loop through the type arguments and set the annotations of each captured type.\n+        List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>(typeToCapture.typeArgs);\n+        List<TypeVariable> orderToCapture = TypesUtils.order(typeMirrorToCapture.keySet(), types);\n+        for (TypeVariable capture : orderToCapture) {\n+            AnnotatedTypeMirror capturedTypeArg = typeMirrorToCapture.get(capture);\n+            int i = capturedTypeMirror.getTypeArguments().indexOf(capture);\n+            AnnotatedTypeMirror uncapturedTypeArg = typeToCapture.getTypeArguments().get(i);\n+            AnnotatedTypeVariable typeVariable =\n+                    (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+            captureWildcard(\n+                    typeVarToTypeArgument,\n+                    typeMirrorToCapture,\n+                    (AnnotatedWildcardType) uncapturedTypeArg,\n+                    typeVariable,\n+                    (AnnotatedTypeVariable) capturedTypeArg);\n+            newTypeArgs.remove(i);\n+            newTypeArgs.add(i, capturedTypeArg);\n+        }\n+        capturedType.setTypeArguments(newTypeArgs);\n+\n+        capturedType.addAnnotations(typeToCapture.getAnnotations());\n+        return capturedType;\n+    }\n+\n+    /**\n+     * Set the annotated bounds for fresh type variable {@code capturedArg}, so that it is the\n+     * capture of {@code wildcard}.\n+     *\n+     * @param argMapping mapping from type variable to its type argument\n+     * @param captureToAnnotatedCapture mapping from captured type mirror to captured annotated type", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4ODk3NQ=="}, "originalCommit": {"oid": "e37fdf2c9f21f60e2044cbd0ad158c854df4fddd"}, "originalPosition": 478}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODI1ODk2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMDo0NDoxOFrOH4lCoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMDo0NDoxOFrOH4lCoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA4OTE4NA==", "bodyText": "The variable naming is confusing.\n\nVariable typeToCapture refers to a single type that needs to be captured.\nVariable typeVarToTypeArgument uses \"To\" to indicate a map type.\nVariable typeMirrorToCapture also uses \"To\", but I'm not sure which meaning of \"To\" it intends.  Maybe it should be \"ToCaptured\"??  Another method uses the name captureToAnnotatedCapture for the same value (I think), which also might be better.  Once you find a good name, use it consistently.\n\nIn the following two variables, the key types are the same, but the documentation refers to it inconsistently as a \"type variable\" (this checks out) and a \"captured type\" (which seems a bit confusing).  Also, how does \"the captured type\" relate to the variable capturedType?\n        // A mapping from type variable to its type argument in the captured type.\n        Map<TypeVariable, AnnotatedTypeMirror> typeVarToTypeArgument = new HashMap<>();\n        // A mapping from the captured type to the annotated captured type.\n        Map<TypeVariable, AnnotatedTypeMirror> typeMirrorToCapture = new HashMap<>();", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r529089184", "createdAt": "2020-11-24T00:44:18Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4240,6 +4291,203 @@ private void makeGroundTargetType(\n         addDefaultAnnotations(functionalType);\n     }\n \n+    /**\n+     * Return true if {@code type} should be captured.\n+     *\n+     * <ul>\n+     *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+     *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and\n+     *       must have a wildcard as a type argument.\n+     *   <li>{@code typeMirror} must have a captured type as a type argument.\n+     * </ul>\n+     *\n+     * @param type annotated type to capture\n+     * @param typeMirror underlying Java type\n+     * @return true if {@code type} should be captured\n+     */\n+    private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!(type.getKind() == TypeKind.DECLARED && typeMirror.getKind() == TypeKind.DECLARED)) {\n+            return false;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        if (typeToCapture.wasRaw() || typeToCapture.containsUninferredTypeArguments()) {\n+            return false;\n+        }\n+\n+        if (typeToCapture.getTypeArguments().isEmpty()\n+                || (capturedTypeMirror.getTypeArguments().size()\n+                        != typeToCapture.getTypeArguments().size())) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+            if (TypesUtils.isCaptured(capturedTypeMirror.getTypeArguments().get(i))\n+                    && typeToCapture.getTypeArguments().get(i).getKind() == TypeKind.WILDCARD) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param typeToCapture type to capture\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+        TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+        return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+    }\n+\n+    /**\n+     * Apply capture conversion.\n+     *\n+     * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+     * variables. See <a\n+     * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS\n+     * 5.1.10</a> for all the details.\n+     *\n+     * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+     * this method returns {@code type}.\n+     *\n+     * @param type type to capture\n+     * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+     *     the underlying type of the captured wildcards\n+     * @return the captured type\n+     */\n+    public AnnotatedTypeMirror applyCaptureConversion(\n+            AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+        if (!shouldCapture(type, typeMirror)) {\n+            return type;\n+        }\n+\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType typeToCapture = (AnnotatedDeclaredType) type;\n+        AnnotatedDeclaredType capturedType =\n+                (AnnotatedDeclaredType)\n+                        AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+        capturedType.getTypeArguments(); // initialize the type arguments\n+\n+        AnnotatedDeclaredType typeDeclaration =\n+                (AnnotatedDeclaredType)\n+                        getAnnotatedType(typeToCapture.getUnderlyingType().asElement());\n+\n+        // A mapping from type variable to its type argument in the captured type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e37fdf2c9f21f60e2044cbd0ad158c854df4fddd"}, "originalPosition": 415}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNjczMTgyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNDo0ODowNlrOH52w7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNDo0ODowNlrOH52w7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQyODE0MQ==", "bodyText": "Here or in the overview documentation of BoundType, please state the object invariants.  I think that one of the two fields lower and upper is always trivial/vacuous/degenerate; that is, either the lower bound is Void/NULL, or the upper bound is Object.  It is also possible for both of those conditions to hold.  Is that correct?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530428141", "createdAt": "2020-11-25T14:48:06Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNjc0NDU1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNDo1MDo1NVrOH5248A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNDo1MDo1NVrOH5248A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQzMDE5Mg==", "bodyText": "Is it the case that the algorithm can ignore the other bound because it is always trivial (is a Void/NULL lower bound or is an Object upper bound)?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530430192", "createdAt": "2020-11-25T14:50:55Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has an explict lower (super) bound that is not the null type. */\n+        protected final boolean hasExplicitLowerBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasExplicitLowerBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n      * Containment is described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * <p>The containment algorithm implemented here is slightly different that what is presented in\n+     * the JLS. The Checker Framework checks that method arguments are subtype of the method\n+     * parameters that have been view-point-adapted to the call site. Java does not do this check;\n+     * instead, it checks if an applicable method exist. By checking that method arguments are\n+     * subtypes of view-point-adapted parameters, the Checker Framework gives better error messages.\n+     * However, view-point-adapting parameters leads to types that Java does not account for in the\n+     * containment algorithm, namely wildcards with upper or lower bounds that are captured types.\n+     * In these cases, containment is called recursively on captured type bound. (Note, it must\n+     * recur rather than call isSubtype because the inside type may be in between the bounds of the\n+     * upper or lower bound. For example: outside: ? extends ? extends Object inside: String)\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             areEqualVisitHistory.put(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            areEqualVisitHistory.put(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            areEqualVisitHistory.put(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        areEqualVisitHistory.put(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        areEqualVisitHistory.put(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     * See {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+     * explanation.\n+     *\n+     * <p>Roughly, the algorithm works as follows (assuming {@code canBeCovariant} is false):\n+     *\n+     * <ul>\n+     *   <li>If inside is a bound type, recur on the explicit bound.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNjc1NDc2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNDo1MzowOFrOH52_XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNDo1MzowOFrOH52_XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQzMTgzNg==", "bodyText": "Why is the outside.hasExplicitLowerBound part of this test necessary?  If my guess about object invariants is correct, then if there is an explicit lower bound, the upper bound is Object, and the other disjunct will definitely evaluate to true.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530431836", "createdAt": "2020-11-25T14:53:08Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has an explict lower (super) bound that is not the null type. */\n+        protected final boolean hasExplicitLowerBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasExplicitLowerBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n      * Containment is described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * <p>The containment algorithm implemented here is slightly different that what is presented in\n+     * the JLS. The Checker Framework checks that method arguments are subtype of the method\n+     * parameters that have been view-point-adapted to the call site. Java does not do this check;\n+     * instead, it checks if an applicable method exist. By checking that method arguments are\n+     * subtypes of view-point-adapted parameters, the Checker Framework gives better error messages.\n+     * However, view-point-adapting parameters leads to types that Java does not account for in the\n+     * containment algorithm, namely wildcards with upper or lower bounds that are captured types.\n+     * In these cases, containment is called recursively on captured type bound. (Note, it must\n+     * recur rather than call isSubtype because the inside type may be in between the bounds of the\n+     * upper or lower bound. For example: outside: ? extends ? extends Object inside: String)\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             areEqualVisitHistory.put(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            areEqualVisitHistory.put(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            areEqualVisitHistory.put(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        areEqualVisitHistory.put(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        areEqualVisitHistory.put(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     * See {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+     * explanation.\n+     *\n+     * <p>Roughly, the algorithm works as follows (assuming {@code canBeCovariant} is false):\n+     *\n+     * <ul>\n+     *   <li>If inside is a bound type, recur on the explicit bound.\n+     *   <li>If one of outside's bounds is itself a bound type, recur on that bound.\n+     *   <li>Otherwise, return {@code outside.lower <: inside && inside <: outside.upper}.\n+     * </ul>\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasExplicitLowerBound && !outside.hasExplicitLowerBound) {\n+                return (canBeCovariant || isSubtype(outside.lower, insideBoundType.lower))\n+                        && isContainedByBoundType(insideBoundType.upper, outside, canBeCovariant);\n+            } else if (outside.hasExplicitLowerBound", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNjc3MzY0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNDo1NzowNFrOH53LYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNDo1NzowNFrOH53LYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQzNDkxMg==", "bodyText": "This logic looks wrong to me (and it differs from the last 4 lines of isContainedBy.\nI think the logic should be\n(canBeCovariant && isSubtype(outside.lower, insideBoundType.lower))\n|| isContainedByBoundType(insideBoundType.upper, outside, canBeCovariant)\nor\ncanBeCovariant ? isSubtype(outside.lower, insideBoundType.lower))\n: isContainedByBoundType(insideBoundType.upper, outside, canBeCovariant)\nNote that these two proposals are not logically equivalent.  Both express approximately:  \"if canBeCovariant is true, then use isSubtype, otherwise use isContainedByBoundType.\"  I'm not sure which one you would want to use.  If the current code is correct, please explain it.\nThe same comment applies just below.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530434912", "createdAt": "2020-11-25T14:57:04Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has an explict lower (super) bound that is not the null type. */\n+        protected final boolean hasExplicitLowerBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasExplicitLowerBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n      * Containment is described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * <p>The containment algorithm implemented here is slightly different that what is presented in\n+     * the JLS. The Checker Framework checks that method arguments are subtype of the method\n+     * parameters that have been view-point-adapted to the call site. Java does not do this check;\n+     * instead, it checks if an applicable method exist. By checking that method arguments are\n+     * subtypes of view-point-adapted parameters, the Checker Framework gives better error messages.\n+     * However, view-point-adapting parameters leads to types that Java does not account for in the\n+     * containment algorithm, namely wildcards with upper or lower bounds that are captured types.\n+     * In these cases, containment is called recursively on captured type bound. (Note, it must\n+     * recur rather than call isSubtype because the inside type may be in between the bounds of the\n+     * upper or lower bound. For example: outside: ? extends ? extends Object inside: String)\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             areEqualVisitHistory.put(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            areEqualVisitHistory.put(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            areEqualVisitHistory.put(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        areEqualVisitHistory.put(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        areEqualVisitHistory.put(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     * See {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+     * explanation.\n+     *\n+     * <p>Roughly, the algorithm works as follows (assuming {@code canBeCovariant} is false):\n+     *\n+     * <ul>\n+     *   <li>If inside is a bound type, recur on the explicit bound.\n+     *   <li>If one of outside's bounds is itself a bound type, recur on that bound.\n+     *   <li>Otherwise, return {@code outside.lower <: inside && inside <: outside.upper}.\n+     * </ul>\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasExplicitLowerBound && !outside.hasExplicitLowerBound) {\n+                return (canBeCovariant || isSubtype(outside.lower, insideBoundType.lower))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNjc5NzUwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTowMjowN1rOH53aSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTowMjowN1rOH53aSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQzODczMQ==", "bodyText": "Rather than using negation, it might be a touch clearer here to add a method hasExplicitUpperBound() to BoundType.  Then this test can be\nif (insideBoundType.hasExplicitUpperBound() && outside.hasExplicitUpperBound())\nwhich I think is more readable.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530438731", "createdAt": "2020-11-25T15:02:07Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has an explict lower (super) bound that is not the null type. */\n+        protected final boolean hasExplicitLowerBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasExplicitLowerBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n      * Containment is described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * <p>The containment algorithm implemented here is slightly different that what is presented in\n+     * the JLS. The Checker Framework checks that method arguments are subtype of the method\n+     * parameters that have been view-point-adapted to the call site. Java does not do this check;\n+     * instead, it checks if an applicable method exist. By checking that method arguments are\n+     * subtypes of view-point-adapted parameters, the Checker Framework gives better error messages.\n+     * However, view-point-adapting parameters leads to types that Java does not account for in the\n+     * containment algorithm, namely wildcards with upper or lower bounds that are captured types.\n+     * In these cases, containment is called recursively on captured type bound. (Note, it must\n+     * recur rather than call isSubtype because the inside type may be in between the bounds of the\n+     * upper or lower bound. For example: outside: ? extends ? extends Object inside: String)\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             areEqualVisitHistory.put(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            areEqualVisitHistory.put(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            areEqualVisitHistory.put(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        areEqualVisitHistory.put(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        areEqualVisitHistory.put(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     * See {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+     * explanation.\n+     *\n+     * <p>Roughly, the algorithm works as follows (assuming {@code canBeCovariant} is false):\n+     *\n+     * <ul>\n+     *   <li>If inside is a bound type, recur on the explicit bound.\n+     *   <li>If one of outside's bounds is itself a bound type, recur on that bound.\n+     *   <li>Otherwise, return {@code outside.lower <: inside && inside <: outside.upper}.\n+     * </ul>\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasExplicitLowerBound && !outside.hasExplicitLowerBound) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNjgwNzg2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTowNDoxOVrOH53gvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTowNDoxOVrOH53gvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0MDM4MA==", "bodyText": "Another confusing thing about this code is that it is within a test !insideBoundType.hasExplicitLowerBound and it uses outsideBoundType.lower.  If my guess about object invariants is right, then whenever hasExplicitLowerBound is false, the lower bound is Void/NULL, and there doesn't seem to be much point in doing a test against two occurrences of Void/NULL.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530440380", "createdAt": "2020-11-25T15:04:19Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has an explict lower (super) bound that is not the null type. */\n+        protected final boolean hasExplicitLowerBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasExplicitLowerBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n      * Containment is described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * <p>The containment algorithm implemented here is slightly different that what is presented in\n+     * the JLS. The Checker Framework checks that method arguments are subtype of the method\n+     * parameters that have been view-point-adapted to the call site. Java does not do this check;\n+     * instead, it checks if an applicable method exist. By checking that method arguments are\n+     * subtypes of view-point-adapted parameters, the Checker Framework gives better error messages.\n+     * However, view-point-adapting parameters leads to types that Java does not account for in the\n+     * containment algorithm, namely wildcards with upper or lower bounds that are captured types.\n+     * In these cases, containment is called recursively on captured type bound. (Note, it must\n+     * recur rather than call isSubtype because the inside type may be in between the bounds of the\n+     * upper or lower bound. For example: outside: ? extends ? extends Object inside: String)\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             areEqualVisitHistory.put(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            areEqualVisitHistory.put(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            areEqualVisitHistory.put(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        areEqualVisitHistory.put(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        areEqualVisitHistory.put(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     * See {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+     * explanation.\n+     *\n+     * <p>Roughly, the algorithm works as follows (assuming {@code canBeCovariant} is false):\n+     *\n+     * <ul>\n+     *   <li>If inside is a bound type, recur on the explicit bound.\n+     *   <li>If one of outside's bounds is itself a bound type, recur on that bound.\n+     *   <li>Otherwise, return {@code outside.lower <: inside && inside <: outside.upper}.\n+     * </ul>\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasExplicitLowerBound && !outside.hasExplicitLowerBound) {\n+                return (canBeCovariant || isSubtype(outside.lower, insideBoundType.lower))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNjgxNDQ1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTowNTo0NVrOH53kzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTowNTo0NVrOH53kzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0MTQyMA==", "bodyText": "The following code also seems to assume that at least one of the bounds of BoundType is non-trivial.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530441420", "createdAt": "2020-11-25T15:05:45Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has an explict lower (super) bound that is not the null type. */\n+        protected final boolean hasExplicitLowerBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasExplicitLowerBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n      * Containment is described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * <p>The containment algorithm implemented here is slightly different that what is presented in\n+     * the JLS. The Checker Framework checks that method arguments are subtype of the method\n+     * parameters that have been view-point-adapted to the call site. Java does not do this check;\n+     * instead, it checks if an applicable method exist. By checking that method arguments are\n+     * subtypes of view-point-adapted parameters, the Checker Framework gives better error messages.\n+     * However, view-point-adapting parameters leads to types that Java does not account for in the\n+     * containment algorithm, namely wildcards with upper or lower bounds that are captured types.\n+     * In these cases, containment is called recursively on captured type bound. (Note, it must\n+     * recur rather than call isSubtype because the inside type may be in between the bounds of the\n+     * upper or lower bound. For example: outside: ? extends ? extends Object inside: String)\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             areEqualVisitHistory.put(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            areEqualVisitHistory.put(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            areEqualVisitHistory.put(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        areEqualVisitHistory.put(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        areEqualVisitHistory.put(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     * See {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+     * explanation.\n+     *\n+     * <p>Roughly, the algorithm works as follows (assuming {@code canBeCovariant} is false):\n+     *\n+     * <ul>\n+     *   <li>If inside is a bound type, recur on the explicit bound.\n+     *   <li>If one of outside's bounds is itself a bound type, recur on that bound.\n+     *   <li>Otherwise, return {@code outside.lower <: inside && inside <: outside.upper}.\n+     * </ul>\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasExplicitLowerBound && !outside.hasExplicitLowerBound) {\n+                return (canBeCovariant || isSubtype(outside.lower, insideBoundType.lower))\n+                        && isContainedByBoundType(insideBoundType.upper, outside, canBeCovariant);\n+            } else if (outside.hasExplicitLowerBound\n+                    || TypesUtils.isObject(outside.upper.getUnderlyingType())) {\n+                return (canBeCovariant || isSubtype(insideBoundType.upper, outside.upper))\n+                        && isContainedByBoundType(insideBoundType.lower, outside, canBeCovariant);\n             }\n-            outsideUpperBound = ((AnnotatedWildcardType) outsideUpperBound).getExtendsBound();\n         }\n \n-        AnnotatedTypeMirror castedInside =\n-                AnnotatedTypes.castedAsSuper(inside.atypeFactory, inside, outsideUpperBound);\n-        if (!isSubtypeCaching(castedInside, outsideUpperBound)) {\n-            return false;\n+        if (BoundType.isBoundType(outside.upper)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNjgxOTgxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTowNjo1OFrOH53oMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNTowNjo1OFrOH53oMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0MjI4OA==", "bodyText": "I'm not sure how this affects the result.  It changes outside's lowest bound, but the return statement on the next line uses outsideUpper which is unaffected by this method call.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530442288", "createdAt": "2020-11-25T15:06:58Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has an explict lower (super) bound that is not the null type. */\n+        protected final boolean hasExplicitLowerBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasExplicitLowerBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n      * Containment is described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * <p>The containment algorithm implemented here is slightly different that what is presented in\n+     * the JLS. The Checker Framework checks that method arguments are subtype of the method\n+     * parameters that have been view-point-adapted to the call site. Java does not do this check;\n+     * instead, it checks if an applicable method exist. By checking that method arguments are\n+     * subtypes of view-point-adapted parameters, the Checker Framework gives better error messages.\n+     * However, view-point-adapting parameters leads to types that Java does not account for in the\n+     * containment algorithm, namely wildcards with upper or lower bounds that are captured types.\n+     * In these cases, containment is called recursively on captured type bound. (Note, it must\n+     * recur rather than call isSubtype because the inside type may be in between the bounds of the\n+     * upper or lower bound. For example: outside: ? extends ? extends Object inside: String)\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             areEqualVisitHistory.put(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            areEqualVisitHistory.put(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            areEqualVisitHistory.put(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        areEqualVisitHistory.put(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        areEqualVisitHistory.put(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     * See {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+     * explanation.\n+     *\n+     * <p>Roughly, the algorithm works as follows (assuming {@code canBeCovariant} is false):\n+     *\n+     * <ul>\n+     *   <li>If inside is a bound type, recur on the explicit bound.\n+     *   <li>If one of outside's bounds is itself a bound type, recur on that bound.\n+     *   <li>Otherwise, return {@code outside.lower <: inside && inside <: outside.upper}.\n+     * </ul>\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasExplicitLowerBound && !outside.hasExplicitLowerBound) {\n+                return (canBeCovariant || isSubtype(outside.lower, insideBoundType.lower))\n+                        && isContainedByBoundType(insideBoundType.upper, outside, canBeCovariant);\n+            } else if (outside.hasExplicitLowerBound\n+                    || TypesUtils.isObject(outside.upper.getUnderlyingType())) {\n+                return (canBeCovariant || isSubtype(insideBoundType.upper, outside.upper))\n+                        && isContainedByBoundType(insideBoundType.lower, outside, canBeCovariant);\n             }\n-            outsideUpperBound = ((AnnotatedWildcardType) outsideUpperBound).getExtendsBound();\n         }\n \n-        AnnotatedTypeMirror castedInside =\n-                AnnotatedTypes.castedAsSuper(inside.atypeFactory, inside, outsideUpperBound);\n-        if (!isSubtypeCaching(castedInside, outsideUpperBound)) {\n-            return false;\n+        if (BoundType.isBoundType(outside.upper)) {\n+            BoundType outsideUpper = new BoundType(outside.upper);\n+            Set<AnnotationMirror> setA =\n+                    AnnotatedTypes.findEffectiveLowerBoundAnnotations(\n+                            qualifierHierarchy, outsideUpper.lower);\n+            Set<AnnotationMirror> setB =\n+                    AnnotatedTypes.findEffectiveLowerBoundAnnotations(\n+                            qualifierHierarchy, outside.lower);\n+            Set<? extends AnnotationMirror> glb =\n+                    qualifierHierarchy.greatestLowerBounds(setA, setB);\n+            addToLowestBound(outside.lower, glb);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNjg0MTI3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNToxMTo0N1rOH531vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNToxMTo0N1rOH531vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0NTc1OQ==", "bodyText": "Is this if test an optimization to save resources compared to the return ... && ... statement on line 435, or is it logically necessary?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r530445759", "createdAt": "2020-11-25T15:11:47Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -272,106 +273,206 @@ protected boolean areEqualInHierarchy(\n     }\n \n     /**\n-     * A declared type is considered a supertype of another declared type only if all of the type\n+     * Represents a wildcard or captured wildcard. Use this to avoid the need for special-case code\n+     * for {@link AnnotatedWildcardType} and {@link AnnotatedTypeVariable}.\n+     */\n+    protected static class BoundType {\n+\n+        /** Lower bound. */\n+        protected final AnnotatedTypeMirror lower;\n+\n+        /** Upper bound. */\n+        protected final AnnotatedTypeMirror upper;\n+\n+        /** Whether this has an explict lower (super) bound that is not the null type. */\n+        protected final boolean hasExplicitLowerBound;\n+\n+        /**\n+         * Creates a bound type.\n+         *\n+         * @param type a wildcard or a captured wildcard\n+         */\n+        protected BoundType(AnnotatedTypeMirror type) {\n+            if (type.getKind() == TypeKind.WILDCARD) {\n+                AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) type;\n+                this.lower = wildcardType.getSuperBound();\n+                this.upper = wildcardType.getExtendsBound();\n+\n+            } else if (TypesUtils.isCaptured(type.getUnderlyingType())) {\n+                AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) type;\n+                this.lower = typeVariable.getLowerBound();\n+                this.upper = typeVariable.getUpperBound();\n+            } else {\n+                throw new BugInCF(\"Unexpected: %s\", type);\n+            }\n+            this.hasExplicitLowerBound = lower.getKind() != TypeKind.NULL;\n+        }\n+\n+        /**\n+         * Returns true if {@code type} is a wildcard or captured wildcard.\n+         *\n+         * @param type type to check\n+         * @return true if {@code type} is a wildcard or captured wildcard\n+         */\n+        protected static boolean isBoundType(AnnotatedTypeMirror type) {\n+            return type.getKind() == TypeKind.WILDCARD\n+                    || TypesUtils.isCaptured(type.getUnderlyingType());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[ extends \" + upper + \" super \" + lower + ']';\n+        }\n+    }\n+\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     *\n+     * <p>A declared type is considered a supertype of another declared type only if all of the type\n      * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n      * Containment is described in <a\n      * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n      * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n      *\n-     * @param inside a type argument of the \"subtype\"\n-     * @param outside a type argument of the \"supertype\"\n+     * <p>The containment algorithm implemented here is slightly different that what is presented in\n+     * the JLS. The Checker Framework checks that method arguments are subtype of the method\n+     * parameters that have been view-point-adapted to the call site. Java does not do this check;\n+     * instead, it checks if an applicable method exist. By checking that method arguments are\n+     * subtypes of view-point-adapted parameters, the Checker Framework gives better error messages.\n+     * However, view-point-adapting parameters leads to types that Java does not account for in the\n+     * containment algorithm, namely wildcards with upper or lower bounds that are captured types.\n+     * In these cases, containment is called recursively on captured type bound. (Note, it must\n+     * recur rather than call isSubtype because the inside type may be in between the bounds of the\n+     * upper or lower bound. For example: outside: ? extends ? extends Object inside: String)\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n      * @param canBeCovariant whether or not type arguments are allowed to be covariant\n      * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n      *     inside <: outside}\n      */\n     protected boolean isContainedBy(\n-            final AnnotatedTypeMirror inside,\n-            final AnnotatedTypeMirror outside,\n-            boolean canBeCovariant) {\n+            AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n         if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n             areEqualVisitHistory.put(inside, outside, currentTop, true);\n             return true;\n         }\n-\n-        if (outside.getKind() != TypeKind.WILDCARD\n-                && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            if (canBeCovariant) {\n-                return isSubtype(inside, outside, currentTop);\n+        if (BoundType.isBoundType(outside)) {\n+            Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+            if (previousResult != null) {\n+                return previousResult;\n             }\n-            return areEqualInHierarchy(inside, outside);\n-        }\n-\n-        AnnotatedTypeMirror outsideUpperBound;\n-        AnnotatedTypeMirror outsideLowerBound;\n-        if (outside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-            outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-        } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-            outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-            outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-        } else {\n-            throw new BugInCF(\n-                    \"Expected a wildcard or captured type variable, but found \" + outside);\n+            areEqualVisitHistory.put(inside, outside, currentTop, true);\n+            boolean result = isContainedByBoundType(inside, new BoundType(outside), canBeCovariant);\n+            areEqualVisitHistory.put(inside, outside, currentTop, result);\n+            return result;\n         }\n-        Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-        if (previousResult != null) {\n-            return previousResult;\n+        if (canBeCovariant) {\n+            return isSubtype(inside, outside, currentTop);\n         }\n-\n-        areEqualVisitHistory.put(inside, outside, currentTop, true);\n-        boolean result =\n-                isContainedWildcard(\n-                        inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-        areEqualVisitHistory.put(inside, outside, currentTop, result);\n-        return result;\n+        return areEqualInHierarchy(inside, outside);\n     }\n \n-    private boolean isContainedWildcard(\n-            AnnotatedTypeMirror inside,\n-            AnnotatedTypeMirror outside,\n-            AnnotatedTypeMirror outsideUpperBound,\n-            AnnotatedTypeMirror outsideLowerBound,\n-            boolean canBeCovariant) {\n-\n-        if (inside.equals(outside)) {\n-            // If they are equal, outside always contains inside.\n-            return true;\n-        }\n-\n-        if (inside.getKind() == TypeKind.WILDCARD) {\n-            outsideUpperBound =\n-                    checker.getTypeFactory()\n-                            .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-        }\n-        while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-            if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-                return true;\n+    /**\n+     * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+     * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+     * See {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+     * explanation.\n+     *\n+     * <p>Roughly, the algorithm works as follows (assuming {@code canBeCovariant} is false):\n+     *\n+     * <ul>\n+     *   <li>If inside is a bound type, recur on the explicit bound.\n+     *   <li>If one of outside's bounds is itself a bound type, recur on that bound.\n+     *   <li>Otherwise, return {@code outside.lower <: inside && inside <: outside.upper}.\n+     * </ul>\n+     *\n+     * @param inside a possibly-contained type\n+     * @param outside a possibly-containing type\n+     * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+     * @return true if inside is contained by outside, or if canBeCovariant == true and {@code\n+     *     inside <: outside}\n+     */\n+    protected boolean isContainedByBoundType(\n+            AnnotatedTypeMirror inside, BoundType outside, boolean canBeCovariant) {\n+        if (BoundType.isBoundType(inside)) {\n+            BoundType insideBoundType = new BoundType(inside);\n+            if (!insideBoundType.hasExplicitLowerBound && !outside.hasExplicitLowerBound) {\n+                return (canBeCovariant || isSubtype(outside.lower, insideBoundType.lower))\n+                        && isContainedByBoundType(insideBoundType.upper, outside, canBeCovariant);\n+            } else if (outside.hasExplicitLowerBound\n+                    || TypesUtils.isObject(outside.upper.getUnderlyingType())) {\n+                return (canBeCovariant || isSubtype(insideBoundType.upper, outside.upper))\n+                        && isContainedByBoundType(insideBoundType.lower, outside, canBeCovariant);\n             }\n-            outsideUpperBound = ((AnnotatedWildcardType) outsideUpperBound).getExtendsBound();\n         }\n \n-        AnnotatedTypeMirror castedInside =\n-                AnnotatedTypes.castedAsSuper(inside.atypeFactory, inside, outsideUpperBound);\n-        if (!isSubtypeCaching(castedInside, outsideUpperBound)) {\n-            return false;\n+        if (BoundType.isBoundType(outside.upper)) {\n+            BoundType outsideUpper = new BoundType(outside.upper);\n+            Set<AnnotationMirror> setA =\n+                    AnnotatedTypes.findEffectiveLowerBoundAnnotations(\n+                            qualifierHierarchy, outsideUpper.lower);\n+            Set<AnnotationMirror> setB =\n+                    AnnotatedTypes.findEffectiveLowerBoundAnnotations(\n+                            qualifierHierarchy, outside.lower);\n+            Set<? extends AnnotationMirror> glb =\n+                    qualifierHierarchy.greatestLowerBounds(setA, setB);\n+            addToLowestBound(outside.lower, glb);\n+            return isContainedByBoundType(inside, outsideUpper, canBeCovariant);\n+        } else if (BoundType.isBoundType(outside.lower)) {\n+            BoundType outsideLower = new BoundType(outside.lower);\n+            return isContainedByBoundType(inside, outsideLower, canBeCovariant);\n+        } else {\n+            if (canBeCovariant) {\n+                if (outside.hasExplicitLowerBound) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9734eb47c03b442894b167b0dcfce454bb3e9de4"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTY4MzU1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDowNDozNFrOJsdLng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDowNDozNFrOJsdLng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NTIzMA==", "bodyText": "The @param Javadoc merely restate the type, which does not supply any information.  Please try to provide more information, such as what it represents or where it is from or other facts about it.  That will make the code easier to understand.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650595230", "createdAt": "2021-06-14T00:04:34Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2204,12 +2212,64 @@ public ParameterizedExecutableType methodFromUse(\n \n     if (tree.getKind() == Tree.Kind.METHOD_INVOCATION\n         && TreeUtils.isMethodInvocation(tree, objectGetClass, processingEnv)) {\n-      adaptGetClassReturnTypeToReceiver(methodType, receiverType);\n+      adaptGetClassReturnTypeToReceiver(methodType, receiverType, tree);\n     }\n \n     return new ParameterizedExecutableType(methodType, typeargs);\n   }\n \n+  /**\n+   * Apply capture conversion to the type arguments of a method invocation.\n+   *\n+   * @param typeVarMapping mapping from type variable to its argument", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTY4NTI2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDowNjoxN1rOJsdMag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDowNjoxN1rOJsdMag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NTQzNA==", "bodyText": "What change to the code will be made?  Will this method be eliminated, or is this comment about some part of the method body?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650595434", "createdAt": "2021-06-14T00:06:17Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2204,12 +2212,64 @@ public ParameterizedExecutableType methodFromUse(\n \n     if (tree.getKind() == Tree.Kind.METHOD_INVOCATION\n         && TreeUtils.isMethodInvocation(tree, objectGetClass, processingEnv)) {\n-      adaptGetClassReturnTypeToReceiver(methodType, receiverType);\n+      adaptGetClassReturnTypeToReceiver(methodType, receiverType, tree);\n     }\n \n     return new ParameterizedExecutableType(methodType, typeargs);\n   }\n \n+  /**\n+   * Apply capture conversion to the type arguments of a method invocation.\n+   *\n+   * @param typeVarMapping mapping from type variable to its argument\n+   * @param declTypeVar list of type variable declarations\n+   * @return a mapping form type variable to its captured type argument\n+   */\n+  private Map<TypeVariable, AnnotatedTypeMirror> captureMethodTypeArgs(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMapping,\n+      List<AnnotatedTypeVariable> declTypeVar) {\n+    // TODO: This should happen as part of Java 8 inference.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTY4NTI3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDowNjoxOVrOJsdMbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQxNjo1MToyNVrOJs87YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NTQzNg==", "bodyText": "Why is this a normal return?  That is, why does this situation not indicate a bug?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650595436", "createdAt": "2021-06-14T00:06:19Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2204,12 +2212,64 @@ public ParameterizedExecutableType methodFromUse(\n \n     if (tree.getKind() == Tree.Kind.METHOD_INVOCATION\n         && TreeUtils.isMethodInvocation(tree, objectGetClass, processingEnv)) {\n-      adaptGetClassReturnTypeToReceiver(methodType, receiverType);\n+      adaptGetClassReturnTypeToReceiver(methodType, receiverType, tree);\n     }\n \n     return new ParameterizedExecutableType(methodType, typeargs);\n   }\n \n+  /**\n+   * Apply capture conversion to the type arguments of a method invocation.\n+   *\n+   * @param typeVarMapping mapping from type variable to its argument\n+   * @param declTypeVar list of type variable declarations\n+   * @return a mapping form type variable to its captured type argument\n+   */\n+  private Map<TypeVariable, AnnotatedTypeMirror> captureMethodTypeArgs(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMapping,\n+      List<AnnotatedTypeVariable> declTypeVar) {\n+    // TODO: This should happen as part of Java 8 inference.\n+    // See Issue #979.\n+    Map<TypeVariable, AnnotatedTypeVariable> typeParameter = new HashMap<>();\n+    for (AnnotatedTypeVariable t : declTypeVar) {\n+      typeParameter.put(t.getUnderlyingType(), t);\n+    }\n+    Map<TypeVariable, AnnotatedTypeMirror> newTypeVarMapping = new HashMap<>();\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeMapping = new HashMap<>();\n+    for (Map.Entry<TypeVariable, AnnotatedTypeMirror> entry : typeVarMapping.entrySet()) {\n+      AnnotatedTypeMirror originalTypeArg = entry.getValue();\n+      TypeVariable typeVariable = entry.getKey();\n+      if (originalTypeArg.containsUninferredTypeArguments()) {\n+        return typeVarMapping;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTExMzg1MA==", "bodyText": "I'm not sure I understand your question.  Uninferred type arguments are an indication of a bug, 979.  To work around that bug, we ignore uninferred type arguments.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651113850", "createdAt": "2021-06-14T16:49:12Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2204,12 +2212,64 @@ public ParameterizedExecutableType methodFromUse(\n \n     if (tree.getKind() == Tree.Kind.METHOD_INVOCATION\n         && TreeUtils.isMethodInvocation(tree, objectGetClass, processingEnv)) {\n-      adaptGetClassReturnTypeToReceiver(methodType, receiverType);\n+      adaptGetClassReturnTypeToReceiver(methodType, receiverType, tree);\n     }\n \n     return new ParameterizedExecutableType(methodType, typeargs);\n   }\n \n+  /**\n+   * Apply capture conversion to the type arguments of a method invocation.\n+   *\n+   * @param typeVarMapping mapping from type variable to its argument\n+   * @param declTypeVar list of type variable declarations\n+   * @return a mapping form type variable to its captured type argument\n+   */\n+  private Map<TypeVariable, AnnotatedTypeMirror> captureMethodTypeArgs(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMapping,\n+      List<AnnotatedTypeVariable> declTypeVar) {\n+    // TODO: This should happen as part of Java 8 inference.\n+    // See Issue #979.\n+    Map<TypeVariable, AnnotatedTypeVariable> typeParameter = new HashMap<>();\n+    for (AnnotatedTypeVariable t : declTypeVar) {\n+      typeParameter.put(t.getUnderlyingType(), t);\n+    }\n+    Map<TypeVariable, AnnotatedTypeMirror> newTypeVarMapping = new HashMap<>();\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeMapping = new HashMap<>();\n+    for (Map.Entry<TypeVariable, AnnotatedTypeMirror> entry : typeVarMapping.entrySet()) {\n+      AnnotatedTypeMirror originalTypeArg = entry.getValue();\n+      TypeVariable typeVariable = entry.getKey();\n+      if (originalTypeArg.containsUninferredTypeArguments()) {\n+        return typeVarMapping;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NTQzNg=="}, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTExNTM2MQ==", "bodyText": "Thanks.  A comment to that effect could be useful.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651115361", "createdAt": "2021-06-14T16:51:25Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2204,12 +2212,64 @@ public ParameterizedExecutableType methodFromUse(\n \n     if (tree.getKind() == Tree.Kind.METHOD_INVOCATION\n         && TreeUtils.isMethodInvocation(tree, objectGetClass, processingEnv)) {\n-      adaptGetClassReturnTypeToReceiver(methodType, receiverType);\n+      adaptGetClassReturnTypeToReceiver(methodType, receiverType, tree);\n     }\n \n     return new ParameterizedExecutableType(methodType, typeargs);\n   }\n \n+  /**\n+   * Apply capture conversion to the type arguments of a method invocation.\n+   *\n+   * @param typeVarMapping mapping from type variable to its argument\n+   * @param declTypeVar list of type variable declarations\n+   * @return a mapping form type variable to its captured type argument\n+   */\n+  private Map<TypeVariable, AnnotatedTypeMirror> captureMethodTypeArgs(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMapping,\n+      List<AnnotatedTypeVariable> declTypeVar) {\n+    // TODO: This should happen as part of Java 8 inference.\n+    // See Issue #979.\n+    Map<TypeVariable, AnnotatedTypeVariable> typeParameter = new HashMap<>();\n+    for (AnnotatedTypeVariable t : declTypeVar) {\n+      typeParameter.put(t.getUnderlyingType(), t);\n+    }\n+    Map<TypeVariable, AnnotatedTypeMirror> newTypeVarMapping = new HashMap<>();\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeMapping = new HashMap<>();\n+    for (Map.Entry<TypeVariable, AnnotatedTypeMirror> entry : typeVarMapping.entrySet()) {\n+      AnnotatedTypeMirror originalTypeArg = entry.getValue();\n+      TypeVariable typeVariable = entry.getKey();\n+      if (originalTypeArg.containsUninferredTypeArguments()) {\n+        return typeVarMapping;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NTQzNg=="}, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTY4ODMwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDowOToyN1rOJsdN5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDowOToyN1rOJsdN5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NTgxNQ==", "bodyText": "These conditions are introduced without preamble or segue.  I first interpreted them as method preconditions, but after reading the implementation it seems more likely that they are laying out the method's algorithm.  (Neither can be correct, because for this line, violation of one of the conditions leads to return false but violation of the other leads to throw new BugInCF.)  Could you please clarify?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650595815", "createdAt": "2021-06-14T00:09:27Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 271}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTY4OTg1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDoxMDo1M1rOJsdOrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDoxMDo1M1rOJsdOrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NjAxNA==", "bodyText": "Please state the relationship between type and typeMirror.  From examining calls, I think that typeMirror must correspond to type and must be a captured type (that is, those are preconditions of the method).", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650596014", "createdAt": "2021-06-14T00:10:53Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 274}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTY5MTI1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDoxMTo1N1rOJsdPTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDoxMTo1N1rOJsdPTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NjE3NA==", "bodyText": "The name capturedTypeMirror was unclear to me when first reading this.  On subsequent readings and after examining call sites, it makes more sense, but could you add documentation and/or renamings to clarify?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650596174", "createdAt": "2021-06-14T00:11:57Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 289}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTY5NTU0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDoxNjoxNFrOJsdRXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjoyNDozMVrOJtwKxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NjcwMw==", "bodyText": "The past tense name wasRaw is in conflict with the present tense documentation \"must not be a raw type\".  (I guess it must not have been written by the programmer as a raw type, even if the type as provided to this method is not raw.  Is that correct?)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650596703", "createdAt": "2021-06-14T00:16:14Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTMyMjMwMw==", "bodyText": "Yes, but to clarify, wasRaw means that the underlying type is raw and the Checker Framework inferred type arguments.  The Checker Framework infers type arguments for all raw types.  wasRaw is probably a bad name.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651322303", "createdAt": "2021-06-14T22:35:57Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NjcwMw=="}, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTMzNTg5NA==", "bodyText": "Could you please update the documentation of wasRaw?  Changing its name sounds like a good idea too -- that could be done in a different pull request and merged into this one.  Thanks!", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651335894", "createdAt": "2021-06-14T23:10:38Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NjcwMw=="}, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk1NDg4Nw==", "bodyText": "The name may be fine after all (now that I understand it), but updating the documentation would still be useful.  Thanks.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651954887", "createdAt": "2021-06-15T16:24:31Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NjcwMw=="}, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 295}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTY5NzU1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDoxODo0NVrOJsdScw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDoxODo0NVrOJsdScw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5Njk3OQ==", "bodyText": "\"generic\" always refers to a type declaration, which has type variables, not type arguments.\nI think that \"generic\" here should be \"parameterized\".  The same comment applies to the other overload of this method.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650596979", "createdAt": "2021-06-14T00:18:45Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 322}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTY5Nzk0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDoxOTozMlrOJsdSsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDoxOTozMlrOJsdSsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NzA0MA==", "bodyText": "This information would be useful in the documentation for shouldCapture.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650597040", "createdAt": "2021-06-14T00:19:32Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 350}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTY5OTIyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDoyMDo1NVrOJsdTTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQyMjoyMDoyNlrOJtJKeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NzE5OA==", "bodyText": "The notion of uninferred wildcards is not in JLS 5.1.10.  Where is a description of the variant that this method computes?  Or are uninferred wildcards always replaced by inferred wildcards before this method terminates?  (In that case, the algorithm differs from 5.1.10 but the result does not.)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650597198", "createdAt": "2021-06-14T00:20:55Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 361}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTMxNTgzMg==", "bodyText": "Uninferred type arguments are a Checker Framework concept. They are a work around for 979.  See the comment on AnnotatedTypeMirror#containsUninferredTypeArguments().", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651315832", "createdAt": "2021-06-14T22:20:26Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NzE5OA=="}, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 361}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTcwMjA3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDoyMzoyM1rOJsdUqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDoyMzoyM1rOJsdUqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NzU0NQ==", "bodyText": "Maybe it would be more descriptive to name this copyNonWildcardTypeArgs or NonWildcardTypeArgCopier, which describes what it does rather than where it is used.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650597545", "createdAt": "2021-06-14T00:23:23Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from the captured type to the annotated captured type.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeMapping = new HashMap<>();\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type mirror to the annotated captured\n+          // type, so that if one captured type refers to another, the correct annotated\n+          // type is used.\n+          capturedTypeMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // If the bounds of the captured wildcard are the same, then it is converted to\n+          // a declared type. This seems to be a violation of the JLS, but javac does\n+          // this, so the Checker Framework must do it.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a captured type.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeMapping.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      captureWildcard(\n+          typeVariableMapping,\n+          capturedTypeMapping,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.remove(i);\n+      newTypeArgs.add(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    // Use the mapping above to substitute the type variables in capturedType.\n+\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its captureType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit\n+   * method.\n+   */\n+  private final CaptureTypeArgCopier captureTypeArgCopier = new CaptureTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code captureType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they are refer to\n+   * the same type variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit\n+   * method.\n+   */\n+  private class CaptureTypeArgCopier extends AnnotatedTypeCopier {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 474}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTcwMjczOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDoyNDo0NVrOJsdVCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDoyNDo0NVrOJsdVCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5NzY0MA==", "bodyText": "What is the relationship between uncapturedType.getUnderlyingType() on this line and local variable capturedTypeMirror?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650597640", "createdAt": "2021-06-14T00:24:45Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 387}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTcwMzg3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDoyNjoyM1rOJsdVog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQyMTo1MjozOVrOJtIYLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5Nzc5NA==", "bodyText": "Regarding \"the captured type\":  I think this method applyCaptureConversion is capturing a single type, which I would call \"the captured type\".  Is this a mapping for the type variables of that type, rather than a mapping from whole captured types?  I may be confused, but please clarify.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650597794", "createdAt": "2021-06-14T00:26:23Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from the captured type to the annotated captured type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 391}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTI4ODkxOA==", "bodyText": "Below I've quoted two related comments that should be discussed together.\n\nThe Javadoc of TypesUtils.isCaptured says \"Returns whether a TypeVariable represents a captured type.\" but I think it is actually whether the type variable comes from a wildcard.  The type variable is part of a captured type but is not itself a captured type.  Although javac's Type.java poorly uses the name isCaptured, I think that TypesUtils should use something more descriptive, such as isCapturedTypeVariable or isTypeVariableFromCaptureConversion or the like.\n\n\n\"each captured type\": This method only captures one type. Are you talking about the type variables that were constructed to stand in for wildcards -- that is, any type argument that changed as a result of capture conversion? Maybe we need terminology for them, but \"captured type\" seems wrong. This naming choice may be related to my comment about isCaptured.\n\nYou've pointed out that I have been using \"captured type\" to mean both the type resulting from apply capture conversion and the \"fresh\" type variables created during capture conversion. Thanks, this is confusing and should be cleaned up.  I agree that it makes more sense that \"captured type\" means the type resulting from applying capture conversion to a type.\nI was calling the type variables created during capture conversion \"captured types\" because:\n\nThat's what comments in the Checker Framework called them.\nCapturedType is the name of the javac class that implements these type variables.\nCalling toString() on a CapturedType results in something like capture#826 of ?.\nIn javac error messages such as:\n\n  where CAP#1 is a fresh type-variable:\n    CAP#1 extends CharSequence from capture of ? extends CharSequence\n\nI can fix 1. 2 is an implementation detail of javac that can be ignored, but 3 and 4 are what really makes it seem like these type variables should be called \"captured types\" or maybe \"capture types\".  So, I propose calling type variables created during capture conversion \"captured type variables\".   (I would also rename TypesUtils.isCapture to isCapturedTypeVariable.) What do you think?  Is that still too confusing?\nAn alternative would be \"fresh type-variable\" which is used in javac error messages.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651288918", "createdAt": "2021-06-14T21:25:37Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from the captured type to the annotated captured type.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5Nzc5NA=="}, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 391}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTMwMjk1Ng==", "bodyText": "I like your proposal of \"captured type variable\".  (I indirectly suggested in in the suggestion about isCapturedTypeVariable.)\n(3 and 4 use \"capture\" but not \"captured type\", so I think they are as compatible with \"captured type variable\" as with \"captured type\".)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651302956", "createdAt": "2021-06-14T21:52:39Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from the captured type to the annotated captured type.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5Nzc5NA=="}, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 391}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTcxMDkxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDozMzo1NVrOJsdZJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQyMToyNzowOFrOJtHkOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5ODY5Mg==", "bodyText": "The Javadoc of TypesUtils.isCaptured says \"Returns whether a TypeVariable represents a captured type.\" but I think it is actually whether the type variable comes from a wildcard.  The type variable is part of a captured type but is not itself a captured type.  Although javac's Type.java poorly uses the name isCaptured, I think that TypesUtils should use something more descriptive, such as isCapturedTypeVariable or isTypeVariableFromCaptureConversion or the like.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650598692", "createdAt": "2021-06-14T00:33:55Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from the captured type to the annotated captured type.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeMapping = new HashMap<>();\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 400}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTI4OTY1Ng==", "bodyText": "I replied to this comment https://github.com/typetools/checker-framework/pull/3922/files#r651288918.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651289656", "createdAt": "2021-06-14T21:27:08Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from the captured type to the annotated captured type.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeMapping = new HashMap<>();\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5ODY5Mg=="}, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 400}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTcxMzE0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDozNTo1NFrOJsdaLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDozNTo1NFrOJsdaLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5ODk1OQ==", "bodyText": "Is this \"If\" something that is definitely true when control reaches this point (in which case \"If\" is not appropriate), or is it describing some conditional effect of the immediately following code (in which case I need a bit more guidance to understand it)?\nAlso, please don't use passive voice \"it is converted\".  Please state the actor, which will also make the comment easier to understand.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650598959", "createdAt": "2021-06-14T00:35:54Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from the captured type to the annotated captured type.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeMapping = new HashMap<>();\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type mirror to the annotated captured\n+          // type, so that if one captured type refers to another, the correct annotated\n+          // type is used.\n+          capturedTypeMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // If the bounds of the captured wildcard are the same, then it is converted to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 413}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTcxMzM1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDozNjoxMFrOJsdaTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDozNjoxMFrOJsdaTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5ODk5MA==", "bodyText": "I think \"captured type\" should be \"wildcard\".", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650598990", "createdAt": "2021-06-14T00:36:10Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from the captured type to the annotated captured type.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeMapping = new HashMap<>();\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type mirror to the annotated captured\n+          // type, so that if one captured type refers to another, the correct annotated\n+          // type is used.\n+          capturedTypeMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // If the bounds of the captured wildcard are the same, then it is converted to\n+          // a declared type. This seems to be a violation of the JLS, but javac does\n+          // this, so the Checker Framework must do it.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a captured type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 422}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEyOTcxNDQ3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQwMDozNzoyMlrOJsda4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNFQyMToyNzozNVrOJtHlAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5OTEzNw==", "bodyText": "\"each captured type\":  This method only captures one type.  Are you talking about the type variables that were constructed to stand in for wildcards -- that is, any type argument that changed as a result of capture conversion?  Maybe we need terminology for them, but \"captured type\" seems wrong.  This naming choice may be related to my comment about isCaptured.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r650599137", "createdAt": "2021-06-14T00:37:22Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from the captured type to the annotated captured type.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeMapping = new HashMap<>();\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type mirror to the annotated captured\n+          // type, so that if one captured type refers to another, the correct annotated\n+          // type is used.\n+          capturedTypeMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // If the bounds of the captured wildcard are the same, then it is converted to\n+          // a declared type. This seems to be a violation of the JLS, but javac does\n+          // this, so the Checker Framework must do it.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a captured type.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 432}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTI4OTg1OA==", "bodyText": "I replied to this comme.nt https://github.com/typetools/checker-framework/pull/3922/files#r651288918.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651289858", "createdAt": "2021-06-14T21:27:35Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4613,442 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} must both be declared types.\n+   *   <li>{@code type} must not be a raw type, must not have an uninferred type argument, and must\n+   *       have a wildcard as a type argument.\n+   *   <li>{@code typeMirror} must have a captured type as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type to capture\n+   * @param typeMirror underlying Java type\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+    if (typeMirror.getKind() != TypeKind.DECLARED) {\n+      throw new BugInCF(\"Expected declared type mirror: %s, type: %s\", typeMirror, type);\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCaptured(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a generic type to fresh type\n+   * variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for all the details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror type from the Java compiler that has captured wildcards, which are used as\n+   *     the underlying type of the captured wildcards\n+   * @return the captured type\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // wildcards, then mark any uncaptured wildcards as \"uninferred\".\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCaptured(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    final AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from the captured type to the annotated captured type.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeMapping = new HashMap<>();\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCaptured(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type mirror to the annotated captured\n+          // type, so that if one captured type refers to another, the correct annotated\n+          // type is used.\n+          capturedTypeMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // If the bounds of the captured wildcard are the same, then it is converted to\n+          // a declared type. This seems to be a violation of the JLS, but javac does\n+          // this, so the Checker Framework must do it.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a captured type.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MDU5OTEzNw=="}, "originalCommit": {"oid": "0540668c191e38670c6c52a774da997594687c51"}, "originalPosition": 432}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEzODUyOTE5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjoxNjo0OVrOJtvxqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjoxNjo0OVrOJtvxqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk0ODQ1Nw==", "bodyText": "As a matter of style, I think a Map.Entry loop body is clearer when the getKey() invocation is on the first line and the getValue() invocation is on the second line.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651948457", "createdAt": "2021-06-15T16:16:49Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2204,12 +2212,70 @@ public ParameterizedExecutableType methodFromUse(\n \n     if (tree.getKind() == Tree.Kind.METHOD_INVOCATION\n         && TreeUtils.isMethodInvocation(tree, objectGetClass, processingEnv)) {\n-      adaptGetClassReturnTypeToReceiver(methodType, receiverType);\n+      adaptGetClassReturnTypeToReceiver(methodType, receiverType, tree);\n     }\n \n     return new ParameterizedExecutableType(methodType, typeargs);\n   }\n \n+  /**\n+   * Apply capture conversion to the type arguments of a method invocation.\n+   *\n+   * @param typeVarMapping mapping from type variable in the method declaration to the corresponding\n+   *     type argument at the method invocation\n+   * @param declTypeVar list of type variable declarations\n+   * @return a mapping from type variable in the method declaration to its captured type argument.\n+   *     For a non-wildcard, Capture conversion is the identity. Its keys are the same as in {@code\n+   *     typeVarMapping}, and the values are their captures (capture conversion may be the\n+   *     identity).\n+   */\n+  private Map<TypeVariable, AnnotatedTypeMirror> captureMethodTypeArgs(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMapping,\n+      List<AnnotatedTypeVariable> declTypeVar) {\n+    // TODO: This should happen as part of Java 8 inference and this method should be removed when\n+    // #979 is fixed.\n+    Map<TypeVariable, AnnotatedTypeVariable> typeParameter = new HashMap<>();\n+    for (AnnotatedTypeVariable t : declTypeVar) {\n+      typeParameter.put(t.getUnderlyingType(), t);\n+    }\n+    // `newTypeVarMapping` is the result of this method.\n+    Map<TypeVariable, AnnotatedTypeMirror> newTypeVarMapping = new HashMap<>();\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    for (Map.Entry<TypeVariable, AnnotatedTypeMirror> entry : typeVarMapping.entrySet()) {\n+      AnnotatedTypeMirror originalTypeArg = entry.getValue();\n+      TypeVariable typeVariable = entry.getKey();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEzODU2Njg3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjoyMzo1NVrOJtwJHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjoyMzo1NVrOJtwJHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk1NDQ2MQ==", "bodyText": "Since the uncaptured type is the first formal parameter, I would swap the order of this assignment and the previous one.  I think that makes the code a bit more uniform and easier to read.  I made similar changes in a number of other places in the code.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651954461", "createdAt": "2021-06-15T16:23:55Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEzODU4OTgwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjoyNzo1MVrOJtwX2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjoyNzo1MVrOJtwX2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk1ODIzMw==", "bodyText": "A variable named \"Mapping\" or \"Map\" reiterates the type and thus adds no new information.  I had to keep referring back to the comments to understand uses of these variables.  Can you give them more descriptive names?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651958233", "createdAt": "2021-06-15T16:27:51Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 393}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEzODU5NjU3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjoyOToxMFrOJtwb9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjoyOToxMFrOJtwb9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk1OTI4NA==", "bodyText": "\"capturing the wildcard\" is funny terminology; consider rewording, per our earlier discussion.\nAlso, where does the \"capturing the wildcard\" occur?  It would be helpful for this comment to be more explicit.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651959284", "createdAt": "2021-06-15T16:29:10Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 407}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEzODYwMDcxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjoyOTo1OFrOJtwehQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjoyOTo1OFrOJtwehQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk1OTk0MQ==", "bodyText": "These two lines are the same in the then clause.  Can this code be hoisted out of the if statement?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651959941", "createdAt": "2021-06-15T16:29:58Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 422}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEzODYwNTQyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjozMDo1NVrOJtwhXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQyMjoyNjozNlrOJt-z8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk2MDY3MA==", "bodyText": "What is the relationship between typeVar.getUnderlyingType() and typeVarTypeMirror?  I'm unclear whether this is replacing a mapping or is adding a new mapping.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651960670", "createdAt": "2021-06-15T16:30:55Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 431}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MjE3MDgwNQ==", "bodyText": "If uncapturedType.getUnderlingType() is G<?, X> , and  the declaration of G is G<T, V>, then typeVar.getUnderlingType() is X and typeVarTypeMirror is V.\ntypeVar.getUnderlyingType() and typeVarTypeMirror can be the same.  For example if G is declared as G<T, V extends G<?, V>>, then uncapturedType could be G<?, V>, in which case both typeVar.getUnderlyingType() and typeVarTypeMirror are V.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r652170805", "createdAt": "2021-06-15T21:38:01Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk2MDY3MA=="}, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 431}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MjE5NDgwMA==", "bodyText": "Thanks for the clarification.  I would be inclined to add a comment given that I had a question -- unless you feel that would be unhelpful clutter.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r652194800", "createdAt": "2021-06-15T22:26:36Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk2MDY3MA=="}, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 431}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEzODYxMzQwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjozMjo0NVrOJtwmaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjozMjo0NVrOJtwmaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk2MTk2MQ==", "bodyText": "List has a set method.  Is there a reason not to use it here?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651961961", "createdAt": "2021-06-15T16:32:45Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarMapping.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      captureWildcard(\n+          typeVariableMapping,\n+          capturedTypeVarMapping,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.remove(i);\n+      newTypeArgs.add(i, capturedTypeArg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 451}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEzODYxODEyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjozMzo0NlrOJtwpPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjozMzo0NlrOJtwpPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk2MjY4Nw==", "bodyText": "This is a confusing location for a comment.  If it refers to the line above, put it before that line.  If it refers to the line below, remove the separating whitespace and maybe add whitespace before the comment.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651962687", "createdAt": "2021-06-15T16:33:46Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarMapping.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      captureWildcard(\n+          typeVariableMapping,\n+          capturedTypeVarMapping,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.remove(i);\n+      newTypeArgs.add(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    // Use the mapping above to substitute the type variables in capturedType.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 455}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEzODYyNjEzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjozNToyOFrOJtwuJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjozNToyOFrOJtwuJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk2Mzk0MQ==", "bodyText": "Here and below, why does the comment use @code instead of @link?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651963941", "createdAt": "2021-06-15T16:35:28Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarMapping.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      captureWildcard(\n+          typeVariableMapping,\n+          capturedTypeVarMapping,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.remove(i);\n+      newTypeArgs.add(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    // Use the mapping above to substitute the type variables in capturedType.\n+\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its captureType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 466}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEzODYzNTQzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjozNzoyM1rOJtwz2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjozNzoyM1rOJtwz2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk2NTQwMA==", "bodyText": "copyArg sounds like an action.  I would use copyOfArg or copiedArg or argCopy.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651965400", "createdAt": "2021-06-15T16:37:23Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarMapping.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      captureWildcard(\n+          typeVariableMapping,\n+          capturedTypeVarMapping,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.remove(i);\n+      newTypeArgs.add(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    // Use the mapping above to substitute the type variables in capturedType.\n+\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its captureType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit\n+   * method.\n+   */\n+  private final NonWildcardTypeArgCopier captureTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code captureType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit\n+   * method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated.\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int size = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[size];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(size);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is type var add it to typeVarMap.\n+      for (int i = 0; i < size; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyArg = visit(uncapturedArg, originalToCopy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 505}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEzODY0MDM0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjozODoyMlrOJtw2wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjozODoyMlrOJtw2wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk2NjE0NQ==", "bodyText": "Please put comments above the code that they refer to.  (That is the standard convention.)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651966145", "createdAt": "2021-06-15T16:38:22Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarMapping.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      captureWildcard(\n+          typeVariableMapping,\n+          capturedTypeVarMapping,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.remove(i);\n+      newTypeArgs.add(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    // Use the mapping above to substitute the type variables in capturedType.\n+\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its captureType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit\n+   * method.\n+   */\n+  private final NonWildcardTypeArgCopier captureTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code captureType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit\n+   * method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated.\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int size = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[size];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(size);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is type var add it to typeVarMap.\n+      for (int i = 0; i < size; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyArg = visit(uncapturedArg, originalToCopy);\n+          if (copyArg.getKind() == TypeKind.TYPEVAR) {\n+            typeVarMap.put(((AnnotatedTypeVariable) copyArg).getUnderlyingType(), copyArg);\n+          }\n+          newTypeArgs[i] = copyArg;\n+        }\n+      }\n+\n+      // Substitute the type variables in each type argument of capturedType using typeVarMap\n+      // created above.\n+      // This makes type variables in capturedType the same object when they are the same type\n+      // variable.\n+      for (int i = 0; i < size; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        AnnotatedTypeMirror capturedArg = capturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() == TypeKind.WILDCARD) {\n+          // Note: this if statement can't be replaced with if", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 521}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDEzODY0NTAxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjozOToyNVrOJtw5vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xNVQxNjozOToyNVrOJtw5vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MTk2NjkwOQ==", "bodyText": "I would change \"contain\" to \"lexically contain\" (if that is true!) to distinguish from the JLS notion of type containment.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r651966909", "createdAt": "2021-06-15T16:39:25Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4619,452 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument, has a wildcard as a type argument\n+   *       and was not a raw type.\n+   *   <li>{@code typeMirror} has a captured type variable as a type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.wasRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+        continue;\n+      }\n+      if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+          || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (!shouldCapture(type, typeMirror)) {\n+      if (type.containsUninferredTypeArguments()\n+          && typeMirror.getKind() == TypeKind.DECLARED\n+          && type.getKind() == TypeKind.DECLARED) {\n+        // If capture conversion is not applied because the type contains uninferred\n+        // type arguments, then mark all wildcards in type as \"uninferred\" before it is returned.\n+        DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+        AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+        for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+          TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+          AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+          if (uncapturedTypeArg.getKind() != TypeKind.WILDCARD) {\n+            continue;\n+          }\n+          if (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD) {\n+            ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+          }\n+        }\n+      }\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    captureTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVariableMapping = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarMapping = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // The type argument is a captured type variable. Use the type argument from the newly\n+          // created and yet-to-be annotated capturedType. (The annotations are added as\n+          // part of capturing the wildcard.)\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarMapping.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework handle that\n+          // case.\n+          typeVariableMapping.put(typeVarTypeMirror, capturedTypeArg);\n+          newTypeArgs.add(capturedTypeArg);\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVariableMapping.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVariableMapping.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Loop through the type arguments and set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarMapping.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      captureWildcard(\n+          typeVariableMapping,\n+          capturedTypeVarMapping,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.remove(i);\n+      newTypeArgs.add(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    // Use the mapping above to substitute the type variables in capturedType.\n+\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its captureType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit\n+   * method.\n+   */\n+  private final NonWildcardTypeArgCopier captureTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code captureType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, Call {@code #copy(AnnotatedDeclaredType, AnnotatedDeclaredType)} rather than a visit\n+   * method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated.\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int size = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[size];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(size);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is type var add it to typeVarMap.\n+      for (int i = 0; i < size; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyArg = visit(uncapturedArg, originalToCopy);\n+          if (copyArg.getKind() == TypeKind.TYPEVAR) {\n+            typeVarMap.put(((AnnotatedTypeVariable) copyArg).getUnderlyingType(), copyArg);\n+          }\n+          newTypeArgs[i] = copyArg;\n+        }\n+      }\n+\n+      // Substitute the type variables in each type argument of capturedType using typeVarMap\n+      // created above.\n+      // This makes type variables in capturedType the same object when they are the same type\n+      // variable.\n+      for (int i = 0; i < size; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        AnnotatedTypeMirror capturedArg = capturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() == TypeKind.WILDCARD) {\n+          // Note: this if statement can't be replaced with if\n+          // (TypesUtils.isCapturedTypeVariable(capturedArg))\n+          // because if the bounds of the captured wildcard are equal, then instead of a captured\n+          // wildcard, the type of the bound is used.\n+          AnnotatedTypeMirror newCapArg =\n+              typeVarSubstitutor.substituteWithoutCopyingTypeArguments(typeVarMap, capturedArg);\n+          newTypeArgs[i] = newCapArg;\n+        }\n+      }\n+      // Set captureType type args to newTypeArgs.\n+      capturedType.setTypeArguments(Arrays.asList(newTypeArgs));\n+\n+      // Visit the enclosing type.\n+      if (uncapturedType.getEnclosingType() != null) {\n+        capturedType.setEnclosingType(\n+            (AnnotatedDeclaredType) visit(uncapturedType.getEnclosingType(), originalToCopy));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the list of type variables such that a type variable in the list only references type\n+   * variables at a lower index than itself.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the type variables ordered so that eachtype variable only references earlier type\n+   *     variables\n+   */\n+  public List<AnnotatedTypeVariable> order(Collection<AnnotatedTypeVariable> collection) {\n+    List<AnnotatedTypeVariable> list = new ArrayList<>(collection);\n+    List<AnnotatedTypeVariable> ordered = new ArrayList<>();\n+    while (!list.isEmpty()) {\n+      AnnotatedTypeVariable free = doesNotContainOthers(list);\n+      list.remove(free);\n+      ordered.add(free);\n+    }\n+    return ordered;\n+  }\n+\n+  /**\n+   * Returns the first TypeVariable in {@code collection} that does not contain any other type in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2d40c4714b402adccdc6e18b24309d1f62f3f03"}, "originalPosition": 561}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE0OTcwMjg4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNTozMjozMlrOJvZjtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNTozMjozMlrOJvZjtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzY4MTU4OQ==", "bodyText": "Variable names like typeVarMapping and newTypeVarMapping are not very informative.  (I realize that existing code in this class does use such names.)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653681589", "createdAt": "2021-06-17T15:32:32Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2204,12 +2212,72 @@ public ParameterizedExecutableType methodFromUse(\n \n     if (tree.getKind() == Tree.Kind.METHOD_INVOCATION\n         && TreeUtils.isMethodInvocation(tree, objectGetClass, processingEnv)) {\n-      adaptGetClassReturnTypeToReceiver(methodType, receiverType);\n+      adaptGetClassReturnTypeToReceiver(methodType, receiverType, tree);\n     }\n \n     return new ParameterizedExecutableType(methodType, typeargs);\n   }\n \n+  /**\n+   * Apply capture conversion to the type arguments of a method invocation.\n+   *\n+   * @param typeVarMapping mapping from type variable in the method declaration to the corresponding", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba975917939e092e254670f663520fd0b32df2df"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE0OTcwMzEzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNTozMjozNVrOJvZj2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNTozMjozNVrOJvZj2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzY4MTYyNg==", "bodyText": "Is this exactly the keys of typeVarMapping, but in order?  If so, please document that.  In that case, is this formal parameter needed?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653681626", "createdAt": "2021-06-17T15:32:35Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -2204,12 +2212,72 @@ public ParameterizedExecutableType methodFromUse(\n \n     if (tree.getKind() == Tree.Kind.METHOD_INVOCATION\n         && TreeUtils.isMethodInvocation(tree, objectGetClass, processingEnv)) {\n-      adaptGetClassReturnTypeToReceiver(methodType, receiverType);\n+      adaptGetClassReturnTypeToReceiver(methodType, receiverType, tree);\n     }\n \n     return new ParameterizedExecutableType(methodType, typeargs);\n   }\n \n+  /**\n+   * Apply capture conversion to the type arguments of a method invocation.\n+   *\n+   * @param typeVarMapping mapping from type variable in the method declaration to the corresponding\n+   *     type argument at the method invocation\n+   * @param declTypeVar list of type variable declarations in the method", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba975917939e092e254670f663520fd0b32df2df"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE0OTcxODc4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNTozNToyNFrOJvZtZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNVQyMTo1MjowNlrOJ0hjlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzY4NDA2OQ==", "bodyText": "What is the reason for the requirement that the underlying type is not raw?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653684069", "createdAt": "2021-06-17T15:35:24Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,447 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17181277aa647d378ebc27e30438023845eafe7a"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NDgxMzgxNw==", "bodyText": "I suppose they could be captured, but currently the Checker Framework ignores raw type arguments, so there isn't much point.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r654813817", "createdAt": "2021-06-19T16:19:09Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,447 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzY4NDA2OQ=="}, "originalCommit": {"oid": "17181277aa647d378ebc27e30438023845eafe7a"}, "originalPosition": 281}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTA1NTUxMQ==", "bodyText": "Could you please add a comment to that effect?  I think that would be helpful.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r659055511", "createdAt": "2021-06-25T21:52:06Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,447 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzY4NDA2OQ=="}, "originalCommit": {"oid": "17181277aa647d378ebc27e30438023845eafe7a"}, "originalPosition": 281}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE0OTcyNDEwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNTozNjoyNlrOJvZwuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNVQyMjowMDo1N1rOJ0hu7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzY4NDkyMA==", "bodyText": "I think it's the case that either:\n\nits underlying type is a wildcard, or\nit has a wildcard as a type argument.\n\nCould you document whichever of these (or some other fact) is true?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653684920", "createdAt": "2021-06-17T15:36:26Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,447 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17181277aa647d378ebc27e30438023845eafe7a"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NDU2MzcyOQ==", "bodyText": "Neither of these are true.   This method is checking if type should be captured.  If type has a wildcard as a type argument (and allow the other conditions are met), then it should be captured.  I'm not sure how to clarify the documentation.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r654563729", "createdAt": "2021-06-18T16:45:01Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,447 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzY4NDkyMA=="}, "originalCommit": {"oid": "17181277aa647d378ebc27e30438023845eafe7a"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTA1ODQxMg==", "bodyText": "In certain parts of the code, there are application invariants about what values are passed to calls.  I was wondering if there are any here.\nFor example, in this method there is a specific relationship between type and typeMirror.  Since typeMirror is a capture, then the underlying type of type was capturable.  I'm wondering what that implies about type.  For example, I think it is impossible for type to be int, because its underlying type does not have a capture and because of where applyCaptureConversion is called.  (Maybe, even if that fact is true, it is an accident of the current call patterns and is not part of the specification or contract of this method.)\nOr, maybe your response here is saying those two facts:\n\ntypeMirror might be a degenerate capture -- that is, it might be the underlying type itself.\nthis method might also perform a degenerate capture.\n\nI hope all this clarifies my question.  Please ask again if not.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r659058412", "createdAt": "2021-06-25T22:00:57Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,447 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzY4NDkyMA=="}, "originalCommit": {"oid": "17181277aa647d378ebc27e30438023845eafe7a"}, "originalPosition": 287}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE0OTk1MzQxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoxOToyMVrOJvb8iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoxOToyMVrOJvb8iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyMDcxNQ==", "bodyText": "I changed the logic slightly here.  Please double-check.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653720715", "createdAt": "2021-06-17T16:19:21Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 362}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE0OTk1NjU2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyMDowMlrOJvb-lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyMDowMlrOJvb-lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyMTIzNg==", "bodyText": "This comment says \"all wildcards\", but there is && after uncapturedTypeArg.getKind() == TypeKind.WILDCARD.  Which is right, and why?  (When does the second conjunct have an effect?  Or should it be an assertion?)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653721236", "createdAt": "2021-06-17T16:20:02Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 363}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE0OTk2MTEzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyMTowN1rOJvcBmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xOFQxNjo1NDozNVrOJwPsPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyMjAwOQ==", "bodyText": "Is the key from the underlying type or from the captured type?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653722009", "createdAt": "2021-06-17T16:21:07Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 398}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NDU2ODUwOA==", "bodyText": "I don't understand this question.  Which underlying type do you mean?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r654568508", "createdAt": "2021-06-18T16:54:35Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyMjAwOQ=="}, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 398}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE0OTk2ODMyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyMjozNlrOJvcGAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyMjozNlrOJvcGAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyMzEzNg==", "bodyText": "Could you document the relationship between typeVarTypeMirror and typeVar.getUnderlyingType(), and why two entries need to be added to typeVarToAnnotatedTypeArg?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653723136", "createdAt": "2021-06-17T16:22:36Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are add by\n+        // #annotateCapturedTypeVar.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 433}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE0OTk3MjAwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyMzoxOFrOJvcINg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyMzoxOFrOJvcINg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyMzcwMg==", "bodyText": "What is the point of this variable?  It is only used once, on the next line.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653723702", "createdAt": "2021-06-17T16:23:18Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are add by\n+        // #annotateCapturedTypeVar.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarToAnnotatedTypeVar.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      annotateCapturedTypeVar(\n+          typeVarToAnnotatedTypeArg,\n+          capturedTypeVarToAnnotatedTypeVar,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.set(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its capturedType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private final NonWildcardTypeArgCopier nonWildcardTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      // `originalToCopy` means a mapping from the original to the copy, not an original that needs\n+      // to be copied.\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 493}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE0OTk3NDM1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyMzo0N1rOJvcJoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyMzo0N1rOJvcJoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyNDA2NA==", "bodyText": "What does this map to?  I think it's an uncaptured type argument.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653724064", "createdAt": "2021-06-17T16:23:47Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are add by\n+        // #annotateCapturedTypeVar.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarToAnnotatedTypeVar.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      annotateCapturedTypeVar(\n+          typeVarToAnnotatedTypeArg,\n+          capturedTypeVarToAnnotatedTypeVar,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.set(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its capturedType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private final NonWildcardTypeArgCopier nonWildcardTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      // `originalToCopy` means a mapping from the original to the copy, not an original that needs\n+      // to be copied.\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int numTypeArgs = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[numTypeArgs];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(numTypeArgs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 498}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE0OTk3OTk0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyNTowMFrOJvcNIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyNTowMFrOJvcNIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyNDk2Mw==", "bodyText": "This may set primary annotations as well as those on the bounds.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653724963", "createdAt": "2021-06-17T16:25:00Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are add by\n+        // #annotateCapturedTypeVar.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarToAnnotatedTypeVar.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      annotateCapturedTypeVar(\n+          typeVarToAnnotatedTypeArg,\n+          capturedTypeVarToAnnotatedTypeVar,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.set(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its capturedType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private final NonWildcardTypeArgCopier nonWildcardTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      // `originalToCopy` means a mapping from the original to the copy, not an original that needs\n+      // to be copied.\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int numTypeArgs = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[numTypeArgs];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(numTypeArgs);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is a type var, add it to typeVarMap.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyOfArg = visit(uncapturedArg, originalToCopy);\n+          if (copyOfArg.getKind() == TypeKind.TYPEVAR) {\n+            typeVarMap.put(((AnnotatedTypeVariable) copyOfArg).getUnderlyingType(), copyOfArg);\n+          }\n+          newTypeArgs[i] = copyOfArg;\n+        }\n+      }\n+\n+      // Substitute the type variables in each type argument of capturedType using typeVarMap.\n+      // This makes type variables in capturedType the same object when they are the same type\n+      // variable.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        AnnotatedTypeMirror capturedArg = capturedType.getTypeArguments().get(i);\n+        // Note: this if statement can't be replaced with\n+        //   if (TypesUtils.isCapturedTypeVariable(capturedArg))\n+        // because if the bounds of the captured wildcard are equal, then instead of a captured\n+        // wildcard, the type of the bound is used.\n+        if (uncapturedArg.getKind() == TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror newCapArg =\n+              typeVarSubstitutor.substituteWithoutCopyingTypeArguments(typeVarMap, capturedArg);\n+          newTypeArgs[i] = newCapArg;\n+        }\n+      }\n+      // Set capturedType type args to newTypeArgs.\n+      capturedType.setTypeArguments(Arrays.asList(newTypeArgs));\n+\n+      // Visit the enclosing type.\n+      if (uncapturedType.getEnclosingType() != null) {\n+        capturedType.setEnclosingType(\n+            (AnnotatedDeclaredType) visit(uncapturedType.getEnclosingType(), originalToCopy));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the list of type variables such that a type variable in the list only references type\n+   * variables at a lower index than itself.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the type variables ordered so that each type variable only references earlier type\n+   *     variables\n+   */\n+  public List<AnnotatedTypeVariable> order(Collection<AnnotatedTypeVariable> collection) {\n+    List<AnnotatedTypeVariable> list = new ArrayList<>(collection);\n+    List<AnnotatedTypeVariable> ordered = new ArrayList<>();\n+    while (!list.isEmpty()) {\n+      AnnotatedTypeVariable free = doesNotContainOthers(list);\n+      list.remove(free);\n+      ordered.add(free);\n+    }\n+    return ordered;\n+  }\n+\n+  /**\n+   * Returns the first TypeVariable in {@code collection} that does not (lexically) contain any\n+   * other type in the collection.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the first TypeVariable in {@code collection} that does not contain any other type in\n+   *     the collection, except possibly itself\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // must be the same object from collection\n+  private AnnotatedTypeVariable doesNotContainOthers(\n+      Collection<? extends AnnotatedTypeVariable> collection) {\n+    for (AnnotatedTypeVariable candidate : collection) {\n+      boolean doesNotContain = true;\n+      for (AnnotatedTypeVariable other : collection) {\n+        if (candidate != other && captureScanner.visit(candidate, other.getUnderlyingType())) {\n+          doesNotContain = false;\n+          break;\n+        }\n+      }\n+      if (doesNotContain) {\n+        return candidate;\n+      }\n+    }\n+    throw new BugInCF(\"Not found: %s\", StringsPlume.join(\",\", collection));\n+  }\n+\n+  /**\n+   * Scanner that returns true if the underlying type of any part of an {@link AnnotatedTypeMirror}\n+   * is the passed captured type variable.\n+   *\n+   * <p>The second argument to visit must be a captured type variable.\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // Captured type vars can be compared with ==.\n+  private final SimpleAnnotatedTypeScanner<Boolean, TypeVariable> captureScanner =\n+      new SimpleAnnotatedTypeScanner<>(\n+          (type, other) -> type.getUnderlyingType() == other, Boolean::logicalOr, false);\n+\n+  /**\n+   * Set the annotated bounds for fresh type variable {@code capturedTypeVar}, so that it is the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 596}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE0OTk4NTU5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyNjoxN1rOJvcQvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyNjoxN1rOJvcQvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyNTg4NQ==", "bodyText": "There is extra logic in the initialization of typeVarUpperBound that is not present for lower bounds.  What is the reason for the difference?  (It just makes me a bit nervous to see a lack of symmetry.)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653725885", "createdAt": "2021-06-17T16:26:17Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are add by\n+        // #annotateCapturedTypeVar.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarToAnnotatedTypeVar.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      annotateCapturedTypeVar(\n+          typeVarToAnnotatedTypeArg,\n+          capturedTypeVarToAnnotatedTypeVar,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.set(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its capturedType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private final NonWildcardTypeArgCopier nonWildcardTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      // `originalToCopy` means a mapping from the original to the copy, not an original that needs\n+      // to be copied.\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int numTypeArgs = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[numTypeArgs];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(numTypeArgs);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is a type var, add it to typeVarMap.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyOfArg = visit(uncapturedArg, originalToCopy);\n+          if (copyOfArg.getKind() == TypeKind.TYPEVAR) {\n+            typeVarMap.put(((AnnotatedTypeVariable) copyOfArg).getUnderlyingType(), copyOfArg);\n+          }\n+          newTypeArgs[i] = copyOfArg;\n+        }\n+      }\n+\n+      // Substitute the type variables in each type argument of capturedType using typeVarMap.\n+      // This makes type variables in capturedType the same object when they are the same type\n+      // variable.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        AnnotatedTypeMirror capturedArg = capturedType.getTypeArguments().get(i);\n+        // Note: this if statement can't be replaced with\n+        //   if (TypesUtils.isCapturedTypeVariable(capturedArg))\n+        // because if the bounds of the captured wildcard are equal, then instead of a captured\n+        // wildcard, the type of the bound is used.\n+        if (uncapturedArg.getKind() == TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror newCapArg =\n+              typeVarSubstitutor.substituteWithoutCopyingTypeArguments(typeVarMap, capturedArg);\n+          newTypeArgs[i] = newCapArg;\n+        }\n+      }\n+      // Set capturedType type args to newTypeArgs.\n+      capturedType.setTypeArguments(Arrays.asList(newTypeArgs));\n+\n+      // Visit the enclosing type.\n+      if (uncapturedType.getEnclosingType() != null) {\n+        capturedType.setEnclosingType(\n+            (AnnotatedDeclaredType) visit(uncapturedType.getEnclosingType(), originalToCopy));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the list of type variables such that a type variable in the list only references type\n+   * variables at a lower index than itself.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the type variables ordered so that each type variable only references earlier type\n+   *     variables\n+   */\n+  public List<AnnotatedTypeVariable> order(Collection<AnnotatedTypeVariable> collection) {\n+    List<AnnotatedTypeVariable> list = new ArrayList<>(collection);\n+    List<AnnotatedTypeVariable> ordered = new ArrayList<>();\n+    while (!list.isEmpty()) {\n+      AnnotatedTypeVariable free = doesNotContainOthers(list);\n+      list.remove(free);\n+      ordered.add(free);\n+    }\n+    return ordered;\n+  }\n+\n+  /**\n+   * Returns the first TypeVariable in {@code collection} that does not (lexically) contain any\n+   * other type in the collection.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the first TypeVariable in {@code collection} that does not contain any other type in\n+   *     the collection, except possibly itself\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // must be the same object from collection\n+  private AnnotatedTypeVariable doesNotContainOthers(\n+      Collection<? extends AnnotatedTypeVariable> collection) {\n+    for (AnnotatedTypeVariable candidate : collection) {\n+      boolean doesNotContain = true;\n+      for (AnnotatedTypeVariable other : collection) {\n+        if (candidate != other && captureScanner.visit(candidate, other.getUnderlyingType())) {\n+          doesNotContain = false;\n+          break;\n+        }\n+      }\n+      if (doesNotContain) {\n+        return candidate;\n+      }\n+    }\n+    throw new BugInCF(\"Not found: %s\", StringsPlume.join(\",\", collection));\n+  }\n+\n+  /**\n+   * Scanner that returns true if the underlying type of any part of an {@link AnnotatedTypeMirror}\n+   * is the passed captured type variable.\n+   *\n+   * <p>The second argument to visit must be a captured type variable.\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // Captured type vars can be compared with ==.\n+  private final SimpleAnnotatedTypeScanner<Boolean, TypeVariable> captureScanner =\n+      new SimpleAnnotatedTypeScanner<>(\n+          (type, other) -> type.getUnderlyingType() == other, Boolean::logicalOr, false);\n+\n+  /**\n+   * Set the annotated bounds for fresh type variable {@code capturedTypeVar}, so that it is the\n+   * capture of {@code wildcard}.\n+   *\n+   * @param typeVarToAnnotatedTypeArg mapping from a (type mirror) type variable to its (annotated\n+   *     type mirror) type argument\n+   * @param capturedTypeVarToAnnotatedTypeVar mapping from a captured type variable to its {@link\n+   *     AnnotatedTypeMirror}\n+   * @param wildcard wildcard which is converted to {@code capturedTypeVar}\n+   * @param typeVariable type variable for which {@code wildcard} is a type argument\n+   * @param capturedTypeVar the fresh type variable which is side-effected by this method\n+   */\n+  private void annotateCapturedTypeVar(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg,\n+      Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar,\n+      AnnotatedWildcardType wildcard,\n+      AnnotatedTypeVariable typeVariable,\n+      AnnotatedTypeVariable capturedTypeVar) {\n+    AnnotatedTypeMirror typeVarUpperBound =\n+        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+            typeVarToAnnotatedTypeArg, typeVariable.getUpperBound());\n+\n+    AnnotatedTypeMirror upperBound =\n+        AnnotatedTypes.greatestLowerBound(this, typeVarUpperBound, wildcard.getExtendsBound());\n+    capturedTypeVar.setUpperBound(upperBound);\n+\n+    AnnotatedTypeMirror lowerBound =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 621}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE0OTk4Nzc2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyNjo0OVrOJvcSHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNVQyMjowMTozM1rOJ0hvrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyNjIzOQ==", "bodyText": "Should those in the intersection also be removed from the bounds where they are now redundant?  Or is it better to retain them?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653726239", "createdAt": "2021-06-17T16:26:49Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are add by\n+        // #annotateCapturedTypeVar.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarToAnnotatedTypeVar.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      annotateCapturedTypeVar(\n+          typeVarToAnnotatedTypeArg,\n+          capturedTypeVarToAnnotatedTypeVar,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.set(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its capturedType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private final NonWildcardTypeArgCopier nonWildcardTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      // `originalToCopy` means a mapping from the original to the copy, not an original that needs\n+      // to be copied.\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int numTypeArgs = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[numTypeArgs];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(numTypeArgs);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is a type var, add it to typeVarMap.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyOfArg = visit(uncapturedArg, originalToCopy);\n+          if (copyOfArg.getKind() == TypeKind.TYPEVAR) {\n+            typeVarMap.put(((AnnotatedTypeVariable) copyOfArg).getUnderlyingType(), copyOfArg);\n+          }\n+          newTypeArgs[i] = copyOfArg;\n+        }\n+      }\n+\n+      // Substitute the type variables in each type argument of capturedType using typeVarMap.\n+      // This makes type variables in capturedType the same object when they are the same type\n+      // variable.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        AnnotatedTypeMirror capturedArg = capturedType.getTypeArguments().get(i);\n+        // Note: this if statement can't be replaced with\n+        //   if (TypesUtils.isCapturedTypeVariable(capturedArg))\n+        // because if the bounds of the captured wildcard are equal, then instead of a captured\n+        // wildcard, the type of the bound is used.\n+        if (uncapturedArg.getKind() == TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror newCapArg =\n+              typeVarSubstitutor.substituteWithoutCopyingTypeArguments(typeVarMap, capturedArg);\n+          newTypeArgs[i] = newCapArg;\n+        }\n+      }\n+      // Set capturedType type args to newTypeArgs.\n+      capturedType.setTypeArguments(Arrays.asList(newTypeArgs));\n+\n+      // Visit the enclosing type.\n+      if (uncapturedType.getEnclosingType() != null) {\n+        capturedType.setEnclosingType(\n+            (AnnotatedDeclaredType) visit(uncapturedType.getEnclosingType(), originalToCopy));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the list of type variables such that a type variable in the list only references type\n+   * variables at a lower index than itself.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the type variables ordered so that each type variable only references earlier type\n+   *     variables\n+   */\n+  public List<AnnotatedTypeVariable> order(Collection<AnnotatedTypeVariable> collection) {\n+    List<AnnotatedTypeVariable> list = new ArrayList<>(collection);\n+    List<AnnotatedTypeVariable> ordered = new ArrayList<>();\n+    while (!list.isEmpty()) {\n+      AnnotatedTypeVariable free = doesNotContainOthers(list);\n+      list.remove(free);\n+      ordered.add(free);\n+    }\n+    return ordered;\n+  }\n+\n+  /**\n+   * Returns the first TypeVariable in {@code collection} that does not (lexically) contain any\n+   * other type in the collection.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the first TypeVariable in {@code collection} that does not contain any other type in\n+   *     the collection, except possibly itself\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // must be the same object from collection\n+  private AnnotatedTypeVariable doesNotContainOthers(\n+      Collection<? extends AnnotatedTypeVariable> collection) {\n+    for (AnnotatedTypeVariable candidate : collection) {\n+      boolean doesNotContain = true;\n+      for (AnnotatedTypeVariable other : collection) {\n+        if (candidate != other && captureScanner.visit(candidate, other.getUnderlyingType())) {\n+          doesNotContain = false;\n+          break;\n+        }\n+      }\n+      if (doesNotContain) {\n+        return candidate;\n+      }\n+    }\n+    throw new BugInCF(\"Not found: %s\", StringsPlume.join(\",\", collection));\n+  }\n+\n+  /**\n+   * Scanner that returns true if the underlying type of any part of an {@link AnnotatedTypeMirror}\n+   * is the passed captured type variable.\n+   *\n+   * <p>The second argument to visit must be a captured type variable.\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // Captured type vars can be compared with ==.\n+  private final SimpleAnnotatedTypeScanner<Boolean, TypeVariable> captureScanner =\n+      new SimpleAnnotatedTypeScanner<>(\n+          (type, other) -> type.getUnderlyingType() == other, Boolean::logicalOr, false);\n+\n+  /**\n+   * Set the annotated bounds for fresh type variable {@code capturedTypeVar}, so that it is the\n+   * capture of {@code wildcard}.\n+   *\n+   * @param typeVarToAnnotatedTypeArg mapping from a (type mirror) type variable to its (annotated\n+   *     type mirror) type argument\n+   * @param capturedTypeVarToAnnotatedTypeVar mapping from a captured type variable to its {@link\n+   *     AnnotatedTypeMirror}\n+   * @param wildcard wildcard which is converted to {@code capturedTypeVar}\n+   * @param typeVariable type variable for which {@code wildcard} is a type argument\n+   * @param capturedTypeVar the fresh type variable which is side-effected by this method\n+   */\n+  private void annotateCapturedTypeVar(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg,\n+      Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar,\n+      AnnotatedWildcardType wildcard,\n+      AnnotatedTypeVariable typeVariable,\n+      AnnotatedTypeVariable capturedTypeVar) {\n+    AnnotatedTypeMirror typeVarUpperBound =\n+        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+            typeVarToAnnotatedTypeArg, typeVariable.getUpperBound());\n+\n+    AnnotatedTypeMirror upperBound =\n+        AnnotatedTypes.greatestLowerBound(this, typeVarUpperBound, wildcard.getExtendsBound());\n+    capturedTypeVar.setUpperBound(upperBound);\n+\n+    AnnotatedTypeMirror lowerBound =\n+        AnnotatedTypes.leastUpperBound(\n+            this, typeVariable.getLowerBound(), wildcard.getSuperBound());\n+    capturedTypeVar.setLowerBound(lowerBound);\n+\n+    // Add as a primary annotation any qualifiers that are the same on the upper and lower bound.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 626}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NDYyNDY4Mg==", "bodyText": "They are expected to be on the bounds so that it is a fully-annotated type, so they should not be removed.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r654624682", "createdAt": "2021-06-18T18:53:42Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are add by\n+        // #annotateCapturedTypeVar.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarToAnnotatedTypeVar.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      annotateCapturedTypeVar(\n+          typeVarToAnnotatedTypeArg,\n+          capturedTypeVarToAnnotatedTypeVar,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.set(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its capturedType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private final NonWildcardTypeArgCopier nonWildcardTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      // `originalToCopy` means a mapping from the original to the copy, not an original that needs\n+      // to be copied.\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int numTypeArgs = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[numTypeArgs];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(numTypeArgs);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is a type var, add it to typeVarMap.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyOfArg = visit(uncapturedArg, originalToCopy);\n+          if (copyOfArg.getKind() == TypeKind.TYPEVAR) {\n+            typeVarMap.put(((AnnotatedTypeVariable) copyOfArg).getUnderlyingType(), copyOfArg);\n+          }\n+          newTypeArgs[i] = copyOfArg;\n+        }\n+      }\n+\n+      // Substitute the type variables in each type argument of capturedType using typeVarMap.\n+      // This makes type variables in capturedType the same object when they are the same type\n+      // variable.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        AnnotatedTypeMirror capturedArg = capturedType.getTypeArguments().get(i);\n+        // Note: this if statement can't be replaced with\n+        //   if (TypesUtils.isCapturedTypeVariable(capturedArg))\n+        // because if the bounds of the captured wildcard are equal, then instead of a captured\n+        // wildcard, the type of the bound is used.\n+        if (uncapturedArg.getKind() == TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror newCapArg =\n+              typeVarSubstitutor.substituteWithoutCopyingTypeArguments(typeVarMap, capturedArg);\n+          newTypeArgs[i] = newCapArg;\n+        }\n+      }\n+      // Set capturedType type args to newTypeArgs.\n+      capturedType.setTypeArguments(Arrays.asList(newTypeArgs));\n+\n+      // Visit the enclosing type.\n+      if (uncapturedType.getEnclosingType() != null) {\n+        capturedType.setEnclosingType(\n+            (AnnotatedDeclaredType) visit(uncapturedType.getEnclosingType(), originalToCopy));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the list of type variables such that a type variable in the list only references type\n+   * variables at a lower index than itself.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the type variables ordered so that each type variable only references earlier type\n+   *     variables\n+   */\n+  public List<AnnotatedTypeVariable> order(Collection<AnnotatedTypeVariable> collection) {\n+    List<AnnotatedTypeVariable> list = new ArrayList<>(collection);\n+    List<AnnotatedTypeVariable> ordered = new ArrayList<>();\n+    while (!list.isEmpty()) {\n+      AnnotatedTypeVariable free = doesNotContainOthers(list);\n+      list.remove(free);\n+      ordered.add(free);\n+    }\n+    return ordered;\n+  }\n+\n+  /**\n+   * Returns the first TypeVariable in {@code collection} that does not (lexically) contain any\n+   * other type in the collection.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the first TypeVariable in {@code collection} that does not contain any other type in\n+   *     the collection, except possibly itself\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // must be the same object from collection\n+  private AnnotatedTypeVariable doesNotContainOthers(\n+      Collection<? extends AnnotatedTypeVariable> collection) {\n+    for (AnnotatedTypeVariable candidate : collection) {\n+      boolean doesNotContain = true;\n+      for (AnnotatedTypeVariable other : collection) {\n+        if (candidate != other && captureScanner.visit(candidate, other.getUnderlyingType())) {\n+          doesNotContain = false;\n+          break;\n+        }\n+      }\n+      if (doesNotContain) {\n+        return candidate;\n+      }\n+    }\n+    throw new BugInCF(\"Not found: %s\", StringsPlume.join(\",\", collection));\n+  }\n+\n+  /**\n+   * Scanner that returns true if the underlying type of any part of an {@link AnnotatedTypeMirror}\n+   * is the passed captured type variable.\n+   *\n+   * <p>The second argument to visit must be a captured type variable.\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // Captured type vars can be compared with ==.\n+  private final SimpleAnnotatedTypeScanner<Boolean, TypeVariable> captureScanner =\n+      new SimpleAnnotatedTypeScanner<>(\n+          (type, other) -> type.getUnderlyingType() == other, Boolean::logicalOr, false);\n+\n+  /**\n+   * Set the annotated bounds for fresh type variable {@code capturedTypeVar}, so that it is the\n+   * capture of {@code wildcard}.\n+   *\n+   * @param typeVarToAnnotatedTypeArg mapping from a (type mirror) type variable to its (annotated\n+   *     type mirror) type argument\n+   * @param capturedTypeVarToAnnotatedTypeVar mapping from a captured type variable to its {@link\n+   *     AnnotatedTypeMirror}\n+   * @param wildcard wildcard which is converted to {@code capturedTypeVar}\n+   * @param typeVariable type variable for which {@code wildcard} is a type argument\n+   * @param capturedTypeVar the fresh type variable which is side-effected by this method\n+   */\n+  private void annotateCapturedTypeVar(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg,\n+      Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar,\n+      AnnotatedWildcardType wildcard,\n+      AnnotatedTypeVariable typeVariable,\n+      AnnotatedTypeVariable capturedTypeVar) {\n+    AnnotatedTypeMirror typeVarUpperBound =\n+        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+            typeVarToAnnotatedTypeArg, typeVariable.getUpperBound());\n+\n+    AnnotatedTypeMirror upperBound =\n+        AnnotatedTypes.greatestLowerBound(this, typeVarUpperBound, wildcard.getExtendsBound());\n+    capturedTypeVar.setUpperBound(upperBound);\n+\n+    AnnotatedTypeMirror lowerBound =\n+        AnnotatedTypes.leastUpperBound(\n+            this, typeVariable.getLowerBound(), wildcard.getSuperBound());\n+    capturedTypeVar.setLowerBound(lowerBound);\n+\n+    // Add as a primary annotation any qualifiers that are the same on the upper and lower bound.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyNjIzOQ=="}, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 626}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTA1ODYwNQ==", "bodyText": "Thanks.  Could you note that?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r659058605", "createdAt": "2021-06-25T22:01:33Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,450 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are add by\n+        // #annotateCapturedTypeVar.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarToAnnotatedTypeVar.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      annotateCapturedTypeVar(\n+          typeVarToAnnotatedTypeArg,\n+          capturedTypeVarToAnnotatedTypeVar,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.set(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its capturedType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private final NonWildcardTypeArgCopier nonWildcardTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      // `originalToCopy` means a mapping from the original to the copy, not an original that needs\n+      // to be copied.\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int numTypeArgs = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[numTypeArgs];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(numTypeArgs);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is a type var, add it to typeVarMap.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyOfArg = visit(uncapturedArg, originalToCopy);\n+          if (copyOfArg.getKind() == TypeKind.TYPEVAR) {\n+            typeVarMap.put(((AnnotatedTypeVariable) copyOfArg).getUnderlyingType(), copyOfArg);\n+          }\n+          newTypeArgs[i] = copyOfArg;\n+        }\n+      }\n+\n+      // Substitute the type variables in each type argument of capturedType using typeVarMap.\n+      // This makes type variables in capturedType the same object when they are the same type\n+      // variable.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        AnnotatedTypeMirror capturedArg = capturedType.getTypeArguments().get(i);\n+        // Note: this if statement can't be replaced with\n+        //   if (TypesUtils.isCapturedTypeVariable(capturedArg))\n+        // because if the bounds of the captured wildcard are equal, then instead of a captured\n+        // wildcard, the type of the bound is used.\n+        if (uncapturedArg.getKind() == TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror newCapArg =\n+              typeVarSubstitutor.substituteWithoutCopyingTypeArguments(typeVarMap, capturedArg);\n+          newTypeArgs[i] = newCapArg;\n+        }\n+      }\n+      // Set capturedType type args to newTypeArgs.\n+      capturedType.setTypeArguments(Arrays.asList(newTypeArgs));\n+\n+      // Visit the enclosing type.\n+      if (uncapturedType.getEnclosingType() != null) {\n+        capturedType.setEnclosingType(\n+            (AnnotatedDeclaredType) visit(uncapturedType.getEnclosingType(), originalToCopy));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the list of type variables such that a type variable in the list only references type\n+   * variables at a lower index than itself.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the type variables ordered so that each type variable only references earlier type\n+   *     variables\n+   */\n+  public List<AnnotatedTypeVariable> order(Collection<AnnotatedTypeVariable> collection) {\n+    List<AnnotatedTypeVariable> list = new ArrayList<>(collection);\n+    List<AnnotatedTypeVariable> ordered = new ArrayList<>();\n+    while (!list.isEmpty()) {\n+      AnnotatedTypeVariable free = doesNotContainOthers(list);\n+      list.remove(free);\n+      ordered.add(free);\n+    }\n+    return ordered;\n+  }\n+\n+  /**\n+   * Returns the first TypeVariable in {@code collection} that does not (lexically) contain any\n+   * other type in the collection.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the first TypeVariable in {@code collection} that does not contain any other type in\n+   *     the collection, except possibly itself\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // must be the same object from collection\n+  private AnnotatedTypeVariable doesNotContainOthers(\n+      Collection<? extends AnnotatedTypeVariable> collection) {\n+    for (AnnotatedTypeVariable candidate : collection) {\n+      boolean doesNotContain = true;\n+      for (AnnotatedTypeVariable other : collection) {\n+        if (candidate != other && captureScanner.visit(candidate, other.getUnderlyingType())) {\n+          doesNotContain = false;\n+          break;\n+        }\n+      }\n+      if (doesNotContain) {\n+        return candidate;\n+      }\n+    }\n+    throw new BugInCF(\"Not found: %s\", StringsPlume.join(\",\", collection));\n+  }\n+\n+  /**\n+   * Scanner that returns true if the underlying type of any part of an {@link AnnotatedTypeMirror}\n+   * is the passed captured type variable.\n+   *\n+   * <p>The second argument to visit must be a captured type variable.\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // Captured type vars can be compared with ==.\n+  private final SimpleAnnotatedTypeScanner<Boolean, TypeVariable> captureScanner =\n+      new SimpleAnnotatedTypeScanner<>(\n+          (type, other) -> type.getUnderlyingType() == other, Boolean::logicalOr, false);\n+\n+  /**\n+   * Set the annotated bounds for fresh type variable {@code capturedTypeVar}, so that it is the\n+   * capture of {@code wildcard}.\n+   *\n+   * @param typeVarToAnnotatedTypeArg mapping from a (type mirror) type variable to its (annotated\n+   *     type mirror) type argument\n+   * @param capturedTypeVarToAnnotatedTypeVar mapping from a captured type variable to its {@link\n+   *     AnnotatedTypeMirror}\n+   * @param wildcard wildcard which is converted to {@code capturedTypeVar}\n+   * @param typeVariable type variable for which {@code wildcard} is a type argument\n+   * @param capturedTypeVar the fresh type variable which is side-effected by this method\n+   */\n+  private void annotateCapturedTypeVar(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg,\n+      Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar,\n+      AnnotatedWildcardType wildcard,\n+      AnnotatedTypeVariable typeVariable,\n+      AnnotatedTypeVariable capturedTypeVar) {\n+    AnnotatedTypeMirror typeVarUpperBound =\n+        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+            typeVarToAnnotatedTypeArg, typeVariable.getUpperBound());\n+\n+    AnnotatedTypeMirror upperBound =\n+        AnnotatedTypes.greatestLowerBound(this, typeVarUpperBound, wildcard.getExtendsBound());\n+    capturedTypeVar.setUpperBound(upperBound);\n+\n+    AnnotatedTypeMirror lowerBound =\n+        AnnotatedTypes.leastUpperBound(\n+            this, typeVariable.getLowerBound(), wildcard.getSuperBound());\n+    capturedTypeVar.setLowerBound(lowerBound);\n+\n+    // Add as a primary annotation any qualifiers that are the same on the upper and lower bound.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyNjIzOQ=="}, "originalCommit": {"oid": "c24683b649f1295977246d51722df7626ed67fa9"}, "originalPosition": 626}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE0OTk5NzM1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyODo1MFrOJvcX-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyODo1MFrOJvcX-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyNzczNw==", "bodyText": "Which AnnotatedTypeVariable is mapped to?  That is, what is its relationship to the key?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653727737", "createdAt": "2021-06-17T16:28:50Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,448 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are added by\n+        // #annotateCapturedTypeVar, which is called at the end of this method.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarToAnnotatedTypeVar.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      annotateCapturedTypeVar(\n+          typeVarToAnnotatedTypeArg,\n+          capturedTypeVarToAnnotatedTypeVar,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.set(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its capturedType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private final NonWildcardTypeArgCopier nonWildcardTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      // The name \"originalToCopy\" means a mapping from the original to the copy, not an original\n+      // that needs to be copied.\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int numTypeArgs = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[numTypeArgs];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(numTypeArgs);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is a type var, add it to typeVarMap.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyOfArg = visit(uncapturedArg, originalToCopy);\n+          newTypeArgs[i] = copyOfArg;\n+          if (copyOfArg.getKind() == TypeKind.TYPEVAR) {\n+            typeVarMap.put(((AnnotatedTypeVariable) copyOfArg).getUnderlyingType(), copyOfArg);\n+          }\n+        }\n+      }\n+\n+      // Substitute the type variables in each type argument of capturedType using typeVarMap.\n+      // This makes type variables in capturedType the same object when they are the same type\n+      // variable.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        AnnotatedTypeMirror capturedArg = capturedType.getTypeArguments().get(i);\n+        // Note: This `if` statement can't be replaced with\n+        //   if (TypesUtils.isCapturedTypeVariable(capturedArg))\n+        // because if the bounds of the captured wildcard are equal, then instead of a captured\n+        // wildcard, the type of the bound is used.\n+        if (uncapturedArg.getKind() == TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror newCapArg =\n+              typeVarSubstitutor.substituteWithoutCopyingTypeArguments(typeVarMap, capturedArg);\n+          newTypeArgs[i] = newCapArg;\n+        }\n+      }\n+      // Set capturedType type args to newTypeArgs.\n+      capturedType.setTypeArguments(Arrays.asList(newTypeArgs));\n+\n+      // Visit the enclosing type.\n+      if (uncapturedType.getEnclosingType() != null) {\n+        capturedType.setEnclosingType(\n+            (AnnotatedDeclaredType) visit(uncapturedType.getEnclosingType(), originalToCopy));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the list of type variables such that a type variable in the list only references type\n+   * variables at a lower index than itself.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the type variables ordered so that each type variable only references earlier type\n+   *     variables\n+   */\n+  public List<AnnotatedTypeVariable> order(Collection<AnnotatedTypeVariable> collection) {\n+    List<AnnotatedTypeVariable> list = new ArrayList<>(collection);\n+    List<AnnotatedTypeVariable> ordered = new ArrayList<>();\n+    while (!list.isEmpty()) {\n+      AnnotatedTypeVariable free = doesNotContainOthers(list);\n+      list.remove(free);\n+      ordered.add(free);\n+    }\n+    return ordered;\n+  }\n+\n+  /**\n+   * Returns the first TypeVariable in {@code collection} that does not lexically contain any other\n+   * type in the collection.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the first TypeVariable in {@code collection} that does not contain any other type in\n+   *     the collection, except possibly itself\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // must be the same object from collection\n+  private AnnotatedTypeVariable doesNotContainOthers(\n+      Collection<? extends AnnotatedTypeVariable> collection) {\n+    for (AnnotatedTypeVariable candidate : collection) {\n+      boolean doesNotContain = true;\n+      for (AnnotatedTypeVariable other : collection) {\n+        if (candidate != other && captureScanner.visit(candidate, other.getUnderlyingType())) {\n+          doesNotContain = false;\n+          break;\n+        }\n+      }\n+      if (doesNotContain) {\n+        return candidate;\n+      }\n+    }\n+    throw new BugInCF(\"Not found: %s\", StringsPlume.join(\",\", collection));\n+  }\n+\n+  /**\n+   * Scanner that returns true if the underlying type of any part of an {@link AnnotatedTypeMirror}\n+   * is the passed captured type variable.\n+   *\n+   * <p>The second argument to visit must be a captured type variable.\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // Captured type vars can be compared with ==.\n+  private final SimpleAnnotatedTypeScanner<Boolean, TypeVariable> captureScanner =\n+      new SimpleAnnotatedTypeScanner<>(\n+          (type, other) -> type.getUnderlyingType() == other, Boolean::logicalOr, false);\n+\n+  /**\n+   * Set the annotated bounds for fresh type variable {@code capturedTypeVar}, so that it is the\n+   * capture of {@code wildcard}.\n+   *\n+   * @param typeVarToAnnotatedTypeArg mapping from a (type mirror) type variable to its (annotated\n+   *     type mirror) type argument\n+   * @param capturedTypeVarToAnnotatedTypeVar mapping from a captured type variable to its {@link\n+   *     AnnotatedTypeMirror}\n+   * @param wildcard wildcard which is converted to {@code capturedTypeVar}\n+   * @param typeVariable type variable for which {@code wildcard} is a type argument\n+   * @param capturedTypeVar the fresh type variable which is side-effected by this method\n+   */\n+  private void annotateCapturedTypeVar(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg,\n+      Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar,\n+      AnnotatedWildcardType wildcard,\n+      AnnotatedTypeVariable typeVariable,\n+      AnnotatedTypeVariable capturedTypeVar) {\n+\n+    AnnotatedTypeMirror typeVarUpperBound =\n+        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+            typeVarToAnnotatedTypeArg, typeVariable.getUpperBound());\n+    AnnotatedTypeMirror upperBound =\n+        AnnotatedTypes.greatestLowerBound(this, typeVarUpperBound, wildcard.getExtendsBound());\n+    capturedTypeVar.setUpperBound(upperBound);\n+\n+    AnnotatedTypeMirror lowerBound =\n+        AnnotatedTypes.leastUpperBound(\n+            this, typeVariable.getLowerBound(), wildcard.getSuperBound());\n+    capturedTypeVar.setLowerBound(lowerBound);\n+\n+    // Add as a primary annotation any qualifiers that are the same on the upper and lower bound.\n+    AnnotationMirrorSet p =\n+        new AnnotationMirrorSet(capturedTypeVar.getUpperBound().getAnnotations());\n+    p.retainAll(capturedTypeVar.getLowerBound().getAnnotations());\n+    capturedTypeVar.replaceAnnotations(p);\n+\n+    capturedTypeVarSubstitutor.substitute(capturedTypeVar, capturedTypeVarToAnnotatedTypeVar);\n+  }\n+\n+  /**\n+   * Substitutes references to captured type variables.\n+   *\n+   * <p>Unlike {@link #typeVarSubstitutor}, this class does not copy the type. Call {@code\n+   * substitute} to use.\n+   */\n+  private final CapturedTypeVarSubstitutor capturedTypeVarSubstitutor =\n+      new CapturedTypeVarSubstitutor();\n+\n+  /**\n+   * Substitutes references to captured types in {@code type} using {@code\n+   * capturedTypeVarToAnnotatedTypeVar}.\n+   *\n+   * <p>Unlike {@link #typeVarSubstitutor}, this class does not copy the type. Call {@code\n+   * substitute} to use.\n+   */\n+  private static class CapturedTypeVarSubstitutor extends AnnotatedTypeCopier {\n+\n+    /** A mapping from a captured type variable to an AnnotatedTypeVariable. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbf7d05df7d953012f508ed42251466bf1463513"}, "originalPosition": 653}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE0OTk5OTg5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyOToyM1rOJvcZmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0xN1QxNjoyOToyM1rOJvcZmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1MzcyODE1NA==", "bodyText": "Are they already captured type variables, or does this method do the work to make them captured type variables?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r653728154", "createdAt": "2021-06-17T16:29:23Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -4631,6 +4622,448 @@ private void makeGroundTargetType(\n     addDefaultAnnotations(functionalType);\n   }\n \n+  /**\n+   * Return true if {@code type} should be captured.\n+   *\n+   * <p>{@code type} should be captured if all of the following are true:\n+   *\n+   * <ul>\n+   *   <li>{@code type} and {@code typeMirror} are both declared types.\n+   *   <li>{@code type} does not have an uninferred type argument and its underlying type is not\n+   *       raw.\n+   *   <li>{@code type} has a wildcard as a type argument and {@code typeMirror} has a captured type\n+   *       variable as the corresponding type argument.\n+   * </ul>\n+   *\n+   * @param type annotated type that might need to be captured\n+   * @param typeMirror the capture of the underlying type of {@code type}\n+   * @return true if {@code type} should be captured\n+   */\n+  private boolean shouldCapture(AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+    if (type.getKind() != TypeKind.DECLARED || typeMirror.getKind() != TypeKind.DECLARED) {\n+      return false;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    if (capturedTypeMirror.getTypeArguments().isEmpty()) {\n+      return false;\n+    }\n+\n+    if (uncapturedType.isUnderlyingTypeRaw() || uncapturedType.containsUninferredTypeArguments()) {\n+      return false;\n+    }\n+\n+    if (capturedTypeMirror.getTypeArguments().size() != uncapturedType.getTypeArguments().size()) {\n+      throw new BugInCF(\n+          \"Not the same number of type arguments: capturedTypeMirror: %s uncapturedType: %s\",\n+          capturedTypeMirror, uncapturedType);\n+    }\n+\n+    for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+      TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+          && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+              || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code typeToCapture}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param typeToCapture type to capture\n+   * @return the result of applying capture conversion to {@code typeToCapture}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(AnnotatedTypeMirror typeToCapture) {\n+    TypeMirror capturedTypeMirror = types.capture(typeToCapture.getUnderlyingType());\n+    return applyCaptureConversion(typeToCapture, capturedTypeMirror);\n+  }\n+\n+  /**\n+   * Apply capture conversion to {@code type}.\n+   *\n+   * <p>Capture conversion is the process of converting wildcards in a parameterized type to fresh\n+   * type variables. See <a\n+   * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-5.html#jls-5.1.10\">JLS 5.1.10</a>\n+   * for details.\n+   *\n+   * <p>If {@code type} is not a declared type or if it does not have any wildcard type arguments,\n+   * this method returns {@code type}.\n+   *\n+   * @param type type to capture\n+   * @param typeMirror the result of applying capture conversion to the underlying type of {@code\n+   *     type}; it is used as the underlying type of the returned type\n+   * @return the result of applying capture conversion to {@code type}\n+   */\n+  public AnnotatedTypeMirror applyCaptureConversion(\n+      AnnotatedTypeMirror type, TypeMirror typeMirror) {\n+\n+    // If capture conversion the type contains uninferred type arguments, don't capture, but\n+    // mark all wildcards in type as \"uninferred\" before it is returned.\n+    if (type.containsUninferredTypeArguments()\n+        && typeMirror.getKind() == TypeKind.DECLARED\n+        && type.getKind() == TypeKind.DECLARED) {\n+      AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+      DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+      for (int i = 0; i < capturedTypeMirror.getTypeArguments().size(); i++) {\n+        AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+        TypeMirror capturedTypeArgTM = capturedTypeMirror.getTypeArguments().get(i);\n+        if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD\n+            && (TypesUtils.isCapturedTypeVariable(capturedTypeArgTM)\n+                || capturedTypeArgTM.getKind() != TypeKind.WILDCARD)) {\n+          ((AnnotatedWildcardType) uncapturedTypeArg).setUninferredTypeArgument();\n+        }\n+      }\n+      return type;\n+    }\n+\n+    if (!shouldCapture(type, typeMirror)) {\n+      return type;\n+    }\n+\n+    AnnotatedDeclaredType uncapturedType = (AnnotatedDeclaredType) type;\n+    DeclaredType capturedTypeMirror = (DeclaredType) typeMirror;\n+    // `capturedType` is the return value of this method.\n+    AnnotatedDeclaredType capturedType =\n+        (AnnotatedDeclaredType) AnnotatedTypeMirror.createType(capturedTypeMirror, this, false);\n+\n+    nonWildcardTypeArgCopier.copy(uncapturedType, capturedType);\n+\n+    AnnotatedDeclaredType typeDeclaration =\n+        (AnnotatedDeclaredType) getAnnotatedType(uncapturedType.getUnderlyingType().asElement());\n+\n+    // A mapping from type variable to its type argument in the captured type.\n+    Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg = new HashMap<>();\n+    // A mapping from a captured type variable to the annotated captured type variable.\n+    Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar = new HashMap<>();\n+    // `newTypeArgs` will be the type arguments of the result of this method.\n+    List<AnnotatedTypeMirror> newTypeArgs = new ArrayList<>();\n+    for (int i = 0; i < typeDeclaration.getTypeArguments().size(); i++) {\n+      TypeVariable typeVarTypeMirror =\n+          (TypeVariable) typeDeclaration.getTypeArguments().get(i).getUnderlyingType();\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeMirror capturedTypeArg = capturedType.getTypeArguments().get(i);\n+      if (uncapturedTypeArg.getKind() == TypeKind.WILDCARD) {\n+        // The type argument is a captured type variable. Use the type argument from the newly\n+        // created and yet-to-be annotated capturedType. (The annotations are added by\n+        // #annotateCapturedTypeVar, which is called at the end of this method.)\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, capturedTypeArg);\n+        newTypeArgs.add(capturedTypeArg);\n+        if (TypesUtils.isCapturedTypeVariable(capturedTypeArg.getUnderlyingType())) {\n+          // Also, add a mapping from the captured type variable to the annotated captured\n+          // type variable, so that if one captured type variable refers to another, the same\n+          // AnnotatedTypeVariable object is used.\n+          capturedTypeVarToAnnotatedTypeVar.put(\n+              ((AnnotatedTypeVariable) capturedTypeArg).getUnderlyingType(),\n+              (AnnotatedTypeVariable) capturedTypeArg);\n+        } else {\n+          // Javac used a declared type instead of a captured type variable.  This seems to happen\n+          // when the bounds of the captured type variable would have been identical. This seems to\n+          // be a violation of the JLS, but javac does this, so the Checker Framework must handle\n+          // that case.\n+          replaceAnnotations(\n+              ((AnnotatedWildcardType) uncapturedTypeArg).getSuperBound(), capturedTypeArg);\n+        }\n+      } else {\n+        // The type argument is not a wildcard.\n+        typeVarToAnnotatedTypeArg.put(typeVarTypeMirror, uncapturedTypeArg);\n+        if (uncapturedTypeArg.getKind() == TypeKind.TYPEVAR) {\n+          AnnotatedTypeVariable typeVar = (AnnotatedTypeVariable) uncapturedTypeArg;\n+          typeVarToAnnotatedTypeArg.put(typeVar.getUnderlyingType(), typeVar);\n+        }\n+        newTypeArgs.add(uncapturedTypeArg);\n+      }\n+    }\n+\n+    // Set the annotations of each captured type variable.\n+    List<AnnotatedTypeVariable> orderToCapture = order(capturedTypeVarToAnnotatedTypeVar.values());\n+    for (AnnotatedTypeVariable capturedTypeArg : orderToCapture) {\n+      int i = capturedTypeMirror.getTypeArguments().indexOf(capturedTypeArg.getUnderlyingType());\n+      AnnotatedTypeMirror uncapturedTypeArg = uncapturedType.getTypeArguments().get(i);\n+      AnnotatedTypeVariable typeVariable =\n+          (AnnotatedTypeVariable) typeDeclaration.getTypeArguments().get(i);\n+      annotateCapturedTypeVar(\n+          typeVarToAnnotatedTypeArg,\n+          capturedTypeVarToAnnotatedTypeVar,\n+          (AnnotatedWildcardType) uncapturedTypeArg,\n+          typeVariable,\n+          capturedTypeArg);\n+      newTypeArgs.set(i, capturedTypeArg);\n+    }\n+\n+    capturedType.setTypeArguments(newTypeArgs);\n+    capturedType.addAnnotations(uncapturedType.getAnnotations());\n+    return capturedType;\n+  }\n+\n+  /**\n+   * Copy the non-wildcard type args from a uncapturedType to its capturedType. Also, ensure that\n+   * type variables in capturedType are the same object when they are refer to the same type\n+   * variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private final NonWildcardTypeArgCopier nonWildcardTypeArgCopier = new NonWildcardTypeArgCopier();\n+\n+  /**\n+   * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+   * ensure that type variables in {@code capturedType} are the same object when they refer to the\n+   * same type variable.\n+   *\n+   * <p>To use, call {@link NonWildcardTypeArgCopier#copy} rather than a visit method.\n+   */\n+  private class NonWildcardTypeArgCopier extends AnnotatedTypeCopier {\n+\n+    /**\n+     * Copy the non-wildcard type args from {@code uncapturedType} to {@code capturedType}. Also,\n+     * ensure that type variables {@code capturedType} are the same object when they are refer to\n+     * the same type variable.\n+     *\n+     * @param uncapturedType a declared type that has not under gone capture conversion\n+     * @param capturedType the captured version of {@code uncapturedType} before it has been\n+     *     annotated\n+     */\n+    private void copy(AnnotatedDeclaredType uncapturedType, AnnotatedDeclaredType capturedType) {\n+\n+      // The name \"originalToCopy\" means a mapping from the original to the copy, not an original\n+      // that needs to be copied.\n+      IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy =\n+          new IdentityHashMap<>();\n+      AnnotatedDeclaredType original = uncapturedType;\n+      originalToCopy.put(original, capturedType);\n+      int numTypeArgs = uncapturedType.getTypeArguments().size();\n+\n+      AnnotatedTypeMirror[] newTypeArgs = new AnnotatedTypeMirror[numTypeArgs];\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarMap = new HashMap<>(numTypeArgs);\n+      // Copy the non-wildcard type args from uncapturedType to newTypeArgs.\n+      // If the non-wildcard type arg is a type var, add it to typeVarMap.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        if (uncapturedArg.getKind() != TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror copyOfArg = visit(uncapturedArg, originalToCopy);\n+          newTypeArgs[i] = copyOfArg;\n+          if (copyOfArg.getKind() == TypeKind.TYPEVAR) {\n+            typeVarMap.put(((AnnotatedTypeVariable) copyOfArg).getUnderlyingType(), copyOfArg);\n+          }\n+        }\n+      }\n+\n+      // Substitute the type variables in each type argument of capturedType using typeVarMap.\n+      // This makes type variables in capturedType the same object when they are the same type\n+      // variable.\n+      for (int i = 0; i < numTypeArgs; i++) {\n+        AnnotatedTypeMirror uncapturedArg = uncapturedType.getTypeArguments().get(i);\n+        AnnotatedTypeMirror capturedArg = capturedType.getTypeArguments().get(i);\n+        // Note: This `if` statement can't be replaced with\n+        //   if (TypesUtils.isCapturedTypeVariable(capturedArg))\n+        // because if the bounds of the captured wildcard are equal, then instead of a captured\n+        // wildcard, the type of the bound is used.\n+        if (uncapturedArg.getKind() == TypeKind.WILDCARD) {\n+          AnnotatedTypeMirror newCapArg =\n+              typeVarSubstitutor.substituteWithoutCopyingTypeArguments(typeVarMap, capturedArg);\n+          newTypeArgs[i] = newCapArg;\n+        }\n+      }\n+      // Set capturedType type args to newTypeArgs.\n+      capturedType.setTypeArguments(Arrays.asList(newTypeArgs));\n+\n+      // Visit the enclosing type.\n+      if (uncapturedType.getEnclosingType() != null) {\n+        capturedType.setEnclosingType(\n+            (AnnotatedDeclaredType) visit(uncapturedType.getEnclosingType(), originalToCopy));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the list of type variables such that a type variable in the list only references type\n+   * variables at a lower index than itself.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the type variables ordered so that each type variable only references earlier type\n+   *     variables\n+   */\n+  public List<AnnotatedTypeVariable> order(Collection<AnnotatedTypeVariable> collection) {\n+    List<AnnotatedTypeVariable> list = new ArrayList<>(collection);\n+    List<AnnotatedTypeVariable> ordered = new ArrayList<>();\n+    while (!list.isEmpty()) {\n+      AnnotatedTypeVariable free = doesNotContainOthers(list);\n+      list.remove(free);\n+      ordered.add(free);\n+    }\n+    return ordered;\n+  }\n+\n+  /**\n+   * Returns the first TypeVariable in {@code collection} that does not lexically contain any other\n+   * type in the collection.\n+   *\n+   * @param collection a collection of type variables\n+   * @return the first TypeVariable in {@code collection} that does not contain any other type in\n+   *     the collection, except possibly itself\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // must be the same object from collection\n+  private AnnotatedTypeVariable doesNotContainOthers(\n+      Collection<? extends AnnotatedTypeVariable> collection) {\n+    for (AnnotatedTypeVariable candidate : collection) {\n+      boolean doesNotContain = true;\n+      for (AnnotatedTypeVariable other : collection) {\n+        if (candidate != other && captureScanner.visit(candidate, other.getUnderlyingType())) {\n+          doesNotContain = false;\n+          break;\n+        }\n+      }\n+      if (doesNotContain) {\n+        return candidate;\n+      }\n+    }\n+    throw new BugInCF(\"Not found: %s\", StringsPlume.join(\",\", collection));\n+  }\n+\n+  /**\n+   * Scanner that returns true if the underlying type of any part of an {@link AnnotatedTypeMirror}\n+   * is the passed captured type variable.\n+   *\n+   * <p>The second argument to visit must be a captured type variable.\n+   */\n+  @SuppressWarnings(\"interning:not.interned\") // Captured type vars can be compared with ==.\n+  private final SimpleAnnotatedTypeScanner<Boolean, TypeVariable> captureScanner =\n+      new SimpleAnnotatedTypeScanner<>(\n+          (type, other) -> type.getUnderlyingType() == other, Boolean::logicalOr, false);\n+\n+  /**\n+   * Set the annotated bounds for fresh type variable {@code capturedTypeVar}, so that it is the\n+   * capture of {@code wildcard}.\n+   *\n+   * @param typeVarToAnnotatedTypeArg mapping from a (type mirror) type variable to its (annotated\n+   *     type mirror) type argument\n+   * @param capturedTypeVarToAnnotatedTypeVar mapping from a captured type variable to its {@link\n+   *     AnnotatedTypeMirror}\n+   * @param wildcard wildcard which is converted to {@code capturedTypeVar}\n+   * @param typeVariable type variable for which {@code wildcard} is a type argument\n+   * @param capturedTypeVar the fresh type variable which is side-effected by this method\n+   */\n+  private void annotateCapturedTypeVar(\n+      Map<TypeVariable, AnnotatedTypeMirror> typeVarToAnnotatedTypeArg,\n+      Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar,\n+      AnnotatedWildcardType wildcard,\n+      AnnotatedTypeVariable typeVariable,\n+      AnnotatedTypeVariable capturedTypeVar) {\n+\n+    AnnotatedTypeMirror typeVarUpperBound =\n+        typeVarSubstitutor.substituteWithoutCopyingTypeArguments(\n+            typeVarToAnnotatedTypeArg, typeVariable.getUpperBound());\n+    AnnotatedTypeMirror upperBound =\n+        AnnotatedTypes.greatestLowerBound(this, typeVarUpperBound, wildcard.getExtendsBound());\n+    capturedTypeVar.setUpperBound(upperBound);\n+\n+    AnnotatedTypeMirror lowerBound =\n+        AnnotatedTypes.leastUpperBound(\n+            this, typeVariable.getLowerBound(), wildcard.getSuperBound());\n+    capturedTypeVar.setLowerBound(lowerBound);\n+\n+    // Add as a primary annotation any qualifiers that are the same on the upper and lower bound.\n+    AnnotationMirrorSet p =\n+        new AnnotationMirrorSet(capturedTypeVar.getUpperBound().getAnnotations());\n+    p.retainAll(capturedTypeVar.getLowerBound().getAnnotations());\n+    capturedTypeVar.replaceAnnotations(p);\n+\n+    capturedTypeVarSubstitutor.substitute(capturedTypeVar, capturedTypeVarToAnnotatedTypeVar);\n+  }\n+\n+  /**\n+   * Substitutes references to captured type variables.\n+   *\n+   * <p>Unlike {@link #typeVarSubstitutor}, this class does not copy the type. Call {@code\n+   * substitute} to use.\n+   */\n+  private final CapturedTypeVarSubstitutor capturedTypeVarSubstitutor =\n+      new CapturedTypeVarSubstitutor();\n+\n+  /**\n+   * Substitutes references to captured types in {@code type} using {@code\n+   * capturedTypeVarToAnnotatedTypeVar}.\n+   *\n+   * <p>Unlike {@link #typeVarSubstitutor}, this class does not copy the type. Call {@code\n+   * substitute} to use.\n+   */\n+  private static class CapturedTypeVarSubstitutor extends AnnotatedTypeCopier {\n+\n+    /** A mapping from a captured type variable to an AnnotatedTypeVariable. */\n+    private Map<TypeVariable, AnnotatedTypeVariable> capturedTypeVarToAnnotatedTypeVar;\n+\n+    /**\n+     * Substitutes references to captured type variable in {@code type} using {@code\n+     * capturedTypeVarToAnnotatedTypeVar}.\n+     *\n+     * <p>Unlike {@link #typeVarSubstitutor}, this method does not copy the type.\n+     *\n+     * @param type AnnotatedTypeMirror whose captured type variables are substituted", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbf7d05df7d953012f508ed42251466bf1463513"}, "originalPosition": 662}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE3OTEyMzUyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxNjozMzoyOVrOJznzcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxNjozMzoyOVrOJznzcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODEwOTI5OA==", "bodyText": "This second sentence is a reference to a different section of the JLS.  Please mention that: \"In JLS section XX, ...\".", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658109298", "createdAt": "2021-06-24T16:33:29Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE3OTEyNzY3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxNjozNDozNFrOJzn2KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yOFQxODo0MDowOVrOJ1c-Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODEwOTk5Mw==", "bodyText": "I find the name of this method a bit hard to read; it sounds more like an imperative or command than a predicate.  Consider changing to \"shouldIgnore...\" or \"isIgnored...\" or the like.\nAlso, the Javadoc of this method says that it returns true if the checker should not issue warnings, but here it seems to affect behavior too.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658109993", "createdAt": "2021-06-24T16:34:34Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODMzMDQzMQ==", "bodyText": "I renamed the method.\n\nAlso, the Javadoc of this method says that it returns true if the checker should not issue warnings, but here it seems to affect behavior too.\n\nI don't understand this statement.  It does return true if the checker should not issue warnings.  In order for the checker to not issue warnings, isSubtype returns true.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658330431", "createdAt": "2021-06-24T22:38:32Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODEwOTk5Mw=="}, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTA1OTA5OQ==", "bodyText": "In the common case, a method either return a value or has a side effect, but not both.  I think this one does both.  Given that it does both, I think it should be documented as such, but right now it is only documented as returning a value and the side effect is not mentioned in the documenation.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r659059099", "createdAt": "2021-06-25T22:03:03Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODEwOTk5Mw=="}, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDAyODk4Ng==", "bodyText": "I'm sorry I still don't understand your comment. What is the side effect does ignoreUninferredTypeArgument have? It doesn't change any fields.  I'm happy to fix the documentation, but I don't understand what's confusing about it.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r660028986", "createdAt": "2021-06-28T18:40:09Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODEwOTk5Mw=="}, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE3OTEzMjMwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxNjozNTozMVrOJzn5BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNVQxNjo0NzozN1rOJ0YSFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODExMDcyNA==", "bodyText": "I don't understand this line.  (I understand the one above, but I don't see why this part of the test is desirable/necessary.)  Maybe it doesn't matter because this is a hack to be removed later.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658110724", "createdAt": "2021-06-24T16:35:31Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n-\n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD\n+        // TODO: the below should be removed after #979 is fixed.\n+        || (TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+            && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODkwMzU3Mg==", "bodyText": "I added a comment.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658903572", "createdAt": "2021-06-25T16:47:37Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n-\n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD\n+        // TODO: the below should be removed after #979 is fixed.\n+        || (TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+            && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODExMDcyNA=="}, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE3OTEzOTMxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxNjozNzowOFrOJzn9UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNVQxNjo0Nzo1N1rOJ0YTBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODExMTgyNA==", "bodyText": "I am not sure why this block is here.  Is it for case 7 in the JLS description?  Is it a hack for #979 that will be removed later?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658111824", "createdAt": "2021-06-24T16:37:08Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n-\n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD\n+        // TODO: the below should be removed after #979 is fixed.\n+        || (TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+            && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {\n+\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n+      }\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result;\n+      if (outside.getKind() == TypeKind.WILDCARD) {\n+        AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideWildcard.getSuperBound(),\n+                outsideWildcard.getExtendsBound(),\n+                canBeCovariant);\n+      } else {\n+        AnnotatedTypeVariable outsideTypeVar = (AnnotatedTypeVariable) outside;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODkwMzgxMg==", "bodyText": "It's a work around.  I moved the code to make this clearer.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658903812", "createdAt": "2021-06-25T16:47:57Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n-\n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD\n+        // TODO: the below should be removed after #979 is fixed.\n+        || (TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+            && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {\n+\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n+      }\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result;\n+      if (outside.getKind() == TypeKind.WILDCARD) {\n+        AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideWildcard.getSuperBound(),\n+                outsideWildcard.getExtendsBound(),\n+                canBeCovariant);\n+      } else {\n+        AnnotatedTypeVariable outsideTypeVar = (AnnotatedTypeVariable) outside;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODExMTgyNA=="}, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE3OTE0NjUxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxNjozODozM1rOJzoBdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxNjozODozM1rOJzoBdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODExMjg4NQ==", "bodyText": "There is no variable outside.  I think this comment should start with:\nLet outside be ? super outsideLower extends outsideUpper.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658112885", "createdAt": "2021-06-24T16:38:33Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n-\n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD\n+        // TODO: the below should be removed after #979 is fixed.\n+        || (TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+            && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {\n+\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n+      }\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result;\n+      if (outside.getKind() == TypeKind.WILDCARD) {\n+        AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideWildcard.getSuperBound(),\n+                outsideWildcard.getExtendsBound(),\n+                canBeCovariant);\n+      } else {\n+        AnnotatedTypeVariable outsideTypeVar = (AnnotatedTypeVariable) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideTypeVar.getLowerBound(),\n+                outsideTypeVar.getUpperBound(),\n+                canBeCovariant);\n       }\n-      return areEqualInHierarchy(inside, outside);\n-    }\n \n-    AnnotatedTypeMirror outsideUpperBound;\n-    AnnotatedTypeMirror outsideLowerBound;\n-    if (outside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-      outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-    } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-      outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-    } else {\n-      throw new BugInCF(\"Expected a wildcard or captured type variable, but found \" + outside);\n+      areEqualVisitHistory.put(inside, outside, currentTop, result);\n+      return result;\n     }\n-    Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-    if (previousResult != null) {\n-      return previousResult;\n+    if (canBeCovariant) {\n+      return isSubtype(inside, outside, currentTop);\n     }\n-\n-    areEqualVisitHistory.put(inside, outside, currentTop, true);\n-    boolean result =\n-        isContainedWildcard(inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-    areEqualVisitHistory.put(inside, outside, currentTop, result);\n-    return result;\n+    return areEqualInHierarchy(inside, outside);\n   }\n \n-  private boolean isContainedWildcard(\n+  /**\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE3OTE1MTE0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxNjozOTo0NVrOJzoEVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNVQyMjowNDoyM1rOJ0hzPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODExMzYyMw==", "bodyText": "Can there be assert outsideUpper.getKind() != TypeKind.NULL; here?  If so, add it -- for documentation more than for error detection.  If not, please explain.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658113623", "createdAt": "2021-06-24T16:39:45Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n-\n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD\n+        // TODO: the below should be removed after #979 is fixed.\n+        || (TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+            && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {\n+\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n+      }\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result;\n+      if (outside.getKind() == TypeKind.WILDCARD) {\n+        AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideWildcard.getSuperBound(),\n+                outsideWildcard.getExtendsBound(),\n+                canBeCovariant);\n+      } else {\n+        AnnotatedTypeVariable outsideTypeVar = (AnnotatedTypeVariable) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideTypeVar.getLowerBound(),\n+                outsideTypeVar.getUpperBound(),\n+                canBeCovariant);\n       }\n-      return areEqualInHierarchy(inside, outside);\n-    }\n \n-    AnnotatedTypeMirror outsideUpperBound;\n-    AnnotatedTypeMirror outsideLowerBound;\n-    if (outside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-      outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-    } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-      outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-    } else {\n-      throw new BugInCF(\"Expected a wildcard or captured type variable, but found \" + outside);\n+      areEqualVisitHistory.put(inside, outside, currentTop, result);\n+      return result;\n     }\n-    Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-    if (previousResult != null) {\n-      return previousResult;\n+    if (canBeCovariant) {\n+      return isSubtype(inside, outside, currentTop);\n     }\n-\n-    areEqualVisitHistory.put(inside, outside, currentTop, true);\n-    boolean result =\n-        isContainedWildcard(inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-    areEqualVisitHistory.put(inside, outside, currentTop, result);\n-    return result;\n+    return areEqualInHierarchy(inside, outside);\n   }\n \n-  private boolean isContainedWildcard(\n+  /**\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}. See\n+   * {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+   * explanation.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outsideLower the lower bound of the possibly-containing type\n+   * @param outsideUpper a the upper bound of the possibly-containing type\n+   * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+   * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n+   *     <: outside}\n+   */\n+  protected boolean isContainedByBoundType(\n       AnnotatedTypeMirror inside,\n-      AnnotatedTypeMirror outside,\n-      AnnotatedTypeMirror outsideUpperBound,\n-      AnnotatedTypeMirror outsideLowerBound,\n+      AnnotatedTypeMirror outsideLower,\n+      AnnotatedTypeMirror outsideUpper,\n       boolean canBeCovariant) {\n-\n-    if (inside.equals(outside)) {\n-      // If they are equal, outside always contains inside.\n-      return true;\n-    }\n-\n-    if (inside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound =\n-          checker\n-              .getTypeFactory()\n-              .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-    }\n-    while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-      if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-        return true;\n+    try {\n+      if (canBeCovariant) {\n+        if (outsideLower.getKind() != TypeKind.NULL) {\n+          return isSubtype(outsideLower, inside);\n+        } else {\n+          return isSubtype(inside, outsideUpper);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODMzMDgxMg==", "bodyText": "Upper bounds are never TypeKind.NULL.  I could add it, but it's nonsensical.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658330812", "createdAt": "2021-06-24T22:39:42Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n-\n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD\n+        // TODO: the below should be removed after #979 is fixed.\n+        || (TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+            && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {\n+\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n+      }\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result;\n+      if (outside.getKind() == TypeKind.WILDCARD) {\n+        AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideWildcard.getSuperBound(),\n+                outsideWildcard.getExtendsBound(),\n+                canBeCovariant);\n+      } else {\n+        AnnotatedTypeVariable outsideTypeVar = (AnnotatedTypeVariable) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideTypeVar.getLowerBound(),\n+                outsideTypeVar.getUpperBound(),\n+                canBeCovariant);\n       }\n-      return areEqualInHierarchy(inside, outside);\n-    }\n \n-    AnnotatedTypeMirror outsideUpperBound;\n-    AnnotatedTypeMirror outsideLowerBound;\n-    if (outside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-      outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-    } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-      outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-    } else {\n-      throw new BugInCF(\"Expected a wildcard or captured type variable, but found \" + outside);\n+      areEqualVisitHistory.put(inside, outside, currentTop, result);\n+      return result;\n     }\n-    Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-    if (previousResult != null) {\n-      return previousResult;\n+    if (canBeCovariant) {\n+      return isSubtype(inside, outside, currentTop);\n     }\n-\n-    areEqualVisitHistory.put(inside, outside, currentTop, true);\n-    boolean result =\n-        isContainedWildcard(inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-    areEqualVisitHistory.put(inside, outside, currentTop, result);\n-    return result;\n+    return areEqualInHierarchy(inside, outside);\n   }\n \n-  private boolean isContainedWildcard(\n+  /**\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}. See\n+   * {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+   * explanation.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outsideLower the lower bound of the possibly-containing type\n+   * @param outsideUpper a the upper bound of the possibly-containing type\n+   * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+   * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n+   *     <: outside}\n+   */\n+  protected boolean isContainedByBoundType(\n       AnnotatedTypeMirror inside,\n-      AnnotatedTypeMirror outside,\n-      AnnotatedTypeMirror outsideUpperBound,\n-      AnnotatedTypeMirror outsideLowerBound,\n+      AnnotatedTypeMirror outsideLower,\n+      AnnotatedTypeMirror outsideUpper,\n       boolean canBeCovariant) {\n-\n-    if (inside.equals(outside)) {\n-      // If they are equal, outside always contains inside.\n-      return true;\n-    }\n-\n-    if (inside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound =\n-          checker\n-              .getTypeFactory()\n-              .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-    }\n-    while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-      if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-        return true;\n+    try {\n+      if (canBeCovariant) {\n+        if (outsideLower.getKind() != TypeKind.NULL) {\n+          return isSubtype(outsideLower, inside);\n+        } else {\n+          return isSubtype(inside, outsideUpper);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODExMzYyMw=="}, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTA1OTUxOQ==", "bodyText": "Ah, that is actually the NULL type, and not an indication that the source code did not contain anything.  (Since the source code can contain a lower bound, an upper bound, or neither.)  I was incorrectly reading it as the latter.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r659059519", "createdAt": "2021-06-25T22:04:23Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n-\n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD\n+        // TODO: the below should be removed after #979 is fixed.\n+        || (TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+            && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {\n+\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n+      }\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result;\n+      if (outside.getKind() == TypeKind.WILDCARD) {\n+        AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideWildcard.getSuperBound(),\n+                outsideWildcard.getExtendsBound(),\n+                canBeCovariant);\n+      } else {\n+        AnnotatedTypeVariable outsideTypeVar = (AnnotatedTypeVariable) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideTypeVar.getLowerBound(),\n+                outsideTypeVar.getUpperBound(),\n+                canBeCovariant);\n       }\n-      return areEqualInHierarchy(inside, outside);\n-    }\n \n-    AnnotatedTypeMirror outsideUpperBound;\n-    AnnotatedTypeMirror outsideLowerBound;\n-    if (outside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-      outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-    } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-      outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-    } else {\n-      throw new BugInCF(\"Expected a wildcard or captured type variable, but found \" + outside);\n+      areEqualVisitHistory.put(inside, outside, currentTop, result);\n+      return result;\n     }\n-    Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-    if (previousResult != null) {\n-      return previousResult;\n+    if (canBeCovariant) {\n+      return isSubtype(inside, outside, currentTop);\n     }\n-\n-    areEqualVisitHistory.put(inside, outside, currentTop, true);\n-    boolean result =\n-        isContainedWildcard(inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-    areEqualVisitHistory.put(inside, outside, currentTop, result);\n-    return result;\n+    return areEqualInHierarchy(inside, outside);\n   }\n \n-  private boolean isContainedWildcard(\n+  /**\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}. See\n+   * {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+   * explanation.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outsideLower the lower bound of the possibly-containing type\n+   * @param outsideUpper a the upper bound of the possibly-containing type\n+   * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+   * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n+   *     <: outside}\n+   */\n+  protected boolean isContainedByBoundType(\n       AnnotatedTypeMirror inside,\n-      AnnotatedTypeMirror outside,\n-      AnnotatedTypeMirror outsideUpperBound,\n-      AnnotatedTypeMirror outsideLowerBound,\n+      AnnotatedTypeMirror outsideLower,\n+      AnnotatedTypeMirror outsideUpper,\n       boolean canBeCovariant) {\n-\n-    if (inside.equals(outside)) {\n-      // If they are equal, outside always contains inside.\n-      return true;\n-    }\n-\n-    if (inside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound =\n-          checker\n-              .getTypeFactory()\n-              .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-    }\n-    while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-      if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-        return true;\n+    try {\n+      if (canBeCovariant) {\n+        if (outsideLower.getKind() != TypeKind.NULL) {\n+          return isSubtype(outsideLower, inside);\n+        } else {\n+          return isSubtype(inside, outsideUpper);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODExMzYyMw=="}, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE3OTE1OTQ3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxNjo0MTozNlrOJzoJOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNVQyMjowNjoxOFrOJ0h1nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODExNDg3Mg==", "bodyText": "This looks suspicious to me.  Per the JLS algorithm, I think the first isSubtype call should be between outsideLower and the bound of inside, not inside itself.  (Likewise for the second isSubtype call.)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658114872", "createdAt": "2021-06-24T16:41:36Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n-\n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD\n+        // TODO: the below should be removed after #979 is fixed.\n+        || (TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+            && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {\n+\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n+      }\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result;\n+      if (outside.getKind() == TypeKind.WILDCARD) {\n+        AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideWildcard.getSuperBound(),\n+                outsideWildcard.getExtendsBound(),\n+                canBeCovariant);\n+      } else {\n+        AnnotatedTypeVariable outsideTypeVar = (AnnotatedTypeVariable) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideTypeVar.getLowerBound(),\n+                outsideTypeVar.getUpperBound(),\n+                canBeCovariant);\n       }\n-      return areEqualInHierarchy(inside, outside);\n-    }\n \n-    AnnotatedTypeMirror outsideUpperBound;\n-    AnnotatedTypeMirror outsideLowerBound;\n-    if (outside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-      outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-    } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-      outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-    } else {\n-      throw new BugInCF(\"Expected a wildcard or captured type variable, but found \" + outside);\n+      areEqualVisitHistory.put(inside, outside, currentTop, result);\n+      return result;\n     }\n-    Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-    if (previousResult != null) {\n-      return previousResult;\n+    if (canBeCovariant) {\n+      return isSubtype(inside, outside, currentTop);\n     }\n-\n-    areEqualVisitHistory.put(inside, outside, currentTop, true);\n-    boolean result =\n-        isContainedWildcard(inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-    areEqualVisitHistory.put(inside, outside, currentTop, result);\n-    return result;\n+    return areEqualInHierarchy(inside, outside);\n   }\n \n-  private boolean isContainedWildcard(\n+  /**\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}. See\n+   * {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+   * explanation.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outsideLower the lower bound of the possibly-containing type\n+   * @param outsideUpper a the upper bound of the possibly-containing type\n+   * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+   * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n+   *     <: outside}\n+   */\n+  protected boolean isContainedByBoundType(\n       AnnotatedTypeMirror inside,\n-      AnnotatedTypeMirror outside,\n-      AnnotatedTypeMirror outsideUpperBound,\n-      AnnotatedTypeMirror outsideLowerBound,\n+      AnnotatedTypeMirror outsideLower,\n+      AnnotatedTypeMirror outsideUpper,\n       boolean canBeCovariant) {\n-\n-    if (inside.equals(outside)) {\n-      // If they are equal, outside always contains inside.\n-      return true;\n-    }\n-\n-    if (inside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound =\n-          checker\n-              .getTypeFactory()\n-              .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-    }\n-    while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-      if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-        return true;\n+    try {\n+      if (canBeCovariant) {\n+        if (outsideLower.getKind() != TypeKind.NULL) {\n+          return isSubtype(outsideLower, inside);\n+        } else {\n+          return isSubtype(inside, outsideUpper);\n+        }\n       }\n-      outsideUpperBound = ((AnnotatedWildcardType) outsideUpperBound).getExtendsBound();\n-    }\n-\n-    if (!TypesUtils.isErasedSubtype(\n-        inside.getUnderlyingType(),\n-        outsideUpperBound.getUnderlyingType(),\n-        inside.atypeFactory.types)) {\n-      // TODO: subtype is a wildcard that should have been captured, so just check the primary\n-      // annotations.\n-      AnnotationMirror subAnno = inside.getEffectiveAnnotationInHierarchy(currentTop);\n-      AnnotationMirror superAnno = outsideUpperBound.getAnnotationInHierarchy(currentTop);\n-      return qualifierHierarchy.isSubtype(subAnno, superAnno);\n-    }\n-\n-    AnnotatedTypeMirror castedInside =\n-        AnnotatedTypes.castedAsSuper(inside.atypeFactory, inside, outsideUpperBound);\n-    if (!isSubtypeCaching(castedInside, outsideUpperBound)) {\n-      return false;\n-    }\n-\n-    if (outside.getKind() == TypeKind.WILDCARD && outsideLowerBound.getKind() == TypeKind.TYPEVAR) {\n-      // tests/all-systems/Issue1991.java crashes without this.\n-      return true;\n+      return isSubtype(outsideLower, inside) && isSubtype(inside, outsideUpper);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODMxMjk3Nw==", "bodyText": "If inside is a widlcard, then isSubtype(outsideLower, inside) calls isSubtype(outsideLower, inside.getLowerBound()) and isSubtype(inside, outsideUpper) calls isSubtype(inside.getUpperBound(), outsideUpper)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658312977", "createdAt": "2021-06-24T22:03:12Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n-\n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD\n+        // TODO: the below should be removed after #979 is fixed.\n+        || (TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+            && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {\n+\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n+      }\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result;\n+      if (outside.getKind() == TypeKind.WILDCARD) {\n+        AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideWildcard.getSuperBound(),\n+                outsideWildcard.getExtendsBound(),\n+                canBeCovariant);\n+      } else {\n+        AnnotatedTypeVariable outsideTypeVar = (AnnotatedTypeVariable) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideTypeVar.getLowerBound(),\n+                outsideTypeVar.getUpperBound(),\n+                canBeCovariant);\n       }\n-      return areEqualInHierarchy(inside, outside);\n-    }\n \n-    AnnotatedTypeMirror outsideUpperBound;\n-    AnnotatedTypeMirror outsideLowerBound;\n-    if (outside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-      outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-    } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-      outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-    } else {\n-      throw new BugInCF(\"Expected a wildcard or captured type variable, but found \" + outside);\n+      areEqualVisitHistory.put(inside, outside, currentTop, result);\n+      return result;\n     }\n-    Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-    if (previousResult != null) {\n-      return previousResult;\n+    if (canBeCovariant) {\n+      return isSubtype(inside, outside, currentTop);\n     }\n-\n-    areEqualVisitHistory.put(inside, outside, currentTop, true);\n-    boolean result =\n-        isContainedWildcard(inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-    areEqualVisitHistory.put(inside, outside, currentTop, result);\n-    return result;\n+    return areEqualInHierarchy(inside, outside);\n   }\n \n-  private boolean isContainedWildcard(\n+  /**\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}. See\n+   * {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+   * explanation.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outsideLower the lower bound of the possibly-containing type\n+   * @param outsideUpper a the upper bound of the possibly-containing type\n+   * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+   * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n+   *     <: outside}\n+   */\n+  protected boolean isContainedByBoundType(\n       AnnotatedTypeMirror inside,\n-      AnnotatedTypeMirror outside,\n-      AnnotatedTypeMirror outsideUpperBound,\n-      AnnotatedTypeMirror outsideLowerBound,\n+      AnnotatedTypeMirror outsideLower,\n+      AnnotatedTypeMirror outsideUpper,\n       boolean canBeCovariant) {\n-\n-    if (inside.equals(outside)) {\n-      // If they are equal, outside always contains inside.\n-      return true;\n-    }\n-\n-    if (inside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound =\n-          checker\n-              .getTypeFactory()\n-              .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-    }\n-    while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-      if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-        return true;\n+    try {\n+      if (canBeCovariant) {\n+        if (outsideLower.getKind() != TypeKind.NULL) {\n+          return isSubtype(outsideLower, inside);\n+        } else {\n+          return isSubtype(inside, outsideUpper);\n+        }\n       }\n-      outsideUpperBound = ((AnnotatedWildcardType) outsideUpperBound).getExtendsBound();\n-    }\n-\n-    if (!TypesUtils.isErasedSubtype(\n-        inside.getUnderlyingType(),\n-        outsideUpperBound.getUnderlyingType(),\n-        inside.atypeFactory.types)) {\n-      // TODO: subtype is a wildcard that should have been captured, so just check the primary\n-      // annotations.\n-      AnnotationMirror subAnno = inside.getEffectiveAnnotationInHierarchy(currentTop);\n-      AnnotationMirror superAnno = outsideUpperBound.getAnnotationInHierarchy(currentTop);\n-      return qualifierHierarchy.isSubtype(subAnno, superAnno);\n-    }\n-\n-    AnnotatedTypeMirror castedInside =\n-        AnnotatedTypes.castedAsSuper(inside.atypeFactory, inside, outsideUpperBound);\n-    if (!isSubtypeCaching(castedInside, outsideUpperBound)) {\n-      return false;\n-    }\n-\n-    if (outside.getKind() == TypeKind.WILDCARD && outsideLowerBound.getKind() == TypeKind.TYPEVAR) {\n-      // tests/all-systems/Issue1991.java crashes without this.\n-      return true;\n+      return isSubtype(outsideLower, inside) && isSubtype(inside, outsideUpper);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODExNDg3Mg=="}, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTA2MDEyNA==", "bodyText": "Since this is a variance from the algorithm as given in the JLS, I think it would be good to either:\n\nchange the code here (to slavishly copy the JLS algorithm) or\nnote that the behavior is identical to the JLS algorithm.\n\nThat will avoid a similar question by readers in the future.  Thanks.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r659060124", "createdAt": "2021-06-25T22:06:18Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,101 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n-   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n+   * 4.5.1 \"Type Arguments of Parameterized Types\"</a>. A declared type is considered a supertype of\n+   * another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n     if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n-\n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD\n+        // TODO: the below should be removed after #979 is fixed.\n+        || (TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+            && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {\n+\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n+      }\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result;\n+      if (outside.getKind() == TypeKind.WILDCARD) {\n+        AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideWildcard.getSuperBound(),\n+                outsideWildcard.getExtendsBound(),\n+                canBeCovariant);\n+      } else {\n+        AnnotatedTypeVariable outsideTypeVar = (AnnotatedTypeVariable) outside;\n+        result =\n+            isContainedByBoundType(\n+                inside,\n+                outsideTypeVar.getLowerBound(),\n+                outsideTypeVar.getUpperBound(),\n+                canBeCovariant);\n       }\n-      return areEqualInHierarchy(inside, outside);\n-    }\n \n-    AnnotatedTypeMirror outsideUpperBound;\n-    AnnotatedTypeMirror outsideLowerBound;\n-    if (outside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-      outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-    } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-      outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-    } else {\n-      throw new BugInCF(\"Expected a wildcard or captured type variable, but found \" + outside);\n+      areEqualVisitHistory.put(inside, outside, currentTop, result);\n+      return result;\n     }\n-    Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n-    if (previousResult != null) {\n-      return previousResult;\n+    if (canBeCovariant) {\n+      return isSubtype(inside, outside, currentTop);\n     }\n-\n-    areEqualVisitHistory.put(inside, outside, currentTop, true);\n-    boolean result =\n-        isContainedWildcard(inside, outside, outsideUpperBound, outsideLowerBound, canBeCovariant);\n-    areEqualVisitHistory.put(inside, outside, currentTop, result);\n-    return result;\n+    return areEqualInHierarchy(inside, outside);\n   }\n \n-  private boolean isContainedWildcard(\n+  /**\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}. See\n+   * {@link #isContainedBy(AnnotatedTypeMirror, AnnotatedTypeMirror, boolean)} for a full\n+   * explanation.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outsideLower the lower bound of the possibly-containing type\n+   * @param outsideUpper a the upper bound of the possibly-containing type\n+   * @param canBeCovariant whether or not type arguments are allowed to be covariant\n+   * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n+   *     <: outside}\n+   */\n+  protected boolean isContainedByBoundType(\n       AnnotatedTypeMirror inside,\n-      AnnotatedTypeMirror outside,\n-      AnnotatedTypeMirror outsideUpperBound,\n-      AnnotatedTypeMirror outsideLowerBound,\n+      AnnotatedTypeMirror outsideLower,\n+      AnnotatedTypeMirror outsideUpper,\n       boolean canBeCovariant) {\n-\n-    if (inside.equals(outside)) {\n-      // If they are equal, outside always contains inside.\n-      return true;\n-    }\n-\n-    if (inside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound =\n-          checker\n-              .getTypeFactory()\n-              .widenToUpperBound(outsideUpperBound, (AnnotatedWildcardType) inside);\n-    }\n-    while (outsideUpperBound.getKind() == TypeKind.WILDCARD) {\n-      if (ignoreUninferredTypeArgument(outsideUpperBound)) {\n-        return true;\n+    try {\n+      if (canBeCovariant) {\n+        if (outsideLower.getKind() != TypeKind.NULL) {\n+          return isSubtype(outsideLower, inside);\n+        } else {\n+          return isSubtype(inside, outsideUpper);\n+        }\n       }\n-      outsideUpperBound = ((AnnotatedWildcardType) outsideUpperBound).getExtendsBound();\n-    }\n-\n-    if (!TypesUtils.isErasedSubtype(\n-        inside.getUnderlyingType(),\n-        outsideUpperBound.getUnderlyingType(),\n-        inside.atypeFactory.types)) {\n-      // TODO: subtype is a wildcard that should have been captured, so just check the primary\n-      // annotations.\n-      AnnotationMirror subAnno = inside.getEffectiveAnnotationInHierarchy(currentTop);\n-      AnnotationMirror superAnno = outsideUpperBound.getAnnotationInHierarchy(currentTop);\n-      return qualifierHierarchy.isSubtype(subAnno, superAnno);\n-    }\n-\n-    AnnotatedTypeMirror castedInside =\n-        AnnotatedTypes.castedAsSuper(inside.atypeFactory, inside, outsideUpperBound);\n-    if (!isSubtypeCaching(castedInside, outsideUpperBound)) {\n-      return false;\n-    }\n-\n-    if (outside.getKind() == TypeKind.WILDCARD && outsideLowerBound.getKind() == TypeKind.TYPEVAR) {\n-      // tests/all-systems/Issue1991.java crashes without this.\n-      return true;\n+      return isSubtype(outsideLower, inside) && isSubtype(inside, outsideUpper);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODExNDg3Mg=="}, "originalCommit": {"oid": "83f6875c155b20abe3efd60c93a15327ed1399c0"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE3OTUwNzkxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxODowMjo0NFrOJzrgHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQyMjo0MjoyNVrOJz1ZQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODE2OTg4NA==", "bodyText": "Just below there is\n if (ignoreTypeArgs) {\n      return true;\n    }\nWhy is no test needed for the raw component?  What if this method were called with two arguments:  raw Class and raw List?  I suspect that subtype and supertype must have some specific relationship, such as that their raw types are the same or in some subtyping relationship.  Could you document that?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658169884", "createdAt": "2021-06-24T18:02:44Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -484,10 +485,16 @@ public Boolean visitDeclared_Declared(\n   /**\n    * A helper class for visitDeclared_Declared. There are subtypes of DefaultTypeHierarchy that need\n    * to customize the handling of type arguments. This method provides a convenient extension point.\n+   *\n+   * @param subtype a possible subtype\n+   * @param supertype a possible supertype\n+   * @param subtypeRaw whether {@code subtype} is a raw type\n+   * @param supertypeRaw whether {@code supertype} is a raw type\n+   * @return the result of visiting type args\n    */\n   protected boolean visitTypeArgs(\n-      final AnnotatedDeclaredType subtype,\n-      final AnnotatedDeclaredType supertype,\n+      AnnotatedDeclaredType subtype,\n+      AnnotatedDeclaredType supertype,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "714d7d96e3f7e60d56541f7d4d0f9d65f51cb2ae"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODMzMTk3MQ==", "bodyText": "I updated the method's Javadoc.  The underlying type of subtype is a subtype of the underlying type of supertype.  Also, this method is only checking the type arguments.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658331971", "createdAt": "2021-06-24T22:42:25Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -484,10 +485,16 @@ public Boolean visitDeclared_Declared(\n   /**\n    * A helper class for visitDeclared_Declared. There are subtypes of DefaultTypeHierarchy that need\n    * to customize the handling of type arguments. This method provides a convenient extension point.\n+   *\n+   * @param subtype a possible subtype\n+   * @param supertype a possible supertype\n+   * @param subtypeRaw whether {@code subtype} is a raw type\n+   * @param supertypeRaw whether {@code supertype} is a raw type\n+   * @return the result of visiting type args\n    */\n   protected boolean visitTypeArgs(\n-      final AnnotatedDeclaredType subtype,\n-      final AnnotatedDeclaredType supertype,\n+      AnnotatedDeclaredType subtype,\n+      AnnotatedDeclaredType supertype,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODE2OTg4NA=="}, "originalCommit": {"oid": "714d7d96e3f7e60d56541f7d4d0f9d65f51cb2ae"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE3OTUxMzI2OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxODowMzoyOFrOJzrjjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNVQyMjo1OToyNFrOJ0iwMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODE3MDc2Nw==", "bodyText": "Below there is also\n    if (subtypeTypeArgs.isEmpty()) {\n      return true;\n    }\nHow can that happen?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658170767", "createdAt": "2021-06-24T18:03:28Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -484,10 +485,16 @@ public Boolean visitDeclared_Declared(\n   /**\n    * A helper class for visitDeclared_Declared. There are subtypes of DefaultTypeHierarchy that need\n    * to customize the handling of type arguments. This method provides a convenient extension point.\n+   *\n+   * @param subtype a possible subtype\n+   * @param supertype a possible supertype\n+   * @param subtypeRaw whether {@code subtype} is a raw type\n+   * @param supertypeRaw whether {@code supertype} is a raw type\n+   * @return the result of visiting type args\n    */\n   protected boolean visitTypeArgs(\n-      final AnnotatedDeclaredType subtype,\n-      final AnnotatedDeclaredType supertype,\n+      AnnotatedDeclaredType subtype,\n+      AnnotatedDeclaredType supertype,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "714d7d96e3f7e60d56541f7d4d0f9d65f51cb2ae"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODMzMjg5MA==", "bodyText": "If subtype doesn't have any type arguments.  This method is called even if subtype doesn't have type arguments.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658332890", "createdAt": "2021-06-24T22:43:25Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -484,10 +485,16 @@ public Boolean visitDeclared_Declared(\n   /**\n    * A helper class for visitDeclared_Declared. There are subtypes of DefaultTypeHierarchy that need\n    * to customize the handling of type arguments. This method provides a convenient extension point.\n+   *\n+   * @param subtype a possible subtype\n+   * @param supertype a possible supertype\n+   * @param subtypeRaw whether {@code subtype} is a raw type\n+   * @param supertypeRaw whether {@code supertype} is a raw type\n+   * @return the result of visiting type args\n    */\n   protected boolean visitTypeArgs(\n-      final AnnotatedDeclaredType subtype,\n-      final AnnotatedDeclaredType supertype,\n+      AnnotatedDeclaredType subtype,\n+      AnnotatedDeclaredType supertype,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODE3MDc2Nw=="}, "originalCommit": {"oid": "714d7d96e3f7e60d56541f7d4d0f9d65f51cb2ae"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTA2MTY1OA==", "bodyText": "A reader might expect that if subtype has no type arguments,  subtypeRaw would be true.  Is that assumption incorrect?  Could you clarify?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r659061658", "createdAt": "2021-06-25T22:11:19Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -484,10 +485,16 @@ public Boolean visitDeclared_Declared(\n   /**\n    * A helper class for visitDeclared_Declared. There are subtypes of DefaultTypeHierarchy that need\n    * to customize the handling of type arguments. This method provides a convenient extension point.\n+   *\n+   * @param subtype a possible subtype\n+   * @param supertype a possible supertype\n+   * @param subtypeRaw whether {@code subtype} is a raw type\n+   * @param supertypeRaw whether {@code supertype} is a raw type\n+   * @return the result of visiting type args\n    */\n   protected boolean visitTypeArgs(\n-      final AnnotatedDeclaredType subtype,\n-      final AnnotatedDeclaredType supertype,\n+      AnnotatedDeclaredType subtype,\n+      AnnotatedDeclaredType supertype,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODE3MDc2Nw=="}, "originalCommit": {"oid": "714d7d96e3f7e60d56541f7d4d0f9d65f51cb2ae"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTA3NTEyMA==", "bodyText": "subtype could be String which is neither raw nor does it have type arguments.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r659075120", "createdAt": "2021-06-25T22:59:24Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -484,10 +485,16 @@ public Boolean visitDeclared_Declared(\n   /**\n    * A helper class for visitDeclared_Declared. There are subtypes of DefaultTypeHierarchy that need\n    * to customize the handling of type arguments. This method provides a convenient extension point.\n+   *\n+   * @param subtype a possible subtype\n+   * @param supertype a possible supertype\n+   * @param subtypeRaw whether {@code subtype} is a raw type\n+   * @param supertypeRaw whether {@code supertype} is a raw type\n+   * @return the result of visiting type args\n    */\n   protected boolean visitTypeArgs(\n-      final AnnotatedDeclaredType subtype,\n-      final AnnotatedDeclaredType supertype,\n+      AnnotatedDeclaredType subtype,\n+      AnnotatedDeclaredType supertype,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODE3MDc2Nw=="}, "originalCommit": {"oid": "714d7d96e3f7e60d56541f7d4d0f9d65f51cb2ae"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE3OTUxOTUyOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxODowNDoyOFrOJzrnhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNFQxODowNDoyOFrOJzrnhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1ODE3MTc4Mg==", "bodyText": "The third paragraph is about comparisons between declarations (generic types).\nThe fourth paragraph is about comparisons between uses (parameterized types).\nShould this refer to the fourth paragraph rather than the third?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r658171782", "createdAt": "2021-06-24T18:04:28Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -517,18 +524,40 @@ protected boolean visitTypeArgs(\n             : AnnotationUtils.getElementValueArray(\n                 covariantAnno, covariantValueElement, Integer.class);\n \n-    for (int i = 0; i < supertypeTypeArgs.size(); i++) {\n-      final AnnotatedTypeMirror superTypeArg = supertypeTypeArgs.get(i);\n-      final AnnotatedTypeMirror subTypeArg = subtypeTypeArgs.get(i);\n-      final boolean covariant = covariantArgIndexes != null && covariantArgIndexes.contains(i);\n-\n-      boolean result = isContainedBy(subTypeArg, superTypeArg, covariant);\n+    // JLS: 4.10.2. Subtyping among Class and Interface Types\n+    // 3th paragraph", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "714d7d96e3f7e60d56541f7d4d0f9d65f51cb2ae"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwMjU3MTIxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjoxMzowMVrOJ2-R_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjoxMzowMVrOJ2-R_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYyMzI5NQ==", "bodyText": "What is the relationship between these types?  Are their erased/raw types the same?  Or is there a subtyping relationship?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661623295", "createdAt": "2021-06-30T16:13:01Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,120 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n    * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * <p>As described in <a\n+   * href=https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.10.2>JLS section\n+   * 4.10.2 Subtyping among Class and Interface Types</a>, a declared type is considered a supertype\n+   * of another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwMjU3NDg5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjoxMzo1MVrOJ2-UTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjoxMzo1MVrOJ2-UTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYyMzg4NQ==", "bodyText": "I usually expect to see a check of a cache at the beginning of the routine.  Should it be moved there, or is there a reason that it needs to appear after other logic?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661623885", "createdAt": "2021-06-30T16:13:51Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,120 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n    * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * <p>As described in <a\n+   * href=https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.10.2>JLS section\n+   * 4.10.2 Subtyping among Class and Interface Types</a>, a declared type is considered a supertype\n+   * of another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n-    if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n+    if (shouldIgnoreUninferredTypeArgs(inside) || shouldIgnoreUninferredTypeArgs(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n \n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD) {\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwMjU4MTI3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjoxNTowN1rOJ2-YFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0wMVQxNjo0ODoyNFrOJ3wl5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYyNDg1Mg==", "bodyText": "Would a better name for this routine be isContainedByBoundedWildcard?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661624852", "createdAt": "2021-06-30T16:15:07Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,120 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n    * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * <p>As described in <a\n+   * href=https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.10.2>JLS section\n+   * 4.10.2 Subtyping among Class and Interface Types</a>, a declared type is considered a supertype\n+   * of another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n-    if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n+    if (shouldIgnoreUninferredTypeArgs(inside) || shouldIgnoreUninferredTypeArgs(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n \n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD) {\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n       }\n-      return areEqualInHierarchy(inside, outside);\n-    }\n+      AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n \n-    AnnotatedTypeMirror outsideUpperBound;\n-    AnnotatedTypeMirror outsideLowerBound;\n-    if (outside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-      outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-    } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-      outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-    } else {\n-      throw new BugInCF(\"Expected a wildcard or captured type variable, but found \" + outside);\n+      // Add a placeholder in case of recursion, to prevent infinite regress.\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result =\n+          isContainedByBoundType(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTgxNTk4OQ==", "bodyText": "I don't think so.  This method is called for unbound wildcards and also captured type variables.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661815989", "createdAt": "2021-06-30T21:14:58Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,120 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n    * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * <p>As described in <a\n+   * href=https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.10.2>JLS section\n+   * 4.10.2 Subtyping among Class and Interface Types</a>, a declared type is considered a supertype\n+   * of another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n-    if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n+    if (shouldIgnoreUninferredTypeArgs(inside) || shouldIgnoreUninferredTypeArgs(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n \n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD) {\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n       }\n-      return areEqualInHierarchy(inside, outside);\n-    }\n+      AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n \n-    AnnotatedTypeMirror outsideUpperBound;\n-    AnnotatedTypeMirror outsideLowerBound;\n-    if (outside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-      outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-    } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-      outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-    } else {\n-      throw new BugInCF(\"Expected a wildcard or captured type variable, but found \" + outside);\n+      // Add a placeholder in case of recursion, to prevent infinite regress.\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result =\n+          isContainedByBoundType(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYyNDg1Mg=="}, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MjQ0NzU4OQ==", "bodyText": "I wasn't sure what \"BoundType\" means.  It sounds like it's containment by the bound type itself, by it's really containment within the bounds.  Maybe isContainedByBoundedType or isContainedWithinBounds or the like?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r662447589", "createdAt": "2021-07-01T16:48:24Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,120 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n    * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * <p>As described in <a\n+   * href=https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.10.2>JLS section\n+   * 4.10.2 Subtyping among Class and Interface Types</a>, a declared type is considered a supertype\n+   * of another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n-    if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n+    if (shouldIgnoreUninferredTypeArgs(inside) || shouldIgnoreUninferredTypeArgs(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n \n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD) {\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n       }\n-      return areEqualInHierarchy(inside, outside);\n-    }\n+      AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n \n-    AnnotatedTypeMirror outsideUpperBound;\n-    AnnotatedTypeMirror outsideLowerBound;\n-    if (outside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-      outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-    } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-      outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-    } else {\n-      throw new BugInCF(\"Expected a wildcard or captured type variable, but found \" + outside);\n+      // Add a placeholder in case of recursion, to prevent infinite regress.\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result =\n+          isContainedByBoundType(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYyNDg1Mg=="}, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwMjU4NjkwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjoxNjoxOVrOJ2-blw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjoxNjoxOVrOJ2-blw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYyNTc1MQ==", "bodyText": "\"they should be equal\":  I'm not sure whether this is describing an application invariant that is true whenever control reaches this line, or it is describing a test that will be performed later in the routine.  Could you rewrite to resolve the ambiguity?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661625751", "createdAt": "2021-06-30T16:16:19Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -285,104 +283,120 @@ protected boolean areEqualInHierarchy(\n   }\n \n   /**\n-   * A declared type is considered a supertype of another declared type only if all of the type\n-   * arguments of the declared type \"contain\" the corresponding type arguments of the subtype.\n-   * Containment is described in <a\n+   * Returns true if {@code outside} contains {@code inside}, that is, if the set of types denoted\n+   * by {@code outside} is a superset of or equal to the set of types denoted by {@code inside}.\n+   *\n+   * <p>Containment is described in <a\n    * href=\"https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.5.1\">JLS section\n    * 4.5.1 \"Type Arguments of Parameterized Types\"</a>.\n    *\n-   * @param inside a type argument of the \"subtype\"\n-   * @param outside a type argument of the \"supertype\"\n+   * <p>As described in <a\n+   * href=https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.10.2>JLS section\n+   * 4.10.2 Subtyping among Class and Interface Types</a>, a declared type is considered a supertype\n+   * of another declared type only if all of the type arguments of the declared type \"contain\" the\n+   * corresponding type arguments of the subtype.\n+   *\n+   * @param inside a possibly-contained type\n+   * @param outside a possibly-containing type\n    * @param canBeCovariant whether or not type arguments are allowed to be covariant\n    * @return true if inside is contained by outside, or if canBeCovariant == true and {@code inside\n    *     <: outside}\n    */\n   protected boolean isContainedBy(\n-      final AnnotatedTypeMirror inside, final AnnotatedTypeMirror outside, boolean canBeCovariant) {\n+      AnnotatedTypeMirror inside, AnnotatedTypeMirror outside, boolean canBeCovariant) {\n \n-    if (ignoreUninferredTypeArgument(inside) || ignoreUninferredTypeArgument(outside)) {\n+    if (shouldIgnoreUninferredTypeArgs(inside) || shouldIgnoreUninferredTypeArgs(outside)) {\n       areEqualVisitHistory.put(inside, outside, currentTop, true);\n       return true;\n     }\n \n-    if (outside.getKind() != TypeKind.WILDCARD\n-        && !TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      if (canBeCovariant) {\n-        return isSubtype(inside, outside, currentTop);\n+    if (outside.getKind() == TypeKind.WILDCARD) {\n+      Boolean previousResult = areEqualVisitHistory.get(inside, outside, currentTop);\n+      if (previousResult != null) {\n+        return previousResult;\n       }\n-      return areEqualInHierarchy(inside, outside);\n-    }\n+      AnnotatedWildcardType outsideWildcard = (AnnotatedWildcardType) outside;\n \n-    AnnotatedTypeMirror outsideUpperBound;\n-    AnnotatedTypeMirror outsideLowerBound;\n-    if (outside.getKind() == TypeKind.WILDCARD) {\n-      outsideUpperBound = ((AnnotatedWildcardType) outside).getExtendsBound();\n-      outsideLowerBound = ((AnnotatedWildcardType) outside).getSuperBound();\n-    } else if (TypesUtils.isCaptured(outside.getUnderlyingType())) {\n-      outsideUpperBound = ((AnnotatedTypeVariable) outside).getUpperBound();\n-      outsideLowerBound = ((AnnotatedTypeVariable) outside).getLowerBound();\n-    } else {\n-      throw new BugInCF(\"Expected a wildcard or captured type variable, but found \" + outside);\n+      // Add a placeholder in case of recursion, to prevent infinite regress.\n+      areEqualVisitHistory.put(inside, outside, currentTop, true);\n+      boolean result =\n+          isContainedByBoundType(\n+              inside,\n+              outsideWildcard.getSuperBound(),\n+              outsideWildcard.getExtendsBound(),\n+              canBeCovariant);\n+      areEqualVisitHistory.put(inside, outside, currentTop, result);\n+      return result;\n+    } else if ((TypesUtils.isCapturedTypeVariable(outside.getUnderlyingType())\n+        && !TypesUtils.isCapturedTypeVariable(inside.getUnderlyingType()))) {\n+      // TODO: This branch should be removed after #979 is fixed.\n+      // If both outside and inside are captured type variables, they should be equal.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwMjYxNjgzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjoyMjowMlrOJ2-vHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjoyMjowMlrOJ2-vHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzMDc0OA==", "bodyText": "\"Checks that\" could mean that the method throws an exception or reports an error.\nOr, \"checks that\" could indicate the method's return value.\nCould you resolve the ambiguity?\nI think that all the visit methods are returning a boolean value indicating whether the method's arguments are in a subtyping relationship.  It would be good to document that in the class Javadoc.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661630748", "createdAt": "2021-06-30T16:22:02Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -482,12 +502,18 @@ public Boolean visitDeclared_Declared(\n   }\n \n   /**\n-   * A helper class for visitDeclared_Declared. There are subtypes of DefaultTypeHierarchy that need\n-   * to customize the handling of type arguments. This method provides a convenient extension point.\n+   * Checks that the type arguments in {@code supertype} contain the type arguments in {@code", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwMjYxOTc0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjoyMjozNlrOJ2-wyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjoyMjozNlrOJ2-wyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzMTE3OA==", "bodyText": "Please make this comment more descriptive.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661631178", "createdAt": "2021-06-30T16:22:36Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -482,12 +502,18 @@ public Boolean visitDeclared_Declared(\n   }\n \n   /**\n-   * A helper class for visitDeclared_Declared. There are subtypes of DefaultTypeHierarchy that need\n-   * to customize the handling of type arguments. This method provides a convenient extension point.\n+   * Checks that the type arguments in {@code supertype} contain the type arguments in {@code\n+   * subtype}. See {@link #isContainedBy} for an explanation of containment.\n+   *\n+   * @param subtype a possible subtype (its underlying type is a subtype of {@code supertype})\n+   * @param supertype a possible supertype (its underlying type is a supertype of {@code subtype})\n+   * @param subtypeRaw whether {@code subtype} is a raw type\n+   * @param supertypeRaw whether {@code supertype} is a raw type\n+   * @return the result of visiting type args", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 254}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwMjYyNTI3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjoyMzo0MlrOJ2-0RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjoyMzo0MlrOJ2-0RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzMjA2OA==", "bodyText": "Why does this case not indicate a bug that should be raised as an exception?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661632068", "createdAt": "2021-06-30T16:23:42Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -503,6 +529,7 @@ protected boolean visitTypeArgs(\n     if (subtypeTypeArgs.size() != supertypeTypeArgs.size()) {\n       return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 266}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwMjYzMzI3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjoyNTozNlrOJ2-5gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQyMTo1NzozOFrOJ3LYpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzMzQwOQ==", "bodyText": "I think this is only handling the 3rd bullet point of that paragraph.  Does it actually handle more?\nNit: I would change \"JLS\" to \"JLS 11\" in case later editions rewrite the section.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661633409", "createdAt": "2021-06-30T16:25:36Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -517,18 +544,40 @@ protected boolean visitTypeArgs(\n             : AnnotationUtils.getElementValueArray(\n                 covariantAnno, covariantValueElement, Integer.class);\n \n-    for (int i = 0; i < supertypeTypeArgs.size(); i++) {\n-      final AnnotatedTypeMirror superTypeArg = supertypeTypeArgs.get(i);\n-      final AnnotatedTypeMirror subTypeArg = subtypeTypeArgs.get(i);\n-      final boolean covariant = covariantArgIndexes != null && covariantArgIndexes.contains(i);\n-\n-      boolean result = isContainedBy(subTypeArg, superTypeArg, covariant);\n+    // JLS: 4.10.2. Subtyping among Class and Interface Types\n+    // 4th paragraph", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTgzNzk5MQ==", "bodyText": "I answered this in this comment.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661837991", "createdAt": "2021-06-30T21:57:38Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -517,18 +544,40 @@ protected boolean visitTypeArgs(\n             : AnnotationUtils.getElementValueArray(\n                 covariantAnno, covariantValueElement, Integer.class);\n \n-    for (int i = 0; i < supertypeTypeArgs.size(); i++) {\n-      final AnnotatedTypeMirror superTypeArg = supertypeTypeArgs.get(i);\n-      final AnnotatedTypeMirror subTypeArg = subtypeTypeArgs.get(i);\n-      final boolean covariant = covariantArgIndexes != null && covariantArgIndexes.contains(i);\n-\n-      boolean result = isContainedBy(subTypeArg, superTypeArg, covariant);\n+    // JLS: 4.10.2. Subtyping among Class and Interface Types\n+    // 4th paragraph", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzMzQwOQ=="}, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 283}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwMjYzOTMxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjoyNjo1NFrOJ2-9Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQyMTo0NDoyMFrOJ3K__g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzNDM3MQ==", "bodyText": "I am a bit confused by this code.  The 5th paragraph says that -- after capture conversion -- one should do a regular subtyping test.  Is this an optimization, because the subtyping test would boil down to isContainedMany?  Or is there another reason we need to diverge from the JLS text?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661634371", "createdAt": "2021-06-30T16:26:54Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -517,18 +544,40 @@ protected boolean visitTypeArgs(\n             : AnnotationUtils.getElementValueArray(\n                 covariantAnno, covariantValueElement, Integer.class);\n \n-    for (int i = 0; i < supertypeTypeArgs.size(); i++) {\n-      final AnnotatedTypeMirror superTypeArg = supertypeTypeArgs.get(i);\n-      final AnnotatedTypeMirror subTypeArg = subtypeTypeArgs.get(i);\n-      final boolean covariant = covariantArgIndexes != null && covariantArgIndexes.contains(i);\n-\n-      boolean result = isContainedBy(subTypeArg, superTypeArg, covariant);\n+    // JLS: 4.10.2. Subtyping among Class and Interface Types\n+    // 4th paragraph\n+    if (isContainedMany(subtype.getTypeArguments(), supertypeTypeArgs, covariantArgIndexes)) {\n+      return true;\n+    }\n+    // 5th paragraph\n+    AnnotatedDeclaredType capturedSubtype =\n+        (AnnotatedDeclaredType) subtype.atypeFactory.applyCaptureConversion(subtype);\n+    return isContainedMany(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 290}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTgzMTY3OA==", "bodyText": "Here's that section in the JLS.  I've numbered the paragraphs and used letters for the bullet points.\n\n4.) Given a generic type declaration C<F1,...,Fn> (n > 0), the direct supertypes of the parameterized type C<T1,...,Tn>, where Ti (1 \u2264 i \u2264 n) is a type, are all of the following:\nA.) D<U1 \u03b8,...,Uk \u03b8>, where D<U1,...,Uk> is a generic type which is a direct supertype of the generic type C<F1,...,Fn> and \u03b8 is the substitution [F1:=T1,...,Fn:=Tn].\nB.) C<S1,...,Sn>, where Si contains Ti (1 \u2264 i \u2264 n) (\u00a74.5.1).\nC.) The type Object, if C<F1,...,Fn> is a generic interface type with no direct superinterfaces.\nD.) The raw type C.\n5.) Given a generic type declaration C<F1,...,Fn> (n > 0), the direct supertypes of the parameterized type C<R1,...,Rn> where at least one of the Ri (1 \u2264 i \u2264 n) is a wildcard type argument, are the direct supertypes of the parameterized type C<X1,...,Xn> which is the result of applying capture conversion to C<R1,...,Rn> (\u00a75.1.10).\n\n4A is applied before visitTypeArgs is called,  this happens in visitDeclared_Declared, AnnotatedTypes.castedAsSuper(subtype.atypeFactory, subtype, supertype);.   So subtype and supertype have the same underlying type in visitTypeArgs.  (The documentation of subtype and supertype was wrong; I've fixed it.)\n4B is applied in visitTypeArgs in the if statement isContainedMany(subtype.getTypeArguments(), supertypeTypeArgs, covariantArgIndexes) (In your comment above you asked if this if statement was for 4C, but it's 4B.)\n5 is applied in visitTypeArgs in isContainedMany(capturedSubtype.getTypeArguments(), supertypeTypeArgs, covariantArgIndexes).  As you suggest, this is an optimization, because calling isSubtype(subtype, supertype) would result in  the isContainedMany(capturedSubtype.getTypeArguments(), supertypeTypeArgs, covariantArgIndexes) call.\nI've attempted to make this clearer in the code.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661831678", "createdAt": "2021-06-30T21:44:20Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -517,18 +544,40 @@ protected boolean visitTypeArgs(\n             : AnnotationUtils.getElementValueArray(\n                 covariantAnno, covariantValueElement, Integer.class);\n \n-    for (int i = 0; i < supertypeTypeArgs.size(); i++) {\n-      final AnnotatedTypeMirror superTypeArg = supertypeTypeArgs.get(i);\n-      final AnnotatedTypeMirror subTypeArg = subtypeTypeArgs.get(i);\n-      final boolean covariant = covariantArgIndexes != null && covariantArgIndexes.contains(i);\n-\n-      boolean result = isContainedBy(subTypeArg, superTypeArg, covariant);\n+    // JLS: 4.10.2. Subtyping among Class and Interface Types\n+    // 4th paragraph\n+    if (isContainedMany(subtype.getTypeArguments(), supertypeTypeArgs, covariantArgIndexes)) {\n+      return true;\n+    }\n+    // 5th paragraph\n+    AnnotatedDeclaredType capturedSubtype =\n+        (AnnotatedDeclaredType) subtype.atypeFactory.applyCaptureConversion(subtype);\n+    return isContainedMany(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzNDM3MQ=="}, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 290}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwMjY2OTEzOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjozMzoxOFrOJ2_Pmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjozMzoxOFrOJ2_Pmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzOTA2Nw==", "bodyText": "Nit: the ordering of tests in this cascaded if is:\nsub && super\n!sub && !super && X\nsub && !super\nsuper && !sub\n!sub && !super && Y\nIt's a bit weird to see the two cases that include \"!sub && !super\" separated rather than appearing together (probably at the end).\nAlso, it might be helpful for documentation (and won't hurt performance) to make the omitted parts of the tests explicit, as I did above.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661639067", "createdAt": "2021-06-30T16:33:18Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -825,6 +892,16 @@ public Boolean visitTypevar_Typevar(\n       } else if (!subtypeHasAnno && !supertypeHasAnno && areEqualInHierarchy(subtype, supertype)) {\n         // two unannotated uses of the same type parameter are of the same type\n         return true;\n+      } else if (subtypeHasAnno) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 357}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwMjY3MzQ5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjozNDowOFrOJ2_SJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjozNDowOFrOJ2_SJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzOTcxOA==", "bodyText": "The cascaded if statement is not exhaustive:  control can fall through.  Why is that?  It might be clearer to make the handling of the final case when haveSameDeclaration is true explicit, unless it needs all the following logic in the method.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661639718", "createdAt": "2021-06-30T16:34:08Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -825,6 +892,16 @@ public Boolean visitTypevar_Typevar(\n       } else if (!subtypeHasAnno && !supertypeHasAnno && areEqualInHierarchy(subtype, supertype)) {\n         // two unannotated uses of the same type parameter are of the same type\n         return true;\n+      } else if (subtypeHasAnno) {\n+        Set<AnnotationMirror> superLBs =\n+            AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, supertype);\n+        AnnotationMirror superLB =\n+            qualifierHierarchy.findAnnotationInHierarchy(superLBs, currentTop);\n+        return qualifierHierarchy.isSubtype(subtype.getAnnotationInHierarchy(currentTop), superLB);\n+      } else if (supertypeHasAnno) {\n+        return qualifierHierarchy.isSubtype(\n+            subtype.getEffectiveAnnotationInHierarchy(currentTop),\n+            supertype.getAnnotationInHierarchy(currentTop));\n \n       } else if (subtype.getUpperBound().getKind() == TypeKind.INTERSECTION) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 368}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwMjY3MzY5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjozNDoxMVrOJ2_STg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjozNDoxMVrOJ2_STg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTYzOTc1OA==", "bodyText": "Three lines below, a comment says \"one use of the type has an annotation and the other does not\", but I don't think that is possible because the previous two cases handled whenever one use has an annotation and one does not.  Can you double-check?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661639758", "createdAt": "2021-06-30T16:34:11Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -825,6 +892,16 @@ public Boolean visitTypevar_Typevar(\n       } else if (!subtypeHasAnno && !supertypeHasAnno && areEqualInHierarchy(subtype, supertype)) {\n         // two unannotated uses of the same type parameter are of the same type\n         return true;\n+      } else if (subtypeHasAnno) {\n+        Set<AnnotationMirror> superLBs =\n+            AnnotatedTypes.findEffectiveLowerBoundAnnotations(qualifierHierarchy, supertype);\n+        AnnotationMirror superLB =\n+            qualifierHierarchy.findAnnotationInHierarchy(superLBs, currentTop);\n+        return qualifierHierarchy.isSubtype(subtype.getAnnotationInHierarchy(currentTop), superLB);\n+      } else if (supertypeHasAnno) {\n+        return qualifierHierarchy.isSubtype(\n+            subtype.getEffectiveAnnotationInHierarchy(currentTop),\n+            supertype.getAnnotationInHierarchy(currentTop));\n \n       } else if (subtype.getUpperBound().getKind() == TypeKind.INTERSECTION) {\n         // This case happens when a type has an intersection bound.  e.g.,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 369}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwMjY3NzA0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjozNDo1NFrOJ2_UWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjozNDo1NFrOJ2_UWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTY0MDI4Mw==", "bodyText": "Are these necessarily the same captured type variable, or might they be different ones?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661640283", "createdAt": "2021-06-30T16:34:54Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -845,6 +922,16 @@ public Boolean visitTypevar_Typevar(\n       }\n     }\n \n+    if (TypesUtils.isCapturedTypeVariable(subtype.getUnderlyingType())\n+        && TypesUtils.isCapturedTypeVariable(supertype.getUnderlyingType())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 375}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwMjY4MDAxOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjozNTozMFrOJ2_WHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjozNTozMFrOJ2_WHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTY0MDczNQ==", "bodyText": "Can you expand on this comment?", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661640735", "createdAt": "2021-06-30T16:35:30Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -845,6 +922,16 @@ public Boolean visitTypevar_Typevar(\n       }\n     }\n \n+    if (TypesUtils.isCapturedTypeVariable(subtype.getUnderlyingType())\n+        && TypesUtils.isCapturedTypeVariable(supertype.getUnderlyingType())) {\n+      // TODO: Can this be removed?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d2e1d98be7e04c8cae2d2da14bc6029af7ab759"}, "originalPosition": 376}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwMjcwNTQ3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjo0MToyNVrOJ2_mfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxOToxMjo0OFrOJ3Frfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTY0NDkyNw==", "bodyText": "The naming of visitTypevarSupertype and visitTypevarSubtype feels inconsistent with the rest of the class.  Usually a visit method name contains the types of its two arguments, so I expected these to be something like visitType_TypeVariable and visitTypeVariable_Type.  Can you explain the reason for the naming, or make it more consistent?  (I realize these are not overloads, but more consistency is still desirable if their names start with visit rather than, say, isSubtype.)", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661644927", "createdAt": "2021-06-30T16:41:25Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -988,46 +1075,57 @@ protected boolean visitTypevarSupertype(\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitTypevarSupertype will combine to isValid the subtypes\n    * upper bound against the supertypes lower bound.\n    */\n   protected boolean visitTypevarSubtype(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecd6d25c064af4beee36dcd8a2337c06bd133695"}, "originalPosition": 415}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTc0NDUxMA==", "bodyText": "#4768", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661744510", "createdAt": "2021-06-30T19:12:48Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -988,46 +1075,57 @@ protected boolean visitTypevarSupertype(\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitTypevarSupertype will combine to isValid the subtypes\n    * upper bound against the supertypes lower bound.\n    */\n   protected boolean visitTypevarSubtype(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTY0NDkyNw=="}, "originalCommit": {"oid": "ecd6d25c064af4beee36dcd8a2337c06bd133695"}, "originalPosition": 415}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDIwMjcxMjMwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjo0Mjo1MlrOJ2_qnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0zMFQxNjo0Mjo1MlrOJ2_qnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTY0NTk4MA==", "bodyText": "This code appears identically above (but for a variable name).  I think the method will be easier to read and understand  if you abstract out this logic into a method of its own.", "url": "https://github.com/typetools/checker-framework/pull/3922#discussion_r661645980", "createdAt": "2021-06-30T16:42:52Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/type/DefaultTypeHierarchy.java", "diffHunk": "@@ -988,46 +1075,57 @@ protected boolean visitTypevarSupertype(\n   }\n \n   /**\n-   * A type variable is a subtype if its upper bounds is below the supertype. Note: When comparing\n-   * two type variables this method and visitTypevarSupertype will combine to isValid the subtypes\n+   * A type variable is a subtype if its upper bound is below the supertype. Note: When comparing\n+   * two type variables, this method and visitTypevarSupertype will combine to isValid the subtypes\n    * upper bound against the supertypes lower bound.\n    */\n   protected boolean visitTypevarSubtype(\n       AnnotatedTypeVariable subtype, AnnotatedTypeMirror supertype) {\n-    AnnotatedTypeMirror upperBound = subtype.getUpperBound();\n-    if (TypesUtils.isBoxedPrimitive(upperBound.getUnderlyingType())\n+    AnnotatedTypeMirror subtypeUpperBound = subtype.getUpperBound();\n+    if (TypesUtils.isBoxedPrimitive(subtypeUpperBound.getUnderlyingType())\n         && supertype instanceof AnnotatedPrimitiveType) {\n-      upperBound = supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) upperBound);\n+      subtypeUpperBound =\n+          supertype.atypeFactory.getUnboxedType((AnnotatedDeclaredType) subtypeUpperBound);\n     }\n     if (supertype.getKind() == TypeKind.DECLARED\n         && TypesUtils.getTypeElement(supertype.getUnderlyingType()).getKind()\n             == ElementKind.INTERFACE) {\n-      // Make sure the upper bound is no wildcard or type variable\n-      while (upperBound.getKind() == TypeKind.TYPEVAR\n-          || upperBound.getKind() == TypeKind.WILDCARD) {\n-        if (upperBound.getKind() == TypeKind.TYPEVAR) {\n-          upperBound = ((AnnotatedTypeVariable) upperBound).getUpperBound();\n+      // Make sure the upper bound is no wildcard or type variable.\n+      while (subtypeUpperBound.getKind() == TypeKind.TYPEVAR\n+          || subtypeUpperBound.getKind() == TypeKind.WILDCARD) {\n+        if (subtypeUpperBound.getKind() == TypeKind.TYPEVAR) {\n+          subtypeUpperBound = ((AnnotatedTypeVariable) subtypeUpperBound).getUpperBound();\n         }\n-        if (upperBound.getKind() == TypeKind.WILDCARD) {\n-          upperBound = ((AnnotatedWildcardType) upperBound).getExtendsBound();\n+        if (subtypeUpperBound.getKind() == TypeKind.WILDCARD) {\n+          subtypeUpperBound = ((AnnotatedWildcardType) subtypeUpperBound).getExtendsBound();\n         }\n       }\n       // If the supertype is an interface, only compare the primary annotations.\n       // The actual type argument could implement the interface and the bound of\n       // the type variable must not implement the interface.\n-      if (upperBound.getKind() == TypeKind.INTERSECTION) {\n+      if (subtypeUpperBound.getKind() == TypeKind.INTERSECTION) {\n         Types types = checker.getTypeUtils();\n-        for (AnnotatedTypeMirror ub : ((AnnotatedIntersectionType) upperBound).getBounds()) {\n+        for (AnnotatedTypeMirror bound :\n+            ((AnnotatedIntersectionType) subtypeUpperBound).getBounds()) {\n+          // Make sure the upper bound is no wildcard or type variable.\n+          while (bound.getKind() == TypeKind.TYPEVAR || bound.getKind() == TypeKind.WILDCARD) {\n+            if (bound.getKind() == TypeKind.TYPEVAR) {\n+              bound = ((AnnotatedTypeVariable) bound).getUpperBound();\n+            }\n+            if (bound.getKind() == TypeKind.WILDCARD) {\n+              bound = ((AnnotatedWildcardType) bound).getExtendsBound();\n+            }\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecd6d25c064af4beee36dcd8a2337c06bd133695"}, "originalPosition": 463}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 938, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}