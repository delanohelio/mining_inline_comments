{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyMzY3Nzg0", "number": 3843, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMDo0NTo1MVrOEzedNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMjoyNToyOVrOEzgRHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDExODI5OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/flow/CFAbstractStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMDo0NTo1MVrOHqt_cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMTo0OToxNVrOHqv9MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU1NTc2Mw==", "bodyText": "Nit: I would probably move move this if/else to a helper method to reduce the indentation.", "url": "https://github.com/typetools/checker-framework/pull/3843#discussion_r514555763", "createdAt": "2020-10-29T20:45:51Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/flow/CFAbstractStore.java", "diffHunk": "@@ -199,54 +199,73 @@ public void updateForMethodCall(\n         if (!(analysis.checker.hasOption(\"assumeSideEffectFree\")\n                 || analysis.checker.hasOption(\"assumePure\")\n                 || isSideEffectFree(atypeFactory, method))) {\n-            // update field values\n-            Map<FieldAccess, V> newFieldValues = new HashMap<>();\n-            for (Map.Entry<FieldAccess, V> e : fieldValues.entrySet()) {\n-                FieldAccess fieldAccess = e.getKey();\n-                V otherVal = e.getValue();\n \n-                // case 3: the field has a monotonic annotation\n-                if (!((GenericAnnotatedTypeFactory<?, ?, ?, ?>) atypeFactory)\n-                        .getSupportedMonotonicTypeQualifiers()\n-                        .isEmpty()) {\n-                    List<Pair<AnnotationMirror, AnnotationMirror>> fieldAnnotations =\n-                            atypeFactory.getAnnotationWithMetaAnnotation(\n-                                    fieldAccess.getField(), MonotonicQualifier.class);\n-                    V newOtherVal = null;\n-                    for (Pair<AnnotationMirror, AnnotationMirror> fieldAnnotation :\n-                            fieldAnnotations) {\n-                        AnnotationMirror monotonicAnnotation = fieldAnnotation.second;\n-                        Name annotation =\n-                                AnnotationUtils.getElementValueClassName(\n-                                        monotonicAnnotation, \"value\", false);\n-                        AnnotationMirror target =\n-                                AnnotationBuilder.fromName(\n-                                        atypeFactory.getElementUtils(), annotation);\n-                        // Make sure the 'target' annotation is present.\n-                        if (AnnotationUtils.containsSame(otherVal.getAnnotations(), target)) {\n-                            newOtherVal =\n-                                    analysis.createSingleAnnotationValue(\n-                                                    target, otherVal.getUnderlyingType())\n-                                            .mostSpecific(newOtherVal, null);\n+            // update local variables\n+            // TODO: Also remove if any element/argument to the annotation is not\n+            // isUnmodifiableByOtherCode.  Example: @KeyFor(\"valueThatCanBeMutated\").\n+            if (analysis.checker.sideEffectsUnrefineAliases) {\n+                localVariableValues\n+                        .entrySet()\n+                        .removeIf(e -> !e.getKey().isUnmodifiableByOtherCode());\n+            }\n+\n+            // update this value\n+            if (analysis.checker.sideEffectsUnrefineAliases) {\n+                thisValue = null;\n+            }\n+\n+            // update field values\n+            if (analysis.checker.sideEffectsUnrefineAliases) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be77e06f7c7f31fbb2e5cfa67a3508ac66db5ed9"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU4Nzk1Mg==", "bodyText": "Let's put this off for now, and revisit the indentation issue later.", "url": "https://github.com/typetools/checker-framework/pull/3843#discussion_r514587952", "createdAt": "2020-10-29T21:49:15Z", "author": {"login": "mernst"}, "path": "framework/src/main/java/org/checkerframework/framework/flow/CFAbstractStore.java", "diffHunk": "@@ -199,54 +199,73 @@ public void updateForMethodCall(\n         if (!(analysis.checker.hasOption(\"assumeSideEffectFree\")\n                 || analysis.checker.hasOption(\"assumePure\")\n                 || isSideEffectFree(atypeFactory, method))) {\n-            // update field values\n-            Map<FieldAccess, V> newFieldValues = new HashMap<>();\n-            for (Map.Entry<FieldAccess, V> e : fieldValues.entrySet()) {\n-                FieldAccess fieldAccess = e.getKey();\n-                V otherVal = e.getValue();\n \n-                // case 3: the field has a monotonic annotation\n-                if (!((GenericAnnotatedTypeFactory<?, ?, ?, ?>) atypeFactory)\n-                        .getSupportedMonotonicTypeQualifiers()\n-                        .isEmpty()) {\n-                    List<Pair<AnnotationMirror, AnnotationMirror>> fieldAnnotations =\n-                            atypeFactory.getAnnotationWithMetaAnnotation(\n-                                    fieldAccess.getField(), MonotonicQualifier.class);\n-                    V newOtherVal = null;\n-                    for (Pair<AnnotationMirror, AnnotationMirror> fieldAnnotation :\n-                            fieldAnnotations) {\n-                        AnnotationMirror monotonicAnnotation = fieldAnnotation.second;\n-                        Name annotation =\n-                                AnnotationUtils.getElementValueClassName(\n-                                        monotonicAnnotation, \"value\", false);\n-                        AnnotationMirror target =\n-                                AnnotationBuilder.fromName(\n-                                        atypeFactory.getElementUtils(), annotation);\n-                        // Make sure the 'target' annotation is present.\n-                        if (AnnotationUtils.containsSame(otherVal.getAnnotations(), target)) {\n-                            newOtherVal =\n-                                    analysis.createSingleAnnotationValue(\n-                                                    target, otherVal.getUnderlyingType())\n-                                            .mostSpecific(newOtherVal, null);\n+            // update local variables\n+            // TODO: Also remove if any element/argument to the annotation is not\n+            // isUnmodifiableByOtherCode.  Example: @KeyFor(\"valueThatCanBeMutated\").\n+            if (analysis.checker.sideEffectsUnrefineAliases) {\n+                localVariableValues\n+                        .entrySet()\n+                        .removeIf(e -> !e.getKey().isUnmodifiableByOtherCode());\n+            }\n+\n+            // update this value\n+            if (analysis.checker.sideEffectsUnrefineAliases) {\n+                thisValue = null;\n+            }\n+\n+            // update field values\n+            if (analysis.checker.sideEffectsUnrefineAliases) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU1NTc2Mw=="}, "originalCommit": {"oid": "be77e06f7c7f31fbb2e5cfa67a3508ac66db5ed9"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDEzMTQwOnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMDo0OTo0M1rOHquHVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMDo0OTo0M1rOHquHVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU1Nzc4MA==", "bodyText": "Since this field is only used by checkers that use dataflow, it should be in GenericAnnotatedTypeFactory.", "url": "https://github.com/typetools/checker-framework/pull/3843#discussion_r514557780", "createdAt": "2020-10-29T20:49:43Z", "author": {"login": "smillst"}, "path": "framework/src/main/java/org/checkerframework/framework/source/SourceChecker.java", "diffHunk": "@@ -479,6 +479,17 @@\n      */\n     private Map<String, String> activeOptions;\n \n+    /**\n+     * Should the analysis assume that side effects to a value can change the type of aliased\n+     * references?\n+     *\n+     * <p>For many type systems, once a local variable's type is refined, side effects to the\n+     * variable's value do not change the variable's type annotations. For some type systems, a side\n+     * effect to the value could change them; set this field to true.\n+     */\n+    // Not final so that subclasses can set it.\n+    public boolean sideEffectsUnrefineAliases = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be77e06f7c7f31fbb2e5cfa67a3508ac66db5ed9"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDQxNTAwOnYy", "diffSide": "RIGHT", "path": "checker/src/main/java/org/checkerframework/checker/nullness/KeyForSubchecker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMjoyNToyOVrOHqw2ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMjozNDo1N1rOHqxD6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwMjYwMg==", "bodyText": "This needs to move, too.", "url": "https://github.com/typetools/checker-framework/pull/3843#discussion_r514602602", "createdAt": "2020-10-29T22:25:29Z", "author": {"login": "smillst"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/KeyForSubchecker.java", "diffHunk": "@@ -9,4 +9,11 @@\n  * @checker_framework.manual #map-key-checker Map Key Checker\n  * @checker_framework.manual #nullness-checker Nullness Checker\n  */\n-public class KeyForSubchecker extends BaseTypeChecker {}\n+public class KeyForSubchecker extends BaseTypeChecker {\n+    {\n+        // While strictly required for soundness, this leads to too many false positives.  Printing\n+        // a key or putting it in a map erases all knowledge of what maps it was a key for.\n+        // TODO: Revisit when side effect annotations are more precise.\n+        // this.sideEffectsUnrefineAliases = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e79a9d9abf2449a2cb6a0fdcd8bb29eb716416d"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwNjA1OQ==", "bodyText": "Thanks for catching that.  I found one other reference that needed to be changed, too.", "url": "https://github.com/typetools/checker-framework/pull/3843#discussion_r514606059", "createdAt": "2020-10-29T22:34:57Z", "author": {"login": "mernst"}, "path": "checker/src/main/java/org/checkerframework/checker/nullness/KeyForSubchecker.java", "diffHunk": "@@ -9,4 +9,11 @@\n  * @checker_framework.manual #map-key-checker Map Key Checker\n  * @checker_framework.manual #nullness-checker Nullness Checker\n  */\n-public class KeyForSubchecker extends BaseTypeChecker {}\n+public class KeyForSubchecker extends BaseTypeChecker {\n+    {\n+        // While strictly required for soundness, this leads to too many false positives.  Printing\n+        // a key or putting it in a map erases all knowledge of what maps it was a key for.\n+        // TODO: Revisit when side effect annotations are more precise.\n+        // this.sideEffectsUnrefineAliases = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYwMjYwMg=="}, "originalCommit": {"oid": "7e79a9d9abf2449a2cb6a0fdcd8bb29eb716416d"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 882, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}