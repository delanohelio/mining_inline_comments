{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NDA3Mzk5", "number": 3524, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoxMzowNVrOETWSUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNTo1NDo1OFrOEUG6ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzIzNTM4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoxMzowNVrOG5CIiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjozNDowMVrOG5q5dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1Njk2OA==", "bodyText": "This only tests that the second argument is any array length access expression. The correct test needs to check that it is an array length access for the array that is the first argument. You can add a test case for this:\n    public static void m4(String @MinLen(1) [] args, String[] otherArray) {\n        // :: error: assignment.type.incompatible\n        String @MinLen(1) [] args2 = Arrays.copyOf(args, otherArray.length);\n    }", "url": "https://github.com/typetools/checker-framework/pull/3524#discussion_r462456968", "createdAt": "2020-07-29T17:13:05Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "diffHunk": "@@ -76,6 +79,26 @@ protected void commonAssignmentCheck(\n                     getTypeFactory().createIntRangeAnnotation(Range.CHAR_EVERYTHING));\n         }\n \n+        if (valueTree.getKind() == Kind.METHOD_INVOCATION\n+                && TreeUtils.isArrayscopyOfMethodInvocation((MethodInvocationTree) valueTree)\n+                && valueType.getKind() == TypeKind.ARRAY) {\n+            List<? extends ExpressionTree> args = ((MethodInvocationTree) valueTree).getArguments();\n+            AnnotatedTypeMirror arrType = atypeFactory.getAnnotatedType(args.get(0));\n+            if (TreeUtils.isArrayLengthAccess(args.get(1))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "688ca4f12aa48340354a9fc8b3748296efabcddb"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyMzA0NQ==", "bodyText": "Do we want to check this now? As suggested above I have added to valuetype any @IntVal or @IntRange annotation on the second argument. Suppose the user intends to have args2 of the same length as otherArray, then this check might lead to a false positive.", "url": "https://github.com/typetools/checker-framework/pull/3524#discussion_r462723045", "createdAt": "2020-07-30T04:10:12Z", "author": {"login": "PRITI1999"}, "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "diffHunk": "@@ -76,6 +79,26 @@ protected void commonAssignmentCheck(\n                     getTypeFactory().createIntRangeAnnotation(Range.CHAR_EVERYTHING));\n         }\n \n+        if (valueTree.getKind() == Kind.METHOD_INVOCATION\n+                && TreeUtils.isArrayscopyOfMethodInvocation((MethodInvocationTree) valueTree)\n+                && valueType.getKind() == TypeKind.ARRAY) {\n+            List<? extends ExpressionTree> args = ((MethodInvocationTree) valueTree).getArguments();\n+            AnnotatedTypeMirror arrType = atypeFactory.getAnnotatedType(args.get(0));\n+            if (TreeUtils.isArrayLengthAccess(args.get(1))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1Njk2OA=="}, "originalCommit": {"oid": "688ca4f12aa48340354a9fc8b3748296efabcddb"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEyNDg1NQ==", "bodyText": "In the test case I suggested, that is a true positive: otherArray might not be @MinLen(1), even if the user hopes that it is - its length could be zero. I think you can add that test method verbatim into the existing test (except for changing the name).", "url": "https://github.com/typetools/checker-framework/pull/3524#discussion_r463124855", "createdAt": "2020-07-30T16:34:01Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "diffHunk": "@@ -76,6 +79,26 @@ protected void commonAssignmentCheck(\n                     getTypeFactory().createIntRangeAnnotation(Range.CHAR_EVERYTHING));\n         }\n \n+        if (valueTree.getKind() == Kind.METHOD_INVOCATION\n+                && TreeUtils.isArrayscopyOfMethodInvocation((MethodInvocationTree) valueTree)\n+                && valueType.getKind() == TypeKind.ARRAY) {\n+            List<? extends ExpressionTree> args = ((MethodInvocationTree) valueTree).getArguments();\n+            AnnotatedTypeMirror arrType = atypeFactory.getAnnotatedType(args.get(0));\n+            if (TreeUtils.isArrayLengthAccess(args.get(1))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1Njk2OA=="}, "originalCommit": {"oid": "688ca4f12aa48340354a9fc8b3748296efabcddb"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzI0NzI3OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoxNjoxMVrOG5CQFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNzoxNjozM1rOG5CRAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1ODkwMA==", "bodyText": "Why only IntVal? If there is an IntRange annotation, you could take its lower bound (from field) and use that.", "url": "https://github.com/typetools/checker-framework/pull/3524#discussion_r462458900", "createdAt": "2020-07-29T17:16:11Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "diffHunk": "@@ -76,6 +79,26 @@ protected void commonAssignmentCheck(\n                     getTypeFactory().createIntRangeAnnotation(Range.CHAR_EVERYTHING));\n         }\n \n+        if (valueTree.getKind() == Kind.METHOD_INVOCATION\n+                && TreeUtils.isArrayscopyOfMethodInvocation((MethodInvocationTree) valueTree)\n+                && valueType.getKind() == TypeKind.ARRAY) {\n+            List<? extends ExpressionTree> args = ((MethodInvocationTree) valueTree).getArguments();\n+            AnnotatedTypeMirror arrType = atypeFactory.getAnnotatedType(args.get(0));\n+            if (TreeUtils.isArrayLengthAccess(args.get(1))) {\n+                valueType = arrType;\n+            } else if (atypeFactory.getAnnotatedType(args.get(1)).getAnnotation(IntVal.class)\n+                    != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "688ca4f12aa48340354a9fc8b3748296efabcddb"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1OTEzNw==", "bodyText": "(and, you should add a test with IntRange when you do)", "url": "https://github.com/typetools/checker-framework/pull/3524#discussion_r462459137", "createdAt": "2020-07-29T17:16:33Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "diffHunk": "@@ -76,6 +79,26 @@ protected void commonAssignmentCheck(\n                     getTypeFactory().createIntRangeAnnotation(Range.CHAR_EVERYTHING));\n         }\n \n+        if (valueTree.getKind() == Kind.METHOD_INVOCATION\n+                && TreeUtils.isArrayscopyOfMethodInvocation((MethodInvocationTree) valueTree)\n+                && valueType.getKind() == TypeKind.ARRAY) {\n+            List<? extends ExpressionTree> args = ((MethodInvocationTree) valueTree).getArguments();\n+            AnnotatedTypeMirror arrType = atypeFactory.getAnnotatedType(args.get(0));\n+            if (TreeUtils.isArrayLengthAccess(args.get(1))) {\n+                valueType = arrType;\n+            } else if (atypeFactory.getAnnotatedType(args.get(1)).getAnnotation(IntVal.class)\n+                    != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ1ODkwMA=="}, "originalCommit": {"oid": "688ca4f12aa48340354a9fc8b3748296efabcddb"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTQzMTczOnYy", "diffSide": "RIGHT", "path": "javacutil/src/main/java/org/checkerframework/javacutil/TreeUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjoxMjoyNFrOG5qEJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjoxMjoyNFrOG5qEJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzExMTIwNQ==", "bodyText": "nit: in camel-case, this should be isArraysCopyOfMethodInvocation (that is, capitalize the \"c\" in \"copy\")", "url": "https://github.com/typetools/checker-framework/pull/3524#discussion_r463111205", "createdAt": "2020-07-30T16:12:24Z", "author": {"login": "kelloggm"}, "path": "javacutil/src/main/java/org/checkerframework/javacutil/TreeUtils.java", "diffHunk": "@@ -1273,6 +1273,27 @@ public static boolean isAnonymousConstructor(final MethodTree method) {\n         return false;\n     }\n \n+    /**\n+     * Determines if the tree is a call to Arrays.copyOf()\n+     *\n+     * @param tree tree to check\n+     * @return true if the given tree is a call to Arrays.copyOf() method\n+     */\n+    public static boolean isArrayscopyOfMethodInvocation(MethodInvocationTree tree) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a6430068cb3d0892bff03d6a6964ab94261e25"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTQ0NDg4OnYy", "diffSide": "RIGHT", "path": "javacutil/src/main/java/org/checkerframework/javacutil/TreeUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjoxNTozNFrOG5qMBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjoxNTozNFrOG5qMBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzExMzIyMg==", "bodyText": "This test isn't strong enough - it will return true on any method named copyOf in a class named Arrays, even if it is not the one from the JDK.\nYou should look at how IndexMethodIdentifier in the Index Checker identifies specific methods; you should be able to use the same kind of code here to identify Arrays.copyOf with confidence.\n(It would probably also be worthwhile to add an inner static class named \"Arrays\" with a static \"copyOf\" method to the tests and then ensure that your code is not invoked when that method is called.)", "url": "https://github.com/typetools/checker-framework/pull/3524#discussion_r463113222", "createdAt": "2020-07-30T16:15:34Z", "author": {"login": "kelloggm"}, "path": "javacutil/src/main/java/org/checkerframework/javacutil/TreeUtils.java", "diffHunk": "@@ -1273,6 +1273,27 @@ public static boolean isAnonymousConstructor(final MethodTree method) {\n         return false;\n     }\n \n+    /**\n+     * Determines if the tree is a call to Arrays.copyOf()\n+     *\n+     * @param tree tree to check\n+     * @return true if the given tree is a call to Arrays.copyOf() method\n+     */\n+    public static boolean isArrayscopyOfMethodInvocation(MethodInvocationTree tree) {\n+        if (tree.getMethodSelect().getKind() != Kind.MEMBER_SELECT) {\n+            return false;\n+        }\n+\n+        MemberSelectTree memberSelectTree = (MemberSelectTree) tree.getMethodSelect();\n+\n+        if (memberSelectTree.getExpression().toString().equals(\"Arrays\")\n+                && getMethodName(memberSelectTree).equals(\"copyOf\")) {\n+            return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a6430068cb3d0892bff03d6a6964ab94261e25"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTUwNjA0OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjozMDoyMlrOG5qxKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjozMDoyMlrOG5qxKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEyMjczMQ==", "bodyText": "Please add a check here that the length of args is what you expect (i.e. 2) and throw a BugInCF otherwise", "url": "https://github.com/typetools/checker-framework/pull/3524#discussion_r463122731", "createdAt": "2020-07-30T16:30:22Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "diffHunk": "@@ -76,6 +80,32 @@ protected void commonAssignmentCheck(\n                     getTypeFactory().createIntRangeAnnotation(Range.CHAR_EVERYTHING));\n         }\n \n+        if (valueTree.getKind() == Kind.METHOD_INVOCATION\n+                && TreeUtils.isArrayscopyOfMethodInvocation((MethodInvocationTree) valueTree)\n+                && valueType.getKind() == TypeKind.ARRAY) {\n+            List<? extends ExpressionTree> args = ((MethodInvocationTree) valueTree).getArguments();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a6430068cb3d0892bff03d6a6964ab94261e25"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTUxNTQ1OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjozMzowM1rOG5q3PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjozMzowM1rOG5q3PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEyNDI4NA==", "bodyText": "Rather than checking for IntVal and IntRange by hand, I suggest using ValueCheckerUtils.getPossibleValues, which returns a Range or null if the annotation isn't integral. It already has support for both IntVal and IntRange, and you should be able to just use its lower bound directly rather than doing the computations below. That will greatly simplify the code.", "url": "https://github.com/typetools/checker-framework/pull/3524#discussion_r463124284", "createdAt": "2020-07-30T16:33:03Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "diffHunk": "@@ -76,6 +80,32 @@ protected void commonAssignmentCheck(\n                     getTypeFactory().createIntRangeAnnotation(Range.CHAR_EVERYTHING));\n         }\n \n+        if (valueTree.getKind() == Kind.METHOD_INVOCATION\n+                && TreeUtils.isArrayscopyOfMethodInvocation((MethodInvocationTree) valueTree)\n+                && valueType.getKind() == TypeKind.ARRAY) {\n+            List<? extends ExpressionTree> args = ((MethodInvocationTree) valueTree).getArguments();\n+            if (getTypeFactory().getAnnotatedType(args.get(1)).getAnnotation(IntVal.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a6430068cb3d0892bff03d6a6964ab94261e25"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTIwMjI4OnYy", "diffSide": "RIGHT", "path": "framework/src/main/java/org/checkerframework/common/value/ValueTreeAnnotator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNTo1NDo1OFrOG6NlBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNTo1NDo1OFrOG6NlBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5MzA2Mg==", "bodyText": "range can be null here, but createArrayLenRange assumes its input in non-null. Can you add a null check and only do the type.replaceAnnotation(atypeFactory.createArrayLenRangeAnnotation(range)); if the range is non-null?", "url": "https://github.com/typetools/checker-framework/pull/3524#discussion_r463693062", "createdAt": "2020-07-31T15:54:58Z", "author": {"login": "kelloggm"}, "path": "framework/src/main/java/org/checkerframework/common/value/ValueTreeAnnotator.java", "diffHunk": "@@ -398,6 +399,20 @@ public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror\n             }\n         }\n \n+        if (atypeFactory\n+                .getMethodIdentifier()\n+                .isArraysCopyOfInvocation(tree, atypeFactory.getProcessingEnv())) {\n+            List<? extends ExpressionTree> args = tree.getArguments();\n+            if (args.size() != 2) {\n+                throw new BugInCF(\n+                        \"Arrays.copyOf() should have 2 arguments. This point should not have reached\");\n+            }\n+            Range range =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e309153a6d4f56e9a1e00ad9849562f1f88c196a"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1607, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}