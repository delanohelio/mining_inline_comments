{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzNTY2MTM1", "number": 2944, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTo0Nzo1MFrOE0Iy9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTo0OTo0NlrOE0IziQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTA1NTI1OnYy", "diffSide": "RIGHT", "path": "h2/src/main/org/h2/value/TypeInfo.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTo0Nzo1MFrOHrucXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMjowMzowMlrOHruimw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMTc0Mg==", "bodyText": "What about if col has type\nROW(VARCHAR, VARCHAR, INT)\nand query has type\nROW(VARCHAR, VARCHAR)\nthen the index would still be usable because the col ordering requirements are strictly a superset of the query ordering requirements\n?", "url": "https://github.com/h2database/h2database/pull/2944#discussion_r515611742", "createdAt": "2020-11-01T11:47:50Z", "author": {"login": "grandinj"}, "path": "h2/src/main/org/h2/value/TypeInfo.java", "diffHunk": "@@ -824,6 +824,87 @@ private static boolean areComparable(TypeInfo t1, TypeInfo t2) {\n         return false;\n     }\n \n+    /**\n+     * Determines whether two specified types have the same ordering rules.\n+     *\n+     * @param t1\n+     *            first data type\n+     * @param t2\n+     *            second data type\n+     * @return whether types are comparable\n+     */\n+    public static boolean haveSameOrdering(TypeInfo t1, TypeInfo t2) {\n+        int vt1 = (t1 = t1.unwrapRow()).getValueType(), vt2 = (t2 = t2.unwrapRow()).getValueType();\n+        if (vt1 > vt2) {\n+            int vt = vt1;\n+            vt1 = vt2;\n+            vt2 = vt;\n+            TypeInfo t = t1;\n+            t1 = t2;\n+            t2 = t;\n+        }\n+        if (vt1 <= Value.NULL) {\n+            return true;\n+        }\n+        if (vt1 == vt2) {\n+            switch (vt1) {\n+            case Value.ARRAY:\n+                return haveSameOrdering((TypeInfo) t1.getExtTypeInfo(), (TypeInfo) t2.getExtTypeInfo());\n+            case Value.ROW: {\n+                Set<Entry<String, TypeInfo>> f1 = ((ExtTypeInfoRow) t1.getExtTypeInfo()).getFields();\n+                Set<Entry<String, TypeInfo>> f2 = ((ExtTypeInfoRow) t2.getExtTypeInfo()).getFields();\n+                int degree = f1.size();\n+                if (f2.size() != degree) {\n+                    return false;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c328859efee5f7714b51f6b006646c96178b79"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMjU4Mw==", "bodyText": "Row values of different degree can't be compared with each other. This condition exists here only for safety, such comparisons are normally rejected earlier.", "url": "https://github.com/h2database/h2database/pull/2944#discussion_r515612583", "createdAt": "2020-11-01T11:55:47Z", "author": {"login": "katzyn"}, "path": "h2/src/main/org/h2/value/TypeInfo.java", "diffHunk": "@@ -824,6 +824,87 @@ private static boolean areComparable(TypeInfo t1, TypeInfo t2) {\n         return false;\n     }\n \n+    /**\n+     * Determines whether two specified types have the same ordering rules.\n+     *\n+     * @param t1\n+     *            first data type\n+     * @param t2\n+     *            second data type\n+     * @return whether types are comparable\n+     */\n+    public static boolean haveSameOrdering(TypeInfo t1, TypeInfo t2) {\n+        int vt1 = (t1 = t1.unwrapRow()).getValueType(), vt2 = (t2 = t2.unwrapRow()).getValueType();\n+        if (vt1 > vt2) {\n+            int vt = vt1;\n+            vt1 = vt2;\n+            vt2 = vt;\n+            TypeInfo t = t1;\n+            t1 = t2;\n+            t2 = t;\n+        }\n+        if (vt1 <= Value.NULL) {\n+            return true;\n+        }\n+        if (vt1 == vt2) {\n+            switch (vt1) {\n+            case Value.ARRAY:\n+                return haveSameOrdering((TypeInfo) t1.getExtTypeInfo(), (TypeInfo) t2.getExtTypeInfo());\n+            case Value.ROW: {\n+                Set<Entry<String, TypeInfo>> f1 = ((ExtTypeInfoRow) t1.getExtTypeInfo()).getFields();\n+                Set<Entry<String, TypeInfo>> f2 = ((ExtTypeInfoRow) t2.getExtTypeInfo()).getFields();\n+                int degree = f1.size();\n+                if (f2.size() != degree) {\n+                    return false;\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMTc0Mg=="}, "originalCommit": {"oid": "47c328859efee5f7714b51f6b006646c96178b79"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMzMzOQ==", "bodyText": "Only arrays with different cardinality are comparable (if types of elements are comparable).", "url": "https://github.com/h2database/h2database/pull/2944#discussion_r515613339", "createdAt": "2020-11-01T12:03:02Z", "author": {"login": "katzyn"}, "path": "h2/src/main/org/h2/value/TypeInfo.java", "diffHunk": "@@ -824,6 +824,87 @@ private static boolean areComparable(TypeInfo t1, TypeInfo t2) {\n         return false;\n     }\n \n+    /**\n+     * Determines whether two specified types have the same ordering rules.\n+     *\n+     * @param t1\n+     *            first data type\n+     * @param t2\n+     *            second data type\n+     * @return whether types are comparable\n+     */\n+    public static boolean haveSameOrdering(TypeInfo t1, TypeInfo t2) {\n+        int vt1 = (t1 = t1.unwrapRow()).getValueType(), vt2 = (t2 = t2.unwrapRow()).getValueType();\n+        if (vt1 > vt2) {\n+            int vt = vt1;\n+            vt1 = vt2;\n+            vt2 = vt;\n+            TypeInfo t = t1;\n+            t1 = t2;\n+            t2 = t;\n+        }\n+        if (vt1 <= Value.NULL) {\n+            return true;\n+        }\n+        if (vt1 == vt2) {\n+            switch (vt1) {\n+            case Value.ARRAY:\n+                return haveSameOrdering((TypeInfo) t1.getExtTypeInfo(), (TypeInfo) t2.getExtTypeInfo());\n+            case Value.ROW: {\n+                Set<Entry<String, TypeInfo>> f1 = ((ExtTypeInfoRow) t1.getExtTypeInfo()).getFields();\n+                Set<Entry<String, TypeInfo>> f2 = ((ExtTypeInfoRow) t2.getExtTypeInfo()).getFields();\n+                int degree = f1.size();\n+                if (f2.size() != degree) {\n+                    return false;\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMTc0Mg=="}, "originalCommit": {"oid": "47c328859efee5f7714b51f6b006646c96178b79"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTA1NjczOnYy", "diffSide": "RIGHT", "path": "h2/src/main/org/h2/command/Parser.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTo0OTo0NlrOHrudEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMjowNzowMFrOHrukSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMTkyMg==", "bodyText": "might possibly be more efficient here to construct the StringBuilder with size\n   result.size() + sqlCommand.size()\n\nto avoid some re-allocations", "url": "https://github.com/h2database/h2database/pull/2944#discussion_r515611922", "createdAt": "2020-11-01T11:49:46Z", "author": {"login": "grandinj"}, "path": "h2/src/main/org/h2/command/Parser.java", "diffHunk": "@@ -6360,15 +6360,23 @@ private void readString(int i, char[] chars, int[] types) {\n     }\n \n     private String readRawString(int i, char[] chars, int[] types) {\n-        StringBuilder result = new StringBuilder();\n+        String result = null;\n+        StringBuilder builder = null;\n         for (;; i++) {\n             boolean next = false;\n             for (;; i++) {\n                 int begin = i;\n                 while (chars[i] != '\\'') {\n                     i++;\n                 }\n-                result.append(sqlCommand, next ? begin - 1 : begin, i);\n+                if (result == null) {\n+                    result = sqlCommand.substring(begin, i);\n+                } else {\n+                    if (builder == null) {\n+                        builder = new StringBuilder(result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e6fdc84acc60ded2d035bc790d3c3fb3f9b62e7"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMzIxOQ==", "bodyText": "That's too much. new StringBuilder(String) allocates space for 16 additional characters, so the next addition in many cases doesn't create a reallocation.\nActually these lines of core aren't executed for the most of character string literals. Literals with many parts ('something ' 'something ' 'something') are rarely used, many programmers and DBAs don't even know that they exists, and only few literals have ' character in them (' '' ').", "url": "https://github.com/h2database/h2database/pull/2944#discussion_r515613219", "createdAt": "2020-11-01T12:01:41Z", "author": {"login": "katzyn"}, "path": "h2/src/main/org/h2/command/Parser.java", "diffHunk": "@@ -6360,15 +6360,23 @@ private void readString(int i, char[] chars, int[] types) {\n     }\n \n     private String readRawString(int i, char[] chars, int[] types) {\n-        StringBuilder result = new StringBuilder();\n+        String result = null;\n+        StringBuilder builder = null;\n         for (;; i++) {\n             boolean next = false;\n             for (;; i++) {\n                 int begin = i;\n                 while (chars[i] != '\\'') {\n                     i++;\n                 }\n-                result.append(sqlCommand, next ? begin - 1 : begin, i);\n+                if (result == null) {\n+                    result = sqlCommand.substring(begin, i);\n+                } else {\n+                    if (builder == null) {\n+                        builder = new StringBuilder(result);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMTkyMg=="}, "originalCommit": {"oid": "4e6fdc84acc60ded2d035bc790d3c3fb3f9b62e7"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMzc3MA==", "bodyText": "I thought about result.size() + i - begin + 1 or something like it, but if string has one ', it can have more, and we also can find a multi-part literal. So such optimization also doesn't look good, that's why I decided to use the default behavior of StringBuilder.", "url": "https://github.com/h2database/h2database/pull/2944#discussion_r515613770", "createdAt": "2020-11-01T12:07:00Z", "author": {"login": "katzyn"}, "path": "h2/src/main/org/h2/command/Parser.java", "diffHunk": "@@ -6360,15 +6360,23 @@ private void readString(int i, char[] chars, int[] types) {\n     }\n \n     private String readRawString(int i, char[] chars, int[] types) {\n-        StringBuilder result = new StringBuilder();\n+        String result = null;\n+        StringBuilder builder = null;\n         for (;; i++) {\n             boolean next = false;\n             for (;; i++) {\n                 int begin = i;\n                 while (chars[i] != '\\'') {\n                     i++;\n                 }\n-                result.append(sqlCommand, next ? begin - 1 : begin, i);\n+                if (result == null) {\n+                    result = sqlCommand.substring(begin, i);\n+                } else {\n+                    if (builder == null) {\n+                        builder = new StringBuilder(result);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMTkyMg=="}, "originalCommit": {"oid": "4e6fdc84acc60ded2d035bc790d3c3fb3f9b62e7"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2098, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}