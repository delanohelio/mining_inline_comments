{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzMzQ5MDE0", "number": 1511, "title": "Scope validation for not associated federated user using idp role maping", "bodyText": "Public Issue : wso2/product-is#10527\nLogic\n\nIsolate getUserRoles flow for the federated user.\nUser attributes consist of unmapped federated roles, mapped local roles and Internal/everyone corresponding to the authenticated user. But we can't isolate them.\nRole mapping consists of mapped federated roles with local roles corresponding to IDP.\nBy cross-checking role mapped local roles and user attributes we can filter valid local roles which mapped to the federated role of an authenticated user.", "createdAt": "2020-12-07T03:44:41Z", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511", "merged": true, "mergeCommit": {"oid": "cebadcb4862c6d50e85d54703f381395f1e46fb6"}, "closed": true, "closedAt": "2020-12-08T05:07:39Z", "author": {"login": "Thumimku"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdjwF-KgFqTU0NTg3NDk1Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkC-xcgFqTU0Njc0ODU0Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1ODc0OTU3", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#pullrequestreview-545874957", "createdAt": "2020-12-07T07:06:33Z", "commit": {"oid": "dfc2db380d7dee0ff40cf5a459d0bb08f99b20a7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MTA0ODIz", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#pullrequestreview-546104823", "createdAt": "2020-12-07T12:33:21Z", "commit": {"oid": "dfc2db380d7dee0ff40cf5a459d0bb08f99b20a7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMjozMzoyMVrOIAkoGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMjozMzoyMVrOIAkoGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ3MTAwMg==", "bodyText": "can this cause any null point exceptions if getIdpManager() returns null?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537471002", "createdAt": "2020-12-07T12:33:21Z", "author": {"login": "pamodaaw"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/util/OAuth2Util.java", "diffHunk": "@@ -3877,4 +3879,53 @@ public static boolean isAllowedScope(List<String> allowedScopesList, String scop\n         }\n         return false;\n     }\n+\n+    /**\n+     * Util method to get Identity Provider by name and tenant domain.\n+     *\n+     * @param identityProviderName Identity provider\n+     * @param tenantDomain         Tenant domain\n+     * @return Identity Provider\n+     * @throws IdentityOAuth2Exception If were unable to get Identity provider.\n+     */\n+    public static IdentityProvider getIdentityProvider(String identityProviderName, String tenantDomain)\n+            throws IdentityOAuth2Exception {\n+\n+        try {\n+            return OAuth2ServiceComponentHolder.getInstance().getIdpManager().getIdPByName(identityProviderName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfc2db380d7dee0ff40cf5a459d0bb08f99b20a7"}, "originalPosition": 28}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dfc2db380d7dee0ff40cf5a459d0bb08f99b20a7", "author": {"user": {"login": "Thumimku", "name": "Thumilan Mikunthan"}}, "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/commit/dfc2db380d7dee0ff40cf5a459d0bb08f99b20a7", "committedDate": "2020-12-07T03:40:20Z", "message": "Scope validation for not associated federated user using idp role mapping"}, "afterCommit": {"oid": "e5c216674443a2579aec7f15b6b391c1c1858f5b", "author": {"user": {"login": "Thumimku", "name": "Thumilan Mikunthan"}}, "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/commit/e5c216674443a2579aec7f15b6b391c1c1858f5b", "committedDate": "2020-12-07T13:32:07Z", "message": "Scope validation for not associated federated user using idp role mapping\n\nnull issue checked"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e5c216674443a2579aec7f15b6b391c1c1858f5b", "author": {"user": {"login": "Thumimku", "name": "Thumilan Mikunthan"}}, "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/commit/e5c216674443a2579aec7f15b6b391c1c1858f5b", "committedDate": "2020-12-07T13:32:07Z", "message": "Scope validation for not associated federated user using idp role mapping\n\nnull issue checked"}, "afterCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "author": {"user": {"login": "Thumimku", "name": "Thumilan Mikunthan"}}, "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/commit/94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "committedDate": "2020-12-07T13:35:04Z", "message": "Scope validation for not associated federated user using idp role mapping\n\nnull issue checked\n\nnull issue checked"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2MTU1MDg4", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#pullrequestreview-546155088", "createdAt": "2020-12-07T13:39:41Z", "commit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzozOTo0MVrOIAnLbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDowODo0N1rOIAodlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxMjgxNA==", "bodyText": "can this cause a ClassCastException if getUserStoreManager() returns null?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537512814", "createdAt": "2020-12-07T13:39:41Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/util/OAuth2Util.java", "diffHunk": "@@ -3877,4 +3879,59 @@ public static boolean isAllowedScope(List<String> allowedScopesList, String scop\n         }\n         return false;\n     }\n+\n+    /**\n+     * Util method to get Identity Provider by name and tenant domain.\n+     *\n+     * @param identityProviderName Identity provider\n+     * @param tenantDomain         Tenant domain\n+     * @return Identity Provider\n+     * @throws IdentityOAuth2Exception If were unable to get Identity provider.\n+     */\n+    public static IdentityProvider getIdentityProvider(String identityProviderName, String tenantDomain)\n+            throws IdentityOAuth2Exception {\n+\n+        try {\n+            if (OAuth2ServiceComponentHolder.getInstance().getIdpManager() != null) {\n+                return OAuth2ServiceComponentHolder.getInstance().getIdpManager().getIdPByName(identityProviderName,\n+                        tenantDomain);\n+            } else {\n+                String errorMsg = String.format(\"Unable to retrieve Idp manager. Error while \" +\n+                        \"getting '%s' Identity  Provider of '%s' tenant.\", identityProviderName, tenantDomain);\n+                throw new IdentityOAuth2Exception(errorMsg);\n+            }\n+        } catch (IdentityProviderManagementException e) {\n+            String errorMsg =\n+                    String.format(\"Error while getting '%s' Identity Provider of '%s' tenant.\", identityProviderName,\n+                            tenantDomain);\n+            throw new IdentityOAuth2Exception(errorMsg, e);\n+        }\n+    }\n+\n+    /**\n+     * Get Internal/everyone role for corresponding user using realm configuration.\n+     *\n+     * @param user Authenticated user\n+     * @return Internal/everyone role\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    public static String getInternalEveryoneRole(AuthenticatedUser user) throws IdentityOAuth2Exception {\n+\n+        try {\n+            RealmConfiguration realmConfiguration = null;\n+            RealmService realmService = OAuthComponentServiceHolder.getInstance().getRealmService();\n+            int tenantId = getTenantId(user.getTenantDomain());\n+            if (realmService != null && tenantId != org.wso2.carbon.base.MultitenantConstants.INVALID_TENANT_ID) {\n+                UserStoreManager userStoreManager = null;\n+                userStoreManager = (UserStoreManager) realmService.getTenantUserRealm(tenantId).getUserStoreManager();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxNDgwMA==", "bodyText": "Do we really need an 'else' block here?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537514800", "createdAt": "2020-12-07T13:42:34Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxNzQ4Ng==", "bodyText": "We can do without the 'else' nesting here since we return in the 'if' block.", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537517486", "createdAt": "2020-12-07T13:46:36Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxOTkyNA==", "bodyText": "Can't we use forEach() here?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537519924", "createdAt": "2020-12-07T13:50:10Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    /**\n+     * Method user to get list of federated users permissions using idp role mapping for not account associated\n+     * federated users.\n+     * @param authenticatedUser    FederatedAuthenticatedUser\n+     * @param authorizationManager AuthorizationManager\n+     * @return List of permissions\n+     * @throws UserStoreException      UserStoreException\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    private String[] getAllowedUIResourcesForNotAssociatedFederatedUser(AuthenticatedUser authenticatedUser,\n+                                                                        AuthorizationManager authorizationManager)\n+            throws UserStoreException, IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        List<String> allowedUIResourcesListForUser = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(authenticatedUser.getFederatedIdPName(),\n+                        authenticatedUser.getTenantDomain());\n+        /*\n+        Values of Groups consists mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking role mapped local roles and values of groups we can filter valid local roles which mapped\n+        to a federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(authenticatedUser.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyMjA2MQ==", "bodyText": "Can we guarantee the getRemoteClaim() would not return null?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537522061", "createdAt": "2020-12-07T13:53:12Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    /**\n+     * Method user to get list of federated users permissions using idp role mapping for not account associated\n+     * federated users.\n+     * @param authenticatedUser    FederatedAuthenticatedUser\n+     * @param authorizationManager AuthorizationManager\n+     * @return List of permissions\n+     * @throws UserStoreException      UserStoreException\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    private String[] getAllowedUIResourcesForNotAssociatedFederatedUser(AuthenticatedUser authenticatedUser,\n+                                                                        AuthorizationManager authorizationManager)\n+            throws UserStoreException, IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        List<String> allowedUIResourcesListForUser = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(authenticatedUser.getFederatedIdPName(),\n+                        authenticatedUser.getTenantDomain());\n+        /*\n+        Values of Groups consists mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking role mapped local roles and values of groups we can filter valid local roles which mapped\n+        to a federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(authenticatedUser.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {\n+                if (roleMapping != null && roleMapping.getLocalRole() != null) {\n+                    if (valuesOfGroups.contains(roleMapping.getLocalRole().getLocalRoleName())) {\n+                        userRolesList.add(roleMapping.getLocalRole().getLocalRoleName());\n+                    }\n+                }\n+            }\n+        }\n+        // Loop through each local role and get permissions.\n+        for (String userRole : userRolesList) {\n+            for (String allowedUIResource : authorizationManager.getAllowedUIResourcesForRole(userRole, \"/\")) {\n+                if (!allowedUIResourcesListForUser.contains(allowedUIResource)) {\n+                    allowedUIResourcesListForUser.add(allowedUIResource);\n+                }\n+            }\n+        }\n+        // Add everyone permission to allowed permission.\n+        allowedUIResourcesListForUser.add(EVERYONE_PERMISSION);\n+\n+        return allowedUIResourcesListForUser.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Get groups params Roles from User attributes.\n+     *\n+     * @param userAttributes User Attributes\n+     * @return User attribute map\n+     */\n+    private List<String> getValuesOfGroupsFromUserAttributes(Map<ClaimMapping, String> userAttributes) {\n+\n+        if (isNotEmpty(userAttributes)) {\n+            for (Map.Entry<ClaimMapping, String> entry : userAttributes.entrySet()) {\n+                if (StringUtils.equals(entry.getKey().getRemoteClaim().getClaimUri(), OAuth2Constants.GROUPS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyMjI2MA==", "bodyText": "Unnecessary new line", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537522260", "createdAt": "2020-12-07T13:53:31Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    /**\n+     * Method user to get list of federated users permissions using idp role mapping for not account associated\n+     * federated users.\n+     * @param authenticatedUser    FederatedAuthenticatedUser\n+     * @param authorizationManager AuthorizationManager\n+     * @return List of permissions\n+     * @throws UserStoreException      UserStoreException\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    private String[] getAllowedUIResourcesForNotAssociatedFederatedUser(AuthenticatedUser authenticatedUser,\n+                                                                        AuthorizationManager authorizationManager)\n+            throws UserStoreException, IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        List<String> allowedUIResourcesListForUser = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(authenticatedUser.getFederatedIdPName(),\n+                        authenticatedUser.getTenantDomain());\n+        /*\n+        Values of Groups consists mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking role mapped local roles and values of groups we can filter valid local roles which mapped\n+        to a federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(authenticatedUser.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {\n+                if (roleMapping != null && roleMapping.getLocalRole() != null) {\n+                    if (valuesOfGroups.contains(roleMapping.getLocalRole().getLocalRoleName())) {\n+                        userRolesList.add(roleMapping.getLocalRole().getLocalRoleName());\n+                    }\n+                }\n+            }\n+        }\n+        // Loop through each local role and get permissions.\n+        for (String userRole : userRolesList) {\n+            for (String allowedUIResource : authorizationManager.getAllowedUIResourcesForRole(userRole, \"/\")) {\n+                if (!allowedUIResourcesListForUser.contains(allowedUIResource)) {\n+                    allowedUIResourcesListForUser.add(allowedUIResource);\n+                }\n+            }\n+        }\n+        // Add everyone permission to allowed permission.\n+        allowedUIResourcesListForUser.add(EVERYONE_PERMISSION);\n+\n+        return allowedUIResourcesListForUser.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Get groups params Roles from User attributes.\n+     *\n+     * @param userAttributes User Attributes\n+     * @return User attribute map\n+     */\n+    private List<String> getValuesOfGroupsFromUserAttributes(Map<ClaimMapping, String> userAttributes) {\n+\n+        if (isNotEmpty(userAttributes)) {\n+            for (Map.Entry<ClaimMapping, String> entry : userAttributes.entrySet()) {\n+                if (StringUtils.equals(entry.getKey().getRemoteClaim().getClaimUri(), OAuth2Constants.GROUPS)) {\n+                    return Arrays.asList(entry.getValue().split(Pattern.quote(ATTRIBUTE_SEPARATOR)));\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNDc0Mw==", "bodyText": "Wouldn't this make the L285 unreachable?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537524743", "createdAt": "2020-12-07T13:56:58Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {\n+                if (!isScopeValid(scope, tenantId)) {\n+                    // If the scope is not registered return false.\n+                    log.error(\"Requested scope \" + scope + \" is invalid\");\n+                    return false;\n+                }\n+                if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"User \" + user.getUserName() + \"in not authorised for scope \" + scope);\n+                    }\n+                    return false;\n+                }\n             }\n+        } else {\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNjkwMQ==", "bodyText": "does the 'else' nesting serve any value?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537526901", "createdAt": "2020-12-07T13:59:54Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {\n+                if (!isScopeValid(scope, tenantId)) {\n+                    // If the scope is not registered return false.\n+                    log.error(\"Requested scope \" + scope + \" is invalid\");\n+                    return false;\n+                }\n+                if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"User \" + user.getUserName() + \"in not authorised for scope \" + scope);\n+                    }\n+                    return false;\n+                }\n             }\n+        } else {\n+            return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNDc0Mw=="}, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNzY0NA==", "bodyText": "Can't we do without the 'else' nesting?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537527644", "createdAt": "2020-12-07T14:00:59Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {\n+                if (!isScopeValid(scope, tenantId)) {\n+                    // If the scope is not registered return false.\n+                    log.error(\"Requested scope \" + scope + \" is invalid\");\n+                    return false;\n+                }\n+                if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"User \" + user.getUserName() + \"in not authorised for scope \" + scope);\n+                    }\n+                    return false;\n+                }\n             }\n+        } else {\n+            return false;\n         }\n         return true;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNzc1NQ==", "bodyText": "Can't we do without the 'else' nesting?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537527755", "createdAt": "2020-12-07T14:01:08Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {\n+                if (!isScopeValid(scope, tenantId)) {\n+                    // If the scope is not registered return false.\n+                    log.error(\"Requested scope \" + scope + \" is invalid\");\n+                    return false;\n+                }\n+                if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"User \" + user.getUserName() + \"in not authorised for scope \" + scope);\n+                    }\n+                    return false;\n+                }\n             }\n+        } else {\n+            return false;\n         }\n         return true;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUzMDAyMA==", "bodyText": "Can't we use forEach() instead?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537530020", "createdAt": "2020-12-07T14:04:15Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUzMTg4Mg==", "bodyText": "Shall we use the full qualified method here instead of importing MapUtils.isNotEmpty()?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537531882", "createdAt": "2020-12-07T14:06:39Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    /**\n+     * Method user to get list of federated users permissions using idp role mapping for not account associated\n+     * federated users.\n+     * @param authenticatedUser    FederatedAuthenticatedUser\n+     * @param authorizationManager AuthorizationManager\n+     * @return List of permissions\n+     * @throws UserStoreException      UserStoreException\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    private String[] getAllowedUIResourcesForNotAssociatedFederatedUser(AuthenticatedUser authenticatedUser,\n+                                                                        AuthorizationManager authorizationManager)\n+            throws UserStoreException, IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        List<String> allowedUIResourcesListForUser = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(authenticatedUser.getFederatedIdPName(),\n+                        authenticatedUser.getTenantDomain());\n+        /*\n+        Values of Groups consists mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking role mapped local roles and values of groups we can filter valid local roles which mapped\n+        to a federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(authenticatedUser.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {\n+                if (roleMapping != null && roleMapping.getLocalRole() != null) {\n+                    if (valuesOfGroups.contains(roleMapping.getLocalRole().getLocalRoleName())) {\n+                        userRolesList.add(roleMapping.getLocalRole().getLocalRoleName());\n+                    }\n+                }\n+            }\n+        }\n+        // Loop through each local role and get permissions.\n+        for (String userRole : userRolesList) {\n+            for (String allowedUIResource : authorizationManager.getAllowedUIResourcesForRole(userRole, \"/\")) {\n+                if (!allowedUIResourcesListForUser.contains(allowedUIResource)) {\n+                    allowedUIResourcesListForUser.add(allowedUIResource);\n+                }\n+            }\n+        }\n+        // Add everyone permission to allowed permission.\n+        allowedUIResourcesListForUser.add(EVERYONE_PERMISSION);\n+\n+        return allowedUIResourcesListForUser.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Get groups params Roles from User attributes.\n+     *\n+     * @param userAttributes User Attributes\n+     * @return User attribute map\n+     */\n+    private List<String> getValuesOfGroupsFromUserAttributes(Map<ClaimMapping, String> userAttributes) {\n+\n+        if (isNotEmpty(userAttributes)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUzMzg0Ng==", "bodyText": "Shall we extract this out as a separate method since the same logic is used at L311?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537533846", "createdAt": "2020-12-07T14:08:47Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {\n+                if (!isScopeValid(scope, tenantId)) {\n+                    // If the scope is not registered return false.\n+                    log.error(\"Requested scope \" + scope + \" is invalid\");\n+                    return false;\n+                }\n+                if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"User \" + user.getUserName() + \"in not authorised for scope \" + scope);\n+                    }\n+                    return false;\n+                }\n             }\n+        } else {\n+            return false;\n         }\n         return true;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    private String[] getUserRolesForNotAssociatedFederatedUser(AuthenticatedUser user)\n+            throws IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(user.getFederatedIdPName(), user.getTenantDomain());\n+        /*\n+        Values of Groups consists unmapped federated roles, mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking federated role mapped local roles and values of groups we can filter valid local roles which\n+        mapped to the federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(user.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {\n+                if (roleMapping != null && roleMapping.getLocalRole() != null) {\n+                    if (valuesOfGroups.contains(roleMapping.getLocalRole().getLocalRoleName())) {\n+                        userRolesList.add(roleMapping.getLocalRole().getLocalRoleName());\n+                    }\n+                }\n+            }\n+        }\n+        // By default we provide Internal/everyone role for all users.\n+        String internalEveryoneRole = OAuth2Util.getInternalEveryoneRole(user);\n+        if (StringUtils.isNotBlank(internalEveryoneRole)) {\n+            userRolesList.add(internalEveryoneRole);\n+        }\n+        return userRolesList.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Get groups params Roles from User attributes.\n+     *\n+     * @param userAttributes User Attributes\n+     * @return User attribute map\n+     */\n+    private List<String> getValuesOfGroupsFromUserAttributes(Map<ClaimMapping, String> userAttributes) {\n+\n+        if (MapUtils.isNotEmpty(userAttributes)) {\n+            for (Map.Entry<ClaimMapping, String> entry : userAttributes.entrySet()) {\n+                if (StringUtils.equals(entry.getKey().getRemoteClaim().getClaimUri(), OAuth2Constants.GROUPS)) {\n+                    return Arrays.asList(entry.getValue().split(Pattern.quote(ATTRIBUTE_SEPARATOR)));\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 209}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "author": {"user": {"login": "Thumimku", "name": "Thumilan Mikunthan"}}, "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/commit/94424f60a3188f7b58ae391f7eccc9a5aaf6b739", "committedDate": "2020-12-07T13:35:04Z", "message": "Scope validation for not associated federated user using idp role mapping\n\nnull issue checked\n\nnull issue checked"}, "afterCommit": {"oid": "32f3f5b0e256bbc515085fd7503c1fde237a9300", "author": {"user": {"login": "Thumimku", "name": "Thumilan Mikunthan"}}, "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/commit/32f3f5b0e256bbc515085fd7503c1fde237a9300", "committedDate": "2020-12-08T02:55:19Z", "message": "Scope validation for not associated federated user using idp role mapping\n\nnull issue checked\n\nnull issue checked\n\ncomments resolved"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NzMxMTc5", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#pullrequestreview-546731179", "createdAt": "2020-12-08T04:10:10Z", "commit": {"oid": "32f3f5b0e256bbc515085fd7503c1fde237a9300"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNDoxMDoxMFrOIBGH3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNDoxMDoxMFrOIBGH3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAxOTgwNA==", "bodyText": "formatting issue", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r538019804", "createdAt": "2020-12-08T04:10:10Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -181,27 +194,29 @@ public boolean validateScope(AccessTokenDO accessTokenDO, String resource) throw\n     public boolean validateScope(OAuthTokenReqMessageContext tokReqMsgCtx) throws\n             UserStoreException, IdentityOAuth2Exception {\n \n-        return validateScope(tokReqMsgCtx.getScope(), tokReqMsgCtx.getAuthorizedUser());\n-    }\n+        return validateScope(tokReqMsgCtx.getScope(), tokReqMsgCtx.getAuthorizedUser(),\n+                tokReqMsgCtx.getOauth2AccessTokenReqDTO().getClientId());    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32f3f5b0e256bbc515085fd7503c1fde237a9300"}, "originalPosition": 64}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fa8b831b576be452425601c762f110c83b6ca24", "author": {"user": {"login": "Thumimku", "name": "Thumilan Mikunthan"}}, "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/commit/8fa8b831b576be452425601c762f110c83b6ca24", "committedDate": "2020-12-08T04:15:53Z", "message": "Scope validation for not associated federated user using idp role mapping\n\nnull issue checked\n\nnull issue checked\n\ncomments resolved\n\nresolve comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "32f3f5b0e256bbc515085fd7503c1fde237a9300", "author": {"user": {"login": "Thumimku", "name": "Thumilan Mikunthan"}}, "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/commit/32f3f5b0e256bbc515085fd7503c1fde237a9300", "committedDate": "2020-12-08T02:55:19Z", "message": "Scope validation for not associated federated user using idp role mapping\n\nnull issue checked\n\nnull issue checked\n\ncomments resolved"}, "afterCommit": {"oid": "8fa8b831b576be452425601c762f110c83b6ca24", "author": {"user": {"login": "Thumimku", "name": "Thumilan Mikunthan"}}, "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/commit/8fa8b831b576be452425601c762f110c83b6ca24", "committedDate": "2020-12-08T04:15:53Z", "message": "Scope validation for not associated federated user using idp role mapping\n\nnull issue checked\n\nnull issue checked\n\ncomments resolved\n\nresolve comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NzMzNTQ1", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#pullrequestreview-546733545", "createdAt": "2020-12-08T04:18:00Z", "commit": {"oid": "8fa8b831b576be452425601c762f110c83b6ca24"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NzQ4NTQz", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#pullrequestreview-546748543", "createdAt": "2020-12-08T05:06:53Z", "commit": {"oid": "8fa8b831b576be452425601c762f110c83b6ca24"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3103, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}