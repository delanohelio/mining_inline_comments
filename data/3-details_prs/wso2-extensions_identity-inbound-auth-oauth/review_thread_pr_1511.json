{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzMzQ5MDE0", "number": 1511, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMjozMzoyMVrOFBwaxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNDoxMDoxMFrOFCHPBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Mzg2MTgyOnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/util/OAuth2Util.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMjozMzoyMVrOIAkoGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMjozMzoyMVrOIAkoGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ3MTAwMg==", "bodyText": "can this cause any null point exceptions if getIdpManager() returns null?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537471002", "createdAt": "2020-12-07T12:33:21Z", "author": {"login": "pamodaaw"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/util/OAuth2Util.java", "diffHunk": "@@ -3877,4 +3879,53 @@ public static boolean isAllowedScope(List<String> allowedScopesList, String scop\n         }\n         return false;\n     }\n+\n+    /**\n+     * Util method to get Identity Provider by name and tenant domain.\n+     *\n+     * @param identityProviderName Identity provider\n+     * @param tenantDomain         Tenant domain\n+     * @return Identity Provider\n+     * @throws IdentityOAuth2Exception If were unable to get Identity provider.\n+     */\n+    public static IdentityProvider getIdentityProvider(String identityProviderName, String tenantDomain)\n+            throws IdentityOAuth2Exception {\n+\n+        try {\n+            return OAuth2ServiceComponentHolder.getInstance().getIdpManager().getIdPByName(identityProviderName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfc2db380d7dee0ff40cf5a459d0bb08f99b20a7"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDE0NTA4OnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/util/OAuth2Util.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzozOTo0MVrOIAnLbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMjo1NzoxNlrOIBEo3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxMjgxNA==", "bodyText": "can this cause a ClassCastException if getUserStoreManager() returns null?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537512814", "createdAt": "2020-12-07T13:39:41Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/util/OAuth2Util.java", "diffHunk": "@@ -3877,4 +3879,59 @@ public static boolean isAllowedScope(List<String> allowedScopesList, String scop\n         }\n         return false;\n     }\n+\n+    /**\n+     * Util method to get Identity Provider by name and tenant domain.\n+     *\n+     * @param identityProviderName Identity provider\n+     * @param tenantDomain         Tenant domain\n+     * @return Identity Provider\n+     * @throws IdentityOAuth2Exception If were unable to get Identity provider.\n+     */\n+    public static IdentityProvider getIdentityProvider(String identityProviderName, String tenantDomain)\n+            throws IdentityOAuth2Exception {\n+\n+        try {\n+            if (OAuth2ServiceComponentHolder.getInstance().getIdpManager() != null) {\n+                return OAuth2ServiceComponentHolder.getInstance().getIdpManager().getIdPByName(identityProviderName,\n+                        tenantDomain);\n+            } else {\n+                String errorMsg = String.format(\"Unable to retrieve Idp manager. Error while \" +\n+                        \"getting '%s' Identity  Provider of '%s' tenant.\", identityProviderName, tenantDomain);\n+                throw new IdentityOAuth2Exception(errorMsg);\n+            }\n+        } catch (IdentityProviderManagementException e) {\n+            String errorMsg =\n+                    String.format(\"Error while getting '%s' Identity Provider of '%s' tenant.\", identityProviderName,\n+                            tenantDomain);\n+            throw new IdentityOAuth2Exception(errorMsg, e);\n+        }\n+    }\n+\n+    /**\n+     * Get Internal/everyone role for corresponding user using realm configuration.\n+     *\n+     * @param user Authenticated user\n+     * @return Internal/everyone role\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    public static String getInternalEveryoneRole(AuthenticatedUser user) throws IdentityOAuth2Exception {\n+\n+        try {\n+            RealmConfiguration realmConfiguration = null;\n+            RealmService realmService = OAuthComponentServiceHolder.getInstance().getRealmService();\n+            int tenantId = getTenantId(user.getTenantDomain());\n+            if (realmService != null && tenantId != org.wso2.carbon.base.MultitenantConstants.INVALID_TENANT_ID) {\n+                UserStoreManager userStoreManager = null;\n+                userStoreManager = (UserStoreManager) realmService.getTenantUserRealm(tenantId).getUserStoreManager();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk5NTQ4Nw==", "bodyText": "can cast null to any reference type without getting any exception, but I get your point added a null check after that.", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537995487", "createdAt": "2020-12-08T02:57:16Z", "author": {"login": "Thumimku"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/util/OAuth2Util.java", "diffHunk": "@@ -3877,4 +3879,59 @@ public static boolean isAllowedScope(List<String> allowedScopesList, String scop\n         }\n         return false;\n     }\n+\n+    /**\n+     * Util method to get Identity Provider by name and tenant domain.\n+     *\n+     * @param identityProviderName Identity provider\n+     * @param tenantDomain         Tenant domain\n+     * @return Identity Provider\n+     * @throws IdentityOAuth2Exception If were unable to get Identity provider.\n+     */\n+    public static IdentityProvider getIdentityProvider(String identityProviderName, String tenantDomain)\n+            throws IdentityOAuth2Exception {\n+\n+        try {\n+            if (OAuth2ServiceComponentHolder.getInstance().getIdpManager() != null) {\n+                return OAuth2ServiceComponentHolder.getInstance().getIdpManager().getIdPByName(identityProviderName,\n+                        tenantDomain);\n+            } else {\n+                String errorMsg = String.format(\"Unable to retrieve Idp manager. Error while \" +\n+                        \"getting '%s' Identity  Provider of '%s' tenant.\", identityProviderName, tenantDomain);\n+                throw new IdentityOAuth2Exception(errorMsg);\n+            }\n+        } catch (IdentityProviderManagementException e) {\n+            String errorMsg =\n+                    String.format(\"Error while getting '%s' Identity Provider of '%s' tenant.\", identityProviderName,\n+                            tenantDomain);\n+            throw new IdentityOAuth2Exception(errorMsg, e);\n+        }\n+    }\n+\n+    /**\n+     * Get Internal/everyone role for corresponding user using realm configuration.\n+     *\n+     * @param user Authenticated user\n+     * @return Internal/everyone role\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    public static String getInternalEveryoneRole(AuthenticatedUser user) throws IdentityOAuth2Exception {\n+\n+        try {\n+            RealmConfiguration realmConfiguration = null;\n+            RealmService realmService = OAuthComponentServiceHolder.getInstance().getRealmService();\n+            int tenantId = getTenantId(user.getTenantDomain());\n+            if (realmService != null && tenantId != org.wso2.carbon.base.MultitenantConstants.INVALID_TENANT_ID) {\n+                UserStoreManager userStoreManager = null;\n+                userStoreManager = (UserStoreManager) realmService.getTenantUserRealm(tenantId).getUserStoreManager();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxMjgxNA=="}, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDE1ODE0OnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzo0MjozNFrOIAnTMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzo0MjozNFrOIAnTMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxNDgwMA==", "bodyText": "Do we really need an 'else' block here?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537514800", "createdAt": "2020-12-07T13:42:34Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDE3NjI4OnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzo0NjozNlrOIAndrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzo0NjozNlrOIAndrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxNzQ4Ng==", "bodyText": "We can do without the 'else' nesting here since we return in the 'if' block.", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537517486", "createdAt": "2020-12-07T13:46:36Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDE5MzEwOnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzo1MDoxMFrOIAnnNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMjo1OToyMVrOIBErwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxOTkyNA==", "bodyText": "Can't we use forEach() here?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537519924", "createdAt": "2020-12-07T13:50:10Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    /**\n+     * Method user to get list of federated users permissions using idp role mapping for not account associated\n+     * federated users.\n+     * @param authenticatedUser    FederatedAuthenticatedUser\n+     * @param authorizationManager AuthorizationManager\n+     * @return List of permissions\n+     * @throws UserStoreException      UserStoreException\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    private String[] getAllowedUIResourcesForNotAssociatedFederatedUser(AuthenticatedUser authenticatedUser,\n+                                                                        AuthorizationManager authorizationManager)\n+            throws UserStoreException, IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        List<String> allowedUIResourcesListForUser = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(authenticatedUser.getFederatedIdPName(),\n+                        authenticatedUser.getTenantDomain());\n+        /*\n+        Values of Groups consists mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking role mapped local roles and values of groups we can filter valid local roles which mapped\n+        to a federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(authenticatedUser.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk5NjIyNQ==", "bodyText": "forEach method works with Java lists, here we are looping object arrays. IMO, it's optimized. please correct me if I am wrong.", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537996225", "createdAt": "2020-12-08T02:59:21Z", "author": {"login": "Thumimku"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    /**\n+     * Method user to get list of federated users permissions using idp role mapping for not account associated\n+     * federated users.\n+     * @param authenticatedUser    FederatedAuthenticatedUser\n+     * @param authorizationManager AuthorizationManager\n+     * @return List of permissions\n+     * @throws UserStoreException      UserStoreException\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    private String[] getAllowedUIResourcesForNotAssociatedFederatedUser(AuthenticatedUser authenticatedUser,\n+                                                                        AuthorizationManager authorizationManager)\n+            throws UserStoreException, IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        List<String> allowedUIResourcesListForUser = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(authenticatedUser.getFederatedIdPName(),\n+                        authenticatedUser.getTenantDomain());\n+        /*\n+        Values of Groups consists mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking role mapped local roles and values of groups we can filter valid local roles which mapped\n+        to a federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(authenticatedUser.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUxOTkyNA=="}, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDIwNzU0OnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzo1MzoxMlrOIAnvjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzo1MzoxMlrOIAnvjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyMjA2MQ==", "bodyText": "Can we guarantee the getRemoteClaim() would not return null?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537522061", "createdAt": "2020-12-07T13:53:12Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    /**\n+     * Method user to get list of federated users permissions using idp role mapping for not account associated\n+     * federated users.\n+     * @param authenticatedUser    FederatedAuthenticatedUser\n+     * @param authorizationManager AuthorizationManager\n+     * @return List of permissions\n+     * @throws UserStoreException      UserStoreException\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    private String[] getAllowedUIResourcesForNotAssociatedFederatedUser(AuthenticatedUser authenticatedUser,\n+                                                                        AuthorizationManager authorizationManager)\n+            throws UserStoreException, IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        List<String> allowedUIResourcesListForUser = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(authenticatedUser.getFederatedIdPName(),\n+                        authenticatedUser.getTenantDomain());\n+        /*\n+        Values of Groups consists mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking role mapped local roles and values of groups we can filter valid local roles which mapped\n+        to a federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(authenticatedUser.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {\n+                if (roleMapping != null && roleMapping.getLocalRole() != null) {\n+                    if (valuesOfGroups.contains(roleMapping.getLocalRole().getLocalRoleName())) {\n+                        userRolesList.add(roleMapping.getLocalRole().getLocalRoleName());\n+                    }\n+                }\n+            }\n+        }\n+        // Loop through each local role and get permissions.\n+        for (String userRole : userRolesList) {\n+            for (String allowedUIResource : authorizationManager.getAllowedUIResourcesForRole(userRole, \"/\")) {\n+                if (!allowedUIResourcesListForUser.contains(allowedUIResource)) {\n+                    allowedUIResourcesListForUser.add(allowedUIResource);\n+                }\n+            }\n+        }\n+        // Add everyone permission to allowed permission.\n+        allowedUIResourcesListForUser.add(EVERYONE_PERMISSION);\n+\n+        return allowedUIResourcesListForUser.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Get groups params Roles from User attributes.\n+     *\n+     * @param userAttributes User Attributes\n+     * @return User attribute map\n+     */\n+    private List<String> getValuesOfGroupsFromUserAttributes(Map<ClaimMapping, String> userAttributes) {\n+\n+        if (isNotEmpty(userAttributes)) {\n+            for (Map.Entry<ClaimMapping, String> entry : userAttributes.entrySet()) {\n+                if (StringUtils.equals(entry.getKey().getRemoteClaim().getClaimUri(), OAuth2Constants.GROUPS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDIwODY0OnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzo1MzozMVrOIAnwVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzo1MzozMVrOIAnwVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyMjI2MA==", "bodyText": "Unnecessary new line", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537522260", "createdAt": "2020-12-07T13:53:31Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    /**\n+     * Method user to get list of federated users permissions using idp role mapping for not account associated\n+     * federated users.\n+     * @param authenticatedUser    FederatedAuthenticatedUser\n+     * @param authorizationManager AuthorizationManager\n+     * @return List of permissions\n+     * @throws UserStoreException      UserStoreException\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    private String[] getAllowedUIResourcesForNotAssociatedFederatedUser(AuthenticatedUser authenticatedUser,\n+                                                                        AuthorizationManager authorizationManager)\n+            throws UserStoreException, IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        List<String> allowedUIResourcesListForUser = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(authenticatedUser.getFederatedIdPName(),\n+                        authenticatedUser.getTenantDomain());\n+        /*\n+        Values of Groups consists mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking role mapped local roles and values of groups we can filter valid local roles which mapped\n+        to a federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(authenticatedUser.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {\n+                if (roleMapping != null && roleMapping.getLocalRole() != null) {\n+                    if (valuesOfGroups.contains(roleMapping.getLocalRole().getLocalRoleName())) {\n+                        userRolesList.add(roleMapping.getLocalRole().getLocalRoleName());\n+                    }\n+                }\n+            }\n+        }\n+        // Loop through each local role and get permissions.\n+        for (String userRole : userRolesList) {\n+            for (String allowedUIResource : authorizationManager.getAllowedUIResourcesForRole(userRole, \"/\")) {\n+                if (!allowedUIResourcesListForUser.contains(allowedUIResource)) {\n+                    allowedUIResourcesListForUser.add(allowedUIResource);\n+                }\n+            }\n+        }\n+        // Add everyone permission to allowed permission.\n+        allowedUIResourcesListForUser.add(EVERYONE_PERMISSION);\n+\n+        return allowedUIResourcesListForUser.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Get groups params Roles from User attributes.\n+     *\n+     * @param userAttributes User Attributes\n+     * @return User attribute map\n+     */\n+    private List<String> getValuesOfGroupsFromUserAttributes(Map<ClaimMapping, String> userAttributes) {\n+\n+        if (isNotEmpty(userAttributes)) {\n+            for (Map.Entry<ClaimMapping, String> entry : userAttributes.entrySet()) {\n+                if (StringUtils.equals(entry.getKey().getRemoteClaim().getClaimUri(), OAuth2Constants.GROUPS)) {\n+                    return Arrays.asList(entry.getValue().split(Pattern.quote(ATTRIBUTE_SEPARATOR)));\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDIyNTA0OnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxMzo1Njo1OFrOIAn6Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMTo1MjoyNlrOIBDJzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNDc0Mw==", "bodyText": "Wouldn't this make the L285 unreachable?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537524743", "createdAt": "2020-12-07T13:56:58Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {\n+                if (!isScopeValid(scope, tenantId)) {\n+                    // If the scope is not registered return false.\n+                    log.error(\"Requested scope \" + scope + \" is invalid\");\n+                    return false;\n+                }\n+                if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"User \" + user.getUserName() + \"in not authorised for scope \" + scope);\n+                    }\n+                    return false;\n+                }\n             }\n+        } else {\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNjkwMQ==", "bodyText": "does the 'else' nesting serve any value?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537526901", "createdAt": "2020-12-07T13:59:54Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {\n+                if (!isScopeValid(scope, tenantId)) {\n+                    // If the scope is not registered return false.\n+                    log.error(\"Requested scope \" + scope + \" is invalid\");\n+                    return false;\n+                }\n+                if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"User \" + user.getUserName() + \"in not authorised for scope \" + scope);\n+                    }\n+                    return false;\n+                }\n             }\n+        } else {\n+            return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNDc0Mw=="}, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3MTE0OA==", "bodyText": "L282 - if user roles remain empty for any user method returns false.\nL285 - Yes reachable, we remove all negative case and in L285 we return valid cases.", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537971148", "createdAt": "2020-12-08T01:52:26Z", "author": {"login": "Thumimku"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {\n+                if (!isScopeValid(scope, tenantId)) {\n+                    // If the scope is not registered return false.\n+                    log.error(\"Requested scope \" + scope + \" is invalid\");\n+                    return false;\n+                }\n+                if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"User \" + user.getUserName() + \"in not authorised for scope \" + scope);\n+                    }\n+                    return false;\n+                }\n             }\n+        } else {\n+            return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNDc0Mw=="}, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDI0NDc0OnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDowMDo1OVrOIAoFXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDowMDo1OVrOIAoFXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNzY0NA==", "bodyText": "Can't we do without the 'else' nesting?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537527644", "createdAt": "2020-12-07T14:00:59Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {\n+                if (!isScopeValid(scope, tenantId)) {\n+                    // If the scope is not registered return false.\n+                    log.error(\"Requested scope \" + scope + \" is invalid\");\n+                    return false;\n+                }\n+                if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"User \" + user.getUserName() + \"in not authorised for scope \" + scope);\n+                    }\n+                    return false;\n+                }\n             }\n+        } else {\n+            return false;\n         }\n         return true;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDI0NTUxOnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDowMTowOFrOIAoFyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDowMTowOFrOIAoFyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUyNzc1NQ==", "bodyText": "Can't we do without the 'else' nesting?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537527755", "createdAt": "2020-12-07T14:01:08Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {\n+                if (!isScopeValid(scope, tenantId)) {\n+                    // If the scope is not registered return false.\n+                    log.error(\"Requested scope \" + scope + \" is invalid\");\n+                    return false;\n+                }\n+                if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"User \" + user.getUserName() + \"in not authorised for scope \" + scope);\n+                    }\n+                    return false;\n+                }\n             }\n+        } else {\n+            return false;\n         }\n         return true;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDI2MTA4OnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDowNDoxNVrOIAoOpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMjo1OTozMlrOIBEsEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUzMDAyMA==", "bodyText": "Can't we use forEach() instead?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537530020", "createdAt": "2020-12-07T14:04:15Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk5NjMwNA==", "bodyText": "forEach method works with Java lists, here we are looping object arrays. IMO, it's optimized. please correct me if I am wrong.", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537996304", "createdAt": "2020-12-08T02:59:32Z", "author": {"login": "Thumimku"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUzMDAyMA=="}, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDI3MzgxOnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDowNjozOVrOIAoV6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDowNjozOVrOIAoV6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUzMTg4Mg==", "bodyText": "Shall we use the full qualified method here instead of importing MapUtils.isNotEmpty()?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537531882", "createdAt": "2020-12-07T14:06:39Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCPermissionBasedInternalScopeValidator.java", "diffHunk": "@@ -192,6 +233,90 @@\n         return userAllowedScopes;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    /**\n+     * Method user to get list of federated users permissions using idp role mapping for not account associated\n+     * federated users.\n+     * @param authenticatedUser    FederatedAuthenticatedUser\n+     * @param authorizationManager AuthorizationManager\n+     * @return List of permissions\n+     * @throws UserStoreException      UserStoreException\n+     * @throws IdentityOAuth2Exception IdentityOAuth2Exception\n+     */\n+    private String[] getAllowedUIResourcesForNotAssociatedFederatedUser(AuthenticatedUser authenticatedUser,\n+                                                                        AuthorizationManager authorizationManager)\n+            throws UserStoreException, IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        List<String> allowedUIResourcesListForUser = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(authenticatedUser.getFederatedIdPName(),\n+                        authenticatedUser.getTenantDomain());\n+        /*\n+        Values of Groups consists mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking role mapped local roles and values of groups we can filter valid local roles which mapped\n+        to a federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(authenticatedUser.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {\n+                if (roleMapping != null && roleMapping.getLocalRole() != null) {\n+                    if (valuesOfGroups.contains(roleMapping.getLocalRole().getLocalRoleName())) {\n+                        userRolesList.add(roleMapping.getLocalRole().getLocalRoleName());\n+                    }\n+                }\n+            }\n+        }\n+        // Loop through each local role and get permissions.\n+        for (String userRole : userRolesList) {\n+            for (String allowedUIResource : authorizationManager.getAllowedUIResourcesForRole(userRole, \"/\")) {\n+                if (!allowedUIResourcesListForUser.contains(allowedUIResource)) {\n+                    allowedUIResourcesListForUser.add(allowedUIResource);\n+                }\n+            }\n+        }\n+        // Add everyone permission to allowed permission.\n+        allowedUIResourcesListForUser.add(EVERYONE_PERMISSION);\n+\n+        return allowedUIResourcesListForUser.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Get groups params Roles from User attributes.\n+     *\n+     * @param userAttributes User Attributes\n+     * @return User attribute map\n+     */\n+    private List<String> getValuesOfGroupsFromUserAttributes(Map<ClaimMapping, String> userAttributes) {\n+\n+        if (isNotEmpty(userAttributes)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NDI4NjEwOnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNDowODo0N1rOIAodlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMTo1NjowNVrOIBDQyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUzMzg0Ng==", "bodyText": "Shall we extract this out as a separate method since the same logic is used at L311?", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537533846", "createdAt": "2020-12-07T14:08:47Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {\n+                if (!isScopeValid(scope, tenantId)) {\n+                    // If the scope is not registered return false.\n+                    log.error(\"Requested scope \" + scope + \" is invalid\");\n+                    return false;\n+                }\n+                if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"User \" + user.getUserName() + \"in not authorised for scope \" + scope);\n+                    }\n+                    return false;\n+                }\n             }\n+        } else {\n+            return false;\n         }\n         return true;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    private String[] getUserRolesForNotAssociatedFederatedUser(AuthenticatedUser user)\n+            throws IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(user.getFederatedIdPName(), user.getTenantDomain());\n+        /*\n+        Values of Groups consists unmapped federated roles, mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking federated role mapped local roles and values of groups we can filter valid local roles which\n+        mapped to the federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(user.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {\n+                if (roleMapping != null && roleMapping.getLocalRole() != null) {\n+                    if (valuesOfGroups.contains(roleMapping.getLocalRole().getLocalRoleName())) {\n+                        userRolesList.add(roleMapping.getLocalRole().getLocalRoleName());\n+                    }\n+                }\n+            }\n+        }\n+        // By default we provide Internal/everyone role for all users.\n+        String internalEveryoneRole = OAuth2Util.getInternalEveryoneRole(user);\n+        if (StringUtils.isNotBlank(internalEveryoneRole)) {\n+            userRolesList.add(internalEveryoneRole);\n+        }\n+        return userRolesList.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Get groups params Roles from User attributes.\n+     *\n+     * @param userAttributes User Attributes\n+     * @return User attribute map\n+     */\n+    private List<String> getValuesOfGroupsFromUserAttributes(Map<ClaimMapping, String> userAttributes) {\n+\n+        if (MapUtils.isNotEmpty(userAttributes)) {\n+            for (Map.Entry<ClaimMapping, String> entry : userAttributes.entrySet()) {\n+                if (StringUtils.equals(entry.getKey().getRemoteClaim().getClaimUri(), OAuth2Constants.GROUPS)) {\n+                    return Arrays.asList(entry.getValue().split(Pattern.quote(ATTRIBUTE_SEPARATOR)));\n+                }\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3MjkzNg==", "bodyText": "It's a separate private method, and L311 serves different logic. Please correct me if I am wrong.", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r537972936", "createdAt": "2020-12-08T01:56:05Z", "author": {"login": "Thumimku"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -224,22 +239,117 @@ private boolean validateScope(String[] requestedScopes, AuthenticatedUser user)\n             return true;\n         }\n \n+        String[] userRoles = null;\n         int tenantId = getTenantId(user);\n-        String[] userRoles = getUserRoles(user);\n \n-        for (String scope : requestedScopes) {\n-            if (!isScopeValid(scope, tenantId)) {\n-                //If the scope is not registered return false\n-                log.error(\"Requested scope \" + scope + \" is invalid\");\n-                return false;\n+        /*\n+        Here we handle scope validation for federated user and local user separately.\n+        For local users - user store is used to get user roles.\n+        For federated user - get user roles from user attributes.\n+        Note that if there is association between a federated user and local user () 'Assert identity using mapped local\n+        subject identifier' flag will be set as true. So authenticated user will be associated local user not\n+        federated user.\n+         */\n+        if (user.isFederatedUser()) {\n+            /*\n+            There is a flow where 'Assert identity using mapped local subject identifier' flag enabled but the\n+            federated user doesn't have any association in localIDP, to handle this case we check for 'Assert\n+            identity using mapped local subject identifier' flag and get roles from userStore.\n+             */\n+            if (isSPAlwaysSendMappedLocalSubjectId(clientId)) {\n+                userRoles = getUserRoles(user);\n+            } else {\n+                // Handle not account associated federated users.\n+                userRoles = getUserRolesForNotAssociatedFederatedUser(user);\n             }\n-            if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n-                return false;\n+        } else {\n+            userRoles = getUserRoles(user);\n+        }\n+        if (ArrayUtils.isNotEmpty(userRoles)) {\n+            for (String scope : requestedScopes) {\n+                if (!isScopeValid(scope, tenantId)) {\n+                    // If the scope is not registered return false.\n+                    log.error(\"Requested scope \" + scope + \" is invalid\");\n+                    return false;\n+                }\n+                if (!isUserAuthorizedForScope(scope, userRoles, tenantId)) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"User \" + user.getUserName() + \"in not authorised for scope \" + scope);\n+                    }\n+                    return false;\n+                }\n             }\n+        } else {\n+            return false;\n         }\n         return true;\n     }\n \n+    private boolean isSPAlwaysSendMappedLocalSubjectId(String clientId) throws IdentityOAuth2Exception {\n+\n+        ServiceProvider serviceProvider = OAuth2Util.getServiceProvider(clientId);\n+        if (serviceProvider != null) {\n+            ClaimConfig claimConfig = serviceProvider.getClaimConfig();\n+            if (claimConfig != null) {\n+                return claimConfig.isAlwaysSendMappedLocalSubjectId();\n+            } else {\n+                throw new IdentityOAuth2Exception(\"Unable to find claim configuration for service provider of client \" +\n+                        \"id \" + clientId);\n+            }\n+        } else {\n+            throw new IdentityOAuth2Exception(\"Unable to find service provider for client id \" + clientId);\n+        }\n+    }\n+\n+    private String[] getUserRolesForNotAssociatedFederatedUser(AuthenticatedUser user)\n+            throws IdentityOAuth2Exception {\n+\n+        List<String> userRolesList = new ArrayList<>();\n+        IdentityProvider identityProvider =\n+                OAuth2Util.getIdentityProvider(user.getFederatedIdPName(), user.getTenantDomain());\n+        /*\n+        Values of Groups consists unmapped federated roles, mapped local roles and Internal/everyone corresponding to\n+        authenticated user.\n+        Role mapping consists mapped federated roles with local roles corresponding to IDP.\n+        By cross checking federated role mapped local roles and values of groups we can filter valid local roles which\n+        mapped to the federated role of authenticated user.\n+         */\n+        List<String> valuesOfGroups = getValuesOfGroupsFromUserAttributes(user.getUserAttributes());\n+        if (CollectionUtils.isNotEmpty(valuesOfGroups)) {\n+            for (RoleMapping roleMapping : identityProvider.getPermissionAndRoleConfig().getRoleMappings()) {\n+                if (roleMapping != null && roleMapping.getLocalRole() != null) {\n+                    if (valuesOfGroups.contains(roleMapping.getLocalRole().getLocalRoleName())) {\n+                        userRolesList.add(roleMapping.getLocalRole().getLocalRoleName());\n+                    }\n+                }\n+            }\n+        }\n+        // By default we provide Internal/everyone role for all users.\n+        String internalEveryoneRole = OAuth2Util.getInternalEveryoneRole(user);\n+        if (StringUtils.isNotBlank(internalEveryoneRole)) {\n+            userRolesList.add(internalEveryoneRole);\n+        }\n+        return userRolesList.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Get groups params Roles from User attributes.\n+     *\n+     * @param userAttributes User Attributes\n+     * @return User attribute map\n+     */\n+    private List<String> getValuesOfGroupsFromUserAttributes(Map<ClaimMapping, String> userAttributes) {\n+\n+        if (MapUtils.isNotEmpty(userAttributes)) {\n+            for (Map.Entry<ClaimMapping, String> entry : userAttributes.entrySet()) {\n+                if (StringUtils.equals(entry.getKey().getRemoteClaim().getClaimUri(), OAuth2Constants.GROUPS)) {\n+                    return Arrays.asList(entry.getValue().split(Pattern.quote(ATTRIBUTE_SEPARATOR)));\n+                }\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzUzMzg0Ng=="}, "originalCommit": {"oid": "94424f60a3188f7b58ae391f7eccc9a5aaf6b739"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NzYwMDA3OnYy", "diffSide": "RIGHT", "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNDoxMDoxMFrOIBGH3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNDoxMDoxMFrOIBGH3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAxOTgwNA==", "bodyText": "formatting issue", "url": "https://github.com/wso2-extensions/identity-inbound-auth-oauth/pull/1511#discussion_r538019804", "createdAt": "2020-12-08T04:10:10Z", "author": {"login": "chamathns"}, "path": "components/org.wso2.carbon.identity.oauth/src/main/java/org/wso2/carbon/identity/oauth2/validators/JDBCScopeValidator.java", "diffHunk": "@@ -181,27 +194,29 @@ public boolean validateScope(AccessTokenDO accessTokenDO, String resource) throw\n     public boolean validateScope(OAuthTokenReqMessageContext tokReqMsgCtx) throws\n             UserStoreException, IdentityOAuth2Exception {\n \n-        return validateScope(tokReqMsgCtx.getScope(), tokReqMsgCtx.getAuthorizedUser());\n-    }\n+        return validateScope(tokReqMsgCtx.getScope(), tokReqMsgCtx.getAuthorizedUser(),\n+                tokReqMsgCtx.getOauth2AccessTokenReqDTO().getClientId());    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32f3f5b0e256bbc515085fd7503c1fde237a9300"}, "originalPosition": 64}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3550, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}