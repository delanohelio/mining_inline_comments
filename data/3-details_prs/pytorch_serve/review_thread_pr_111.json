{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxNTY2MTg1", "number": 111, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzo1OToxOVrODp9w_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDozMjoyNFrODtRxQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzMwMTczOnYy", "diffSide": "RIGHT", "path": "docs/snapshot.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzo1OToxOVrOF5d_AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzo1OToxOVrOF5d_AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNDQxNw==", "bodyText": "@fbbradheintz @chauhang  Please review this.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395804417", "createdAt": "2020-03-20T17:59:19Z", "author": {"login": "mycpuorg"}, "path": "docs/snapshot.md", "diffHunk": "@@ -0,0 +1,32 @@\n+# TorchServe model snapshot\n+\n+TorchServe preserves server runtime configuration across sessions such that a TorchServe instance experiencing either a planned or unplanned service stop can restore its state upon restart.\n+ \n+A TorchServe's snapshot consists of following:\n+\n+ - Server configuration, which comprises: Which models are running, which versions of those models, and how many workers are active for each model.\n+ - Default server configuration used while starting TorchServe the first time.\n+ \n+The snapshot is taken at following instances -", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzMwODgwOnYy", "diffSide": "RIGHT", "path": "docs/snapshot.md", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODowMToyNlrOF5eDrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMTo0MzoxMVrOF6ZNHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNTYxMw==", "bodyText": "define \"last snapshot\" is this same as latesttimestamp-snapshot.cfg? Why not latesttimestamp-shutdown.cfg?", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395805613", "createdAt": "2020-03-20T18:01:26Z", "author": {"login": "mycpuorg"}, "path": "docs/snapshot.md", "diffHunk": "@@ -0,0 +1,32 @@\n+# TorchServe model snapshot\n+\n+TorchServe preserves server runtime configuration across sessions such that a TorchServe instance experiencing either a planned or unplanned service stop can restore its state upon restart.\n+ \n+A TorchServe's snapshot consists of following:\n+\n+ - Server configuration, which comprises: Which models are running, which versions of those models, and how many workers are active for each model.\n+ - Default server configuration used while starting TorchServe the first time.\n+ \n+The snapshot is taken at following instances -\n+\n+ - After successful startup, the server stores its current configuration in a timestamped snapshot file ./logs/configs/<YYYYMMDDHHmmSS>-startup.cfg\n+\n+ - If a user calls the Management API in a way that changes the server runtime config, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-snapshot.cfg\n+\n+ - When the server is shut down intentionally with `torchserve --stop`, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-shutdown.cfg\n+\n+User can use snapshots to restore the TorchServe's state as follows :\n+\n+ - If no config file is supplied with `--ts-config-file` flag while starting TorchServe, last snapshot in ./logs/configs is used for startup.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NTgzMQ==", "bodyText": "latesttimestamp-shutdown.cfg will be generated in case of a proper shutdown using torchserve --stop only. In case of server crash or any such event the file will not be generated. Thus, torchserve will always use the latest available snapshot.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395995831", "createdAt": "2020-03-21T14:11:40Z", "author": {"login": "harshbafna"}, "path": "docs/snapshot.md", "diffHunk": "@@ -0,0 +1,32 @@\n+# TorchServe model snapshot\n+\n+TorchServe preserves server runtime configuration across sessions such that a TorchServe instance experiencing either a planned or unplanned service stop can restore its state upon restart.\n+ \n+A TorchServe's snapshot consists of following:\n+\n+ - Server configuration, which comprises: Which models are running, which versions of those models, and how many workers are active for each model.\n+ - Default server configuration used while starting TorchServe the first time.\n+ \n+The snapshot is taken at following instances -\n+\n+ - After successful startup, the server stores its current configuration in a timestamped snapshot file ./logs/configs/<YYYYMMDDHHmmSS>-startup.cfg\n+\n+ - If a user calls the Management API in a way that changes the server runtime config, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-snapshot.cfg\n+\n+ - When the server is shut down intentionally with `torchserve --stop`, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-shutdown.cfg\n+\n+User can use snapshots to restore the TorchServe's state as follows :\n+\n+ - If no config file is supplied with `--ts-config-file` flag while starting TorchServe, last snapshot in ./logs/configs is used for startup.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNTYxMw=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxNzA0OA==", "bodyText": "OK so we are using the filesystem generated timestamp for deciding the last snapshot. This implies that any config changes that might have occurred between last snapshot and last shutdown will be taken care of since the files will be written through.\nThe obvious question is what if the filesystem is remote? The sequential consistency may not be always guaranteed by such services (ex: S3 or third party HDFS) In these cases, we need to ensure the serialization of the requests happen through implementation.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396617048", "createdAt": "2020-03-23T17:13:58Z", "author": {"login": "mycpuorg"}, "path": "docs/snapshot.md", "diffHunk": "@@ -0,0 +1,32 @@\n+# TorchServe model snapshot\n+\n+TorchServe preserves server runtime configuration across sessions such that a TorchServe instance experiencing either a planned or unplanned service stop can restore its state upon restart.\n+ \n+A TorchServe's snapshot consists of following:\n+\n+ - Server configuration, which comprises: Which models are running, which versions of those models, and how many workers are active for each model.\n+ - Default server configuration used while starting TorchServe the first time.\n+ \n+The snapshot is taken at following instances -\n+\n+ - After successful startup, the server stores its current configuration in a timestamped snapshot file ./logs/configs/<YYYYMMDDHHmmSS>-startup.cfg\n+\n+ - If a user calls the Management API in a way that changes the server runtime config, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-snapshot.cfg\n+\n+ - When the server is shut down intentionally with `torchserve --stop`, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-shutdown.cfg\n+\n+User can use snapshots to restore the TorchServe's state as follows :\n+\n+ - If no config file is supplied with `--ts-config-file` flag while starting TorchServe, last snapshot in ./logs/configs is used for startup.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNTYxMw=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc2NzE3NA==", "bodyText": "I've started an issue to discuss improvements for the next revision. Please see issue #119.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396767174", "createdAt": "2020-03-23T21:27:18Z", "author": {"login": "fbbradheintz"}, "path": "docs/snapshot.md", "diffHunk": "@@ -0,0 +1,32 @@\n+# TorchServe model snapshot\n+\n+TorchServe preserves server runtime configuration across sessions such that a TorchServe instance experiencing either a planned or unplanned service stop can restore its state upon restart.\n+ \n+A TorchServe's snapshot consists of following:\n+\n+ - Server configuration, which comprises: Which models are running, which versions of those models, and how many workers are active for each model.\n+ - Default server configuration used while starting TorchServe the first time.\n+ \n+The snapshot is taken at following instances -\n+\n+ - After successful startup, the server stores its current configuration in a timestamped snapshot file ./logs/configs/<YYYYMMDDHHmmSS>-startup.cfg\n+\n+ - If a user calls the Management API in a way that changes the server runtime config, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-snapshot.cfg\n+\n+ - When the server is shut down intentionally with `torchserve --stop`, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-shutdown.cfg\n+\n+User can use snapshots to restore the TorchServe's state as follows :\n+\n+ - If no config file is supplied with `--ts-config-file` flag while starting TorchServe, last snapshot in ./logs/configs is used for startup.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNTYxMw=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3NDY4Nw==", "bodyText": "This is okay for the time being. We have #119 to track discussion of enhancements after release.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396774687", "createdAt": "2020-03-23T21:43:11Z", "author": {"login": "fbbradheintz"}, "path": "docs/snapshot.md", "diffHunk": "@@ -0,0 +1,32 @@\n+# TorchServe model snapshot\n+\n+TorchServe preserves server runtime configuration across sessions such that a TorchServe instance experiencing either a planned or unplanned service stop can restore its state upon restart.\n+ \n+A TorchServe's snapshot consists of following:\n+\n+ - Server configuration, which comprises: Which models are running, which versions of those models, and how many workers are active for each model.\n+ - Default server configuration used while starting TorchServe the first time.\n+ \n+The snapshot is taken at following instances -\n+\n+ - After successful startup, the server stores its current configuration in a timestamped snapshot file ./logs/configs/<YYYYMMDDHHmmSS>-startup.cfg\n+\n+ - If a user calls the Management API in a way that changes the server runtime config, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-snapshot.cfg\n+\n+ - When the server is shut down intentionally with `torchserve --stop`, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-shutdown.cfg\n+\n+User can use snapshots to restore the TorchServe's state as follows :\n+\n+ - If no config file is supplied with `--ts-config-file` flag while starting TorchServe, last snapshot in ./logs/configs is used for startup.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNTYxMw=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzMxNDE4OnYy", "diffSide": "RIGHT", "path": "docs/snapshot.md", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODowMzowNFrOF5eHKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMTozNDoxOVrOF6Y8_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNjUwNg==", "bodyText": "I expect the user to mostly start with just this torchserve --start --model-store <model store> what happens then?\nWhat's to prevent a blowup of snapshots and configuration files? Do we simply archive them periodically?", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395806506", "createdAt": "2020-03-20T18:03:04Z", "author": {"login": "mycpuorg"}, "path": "docs/snapshot.md", "diffHunk": "@@ -0,0 +1,32 @@\n+# TorchServe model snapshot\n+\n+TorchServe preserves server runtime configuration across sessions such that a TorchServe instance experiencing either a planned or unplanned service stop can restore its state upon restart.\n+ \n+A TorchServe's snapshot consists of following:\n+\n+ - Server configuration, which comprises: Which models are running, which versions of those models, and how many workers are active for each model.\n+ - Default server configuration used while starting TorchServe the first time.\n+ \n+The snapshot is taken at following instances -\n+\n+ - After successful startup, the server stores its current configuration in a timestamped snapshot file ./logs/configs/<YYYYMMDDHHmmSS>-startup.cfg\n+\n+ - If a user calls the Management API in a way that changes the server runtime config, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-snapshot.cfg\n+\n+ - When the server is shut down intentionally with `torchserve --stop`, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-shutdown.cfg\n+\n+User can use snapshots to restore the TorchServe's state as follows :\n+\n+ - If no config file is supplied with `--ts-config-file` flag while starting TorchServe, last snapshot in ./logs/configs is used for startup.\n+ - If no config file is supplied with `--ts-config-file` flag and no snapshots are available, TorchServe starts with default configurations.\n+ - The user restarts the server specifying this config file: `torchserve --start --model-store <model store> --ts-config <known good config snapshot>`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NjA1Mw==", "bodyText": "In this case, first TorchServe will check if any snapshot is available, if yes then it will use the server config present in the snapshot in the startup and will register all the models with respective versions and workers based on the information saved in the startup.\nIf no snapshot is available, then torchserve will start with the default configurations and no model will be registered at the start. This is the existing behavior in case no config file is supplied at the startup.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395996053", "createdAt": "2020-03-21T14:14:51Z", "author": {"login": "harshbafna"}, "path": "docs/snapshot.md", "diffHunk": "@@ -0,0 +1,32 @@\n+# TorchServe model snapshot\n+\n+TorchServe preserves server runtime configuration across sessions such that a TorchServe instance experiencing either a planned or unplanned service stop can restore its state upon restart.\n+ \n+A TorchServe's snapshot consists of following:\n+\n+ - Server configuration, which comprises: Which models are running, which versions of those models, and how many workers are active for each model.\n+ - Default server configuration used while starting TorchServe the first time.\n+ \n+The snapshot is taken at following instances -\n+\n+ - After successful startup, the server stores its current configuration in a timestamped snapshot file ./logs/configs/<YYYYMMDDHHmmSS>-startup.cfg\n+\n+ - If a user calls the Management API in a way that changes the server runtime config, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-snapshot.cfg\n+\n+ - When the server is shut down intentionally with `torchserve --stop`, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-shutdown.cfg\n+\n+User can use snapshots to restore the TorchServe's state as follows :\n+\n+ - If no config file is supplied with `--ts-config-file` flag while starting TorchServe, last snapshot in ./logs/configs is used for startup.\n+ - If no config file is supplied with `--ts-config-file` flag and no snapshots are available, TorchServe starts with default configurations.\n+ - The user restarts the server specifying this config file: `torchserve --start --model-store <model store> --ts-config <known good config snapshot>`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNjUwNg=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIxOTExNQ==", "bodyText": "There is no such mechanism present to archive snapshots or cleanup. I think we should clean it up based on some time related config param.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396219115", "createdAt": "2020-03-23T05:24:21Z", "author": {"login": "harshbafna"}, "path": "docs/snapshot.md", "diffHunk": "@@ -0,0 +1,32 @@\n+# TorchServe model snapshot\n+\n+TorchServe preserves server runtime configuration across sessions such that a TorchServe instance experiencing either a planned or unplanned service stop can restore its state upon restart.\n+ \n+A TorchServe's snapshot consists of following:\n+\n+ - Server configuration, which comprises: Which models are running, which versions of those models, and how many workers are active for each model.\n+ - Default server configuration used while starting TorchServe the first time.\n+ \n+The snapshot is taken at following instances -\n+\n+ - After successful startup, the server stores its current configuration in a timestamped snapshot file ./logs/configs/<YYYYMMDDHHmmSS>-startup.cfg\n+\n+ - If a user calls the Management API in a way that changes the server runtime config, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-snapshot.cfg\n+\n+ - When the server is shut down intentionally with `torchserve --stop`, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-shutdown.cfg\n+\n+User can use snapshots to restore the TorchServe's state as follows :\n+\n+ - If no config file is supplied with `--ts-config-file` flag while starting TorchServe, last snapshot in ./logs/configs is used for startup.\n+ - If no config file is supplied with `--ts-config-file` flag and no snapshots are available, TorchServe starts with default configurations.\n+ - The user restarts the server specifying this config file: `torchserve --start --model-store <model store> --ts-config <known good config snapshot>`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNjUwNg=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyMTc3OQ==", "bodyText": "Created the issue: #115 for archiving", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396621779", "createdAt": "2020-03-23T17:20:42Z", "author": {"login": "mycpuorg"}, "path": "docs/snapshot.md", "diffHunk": "@@ -0,0 +1,32 @@\n+# TorchServe model snapshot\n+\n+TorchServe preserves server runtime configuration across sessions such that a TorchServe instance experiencing either a planned or unplanned service stop can restore its state upon restart.\n+ \n+A TorchServe's snapshot consists of following:\n+\n+ - Server configuration, which comprises: Which models are running, which versions of those models, and how many workers are active for each model.\n+ - Default server configuration used while starting TorchServe the first time.\n+ \n+The snapshot is taken at following instances -\n+\n+ - After successful startup, the server stores its current configuration in a timestamped snapshot file ./logs/configs/<YYYYMMDDHHmmSS>-startup.cfg\n+\n+ - If a user calls the Management API in a way that changes the server runtime config, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-snapshot.cfg\n+\n+ - When the server is shut down intentionally with `torchserve --stop`, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-shutdown.cfg\n+\n+User can use snapshots to restore the TorchServe's state as follows :\n+\n+ - If no config file is supplied with `--ts-config-file` flag while starting TorchServe, last snapshot in ./logs/configs is used for startup.\n+ - If no config file is supplied with `--ts-config-file` flag and no snapshots are available, TorchServe starts with default configurations.\n+ - The user restarts the server specifying this config file: `torchserve --start --model-store <model store> --ts-config <known good config snapshot>`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNjUwNg=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc1NzU2NA==", "bodyText": "Commenting on the issue", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396757564", "createdAt": "2020-03-23T21:08:06Z", "author": {"login": "fbbradheintz"}, "path": "docs/snapshot.md", "diffHunk": "@@ -0,0 +1,32 @@\n+# TorchServe model snapshot\n+\n+TorchServe preserves server runtime configuration across sessions such that a TorchServe instance experiencing either a planned or unplanned service stop can restore its state upon restart.\n+ \n+A TorchServe's snapshot consists of following:\n+\n+ - Server configuration, which comprises: Which models are running, which versions of those models, and how many workers are active for each model.\n+ - Default server configuration used while starting TorchServe the first time.\n+ \n+The snapshot is taken at following instances -\n+\n+ - After successful startup, the server stores its current configuration in a timestamped snapshot file ./logs/configs/<YYYYMMDDHHmmSS>-startup.cfg\n+\n+ - If a user calls the Management API in a way that changes the server runtime config, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-snapshot.cfg\n+\n+ - When the server is shut down intentionally with `torchserve --stop`, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-shutdown.cfg\n+\n+User can use snapshots to restore the TorchServe's state as follows :\n+\n+ - If no config file is supplied with `--ts-config-file` flag while starting TorchServe, last snapshot in ./logs/configs is used for startup.\n+ - If no config file is supplied with `--ts-config-file` flag and no snapshots are available, TorchServe starts with default configurations.\n+ - The user restarts the server specifying this config file: `torchserve --start --model-store <model store> --ts-config <known good config snapshot>`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNjUwNg=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MDU1OA==", "bodyText": "This is okay for the initial release, and we have #115 to track discussion of future enhancements.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396770558", "createdAt": "2020-03-23T21:34:19Z", "author": {"login": "fbbradheintz"}, "path": "docs/snapshot.md", "diffHunk": "@@ -0,0 +1,32 @@\n+# TorchServe model snapshot\n+\n+TorchServe preserves server runtime configuration across sessions such that a TorchServe instance experiencing either a planned or unplanned service stop can restore its state upon restart.\n+ \n+A TorchServe's snapshot consists of following:\n+\n+ - Server configuration, which comprises: Which models are running, which versions of those models, and how many workers are active for each model.\n+ - Default server configuration used while starting TorchServe the first time.\n+ \n+The snapshot is taken at following instances -\n+\n+ - After successful startup, the server stores its current configuration in a timestamped snapshot file ./logs/configs/<YYYYMMDDHHmmSS>-startup.cfg\n+\n+ - If a user calls the Management API in a way that changes the server runtime config, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-snapshot.cfg\n+\n+ - When the server is shut down intentionally with `torchserve --stop`, snapshot is saved to ./logs/configs/<YYYYMMDDHHmmSS>-shutdown.cfg\n+\n+User can use snapshots to restore the TorchServe's state as follows :\n+\n+ - If no config file is supplied with `--ts-config-file` flag while starting TorchServe, last snapshot in ./logs/configs is used for startup.\n+ - If no config file is supplied with `--ts-config-file` flag and no snapshots are available, TorchServe starts with default configurations.\n+ - The user restarts the server specifying this config file: `torchserve --start --model-store <model store> --ts-config <known good config snapshot>`", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNjUwNg=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzMxOTA1OnYy", "diffSide": "RIGHT", "path": "frontend/server/src/main/java/org/pytorch/serve/ModelServer.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODowNDozN1rOF5eKeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QyMTo0MjoyN1rOF6ZLeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzM1NA==", "bodyText": "In effect, we are using filesystem to provide mutual exclusion at a coarse locking level for namespace collision? Is that right?", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395807354", "createdAt": "2020-03-20T18:04:37Z", "author": {"login": "mycpuorg"}, "path": "frontend/server/src/main/java/org/pytorch/serve/ModelServer.java", "diffHunk": "@@ -89,6 +89,9 @@ public void startAndWait() throws InterruptedException, IOException, GeneralSecu\n             // Create and schedule metrics manager\n             MetricManager.scheduleMetrics(configManager);\n             System.out.println(\"Model server started.\"); // NOPMD\n+\n+            SnapshotManager.getInstance().saveSnapshot(\"startup\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIxOTk1Ng==", "bodyText": "As per my understanding, the answer is yes. However, it will be great if you could elaborate a bit more on this.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396219956", "createdAt": "2020-03-23T05:28:14Z", "author": {"login": "harshbafna"}, "path": "frontend/server/src/main/java/org/pytorch/serve/ModelServer.java", "diffHunk": "@@ -89,6 +89,9 @@ public void startAndWait() throws InterruptedException, IOException, GeneralSecu\n             // Create and schedule metrics manager\n             MetricManager.scheduleMetrics(configManager);\n             System.out.println(\"Model server started.\"); // NOPMD\n+\n+            SnapshotManager.getInstance().saveSnapshot(\"startup\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzM1NA=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyMjY5NA==", "bodyText": "Basically, we are using the underlying filesystem (local or remote) for mutually excluding the storage/writes of the snapshots.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396622694", "createdAt": "2020-03-23T17:22:05Z", "author": {"login": "mycpuorg"}, "path": "frontend/server/src/main/java/org/pytorch/serve/ModelServer.java", "diffHunk": "@@ -89,6 +89,9 @@ public void startAndWait() throws InterruptedException, IOException, GeneralSecu\n             // Create and schedule metrics manager\n             MetricManager.scheduleMetrics(configManager);\n             System.out.println(\"Model server started.\"); // NOPMD\n+\n+            SnapshotManager.getInstance().saveSnapshot(\"startup\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzM1NA=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc2NTgyOA==", "bodyText": "We should definitely be thinking about how to make this more robust. I have started an issue for discussion: #119", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396765828", "createdAt": "2020-03-23T21:24:27Z", "author": {"login": "fbbradheintz"}, "path": "frontend/server/src/main/java/org/pytorch/serve/ModelServer.java", "diffHunk": "@@ -89,6 +89,9 @@ public void startAndWait() throws InterruptedException, IOException, GeneralSecu\n             // Create and schedule metrics manager\n             MetricManager.scheduleMetrics(configManager);\n             System.out.println(\"Model server started.\"); // NOPMD\n+\n+            SnapshotManager.getInstance().saveSnapshot(\"startup\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzM1NA=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3NDI2Ng==", "bodyText": "This is fine for the current release; we have #119 to track discussion for enhancements after the initial release.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396774266", "createdAt": "2020-03-23T21:42:27Z", "author": {"login": "fbbradheintz"}, "path": "frontend/server/src/main/java/org/pytorch/serve/ModelServer.java", "diffHunk": "@@ -89,6 +89,9 @@ public void startAndWait() throws InterruptedException, IOException, GeneralSecu\n             // Create and schedule metrics manager\n             MetricManager.scheduleMetrics(configManager);\n             System.out.println(\"Model server started.\"); // NOPMD\n+\n+            SnapshotManager.getInstance().saveSnapshot(\"startup\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwNzM1NA=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzMyOTA0OnYy", "diffSide": "RIGHT", "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/ModelInfo.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODowNzo1NVrOF5eRAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQxNzoyNDo1MlrOF9K-CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwOTAyNw==", "bodyText": "How is this different from class Model  seems redundant? If it's redundant, we should remove it. If it's not redundant, then why are moving class ModelInfo under snapshot. Since class Snaphot should, in theory, not be concerned about specifics of the model as per the documentation.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395809027", "createdAt": "2020-03-20T18:07:55Z", "author": {"login": "mycpuorg"}, "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/ModelInfo.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package org.pytorch.serve.snapshot;\n+\n+class ModelInfo {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NjQzMg==", "bodyText": "The existing Model class also consists of ModelArchive reference which in turn has reference to Manifest.\nWe needed a simple representation/data-structutre of all the registered models and their corresponding params like workers, corresponding mar file in model-store, batch size etc., which is used while saving snapshot.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395996432", "createdAt": "2020-03-21T14:18:36Z", "author": {"login": "harshbafna"}, "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/ModelInfo.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package org.pytorch.serve.snapshot;\n+\n+class ModelInfo {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwOTAyNw=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzMDc4NA==", "bodyText": "This results in duplication of members in memory. This implementation is OK for as long as the number of models is low. The moment we start scaling things the larger memory occupant members will also be duplicated. AFAIK, currently we are not using any data members that occupy large amounts of memory in ModelInfo that may not always be the case.\nInstead, if we can use a friend class that can store references to the members of Model in memory that might be efficient. I think we also need to come up with a better name for this class to clarify that this is related to snapshot.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396630784", "createdAt": "2020-03-23T17:33:32Z", "author": {"login": "mycpuorg"}, "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/ModelInfo.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package org.pytorch.serve.snapshot;\n+\n+class ModelInfo {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwOTAyNw=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY4NzE3Nw==", "bodyText": "Created Issue #130\nWe must run benchmark to understand clearly how much impact this change actually has on the memory footprint of the system.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r399687177", "createdAt": "2020-03-28T17:24:52Z", "author": {"login": "mycpuorg"}, "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/ModelInfo.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package org.pytorch.serve.snapshot;\n+\n+class ModelInfo {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgwOTAyNw=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzM0MDQxOnYy", "diffSide": "RIGHT", "path": "frontend/server/src/main/java/org/pytorch/serve/wlm/ModelManager.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODoxMTo0MVrOF5eYeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMDo0MjozMFrOF6qYXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMDkzNw==", "bodyText": "why?", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395810937", "createdAt": "2020-03-20T18:11:41Z", "author": {"login": "mycpuorg"}, "path": "frontend/server/src/main/java/org/pytorch/serve/wlm/ModelManager.java", "diffHunk": "@@ -37,11 +37,13 @@\n     private ConcurrentHashMap<String, ModelVersionedRefs> modelsNameMap;\n     private HashSet<String> startupModels;\n     private ScheduledExecutorService scheduler;\n+    private ConcurrentHashMap<String, String> modelUnregisterProgress;\n \n     private ModelManager(ConfigManager configManager, WorkLoadManager wlm) {\n         this.configManager = configManager;\n         this.wlm = wlm;\n         modelsNameMap = new ConcurrentHashMap<>();\n+        modelUnregisterProgress = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NjUwNw==", "bodyText": "This was ported from Checkpoint APIs implementation and created issue while doing soft-restart of server.\nHowever, this is useful to reject multiple unregister calls for same model-version which could lead to potential NullPointer exceptions.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395996507", "createdAt": "2020-03-21T14:19:58Z", "author": {"login": "harshbafna"}, "path": "frontend/server/src/main/java/org/pytorch/serve/wlm/ModelManager.java", "diffHunk": "@@ -37,11 +37,13 @@\n     private ConcurrentHashMap<String, ModelVersionedRefs> modelsNameMap;\n     private HashSet<String> startupModels;\n     private ScheduledExecutorService scheduler;\n+    private ConcurrentHashMap<String, String> modelUnregisterProgress;\n \n     private ModelManager(ConfigManager configManager, WorkLoadManager wlm) {\n         this.configManager = configManager;\n         this.wlm = wlm;\n         modelsNameMap = new ConcurrentHashMap<>();\n+        modelUnregisterProgress = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMDkzNw=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzMjE1MQ==", "bodyText": "OK I understand, but it might be worth solving those NullPointer exceptions in the first place and then return error codes for duplicate unregister calls instead of storing the map of ongoing unregister requests.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396632151", "createdAt": "2020-03-23T17:35:34Z", "author": {"login": "mycpuorg"}, "path": "frontend/server/src/main/java/org/pytorch/serve/wlm/ModelManager.java", "diffHunk": "@@ -37,11 +37,13 @@\n     private ConcurrentHashMap<String, ModelVersionedRefs> modelsNameMap;\n     private HashSet<String> startupModels;\n     private ScheduledExecutorService scheduler;\n+    private ConcurrentHashMap<String, String> modelUnregisterProgress;\n \n     private ModelManager(ConfigManager configManager, WorkLoadManager wlm) {\n         this.configManager = configManager;\n         this.wlm = wlm;\n         modelsNameMap = new ConcurrentHashMap<>();\n+        modelUnregisterProgress = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMDkzNw=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3NTU5OA==", "bodyText": "Agreed, we should be giving an HTTP 404 rather than an NPE if someone unregisters an unregistered model version.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396775598", "createdAt": "2020-03-23T21:45:16Z", "author": {"login": "fbbradheintz"}, "path": "frontend/server/src/main/java/org/pytorch/serve/wlm/ModelManager.java", "diffHunk": "@@ -37,11 +37,13 @@\n     private ConcurrentHashMap<String, ModelVersionedRefs> modelsNameMap;\n     private HashSet<String> startupModels;\n     private ScheduledExecutorService scheduler;\n+    private ConcurrentHashMap<String, String> modelUnregisterProgress;\n \n     private ModelManager(ConfigManager configManager, WorkLoadManager wlm) {\n         this.configManager = configManager;\n         this.wlm = wlm;\n         modelsNameMap = new ConcurrentHashMap<>();\n+        modelUnregisterProgress = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMDkzNw=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA1NjA5NA==", "bodyText": "Fixed the null pointer scenario.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r397056094", "createdAt": "2020-03-24T10:42:30Z", "author": {"login": "harshbafna"}, "path": "frontend/server/src/main/java/org/pytorch/serve/wlm/ModelManager.java", "diffHunk": "@@ -37,11 +37,13 @@\n     private ConcurrentHashMap<String, ModelVersionedRefs> modelsNameMap;\n     private HashSet<String> startupModels;\n     private ScheduledExecutorService scheduler;\n+    private ConcurrentHashMap<String, String> modelUnregisterProgress;\n \n     private ModelManager(ConfigManager configManager, WorkLoadManager wlm) {\n         this.configManager = configManager;\n         this.wlm = wlm;\n         modelsNameMap = new ConcurrentHashMap<>();\n+        modelUnregisterProgress = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMDkzNw=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzM0NTM5OnYy", "diffSide": "RIGHT", "path": "frontend/server/src/main/java/org/pytorch/serve/wlm/WorkLoadManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODoxMzoyN1rOF5eb3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQxNDoyNjozOFrOF5pvdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMTgwNw==", "bodyText": "What's the case when the model changed and it is a startup? It's not clear.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395811807", "createdAt": "2020-03-20T18:13:27Z", "author": {"login": "mycpuorg"}, "path": "frontend/server/src/main/java/org/pytorch/serve/wlm/WorkLoadManager.java", "diffHunk": "@@ -82,7 +83,7 @@ public int getNumRunningWorkers(ModelVersionName modelVersionName) {\n         return numWorking;\n     }\n \n-    public CompletableFuture<HttpResponseStatus> modelChanged(Model model) {\n+    public CompletableFuture<HttpResponseStatus> modelChanged(Model model, boolean isStartup) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NzA0Ng==", "bodyText": "Model changed is called in two situations : worker scale or unregister.  On startup this will be called in following cases :\n\n\nWhile starting torchserve with init models, all models will be scaled up with default worker configuration.\n\n\nWhile starting torchserve with a snapshot, all model will be scaled up to their previously saved state.\n\n\nDue to this multiple snapshot files gets generated at the time of startup (one per model register-and-scale process). Also, timestamp-startup.cfg will be generated at the startup which contains all this information.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395997046", "createdAt": "2020-03-21T14:26:38Z", "author": {"login": "harshbafna"}, "path": "frontend/server/src/main/java/org/pytorch/serve/wlm/WorkLoadManager.java", "diffHunk": "@@ -82,7 +83,7 @@ public int getNumRunningWorkers(ModelVersionName modelVersionName) {\n         return numWorking;\n     }\n \n-    public CompletableFuture<HttpResponseStatus> modelChanged(Model model) {\n+    public CompletableFuture<HttpResponseStatus> modelChanged(Model model, boolean isStartup) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMTgwNw=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzM0OTM4OnYy", "diffSide": "RIGHT", "path": "frontend/server/src/main/java/org/pytorch/serve/http/ManagementRequestHandler.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODoxNDozOFrOF5eeaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMDo0MzowMVrOF6qZow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMjQ1OQ==", "bodyText": "It's not clear why this string \"snapshot\" is required?", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395812459", "createdAt": "2020-03-20T18:14:38Z", "author": {"login": "mycpuorg"}, "path": "frontend/server/src/main/java/org/pytorch/serve/http/ManagementRequestHandler.java", "diffHunk": "@@ -240,6 +241,7 @@ private void handleRegisterModel(\n         final String msg = \"Model \\\"\" + modelName + \"\\\" registered\";\n         if (initialWorkers <= 0) {\n             NettyUtils.sendJsonResponse(ctx, new StatusResponse(msg));\n+            SnapshotManager.getInstance().saveSnapshot(\"snapshot\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NzM5MQ==", "bodyText": "This is just a flag to know which type of snapshot file is to be created : timestamp-snapshot.cfg , timestamp-startup.cfg, timestamp-shutdown.cfg.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395997391", "createdAt": "2020-03-21T14:31:23Z", "author": {"login": "harshbafna"}, "path": "frontend/server/src/main/java/org/pytorch/serve/http/ManagementRequestHandler.java", "diffHunk": "@@ -240,6 +241,7 @@ private void handleRegisterModel(\n         final String msg = \"Model \\\"\" + modelName + \"\\\" registered\";\n         if (initialWorkers <= 0) {\n             NettyUtils.sendJsonResponse(ctx, new StatusResponse(msg));\n+            SnapshotManager.getInstance().saveSnapshot(\"snapshot\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMjQ1OQ=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzNzQ5NQ==", "bodyText": "so a wrapper around?", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396637495", "createdAt": "2020-03-23T17:43:49Z", "author": {"login": "mycpuorg"}, "path": "frontend/server/src/main/java/org/pytorch/serve/http/ManagementRequestHandler.java", "diffHunk": "@@ -240,6 +241,7 @@ private void handleRegisterModel(\n         final String msg = \"Model \\\"\" + modelName + \"\\\" registered\";\n         if (initialWorkers <= 0) {\n             NettyUtils.sendJsonResponse(ctx, new StatusResponse(msg));\n+            SnapshotManager.getInstance().saveSnapshot(\"snapshot\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMjQ1OQ=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc2NzY2Ng==", "bodyText": "If we're going to use this string in more than one place (and I see it below in line 283), could you please make it a constant?", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396767666", "createdAt": "2020-03-23T21:28:17Z", "author": {"login": "fbbradheintz"}, "path": "frontend/server/src/main/java/org/pytorch/serve/http/ManagementRequestHandler.java", "diffHunk": "@@ -240,6 +241,7 @@ private void handleRegisterModel(\n         final String msg = \"Model \\\"\" + modelName + \"\\\" registered\";\n         if (initialWorkers <= 0) {\n             NettyUtils.sendJsonResponse(ctx, new StatusResponse(msg));\n+            SnapshotManager.getInstance().saveSnapshot(\"snapshot\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMjQ1OQ=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc2OTYzNg==", "bodyText": "And likewise with the other related strings.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396769636", "createdAt": "2020-03-23T21:32:18Z", "author": {"login": "fbbradheintz"}, "path": "frontend/server/src/main/java/org/pytorch/serve/http/ManagementRequestHandler.java", "diffHunk": "@@ -240,6 +241,7 @@ private void handleRegisterModel(\n         final String msg = \"Model \\\"\" + modelName + \"\\\" registered\";\n         if (initialWorkers <= 0) {\n             NettyUtils.sendJsonResponse(ctx, new StatusResponse(msg));\n+            SnapshotManager.getInstance().saveSnapshot(\"snapshot\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMjQ1OQ=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA1NjQxOQ==", "bodyText": "Added wrapper functions in SnapshotManager to take care of this.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r397056419", "createdAt": "2020-03-24T10:43:01Z", "author": {"login": "harshbafna"}, "path": "frontend/server/src/main/java/org/pytorch/serve/http/ManagementRequestHandler.java", "diffHunk": "@@ -240,6 +241,7 @@ private void handleRegisterModel(\n         final String msg = \"Model \\\"\" + modelName + \"\\\" registered\";\n         if (initialWorkers <= 0) {\n             NettyUtils.sendJsonResponse(ctx, new StatusResponse(msg));\n+            SnapshotManager.getInstance().saveSnapshot(\"snapshot\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMjQ1OQ=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzM1NDI5OnYy", "diffSide": "RIGHT", "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/FSSnapshotSerializer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODoxNjowNlrOF5ehaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOFQxNzoxMzozOVrOF9K5cQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMzIyNQ==", "bodyText": "Why not a separate location for configs, they are \"special\" in some sense. They are different from simply log locations.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395813225", "createdAt": "2020-03-20T18:16:06Z", "author": {"login": "mycpuorg"}, "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/FSSnapshotSerializer.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.pytorch.serve.snapshot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Properties;\n+import org.apache.commons.io.FileUtils;\n+import org.pytorch.serve.http.ConflictStatusException;\n+import org.pytorch.serve.util.ConfigManager;\n+\n+public class FSSnapshotSerializer implements SnapshotSerializer {\n+\n+    private ConfigManager configManager = ConfigManager.getInstance();\n+    public static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+\n+    public void saveSnapshot(Snapshot snapshot) throws IOException, ConflictStatusException {\n+        File snapshotPath = new File(System.getProperty(\"LOG_LOCATION\") + \"/config\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NzI5Ng==", "bodyText": "The thought was that, unless required for restoring to an old state, all snapshots are essentially logs dumps of current state of the server. We currently store the snapshots inside config directory in log_location.\nWe will need to introduce a new mandatory startup flag like --snapshot-dir to store it in a separate directory.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395997296", "createdAt": "2020-03-21T14:30:06Z", "author": {"login": "harshbafna"}, "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/FSSnapshotSerializer.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.pytorch.serve.snapshot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Properties;\n+import org.apache.commons.io.FileUtils;\n+import org.pytorch.serve.http.ConflictStatusException;\n+import org.pytorch.serve.util.ConfigManager;\n+\n+public class FSSnapshotSerializer implements SnapshotSerializer {\n+\n+    private ConfigManager configManager = ConfigManager.getInstance();\n+    public static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+\n+    public void saveSnapshot(Snapshot snapshot) throws IOException, ConflictStatusException {\n+        File snapshotPath = new File(System.getProperty(\"LOG_LOCATION\") + \"/config\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMzIyNQ=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTY4NjAwMQ==", "bodyText": "@fbbradheintz  created #120", "url": "https://github.com/pytorch/serve/pull/111#discussion_r399686001", "createdAt": "2020-03-28T17:13:39Z", "author": {"login": "mycpuorg"}, "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/FSSnapshotSerializer.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.pytorch.serve.snapshot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Properties;\n+import org.apache.commons.io.FileUtils;\n+import org.pytorch.serve.http.ConflictStatusException;\n+import org.pytorch.serve.util.ConfigManager;\n+\n+public class FSSnapshotSerializer implements SnapshotSerializer {\n+\n+    private ConfigManager configManager = ConfigManager.getInstance();\n+    public static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+\n+    public void saveSnapshot(Snapshot snapshot) throws IOException, ConflictStatusException {\n+        File snapshotPath = new File(System.getProperty(\"LOG_LOCATION\") + \"/config\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMzIyNQ=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzM1NTk3OnYy", "diffSide": "RIGHT", "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/FSSnapshotSerializer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODoxNjozOVrOF5eiew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMjowNDowMlrOF6CZtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMzQ5OQ==", "bodyText": "Please use global const definitions for property names", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395813499", "createdAt": "2020-03-20T18:16:39Z", "author": {"login": "mycpuorg"}, "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/FSSnapshotSerializer.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.pytorch.serve.snapshot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Properties;\n+import org.apache.commons.io.FileUtils;\n+import org.pytorch.serve.http.ConflictStatusException;\n+import org.pytorch.serve.util.ConfigManager;\n+\n+public class FSSnapshotSerializer implements SnapshotSerializer {\n+\n+    private ConfigManager configManager = ConfigManager.getInstance();\n+    public static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+\n+    public void saveSnapshot(Snapshot snapshot) throws IOException, ConflictStatusException {\n+        File snapshotPath = new File(System.getProperty(\"LOG_LOCATION\") + \"/config\");\n+\n+        FileUtils.forceMkdir(snapshotPath);\n+\n+        Properties prop = configManager.getConfiguration();\n+\n+        File snapshotFile = new File(snapshotPath, snapshot.getName());\n+        if (snapshotFile.exists()) {\n+            throw new ConflictStatusException(\n+                    \"Snapshot \" + snapshot.getName() + \" already exists.\");\n+        }\n+\n+        String snapshotJson = GSON.toJson(snapshot, Snapshot.class);\n+        prop.put(\"model_snapshot\", snapshotJson);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQwMTA3Nw==", "bodyText": "Done.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r396401077", "createdAt": "2020-03-23T12:04:02Z", "author": {"login": "harshbafna"}, "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/FSSnapshotSerializer.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.pytorch.serve.snapshot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Properties;\n+import org.apache.commons.io.FileUtils;\n+import org.pytorch.serve.http.ConflictStatusException;\n+import org.pytorch.serve.util.ConfigManager;\n+\n+public class FSSnapshotSerializer implements SnapshotSerializer {\n+\n+    private ConfigManager configManager = ConfigManager.getInstance();\n+    public static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+\n+    public void saveSnapshot(Snapshot snapshot) throws IOException, ConflictStatusException {\n+        File snapshotPath = new File(System.getProperty(\"LOG_LOCATION\") + \"/config\");\n+\n+        FileUtils.forceMkdir(snapshotPath);\n+\n+        Properties prop = configManager.getConfiguration();\n+\n+        File snapshotFile = new File(snapshotPath, snapshot.getName());\n+        if (snapshotFile.exists()) {\n+            throw new ConflictStatusException(\n+                    \"Snapshot \" + snapshot.getName() + \" already exists.\");\n+        }\n+\n+        String snapshotJson = GSON.toJson(snapshot, Snapshot.class);\n+        prop.put(\"model_snapshot\", snapshotJson);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxMzQ5OQ=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzM3MDc0OnYy", "diffSide": "RIGHT", "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/Snapshot.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODoyMToxOFrOF5er0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNzoxMTowN1rOF66oPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxNTg5MA==", "bodyText": "looks more and more like Snapshot is assuming the role of ModelVersionedRefs why? This increases the footprint of the whole application dramatically. Until clarified, please consider writing a design doc or adding design under documentation for this feature.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395815890", "createdAt": "2020-03-20T18:21:18Z", "author": {"login": "mycpuorg"}, "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/Snapshot.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package org.pytorch.serve.snapshot;\n+\n+import java.util.Map;\n+\n+public class Snapshot {\n+    private String name;\n+    private int modelCount;\n+    private long created;\n+    private Map<String, Map<String, ModelInfo>> models;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk5NzY1NQ==", "bodyText": "Snapshot is essentially dumping all the current state of all registered models, which is stored using ModelVersionedRefs. While saving snapshot it actually refers the current ModelVersionRefs and generates the snapshot object to dump.\nAs indicated in one of the earlier comment the only difference is between the Model class and the ModelInfo class used for representation.  Also ModelVersionedRefs contains much too detailed information about the current in-memory state of registered models, which is not required in the snapshot.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r395997655", "createdAt": "2020-03-21T14:35:14Z", "author": {"login": "harshbafna"}, "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/Snapshot.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package org.pytorch.serve.snapshot;\n+\n+import java.util.Map;\n+\n+public class Snapshot {\n+    private String name;\n+    private int modelCount;\n+    private long created;\n+    private Map<String, Map<String, ModelInfo>> models;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxNTg5MA=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMyMjMwMg==", "bodyText": "renamed ModelInfo to ModelSnapshot", "url": "https://github.com/pytorch/serve/pull/111#discussion_r397322302", "createdAt": "2020-03-24T17:11:07Z", "author": {"login": "harshbafna"}, "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/Snapshot.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package org.pytorch.serve.snapshot;\n+\n+import java.util.Map;\n+\n+public class Snapshot {\n+    private String name;\n+    private int modelCount;\n+    private long created;\n+    private Map<String, Map<String, ModelInfo>> models;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgxNTg5MA=="}, "originalCommit": {"oid": "a2a8d17552664161a31b7fa2a54abc9607215039"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzg0ODI3OnYy", "diffSide": "RIGHT", "path": "frontend/server/src/main/java/org/pytorch/serve/wlm/ModelManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo0MDozNlrOF-lUgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo0MDozNlrOF-lUgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE2NzQ4OQ==", "bodyText": "Should this be an assertion, or a warning in the logs? Someone may have moved models out of the model store on purpose. We obviously shouldn't handle this silently, but I don't think crashing the app is the user experience we're after either.\nPlease update this to:\n\nContinue healthy startup without the missing models\nEmit clear & helpful log messages about which model was missing to ts_log.log and stdout/stderr", "url": "https://github.com/pytorch/serve/pull/111#discussion_r401167489", "createdAt": "2020-03-31T19:40:36Z", "author": {"login": "fbbradheintz"}, "path": "frontend/server/src/main/java/org/pytorch/serve/wlm/ModelManager.java", "diffHunk": "@@ -201,24 +205,40 @@ public HttpResponseStatus setDefaultVersion(String modelName, String newModelVer\n     }\n \n     public CompletableFuture<HttpResponseStatus> updateModel(\n-            String modelName, String versionId, int minWorkers, int maxWorkers) {\n+            String modelName, String versionId, int minWorkers, int maxWorkers, boolean isStartup) {\n         ModelVersionedRefs vmodel = modelsNameMap.get(modelName);\n         if (vmodel == null) {\n             throw new AssertionError(\"Model not found: \" + modelName);\n         }\n \n         Model model = vmodel.getVersionModel(versionId);\n+\n+        if (model == null) {\n+            throw new AssertionError(\"Model version not not found for model : \" + modelName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcf9f9ea8cae63337f895fc2d2c3e338e22ad35a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzg3MDkzOnYy", "diffSide": "RIGHT", "path": "frontend/server/src/main/java/org/pytorch/serve/util/ConfigManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo0NzowOFrOF-liFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwODoyMzoxMlrOF-12gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MDk2Nw==", "bodyText": "This might be a problem; elsewhere I see a command line arg (-ss/--snapshot-store) defined for the config folder, but this is just adding /config to the log folder. Either we should pull out the CLI option, or we should store the config folder in a property accessible by all modules that need it (as it looks like was done for the log location).", "url": "https://github.com/pytorch/serve/pull/111#discussion_r401170967", "createdAt": "2020-03-31T19:47:08Z", "author": {"login": "fbbradheintz"}, "path": "frontend/server/src/main/java/org/pytorch/serve/util/ConfigManager.java", "diffHunk": "@@ -428,6 +443,31 @@ private PrivateKey loadPrivateKey(String keyFile) throws IOException, GeneralSec\n         }\n     }\n \n+    private String getLastSnapshot() {\n+        if (isSnapshotDisabled()) {\n+            return null;\n+        }\n+\n+        String latestSnapshotPath = null;\n+        Path configPath = Paths.get(System.getProperty(\"LOG_LOCATION\"), \"config\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcf9f9ea8cae63337f895fc2d2c3e338e22ad35a"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQzODMzOA==", "bodyText": "Done.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r401438338", "createdAt": "2020-04-01T08:23:12Z", "author": {"login": "harshbafna"}, "path": "frontend/server/src/main/java/org/pytorch/serve/util/ConfigManager.java", "diffHunk": "@@ -428,6 +443,31 @@ private PrivateKey loadPrivateKey(String keyFile) throws IOException, GeneralSec\n         }\n     }\n \n+    private String getLastSnapshot() {\n+        if (isSnapshotDisabled()) {\n+            return null;\n+        }\n+\n+        String latestSnapshotPath = null;\n+        Path configPath = Paths.get(System.getProperty(\"LOG_LOCATION\"), \"config\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MDk2Nw=="}, "originalCommit": {"oid": "fcf9f9ea8cae63337f895fc2d2c3e338e22ad35a"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzg4Mzk3OnYy", "diffSide": "RIGHT", "path": "frontend/server/src/main/java/org/pytorch/serve/util/ConfigManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxOTo1MDozOFrOF-lqDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwODoyMjozMVrOF-11CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MzAwNg==", "bodyText": "Do we want last modified time, or the timestamp on the file. If someone brings up a older config file in an editor and changes the last mod date, TorchServe might do unintended things, e.g. start up with the wrong file.\nThe YYYYmmDDHHMMSS format was specifically chosen so that the most recently timestamped file could be found with a simple name sort.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r401173006", "createdAt": "2020-03-31T19:50:38Z", "author": {"login": "fbbradheintz"}, "path": "frontend/server/src/main/java/org/pytorch/serve/util/ConfigManager.java", "diffHunk": "@@ -428,6 +443,31 @@ private PrivateKey loadPrivateKey(String keyFile) throws IOException, GeneralSec\n         }\n     }\n \n+    private String getLastSnapshot() {\n+        if (isSnapshotDisabled()) {\n+            return null;\n+        }\n+\n+        String latestSnapshotPath = null;\n+        Path configPath = Paths.get(System.getProperty(\"LOG_LOCATION\"), \"config\");\n+\n+        if (Files.exists(configPath)) {\n+            try {\n+                Optional<Path> lastFilePath =\n+                        Files.list(configPath)\n+                                .filter(f -> !Files.isDirectory(f))\n+                                .max(Comparator.comparingLong(f -> f.toFile().lastModified()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcf9f9ea8cae63337f895fc2d2c3e338e22ad35a"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQzNzk2MQ==", "bodyText": "Done.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r401437961", "createdAt": "2020-04-01T08:22:31Z", "author": {"login": "harshbafna"}, "path": "frontend/server/src/main/java/org/pytorch/serve/util/ConfigManager.java", "diffHunk": "@@ -428,6 +443,31 @@ private PrivateKey loadPrivateKey(String keyFile) throws IOException, GeneralSec\n         }\n     }\n \n+    private String getLastSnapshot() {\n+        if (isSnapshotDisabled()) {\n+            return null;\n+        }\n+\n+        String latestSnapshotPath = null;\n+        Path configPath = Paths.get(System.getProperty(\"LOG_LOCATION\"), \"config\");\n+\n+        if (Files.exists(configPath)) {\n+            try {\n+                Optional<Path> lastFilePath =\n+                        Files.list(configPath)\n+                                .filter(f -> !Files.isDirectory(f))\n+                                .max(Comparator.comparingLong(f -> f.toFile().lastModified()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3MzAwNg=="}, "originalCommit": {"oid": "fcf9f9ea8cae63337f895fc2d2c3e338e22ad35a"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4Nzk2NTQ1OnYy", "diffSide": "RIGHT", "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/FSSnapshotSerializer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDoxMzozMFrOF-mbsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwODoyMjo0MVrOF-11ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NTcxMw==", "bodyText": "I made a note on this elsewhere. Again, we should have a property or other single source of truth for the config folder, as we do for the log folder. The duplicated code that builds a path string from scratch every time invites bugs.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r401185713", "createdAt": "2020-03-31T20:13:30Z", "author": {"login": "fbbradheintz"}, "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/FSSnapshotSerializer.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.pytorch.serve.snapshot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Properties;\n+import org.apache.commons.io.FileUtils;\n+import org.pytorch.serve.util.ConfigManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FSSnapshotSerializer implements SnapshotSerializer {\n+\n+    private Logger logger = LoggerFactory.getLogger(FSSnapshotSerializer.class);\n+    private ConfigManager configManager = ConfigManager.getInstance();\n+    private static final String TS_MODEL_SNAPSHOT = \"model_snapshot\";\n+    public static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+\n+    @Override\n+    public void saveSnapshot(Snapshot snapshot) throws IOException {\n+        File snapshotPath = new File(System.getProperty(\"LOG_LOCATION\"), \"config\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcf9f9ea8cae63337f895fc2d2c3e338e22ad35a"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQzODA1Mg==", "bodyText": "Done.", "url": "https://github.com/pytorch/serve/pull/111#discussion_r401438052", "createdAt": "2020-04-01T08:22:41Z", "author": {"login": "harshbafna"}, "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/FSSnapshotSerializer.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.pytorch.serve.snapshot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Properties;\n+import org.apache.commons.io.FileUtils;\n+import org.pytorch.serve.util.ConfigManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FSSnapshotSerializer implements SnapshotSerializer {\n+\n+    private Logger logger = LoggerFactory.getLogger(FSSnapshotSerializer.class);\n+    private ConfigManager configManager = ConfigManager.getInstance();\n+    private static final String TS_MODEL_SNAPSHOT = \"model_snapshot\";\n+    public static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+\n+    @Override\n+    public void saveSnapshot(Snapshot snapshot) throws IOException {\n+        File snapshotPath = new File(System.getProperty(\"LOG_LOCATION\"), \"config\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NTcxMw=="}, "originalCommit": {"oid": "fcf9f9ea8cae63337f895fc2d2c3e338e22ad35a"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4ODAxMDQxOnYy", "diffSide": "RIGHT", "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/FSSnapshotSerializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDoyNToxMFrOF-m2zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDoyNToxMFrOF-m2zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5MjY1NQ==", "bodyText": "The output format surprised me here. When the detailed notes on issue #73 suggested using the config files, we had pictured using the config files, in the same manner they're normally used, not embedding some other serialization scheme within the config files.\nIt's probably too late to pull back on this for the initial release, but can someone explain to me whether there's a reason that we're doing it this way instead of just building a normal config file?", "url": "https://github.com/pytorch/serve/pull/111#discussion_r401192655", "createdAt": "2020-03-31T20:25:10Z", "author": {"login": "fbbradheintz"}, "path": "frontend/server/src/main/java/org/pytorch/serve/snapshot/FSSnapshotSerializer.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.pytorch.serve.snapshot;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Properties;\n+import org.apache.commons.io.FileUtils;\n+import org.pytorch.serve.util.ConfigManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class FSSnapshotSerializer implements SnapshotSerializer {\n+\n+    private Logger logger = LoggerFactory.getLogger(FSSnapshotSerializer.class);\n+    private ConfigManager configManager = ConfigManager.getInstance();\n+    private static final String TS_MODEL_SNAPSHOT = \"model_snapshot\";\n+    public static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();\n+\n+    @Override\n+    public void saveSnapshot(Snapshot snapshot) throws IOException {\n+        File snapshotPath = new File(System.getProperty(\"LOG_LOCATION\"), \"config\");\n+\n+        FileUtils.forceMkdir(snapshotPath);\n+\n+        Properties prop = configManager.getConfiguration();\n+\n+        File snapshotFile = new File(snapshotPath, snapshot.getName());\n+        if (snapshotFile.exists()) {\n+            logger.error(\n+                    \"Snapshot \" + snapshot.getName() + \" already exists. Not saving the sanpshot.\");\n+        }\n+\n+        String snapshotJson = GSON.toJson(snapshot, Snapshot.class);\n+        prop.put(TS_MODEL_SNAPSHOT, snapshotJson);\n+        try (OutputStream os = Files.newOutputStream(snapshotFile.toPath())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcf9f9ea8cae63337f895fc2d2c3e338e22ad35a"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4ODAzNjQ4OnYy", "diffSide": "RIGHT", "path": "ts/arg_parser.py", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDozMjoyNFrOF-nG2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMDozMjoyNFrOF-nG2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5Njc2MA==", "bodyText": "My understanding is that this is no longer required because we anticipate the model store property coming from the config snapshots. Do we have a way to catch it if there's no --model-store option and no model store specified in the config?", "url": "https://github.com/pytorch/serve/pull/111#discussion_r401196760", "createdAt": "2020-03-31T20:32:24Z", "author": {"login": "fbbradheintz"}, "path": "ts/arg_parser.py", "diffHunk": "@@ -30,6 +30,7 @@ def ts_parser():\n                             dest='ts_config',\n                             help='Configuration file for model server')\n         parser.add_argument('--model-store',\n+                            required=False,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcf9f9ea8cae63337f895fc2d2c3e338e22ad35a"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1687, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}