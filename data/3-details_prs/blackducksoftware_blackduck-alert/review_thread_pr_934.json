{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzODI1MjQ5", "number": 934, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDozNDozN1rODrrJqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNzoyMTozNFrODrwE9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTIyMzQ2OnYy", "diffSide": "RIGHT", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/ui/ProviderGlobalUIConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDozNDozN1rOF8J5cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNjo1ODo0OVrOF8Q3yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYyMTA0Mg==", "bodyText": "I don't think we really need this empty check. If the content is empty, we'll stream through an empty list creating another empty list which we're checking later on.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/934#discussion_r398621042", "createdAt": "2020-03-26T14:34:37Z", "author": {"login": "bamandel"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/ui/ProviderGlobalUIConfig.java", "diffHunk": "@@ -58,4 +74,29 @@ public ProviderKey getProviderKey() {\n         return providerKey;\n     }\n \n+    private Collection<String> validateDuplicateNames(FieldValueModel fieldToValidate, FieldModel fieldModel) {\n+        try {\n+            List<ConfigurationModel> configurations = configurationAccessor.getConfigurationsByDescriptorType(DescriptorType.PROVIDER);\n+            if (!configurations.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2212415e7b0427bb939ad359710bca887d161791"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODczNTMwNg==", "bodyText": "I think this is defensive coding and saves us from running a few lines of code that we may not want.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/934#discussion_r398735306", "createdAt": "2020-03-26T16:58:49Z", "author": {"login": "jamesrichard91"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/ui/ProviderGlobalUIConfig.java", "diffHunk": "@@ -58,4 +74,29 @@ public ProviderKey getProviderKey() {\n         return providerKey;\n     }\n \n+    private Collection<String> validateDuplicateNames(FieldValueModel fieldToValidate, FieldModel fieldModel) {\n+        try {\n+            List<ConfigurationModel> configurations = configurationAccessor.getConfigurationsByDescriptorType(DescriptorType.PROVIDER);\n+            if (!configurations.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYyMTA0Mg=="}, "originalCommit": {"oid": "2212415e7b0427bb939ad359710bca887d161791"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTMwNDgxOnYy", "diffSide": "RIGHT", "path": "src/main/js/field/TableDisplay.js", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo1MTozOVrOF8KtGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo1MTozOVrOF8KtGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzNDI2Ng==", "bodyText": "Probably don't need this variable anymore", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/934#discussion_r398634266", "createdAt": "2020-03-26T14:51:39Z", "author": {"login": "bamandel"}, "path": "src/main/js/field/TableDisplay.js", "diffHunk": "@@ -150,25 +151,57 @@ class TableDisplay extends Component {\n         this.handleSubmit();\n     }\n \n+    handleInsertModalTest(event, onModalClose) {\n+        if (event) {\n+            event.preventDefault()\n+            event.stopPropagation();\n+        }\n+        const { nestedInAnotherModal } = this.props;\n+        // nested modals are not supported by react-bootstrap.\n+        // if this table is nested in a modal it cannot call onModalClose because it would close all modals.\n+        if (!nestedInAnotherModal) {\n+            onModalClose();\n+        }\n+        this.handleTest();\n+    }\n+\n     handleSubmit(event) {\n         if (event) {\n             event.preventDefault()\n             event.stopPropagation();\n         }\n-        const result = this.props.onConfigSave();\n-        const validationState = result ? VALIDATION_STATE.SUCCESS : VALIDATION_STATE.FAILED;\n-        this.setState({\n-            uiValidation: validationState\n-        });\n-        this.setState({\n-            showConfiguration: false\n-        });\n+        const callback = (result) => {\n+            const validationState = result ? VALIDATION_STATE.SUCCESS : VALIDATION_STATE.FAILED;\n+            const validationSetCallback = () => this.setState({\n+                showConfiguration: false\n+            }, this.updateData);\n+            this.setState({\n+                uiValidation: validationState\n+            }, validationSetCallback);\n+        };\n+        this.props.onConfigSave(callback);\n+    }\n+\n+    handleTest(event) {\n+        if (event) {\n+            event.preventDefault()\n+            event.stopPropagation();\n+        }\n+        const callback = (result) => {\n+            const validationState = result ? VALIDATION_STATE.SUCCESS : VALIDATION_STATE.FAILED;\n+            this.setState({\n+                uiValidation: validationState\n+            });\n+        };\n+        this.props.onConfigTest(callback);\n     }\n \n     createEditModal() {\n         const { currentRowSelected } = this.state;\n-        const { modalTitle, newConfigFields, inProgress } = this.props;\n-        const showModal = Boolean(currentRowSelected) || this.isShowModal();\n+        const { modalTitle, newConfigFields, inProgress, testButton, testButtonLabel, errorDialogMessage, actionMessage } = this.props;\n+        const showModal = this.isShowModal();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2212415e7b0427bb939ad359710bca887d161791"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTMxNjI5OnYy", "diffSide": "RIGHT", "path": "src/main/js/providers/ProviderTable.js", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNDo1Mzo1OFrOF8K0Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNTo1NDo0OVrOF8N0Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzNjEzMA==", "bodyText": "HandleChange seems to be very similar everywhere. Could this be made common somewhere? If it's similar to the TableDisplay, perhaps we add most of this code there?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/934#discussion_r398636130", "createdAt": "2020-03-26T14:53:58Z", "author": {"login": "bamandel"}, "path": "src/main/js/providers/ProviderTable.js", "diffHunk": "@@ -0,0 +1,363 @@\n+import React, { Component } from 'react';\n+import { connect } from 'react-redux';\n+import { withRouter } from 'react-router-dom';\n+import ConfigurationLabel from 'component/common/ConfigurationLabel';\n+import PropTypes from 'prop-types';\n+import { clearConfigFieldErrors, deleteConfig, getAllConfigs, testConfig, updateConfig } from 'store/actions/globalConfiguration';\n+import * as DescriptorUtilities from 'util/descriptorUtilities';\n+import * as FieldModelUtilities from 'util/fieldModelUtilities';\n+import TableDisplay from 'field/TableDisplay';\n+import FieldsPanel from 'field/FieldsPanel';\n+import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\n+\n+const ProviderCommonKeys = {\n+    KEY_NAME: 'provider.common.config.name',\n+    KEY_ENABLED: 'provider.common.config.enabled'\n+}\n+\n+class ProviderTable extends Component {\n+    constructor(props) {\n+        super(props);\n+        this.createTableData = this.createTableData.bind(this);\n+        this.retrieveData = this.retrieveData.bind(this);\n+        this.clearModalFieldState = this.clearModalFieldState.bind(this);\n+        this.createColumns = this.createColumns.bind(this);\n+        this.handleChange = this.handleChange.bind(this);\n+        this.onSave = this.onSave.bind(this);\n+        this.onTest = this.onTest.bind(this);\n+        this.onConfigClose = this.onConfigClose.bind(this);\n+        this.onDelete = this.onDelete.bind(this);\n+        this.createModalFields = this.createModalFields.bind(this);\n+        this.onEdit = this.onEdit.bind(this);\n+        this.onCopy = this.onCopy.bind(this);\n+        this.combineModelWithDefaults = this.combineModelWithDefaults.bind(this);\n+\n+        this.state = {\n+            descriptor: null,\n+            providerConfig: {},\n+            saveCallback: () => null\n+        };\n+    }\n+\n+    componentDidMount() {\n+        const descriptor = this.props.descriptors.find(descriptor => descriptor.name === this.props.descriptorName\n+            && descriptor.context === DescriptorUtilities.CONTEXT_TYPE.GLOBAL)\n+        if (descriptor) {\n+            const emptyConfig = FieldModelUtilities.createFieldModelWithDefaults(descriptor.fields, DescriptorUtilities.CONTEXT_TYPE.GLOBAL, descriptor.name);\n+            this.setState({\n+                descriptor,\n+                providerConfig: emptyConfig\n+            });\n+            this.props.getAllConfigs(descriptor.name);\n+        }\n+    }\n+\n+    componentDidUpdate(prevProps) {\n+        if (prevProps.updateStatus === 'UPDATING' && (this.props.updateStatus === 'UPDATED' || this.props.updateStatus === 'ERROR')) {\n+            this.state.saveCallback(true);\n+        }\n+    }\n+\n+    combineModelWithDefaults(providerConfig) {\n+        const { descriptor } = this.state;\n+        if (!descriptor) {\n+            return {};\n+        }\n+        const emptyConfig = FieldModelUtilities.createFieldModelWithDefaults(descriptor.fields, DescriptorUtilities.CONTEXT_TYPE.GLOBAL, descriptor.name);\n+        const updatedFieldModel = FieldModelUtilities.combineFieldModels(emptyConfig, providerConfig);\n+        if (providerConfig.id) {\n+            updatedFieldModel.id = providerConfig.id;\n+        }\n+        return updatedFieldModel;\n+    }\n+\n+    createColumns() {\n+        return [\n+            {\n+                header: 'id',\n+                headerLabel: 'Id',\n+                isKey: true,\n+                hidden: true\n+            },\n+            {\n+                header: 'name',\n+                headerLabel: 'Name',\n+                isKey: false,\n+                hidden: false\n+            },\n+            {\n+                header: 'createdAt',\n+                headerLabel: 'Created At',\n+                isKey: false,\n+                hidden: false\n+            },\n+            {\n+                header: 'lastUpdated',\n+                headerLabel: 'Last Updated',\n+                isKey: false,\n+                hidden: false\n+            },\n+            {\n+                header: 'enabled',\n+                headerLabel: 'Enabled',\n+                isKey: false,\n+                hidden: false,\n+                dataFormat: this.enabledState\n+            }\n+        ];\n+    }\n+\n+    enabledState(cell) {\n+        const icon = (cell == 'true') ? 'check' : 'times';\n+        const color = (cell == 'true') ? 'synopsysGreen' : 'synopsysRed';\n+        const className = `alert-icon ${color}`;\n+\n+        return (\n+            <div className=\"btn btn-link jobIconButton\">\n+                <FontAwesomeIcon icon={icon} className={className} size=\"lg\" />\n+            </div>\n+        );\n+    }\n+\n+    onConfigClose(callback) {\n+        this.props.clearFieldErrors();\n+        callback();\n+    }\n+\n+    clearModalFieldState() {\n+        if (this.state.providerConfig && Object.keys(this.state.providerConfig).length > 0) {\n+            this.setState({\n+                providerConfig: {}\n+            });\n+        }\n+    }\n+\n+    retrieveData() {\n+        const { descriptor } = this.state;\n+        if (descriptor) {\n+            this.props.getAllConfigs(descriptor.name);\n+        }\n+    }\n+\n+    handleChange(e) {\n+        const { name, value, type, checked } = e.target;\n+        const { providerConfig } = this.state;\n+\n+        const updatedValue = type === 'checkbox' ? checked.toString().toLowerCase() === 'true' : value;\n+        const newProviderConfig = Object.assign(providerConfig, FieldModelUtilities.updateFieldModelSingleValue(providerConfig, name, updatedValue));\n+\n+        this.setState({\n+            providerConfig: newProviderConfig\n+        });\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2212415e7b0427bb939ad359710bca887d161791"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzNjkyNA==", "bodyText": "FieldsPanel handles its on handleChange similar to this. Perhaps we could do it that way.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/934#discussion_r398636924", "createdAt": "2020-03-26T14:54:52Z", "author": {"login": "bamandel"}, "path": "src/main/js/providers/ProviderTable.js", "diffHunk": "@@ -0,0 +1,363 @@\n+import React, { Component } from 'react';\n+import { connect } from 'react-redux';\n+import { withRouter } from 'react-router-dom';\n+import ConfigurationLabel from 'component/common/ConfigurationLabel';\n+import PropTypes from 'prop-types';\n+import { clearConfigFieldErrors, deleteConfig, getAllConfigs, testConfig, updateConfig } from 'store/actions/globalConfiguration';\n+import * as DescriptorUtilities from 'util/descriptorUtilities';\n+import * as FieldModelUtilities from 'util/fieldModelUtilities';\n+import TableDisplay from 'field/TableDisplay';\n+import FieldsPanel from 'field/FieldsPanel';\n+import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\n+\n+const ProviderCommonKeys = {\n+    KEY_NAME: 'provider.common.config.name',\n+    KEY_ENABLED: 'provider.common.config.enabled'\n+}\n+\n+class ProviderTable extends Component {\n+    constructor(props) {\n+        super(props);\n+        this.createTableData = this.createTableData.bind(this);\n+        this.retrieveData = this.retrieveData.bind(this);\n+        this.clearModalFieldState = this.clearModalFieldState.bind(this);\n+        this.createColumns = this.createColumns.bind(this);\n+        this.handleChange = this.handleChange.bind(this);\n+        this.onSave = this.onSave.bind(this);\n+        this.onTest = this.onTest.bind(this);\n+        this.onConfigClose = this.onConfigClose.bind(this);\n+        this.onDelete = this.onDelete.bind(this);\n+        this.createModalFields = this.createModalFields.bind(this);\n+        this.onEdit = this.onEdit.bind(this);\n+        this.onCopy = this.onCopy.bind(this);\n+        this.combineModelWithDefaults = this.combineModelWithDefaults.bind(this);\n+\n+        this.state = {\n+            descriptor: null,\n+            providerConfig: {},\n+            saveCallback: () => null\n+        };\n+    }\n+\n+    componentDidMount() {\n+        const descriptor = this.props.descriptors.find(descriptor => descriptor.name === this.props.descriptorName\n+            && descriptor.context === DescriptorUtilities.CONTEXT_TYPE.GLOBAL)\n+        if (descriptor) {\n+            const emptyConfig = FieldModelUtilities.createFieldModelWithDefaults(descriptor.fields, DescriptorUtilities.CONTEXT_TYPE.GLOBAL, descriptor.name);\n+            this.setState({\n+                descriptor,\n+                providerConfig: emptyConfig\n+            });\n+            this.props.getAllConfigs(descriptor.name);\n+        }\n+    }\n+\n+    componentDidUpdate(prevProps) {\n+        if (prevProps.updateStatus === 'UPDATING' && (this.props.updateStatus === 'UPDATED' || this.props.updateStatus === 'ERROR')) {\n+            this.state.saveCallback(true);\n+        }\n+    }\n+\n+    combineModelWithDefaults(providerConfig) {\n+        const { descriptor } = this.state;\n+        if (!descriptor) {\n+            return {};\n+        }\n+        const emptyConfig = FieldModelUtilities.createFieldModelWithDefaults(descriptor.fields, DescriptorUtilities.CONTEXT_TYPE.GLOBAL, descriptor.name);\n+        const updatedFieldModel = FieldModelUtilities.combineFieldModels(emptyConfig, providerConfig);\n+        if (providerConfig.id) {\n+            updatedFieldModel.id = providerConfig.id;\n+        }\n+        return updatedFieldModel;\n+    }\n+\n+    createColumns() {\n+        return [\n+            {\n+                header: 'id',\n+                headerLabel: 'Id',\n+                isKey: true,\n+                hidden: true\n+            },\n+            {\n+                header: 'name',\n+                headerLabel: 'Name',\n+                isKey: false,\n+                hidden: false\n+            },\n+            {\n+                header: 'createdAt',\n+                headerLabel: 'Created At',\n+                isKey: false,\n+                hidden: false\n+            },\n+            {\n+                header: 'lastUpdated',\n+                headerLabel: 'Last Updated',\n+                isKey: false,\n+                hidden: false\n+            },\n+            {\n+                header: 'enabled',\n+                headerLabel: 'Enabled',\n+                isKey: false,\n+                hidden: false,\n+                dataFormat: this.enabledState\n+            }\n+        ];\n+    }\n+\n+    enabledState(cell) {\n+        const icon = (cell == 'true') ? 'check' : 'times';\n+        const color = (cell == 'true') ? 'synopsysGreen' : 'synopsysRed';\n+        const className = `alert-icon ${color}`;\n+\n+        return (\n+            <div className=\"btn btn-link jobIconButton\">\n+                <FontAwesomeIcon icon={icon} className={className} size=\"lg\" />\n+            </div>\n+        );\n+    }\n+\n+    onConfigClose(callback) {\n+        this.props.clearFieldErrors();\n+        callback();\n+    }\n+\n+    clearModalFieldState() {\n+        if (this.state.providerConfig && Object.keys(this.state.providerConfig).length > 0) {\n+            this.setState({\n+                providerConfig: {}\n+            });\n+        }\n+    }\n+\n+    retrieveData() {\n+        const { descriptor } = this.state;\n+        if (descriptor) {\n+            this.props.getAllConfigs(descriptor.name);\n+        }\n+    }\n+\n+    handleChange(e) {\n+        const { name, value, type, checked } = e.target;\n+        const { providerConfig } = this.state;\n+\n+        const updatedValue = type === 'checkbox' ? checked.toString().toLowerCase() === 'true' : value;\n+        const newProviderConfig = Object.assign(providerConfig, FieldModelUtilities.updateFieldModelSingleValue(providerConfig, name, updatedValue));\n+\n+        this.setState({\n+            providerConfig: newProviderConfig\n+        });\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzNjEzMA=="}, "originalCommit": {"oid": "2212415e7b0427bb939ad359710bca887d161791"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY4NTIwMw==", "bodyText": "I will look into this with another feature I will add.  I will consider it for a different PR.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/934#discussion_r398685203", "createdAt": "2020-03-26T15:54:49Z", "author": {"login": "psantos1113"}, "path": "src/main/js/providers/ProviderTable.js", "diffHunk": "@@ -0,0 +1,363 @@\n+import React, { Component } from 'react';\n+import { connect } from 'react-redux';\n+import { withRouter } from 'react-router-dom';\n+import ConfigurationLabel from 'component/common/ConfigurationLabel';\n+import PropTypes from 'prop-types';\n+import { clearConfigFieldErrors, deleteConfig, getAllConfigs, testConfig, updateConfig } from 'store/actions/globalConfiguration';\n+import * as DescriptorUtilities from 'util/descriptorUtilities';\n+import * as FieldModelUtilities from 'util/fieldModelUtilities';\n+import TableDisplay from 'field/TableDisplay';\n+import FieldsPanel from 'field/FieldsPanel';\n+import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\n+\n+const ProviderCommonKeys = {\n+    KEY_NAME: 'provider.common.config.name',\n+    KEY_ENABLED: 'provider.common.config.enabled'\n+}\n+\n+class ProviderTable extends Component {\n+    constructor(props) {\n+        super(props);\n+        this.createTableData = this.createTableData.bind(this);\n+        this.retrieveData = this.retrieveData.bind(this);\n+        this.clearModalFieldState = this.clearModalFieldState.bind(this);\n+        this.createColumns = this.createColumns.bind(this);\n+        this.handleChange = this.handleChange.bind(this);\n+        this.onSave = this.onSave.bind(this);\n+        this.onTest = this.onTest.bind(this);\n+        this.onConfigClose = this.onConfigClose.bind(this);\n+        this.onDelete = this.onDelete.bind(this);\n+        this.createModalFields = this.createModalFields.bind(this);\n+        this.onEdit = this.onEdit.bind(this);\n+        this.onCopy = this.onCopy.bind(this);\n+        this.combineModelWithDefaults = this.combineModelWithDefaults.bind(this);\n+\n+        this.state = {\n+            descriptor: null,\n+            providerConfig: {},\n+            saveCallback: () => null\n+        };\n+    }\n+\n+    componentDidMount() {\n+        const descriptor = this.props.descriptors.find(descriptor => descriptor.name === this.props.descriptorName\n+            && descriptor.context === DescriptorUtilities.CONTEXT_TYPE.GLOBAL)\n+        if (descriptor) {\n+            const emptyConfig = FieldModelUtilities.createFieldModelWithDefaults(descriptor.fields, DescriptorUtilities.CONTEXT_TYPE.GLOBAL, descriptor.name);\n+            this.setState({\n+                descriptor,\n+                providerConfig: emptyConfig\n+            });\n+            this.props.getAllConfigs(descriptor.name);\n+        }\n+    }\n+\n+    componentDidUpdate(prevProps) {\n+        if (prevProps.updateStatus === 'UPDATING' && (this.props.updateStatus === 'UPDATED' || this.props.updateStatus === 'ERROR')) {\n+            this.state.saveCallback(true);\n+        }\n+    }\n+\n+    combineModelWithDefaults(providerConfig) {\n+        const { descriptor } = this.state;\n+        if (!descriptor) {\n+            return {};\n+        }\n+        const emptyConfig = FieldModelUtilities.createFieldModelWithDefaults(descriptor.fields, DescriptorUtilities.CONTEXT_TYPE.GLOBAL, descriptor.name);\n+        const updatedFieldModel = FieldModelUtilities.combineFieldModels(emptyConfig, providerConfig);\n+        if (providerConfig.id) {\n+            updatedFieldModel.id = providerConfig.id;\n+        }\n+        return updatedFieldModel;\n+    }\n+\n+    createColumns() {\n+        return [\n+            {\n+                header: 'id',\n+                headerLabel: 'Id',\n+                isKey: true,\n+                hidden: true\n+            },\n+            {\n+                header: 'name',\n+                headerLabel: 'Name',\n+                isKey: false,\n+                hidden: false\n+            },\n+            {\n+                header: 'createdAt',\n+                headerLabel: 'Created At',\n+                isKey: false,\n+                hidden: false\n+            },\n+            {\n+                header: 'lastUpdated',\n+                headerLabel: 'Last Updated',\n+                isKey: false,\n+                hidden: false\n+            },\n+            {\n+                header: 'enabled',\n+                headerLabel: 'Enabled',\n+                isKey: false,\n+                hidden: false,\n+                dataFormat: this.enabledState\n+            }\n+        ];\n+    }\n+\n+    enabledState(cell) {\n+        const icon = (cell == 'true') ? 'check' : 'times';\n+        const color = (cell == 'true') ? 'synopsysGreen' : 'synopsysRed';\n+        const className = `alert-icon ${color}`;\n+\n+        return (\n+            <div className=\"btn btn-link jobIconButton\">\n+                <FontAwesomeIcon icon={icon} className={className} size=\"lg\" />\n+            </div>\n+        );\n+    }\n+\n+    onConfigClose(callback) {\n+        this.props.clearFieldErrors();\n+        callback();\n+    }\n+\n+    clearModalFieldState() {\n+        if (this.state.providerConfig && Object.keys(this.state.providerConfig).length > 0) {\n+            this.setState({\n+                providerConfig: {}\n+            });\n+        }\n+    }\n+\n+    retrieveData() {\n+        const { descriptor } = this.state;\n+        if (descriptor) {\n+            this.props.getAllConfigs(descriptor.name);\n+        }\n+    }\n+\n+    handleChange(e) {\n+        const { name, value, type, checked } = e.target;\n+        const { providerConfig } = this.state;\n+\n+        const updatedValue = type === 'checkbox' ? checked.toString().toLowerCase() === 'true' : value;\n+        const newProviderConfig = Object.assign(providerConfig, FieldModelUtilities.updateFieldModelSingleValue(providerConfig, name, updatedValue));\n+\n+        this.setState({\n+            providerConfig: newProviderConfig\n+        });\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzNjEzMA=="}, "originalCommit": {"oid": "2212415e7b0427bb939ad359710bca887d161791"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTUxMDk5OnYy", "diffSide": "RIGHT", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/ui/ProviderGlobalUIConfig.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNTozMzowMlrOF8MvcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxODo1ODoxMFrOF8V8Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2NzYzMg==", "bodyText": "Should this be a database constraint? I don't think this is the appropriate place to handle this error.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/934#discussion_r398667632", "createdAt": "2020-03-26T15:33:02Z", "author": {"login": "gkillough"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/ui/ProviderGlobalUIConfig.java", "diffHunk": "@@ -58,4 +74,29 @@ public ProviderKey getProviderKey() {\n         return providerKey;\n     }\n \n+    private Collection<String> validateDuplicateNames(FieldValueModel fieldToValidate, FieldModel fieldModel) {\n+        try {\n+            List<ConfigurationModel> configurations = configurationAccessor.getConfigurationsByDescriptorType(DescriptorType.PROVIDER);\n+            if (!configurations.isEmpty()) {\n+                List<ConfigurationModel> modelsWithName = configurations.stream()\n+                                                              .filter(configurationModel ->\n+                                                                          configurationModel.getField(ProviderDescriptor.KEY_PROVIDER_CONFIG_NAME)\n+                                                                              .flatMap(ConfigurationFieldModel::getFieldValue)\n+                                                                              .filter(configName -> configName.equals(fieldToValidate.getValue().orElse(\"\")))\n+                                                                              .isPresent())\n+                                                              .collect(Collectors.toList());\n+                if (modelsWithName.size() > 1) {\n+                    return List.of(ERROR_DUPLICATE_PROVIDER_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2212415e7b0427bb939ad359710bca887d161791"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODczNjYyNw==", "bodyText": "We could move this duplicate validation into the database accessors.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/934#discussion_r398736627", "createdAt": "2020-03-26T17:00:31Z", "author": {"login": "jamesrichard91"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/ui/ProviderGlobalUIConfig.java", "diffHunk": "@@ -58,4 +74,29 @@ public ProviderKey getProviderKey() {\n         return providerKey;\n     }\n \n+    private Collection<String> validateDuplicateNames(FieldValueModel fieldToValidate, FieldModel fieldModel) {\n+        try {\n+            List<ConfigurationModel> configurations = configurationAccessor.getConfigurationsByDescriptorType(DescriptorType.PROVIDER);\n+            if (!configurations.isEmpty()) {\n+                List<ConfigurationModel> modelsWithName = configurations.stream()\n+                                                              .filter(configurationModel ->\n+                                                                          configurationModel.getField(ProviderDescriptor.KEY_PROVIDER_CONFIG_NAME)\n+                                                                              .flatMap(ConfigurationFieldModel::getFieldValue)\n+                                                                              .filter(configName -> configName.equals(fieldToValidate.getValue().orElse(\"\")))\n+                                                                              .isPresent())\n+                                                              .collect(Collectors.toList());\n+                if (modelsWithName.size() > 1) {\n+                    return List.of(ERROR_DUPLICATE_PROVIDER_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2NzYzMg=="}, "originalCommit": {"oid": "2212415e7b0427bb939ad359710bca887d161791"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgxNjQ5Ng==", "bodyText": "A database exception won't get associated as a field exception and then we can't display the error of a duplicate name with the name text field in the form.  We perform the same validation with job names and construct the the field exception in the JobConfigActions.  If I throw a database exception it won't be tied to a field.  We should add a constraint to the database that the configuration name be unique", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/934#discussion_r398816496", "createdAt": "2020-03-26T18:55:13Z", "author": {"login": "psantos1113"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/ui/ProviderGlobalUIConfig.java", "diffHunk": "@@ -58,4 +74,29 @@ public ProviderKey getProviderKey() {\n         return providerKey;\n     }\n \n+    private Collection<String> validateDuplicateNames(FieldValueModel fieldToValidate, FieldModel fieldModel) {\n+        try {\n+            List<ConfigurationModel> configurations = configurationAccessor.getConfigurationsByDescriptorType(DescriptorType.PROVIDER);\n+            if (!configurations.isEmpty()) {\n+                List<ConfigurationModel> modelsWithName = configurations.stream()\n+                                                              .filter(configurationModel ->\n+                                                                          configurationModel.getField(ProviderDescriptor.KEY_PROVIDER_CONFIG_NAME)\n+                                                                              .flatMap(ConfigurationFieldModel::getFieldValue)\n+                                                                              .filter(configName -> configName.equals(fieldToValidate.getValue().orElse(\"\")))\n+                                                                              .isPresent())\n+                                                              .collect(Collectors.toList());\n+                if (modelsWithName.size() > 1) {\n+                    return List.of(ERROR_DUPLICATE_PROVIDER_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2NzYzMg=="}, "originalCommit": {"oid": "2212415e7b0427bb939ad359710bca887d161791"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgxODMzNQ==", "bodyText": "My bad, I realize this is the validator, not the endpoint.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/934#discussion_r398818335", "createdAt": "2020-03-26T18:58:10Z", "author": {"login": "gkillough"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/ui/ProviderGlobalUIConfig.java", "diffHunk": "@@ -58,4 +74,29 @@ public ProviderKey getProviderKey() {\n         return providerKey;\n     }\n \n+    private Collection<String> validateDuplicateNames(FieldValueModel fieldToValidate, FieldModel fieldModel) {\n+        try {\n+            List<ConfigurationModel> configurations = configurationAccessor.getConfigurationsByDescriptorType(DescriptorType.PROVIDER);\n+            if (!configurations.isEmpty()) {\n+                List<ConfigurationModel> modelsWithName = configurations.stream()\n+                                                              .filter(configurationModel ->\n+                                                                          configurationModel.getField(ProviderDescriptor.KEY_PROVIDER_CONFIG_NAME)\n+                                                                              .flatMap(ConfigurationFieldModel::getFieldValue)\n+                                                                              .filter(configName -> configName.equals(fieldToValidate.getValue().orElse(\"\")))\n+                                                                              .isPresent())\n+                                                              .collect(Collectors.toList());\n+                if (modelsWithName.size() > 1) {\n+                    return List.of(ERROR_DUPLICATE_PROVIDER_NAME);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2NzYzMg=="}, "originalCommit": {"oid": "2212415e7b0427bb939ad359710bca887d161791"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTUyMDc3OnYy", "diffSide": "RIGHT", "path": "src/main/js/Navigation.js", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNTozNTowM1rOF8M1pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNTo1NToyOVrOF8N2YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2OTIyMQ==", "bodyText": "Anything we can do to make this more dynamic? We should have a display name in the provider metadata no?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/934#discussion_r398669221", "createdAt": "2020-03-26T15:35:03Z", "author": {"login": "gkillough"}, "path": "src/main/js/Navigation.js", "diffHunk": "@@ -40,12 +40,18 @@ class Navigation extends Component {\n \n     render() {\n         const channelGlobals = this.createNavItemForDescriptors(DescriptorUtilities.DESCRIPTOR_TYPE.CHANNEL, DescriptorUtilities.CONTEXT_TYPE.GLOBAL, '/alert/channels/', 'Channels');\n-        const providers = this.createNavItemForDescriptors(DescriptorUtilities.DESCRIPTOR_TYPE.PROVIDER, DescriptorUtilities.CONTEXT_TYPE.GLOBAL, '/alert/providers/', 'Providers');\n         const components = this.createNavItemForDescriptors(DescriptorUtilities.DESCRIPTOR_TYPE.COMPONENT, DescriptorUtilities.CONTEXT_TYPE.GLOBAL, '/alert/components/');\n \n         const nav = (\n             <Fragment>\n-                {providers}\n+                <li className=\"navHeader\">\n+                    Providers\n+                </li>\n+                <li>\n+                    <NavLink to=\"/alert/providers/blackduck\" activeClassName=\"activeNav\">\n+                        Black Duck\n+                    </NavLink>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2212415e7b0427bb939ad359710bca887d161791"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY4NTc5Mw==", "bodyText": "I should be able to iterate through the providers to make it more dynamic.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/934#discussion_r398685793", "createdAt": "2020-03-26T15:55:29Z", "author": {"login": "psantos1113"}, "path": "src/main/js/Navigation.js", "diffHunk": "@@ -40,12 +40,18 @@ class Navigation extends Component {\n \n     render() {\n         const channelGlobals = this.createNavItemForDescriptors(DescriptorUtilities.DESCRIPTOR_TYPE.CHANNEL, DescriptorUtilities.CONTEXT_TYPE.GLOBAL, '/alert/channels/', 'Channels');\n-        const providers = this.createNavItemForDescriptors(DescriptorUtilities.DESCRIPTOR_TYPE.PROVIDER, DescriptorUtilities.CONTEXT_TYPE.GLOBAL, '/alert/providers/', 'Providers');\n         const components = this.createNavItemForDescriptors(DescriptorUtilities.DESCRIPTOR_TYPE.COMPONENT, DescriptorUtilities.CONTEXT_TYPE.GLOBAL, '/alert/components/');\n \n         const nav = (\n             <Fragment>\n-                {providers}\n+                <li className=\"navHeader\">\n+                    Providers\n+                </li>\n+                <li>\n+                    <NavLink to=\"/alert/providers/blackduck\" activeClassName=\"activeNav\">\n+                        Black Duck\n+                    </NavLink>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2OTIyMQ=="}, "originalCommit": {"oid": "2212415e7b0427bb939ad359710bca887d161791"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MTU0MjAwOnYy", "diffSide": "RIGHT", "path": "src/main/js/store/actions/globalConfiguration.js", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNTozOTowNlrOF8NC2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNTo1Njo0MlrOF8N6Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY3MjYwMA==", "bodyText": "Are we storing the CSRF token as a cookie?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/934#discussion_r398672600", "createdAt": "2020-03-26T15:39:06Z", "author": {"login": "gkillough"}, "path": "src/main/js/store/actions/globalConfiguration.js", "diffHunk": "@@ -152,6 +167,27 @@ export function refreshConfig(id) {\n     };\n }\n \n+export function getAllConfigs(descriptorName) {\n+    return (dispatch, getState) => {\n+        dispatch(fetchingConfig());\n+        const { csrfToken } = getState().session;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2212415e7b0427bb939ad359710bca887d161791"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY4Njc3NQ==", "bodyText": "The CSRF token is stored in the redux state for the application.  When you login we update the redux state with the CSRF token for the application.  It isn't stored as a cookie.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/934#discussion_r398686775", "createdAt": "2020-03-26T15:56:42Z", "author": {"login": "psantos1113"}, "path": "src/main/js/store/actions/globalConfiguration.js", "diffHunk": "@@ -152,6 +167,27 @@ export function refreshConfig(id) {\n     };\n }\n \n+export function getAllConfigs(descriptorName) {\n+    return (dispatch, getState) => {\n+        dispatch(fetchingConfig());\n+        const { csrfToken } = getState().session;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY3MjYwMA=="}, "originalCommit": {"oid": "2212415e7b0427bb939ad359710bca887d161791"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MjAzMDYyOnYy", "diffSide": "RIGHT", "path": "src/main/js/providers/ProviderTable.js", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNzoyMTozNFrOF8R3_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNzoyMTozNFrOF8R3_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc1MTc0Mw==", "bodyText": "I dont think this method name makes sense. Maybe checkGlobalPermissions ?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/934#discussion_r398751743", "createdAt": "2020-03-26T17:21:34Z", "author": {"login": "jamesrichard91"}, "path": "src/main/js/providers/ProviderTable.js", "diffHunk": "@@ -0,0 +1,363 @@\n+import React, { Component } from 'react';\n+import { connect } from 'react-redux';\n+import { withRouter } from 'react-router-dom';\n+import ConfigurationLabel from 'component/common/ConfigurationLabel';\n+import PropTypes from 'prop-types';\n+import { clearConfigFieldErrors, deleteConfig, getAllConfigs, testConfig, updateConfig } from 'store/actions/globalConfiguration';\n+import * as DescriptorUtilities from 'util/descriptorUtilities';\n+import * as FieldModelUtilities from 'util/fieldModelUtilities';\n+import TableDisplay from 'field/TableDisplay';\n+import FieldsPanel from 'field/FieldsPanel';\n+import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\n+\n+const ProviderCommonKeys = {\n+    KEY_NAME: 'provider.common.config.name',\n+    KEY_ENABLED: 'provider.common.config.enabled'\n+}\n+\n+class ProviderTable extends Component {\n+    constructor(props) {\n+        super(props);\n+        this.createTableData = this.createTableData.bind(this);\n+        this.retrieveData = this.retrieveData.bind(this);\n+        this.clearModalFieldState = this.clearModalFieldState.bind(this);\n+        this.createColumns = this.createColumns.bind(this);\n+        this.handleChange = this.handleChange.bind(this);\n+        this.onSave = this.onSave.bind(this);\n+        this.onTest = this.onTest.bind(this);\n+        this.onConfigClose = this.onConfigClose.bind(this);\n+        this.onDelete = this.onDelete.bind(this);\n+        this.createModalFields = this.createModalFields.bind(this);\n+        this.onEdit = this.onEdit.bind(this);\n+        this.onCopy = this.onCopy.bind(this);\n+        this.combineModelWithDefaults = this.combineModelWithDefaults.bind(this);\n+\n+        this.state = {\n+            descriptor: null,\n+            providerConfig: {},\n+            saveCallback: () => null\n+        };\n+    }\n+\n+    componentDidMount() {\n+        const descriptor = this.props.descriptors.find(descriptor => descriptor.name === this.props.descriptorName\n+            && descriptor.context === DescriptorUtilities.CONTEXT_TYPE.GLOBAL)\n+        if (descriptor) {\n+            const emptyConfig = FieldModelUtilities.createFieldModelWithDefaults(descriptor.fields, DescriptorUtilities.CONTEXT_TYPE.GLOBAL, descriptor.name);\n+            this.setState({\n+                descriptor,\n+                providerConfig: emptyConfig\n+            });\n+            this.props.getAllConfigs(descriptor.name);\n+        }\n+    }\n+\n+    componentDidUpdate(prevProps) {\n+        if (prevProps.updateStatus === 'UPDATING' && (this.props.updateStatus === 'UPDATED' || this.props.updateStatus === 'ERROR')) {\n+            this.state.saveCallback(true);\n+        }\n+    }\n+\n+    combineModelWithDefaults(providerConfig) {\n+        const { descriptor } = this.state;\n+        if (!descriptor) {\n+            return {};\n+        }\n+        const emptyConfig = FieldModelUtilities.createFieldModelWithDefaults(descriptor.fields, DescriptorUtilities.CONTEXT_TYPE.GLOBAL, descriptor.name);\n+        const updatedFieldModel = FieldModelUtilities.combineFieldModels(emptyConfig, providerConfig);\n+        if (providerConfig.id) {\n+            updatedFieldModel.id = providerConfig.id;\n+        }\n+        return updatedFieldModel;\n+    }\n+\n+    createColumns() {\n+        return [\n+            {\n+                header: 'id',\n+                headerLabel: 'Id',\n+                isKey: true,\n+                hidden: true\n+            },\n+            {\n+                header: 'name',\n+                headerLabel: 'Name',\n+                isKey: false,\n+                hidden: false\n+            },\n+            {\n+                header: 'createdAt',\n+                headerLabel: 'Created At',\n+                isKey: false,\n+                hidden: false\n+            },\n+            {\n+                header: 'lastUpdated',\n+                headerLabel: 'Last Updated',\n+                isKey: false,\n+                hidden: false\n+            },\n+            {\n+                header: 'enabled',\n+                headerLabel: 'Enabled',\n+                isKey: false,\n+                hidden: false,\n+                dataFormat: this.enabledState\n+            }\n+        ];\n+    }\n+\n+    enabledState(cell) {\n+        const icon = (cell == 'true') ? 'check' : 'times';\n+        const color = (cell == 'true') ? 'synopsysGreen' : 'synopsysRed';\n+        const className = `alert-icon ${color}`;\n+\n+        return (\n+            <div className=\"btn btn-link jobIconButton\">\n+                <FontAwesomeIcon icon={icon} className={className} size=\"lg\" />\n+            </div>\n+        );\n+    }\n+\n+    onConfigClose(callback) {\n+        this.props.clearFieldErrors();\n+        callback();\n+    }\n+\n+    clearModalFieldState() {\n+        if (this.state.providerConfig && Object.keys(this.state.providerConfig).length > 0) {\n+            this.setState({\n+                providerConfig: {}\n+            });\n+        }\n+    }\n+\n+    retrieveData() {\n+        const { descriptor } = this.state;\n+        if (descriptor) {\n+            this.props.getAllConfigs(descriptor.name);\n+        }\n+    }\n+\n+    handleChange(e) {\n+        const { name, value, type, checked } = e.target;\n+        const { providerConfig } = this.state;\n+\n+        const updatedValue = type === 'checkbox' ? checked.toString().toLowerCase() === 'true' : value;\n+        const newProviderConfig = Object.assign(providerConfig, FieldModelUtilities.updateFieldModelSingleValue(providerConfig, name, updatedValue));\n+\n+        this.setState({\n+            providerConfig: newProviderConfig\n+        });\n+    }\n+\n+    onSave(callback) {\n+        const { providerConfig } = this.state;\n+        const configToUpdate = this.combineModelWithDefaults(providerConfig);\n+        this.props.updateConfig(configToUpdate);\n+        this.setState({\n+            saveCallback: callback\n+        });\n+        return true;\n+    }\n+\n+    onTest(callback) {\n+        const { providerConfig } = this.state;\n+        const configToUpdate = this.combineModelWithDefaults(providerConfig);\n+        this.props.testConfig(configToUpdate, '');\n+        callback(true);\n+        return true;\n+    }\n+\n+    onDelete(configsToDelete, callback) {\n+        if (configsToDelete) {\n+            configsToDelete.forEach(configId => {\n+                this.props.deleteConfig(configId);\n+            });\n+        }\n+        callback();\n+        this.retrieveData();\n+    }\n+\n+    createModalFields() {\n+        const { providerConfig, descriptor } = this.state;\n+        const { fieldErrors } = this.props;\n+        const newConfig = this.combineModelWithDefaults(providerConfig);\n+        if (descriptor) {\n+            return (\n+                <div>\n+                    <FieldsPanel\n+                        descriptorFields={descriptor.fields}\n+                        self={this}\n+                        fieldErrors={fieldErrors}\n+                        stateName={'providerConfig'}\n+                        currentConfig={newConfig}\n+                    />\n+                </div>\n+            );\n+        }\n+        return <div />;\n+    }\n+\n+    onEdit(selectedRow, callback) {\n+        const { id } = selectedRow;\n+        const { providerConfigs } = this.props;\n+        const selectedConfig = providerConfigs.find(config => config.id === id);\n+        this.setState({\n+            providerConfig: selectedConfig\n+        }, callback);\n+    }\n+\n+    onCopy(selectedRow, callback) {\n+        const { id } = selectedRow;\n+        const { providerConfigs } = this.props;\n+        let selectedConfig = providerConfigs.find(config => config.id === id);\n+        const { descriptor } = this.state;\n+        if (descriptor) {\n+            descriptor.fields.forEach(field => {\n+                if (field.sensitive) {\n+                    selectedConfig = FieldModelUtilities.updateFieldModelSingleValue(selectedConfig, field.key, \"\");\n+                }\n+            });\n+        }\n+\n+        selectedConfig.id = null;\n+        this.setState({\n+            providerConfig: selectedConfig\n+        }, callback);\n+    }\n+\n+    checkJobPermissions(operation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2212415e7b0427bb939ad359710bca887d161791"}, "originalPosition": 230}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1944, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}