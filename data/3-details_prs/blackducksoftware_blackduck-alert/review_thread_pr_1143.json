{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1NDk5NTU4", "number": 1143, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNjozODo0MVrOEd0RqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzowODowMlrOEd02ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzAwNjQ5OnYy", "diffSide": "RIGHT", "path": "alert-database/src/main/java/com/synopsys/integration/alert/database/api/DefaultConfigurationAccessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNjozODo0MVrOHJNQmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzowMzo0MFrOHJOCZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQxNjQ3NA==", "bodyText": "It seems odd that we need to add these flushes throughout our code.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1143#discussion_r479416474", "createdAt": "2020-08-28T16:38:41Z", "author": {"login": "jamesrichard91"}, "path": "alert-database/src/main/java/com/synopsys/integration/alert/database/api/DefaultConfigurationAccessor.java", "diffHunk": "@@ -325,6 +325,7 @@ public ConfigurationModel updateConfiguration(Long descriptorConfigId, Collectio\n \n         List<FieldValueEntity> oldValues = fieldValueRepository.findByConfigId(descriptorConfigId);\n         fieldValueRepository.deleteAll(oldValues);\n+        fieldValueRepository.flush();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ea82fbb9bc96c4880b900a001b342b6dbe543c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQyOTIyMA==", "bodyText": "Yeah, seems like a code smell, but it shouldn't cause an issue other than a minor performance hit.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1143#discussion_r479429220", "createdAt": "2020-08-28T17:03:40Z", "author": {"login": "gkillough"}, "path": "alert-database/src/main/java/com/synopsys/integration/alert/database/api/DefaultConfigurationAccessor.java", "diffHunk": "@@ -325,6 +325,7 @@ public ConfigurationModel updateConfiguration(Long descriptorConfigId, Collectio\n \n         List<FieldValueEntity> oldValues = fieldValueRepository.findByConfigId(descriptorConfigId);\n         fieldValueRepository.deleteAll(oldValues);\n+        fieldValueRepository.flush();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQxNjQ3NA=="}, "originalCommit": {"oid": "b6ea82fbb9bc96c4880b900a001b342b6dbe543c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzA0NDY0OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/synopsys/integration/alert/channel/azure/boards/actions/AzureBoardsGlobalApiAction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNjo1MDozMFrOHJNn6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNjo1MDozMFrOHJNn6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQyMjQ0MA==", "bodyText": "I think this method should take in only a ConfigurationModel and return a Map<String, FieldValueModel> object. Then wherever we generate the Optional, we instead call map and pass this method as a method reference. Then just return the new object like we do on line 93. Does that make sense?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1143#discussion_r479422440", "createdAt": "2020-08-28T16:50:30Z", "author": {"login": "bamandel"}, "path": "src/main/java/com/synopsys/integration/alert/channel/azure/boards/actions/AzureBoardsGlobalApiAction.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * blackduck-alert\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.channel.azure.boards.actions;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import com.synopsys.integration.alert.channel.azure.boards.descriptor.AzureBoardsDescriptor;\n+import com.synopsys.integration.alert.common.action.ApiAction;\n+import com.synopsys.integration.alert.common.descriptor.DescriptorKey;\n+import com.synopsys.integration.alert.common.descriptor.DescriptorMap;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.exception.AlertException;\n+import com.synopsys.integration.alert.common.persistence.accessor.ConfigurationAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationModel;\n+import com.synopsys.integration.alert.common.persistence.util.ConfigurationFieldModelConverter;\n+import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.alert.common.rest.model.FieldValueModel;\n+\n+@Component\n+public class AzureBoardsGlobalApiAction extends ApiAction {\n+    private ConfigurationAccessor configurationAccessor;\n+    private DescriptorMap descriptorMap;\n+    private ConfigurationFieldModelConverter fieldModelConverter;\n+\n+    @Autowired\n+    public AzureBoardsGlobalApiAction(ConfigurationAccessor configurationAccessor, DescriptorMap descriptorMap, ConfigurationFieldModelConverter configurationFieldModelConverter) {\n+        this.configurationAccessor = configurationAccessor;\n+        this.descriptorMap = descriptorMap;\n+        this.fieldModelConverter = configurationFieldModelConverter;\n+    }\n+\n+    @Override\n+    public FieldModel beforeSaveAction(FieldModel fieldModel) throws AlertException {\n+        FieldModel updatedFieldModel = super.beforeSaveAction(fieldModel);\n+        Optional<DescriptorKey> descriptorKey = descriptorMap.getDescriptorKey(fieldModel.getDescriptorName());\n+\n+        if (descriptorKey.isPresent()) {\n+            ConfigContextEnum context = ConfigContextEnum.valueOf(fieldModel.getContext());\n+            List<ConfigurationModel> existingConfig = configurationAccessor.getConfigurationsByDescriptorKeyAndContext(descriptorKey.get(), context);\n+            Optional<ConfigurationModel> configurationModel = existingConfig.stream()\n+                                                                  .findFirst();\n+            updatedFieldModel = updateTokenFields(updatedFieldModel, configurationModel);\n+        }\n+        return updatedFieldModel;\n+    }\n+\n+    @Override\n+    public FieldModel beforeUpdateAction(FieldModel fieldModel) throws AlertException {\n+        FieldModel updatedFieldModel = super.beforeUpdateAction(fieldModel);\n+        Optional<ConfigurationModel> existingConfig = configurationAccessor.getConfigurationById(Long.valueOf(fieldModel.getId()));\n+        return updateTokenFields(updatedFieldModel, existingConfig);\n+    }\n+\n+    private FieldModel updateTokenFields(FieldModel fieldModel, Optional<ConfigurationModel> existingConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ea82fbb9bc96c4880b900a001b342b6dbe543c"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzEwMDU4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/synopsys/integration/alert/channel/azure/boards/actions/AzureBoardsGlobalApiAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzowODowMlrOHJOLFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxNzoxODoyNlrOHJOevg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQzMTQ0NA==", "bodyText": "Do we always want to prefer what's in the DB? Or should we use the value of the FieldValueModel if it has one?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1143#discussion_r479431444", "createdAt": "2020-08-28T17:08:02Z", "author": {"login": "gkillough"}, "path": "src/main/java/com/synopsys/integration/alert/channel/azure/boards/actions/AzureBoardsGlobalApiAction.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * blackduck-alert\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.channel.azure.boards.actions;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import com.synopsys.integration.alert.channel.azure.boards.descriptor.AzureBoardsDescriptor;\n+import com.synopsys.integration.alert.common.action.ApiAction;\n+import com.synopsys.integration.alert.common.descriptor.DescriptorKey;\n+import com.synopsys.integration.alert.common.descriptor.DescriptorMap;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.exception.AlertException;\n+import com.synopsys.integration.alert.common.persistence.accessor.ConfigurationAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationModel;\n+import com.synopsys.integration.alert.common.persistence.util.ConfigurationFieldModelConverter;\n+import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.alert.common.rest.model.FieldValueModel;\n+\n+@Component\n+public class AzureBoardsGlobalApiAction extends ApiAction {\n+    private ConfigurationAccessor configurationAccessor;\n+    private DescriptorMap descriptorMap;\n+    private ConfigurationFieldModelConverter fieldModelConverter;\n+\n+    @Autowired\n+    public AzureBoardsGlobalApiAction(ConfigurationAccessor configurationAccessor, DescriptorMap descriptorMap, ConfigurationFieldModelConverter configurationFieldModelConverter) {\n+        this.configurationAccessor = configurationAccessor;\n+        this.descriptorMap = descriptorMap;\n+        this.fieldModelConverter = configurationFieldModelConverter;\n+    }\n+\n+    @Override\n+    public FieldModel beforeSaveAction(FieldModel fieldModel) throws AlertException {\n+        FieldModel updatedFieldModel = super.beforeSaveAction(fieldModel);\n+        Optional<DescriptorKey> descriptorKey = descriptorMap.getDescriptorKey(fieldModel.getDescriptorName());\n+\n+        if (descriptorKey.isPresent()) {\n+            ConfigContextEnum context = ConfigContextEnum.valueOf(fieldModel.getContext());\n+            List<ConfigurationModel> existingConfig = configurationAccessor.getConfigurationsByDescriptorKeyAndContext(descriptorKey.get(), context);\n+            Optional<ConfigurationModel> configurationModel = existingConfig.stream()\n+                                                                  .findFirst();\n+            updatedFieldModel = updateTokenFields(updatedFieldModel, configurationModel);\n+        }\n+        return updatedFieldModel;\n+    }\n+\n+    @Override\n+    public FieldModel beforeUpdateAction(FieldModel fieldModel) throws AlertException {\n+        FieldModel updatedFieldModel = super.beforeUpdateAction(fieldModel);\n+        Optional<ConfigurationModel> existingConfig = configurationAccessor.getConfigurationById(Long.valueOf(fieldModel.getId()));\n+        return updateTokenFields(updatedFieldModel, existingConfig);\n+    }\n+\n+    private FieldModel updateTokenFields(FieldModel fieldModel, Optional<ConfigurationModel> existingConfig) {\n+        Map<String, FieldValueModel> keyToValues = new HashMap<>(fieldModel.getKeyToValues());\n+        if (existingConfig.isPresent()) {\n+            ConfigurationModel configurationModel = existingConfig.get();\n+            Map<String, FieldValueModel> existingFields = fieldModelConverter.convertToFieldValuesMap(configurationModel.getCopyOfFieldList());\n+\n+            // These fields are saved in the OAuth callback controller so we need to preserve their values on a save or an update.\n+            updateMapWithMissingField(AzureBoardsDescriptor.KEY_ACCESS_TOKEN, existingFields, keyToValues);\n+            updateMapWithMissingField(AzureBoardsDescriptor.KEY_REFRESH_TOKEN, existingFields, keyToValues);\n+            updateMapWithMissingField(AzureBoardsDescriptor.KEY_TOKEN_EXPIRATION_MILLIS, existingFields, keyToValues);\n+            updateMapWithMissingField(AzureBoardsDescriptor.KEY_OAUTH_USER_EMAIL, existingFields, keyToValues);\n+        }\n+\n+        return new FieldModel(fieldModel.getDescriptorName(), fieldModel.getContext(), fieldModel.getCreatedAt(), fieldModel.getLastUpdated(), keyToValues);\n+    }\n+\n+    private void updateMapWithMissingField(String key, Map<String, FieldValueModel> databaseFields, Map<String, FieldValueModel> fieldModelFields) {\n+        if (databaseFields.containsKey(key)) {\n+            fieldModelFields.put(key, databaseFields.get(key));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6ea82fbb9bc96c4880b900a001b342b6dbe543c"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQzNjQ3OA==", "bodyText": "The fieldModel on a save will not have the token fields.  They aren't rendered at all in the UI, therefore the FieldModel we are trying to save will be missing those values always.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1143#discussion_r479436478", "createdAt": "2020-08-28T17:18:26Z", "author": {"login": "psantos1113"}, "path": "src/main/java/com/synopsys/integration/alert/channel/azure/boards/actions/AzureBoardsGlobalApiAction.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * blackduck-alert\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.channel.azure.boards.actions;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n+\n+import com.synopsys.integration.alert.channel.azure.boards.descriptor.AzureBoardsDescriptor;\n+import com.synopsys.integration.alert.common.action.ApiAction;\n+import com.synopsys.integration.alert.common.descriptor.DescriptorKey;\n+import com.synopsys.integration.alert.common.descriptor.DescriptorMap;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.exception.AlertException;\n+import com.synopsys.integration.alert.common.persistence.accessor.ConfigurationAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationModel;\n+import com.synopsys.integration.alert.common.persistence.util.ConfigurationFieldModelConverter;\n+import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.alert.common.rest.model.FieldValueModel;\n+\n+@Component\n+public class AzureBoardsGlobalApiAction extends ApiAction {\n+    private ConfigurationAccessor configurationAccessor;\n+    private DescriptorMap descriptorMap;\n+    private ConfigurationFieldModelConverter fieldModelConverter;\n+\n+    @Autowired\n+    public AzureBoardsGlobalApiAction(ConfigurationAccessor configurationAccessor, DescriptorMap descriptorMap, ConfigurationFieldModelConverter configurationFieldModelConverter) {\n+        this.configurationAccessor = configurationAccessor;\n+        this.descriptorMap = descriptorMap;\n+        this.fieldModelConverter = configurationFieldModelConverter;\n+    }\n+\n+    @Override\n+    public FieldModel beforeSaveAction(FieldModel fieldModel) throws AlertException {\n+        FieldModel updatedFieldModel = super.beforeSaveAction(fieldModel);\n+        Optional<DescriptorKey> descriptorKey = descriptorMap.getDescriptorKey(fieldModel.getDescriptorName());\n+\n+        if (descriptorKey.isPresent()) {\n+            ConfigContextEnum context = ConfigContextEnum.valueOf(fieldModel.getContext());\n+            List<ConfigurationModel> existingConfig = configurationAccessor.getConfigurationsByDescriptorKeyAndContext(descriptorKey.get(), context);\n+            Optional<ConfigurationModel> configurationModel = existingConfig.stream()\n+                                                                  .findFirst();\n+            updatedFieldModel = updateTokenFields(updatedFieldModel, configurationModel);\n+        }\n+        return updatedFieldModel;\n+    }\n+\n+    @Override\n+    public FieldModel beforeUpdateAction(FieldModel fieldModel) throws AlertException {\n+        FieldModel updatedFieldModel = super.beforeUpdateAction(fieldModel);\n+        Optional<ConfigurationModel> existingConfig = configurationAccessor.getConfigurationById(Long.valueOf(fieldModel.getId()));\n+        return updateTokenFields(updatedFieldModel, existingConfig);\n+    }\n+\n+    private FieldModel updateTokenFields(FieldModel fieldModel, Optional<ConfigurationModel> existingConfig) {\n+        Map<String, FieldValueModel> keyToValues = new HashMap<>(fieldModel.getKeyToValues());\n+        if (existingConfig.isPresent()) {\n+            ConfigurationModel configurationModel = existingConfig.get();\n+            Map<String, FieldValueModel> existingFields = fieldModelConverter.convertToFieldValuesMap(configurationModel.getCopyOfFieldList());\n+\n+            // These fields are saved in the OAuth callback controller so we need to preserve their values on a save or an update.\n+            updateMapWithMissingField(AzureBoardsDescriptor.KEY_ACCESS_TOKEN, existingFields, keyToValues);\n+            updateMapWithMissingField(AzureBoardsDescriptor.KEY_REFRESH_TOKEN, existingFields, keyToValues);\n+            updateMapWithMissingField(AzureBoardsDescriptor.KEY_TOKEN_EXPIRATION_MILLIS, existingFields, keyToValues);\n+            updateMapWithMissingField(AzureBoardsDescriptor.KEY_OAUTH_USER_EMAIL, existingFields, keyToValues);\n+        }\n+\n+        return new FieldModel(fieldModel.getDescriptorName(), fieldModel.getContext(), fieldModel.getCreatedAt(), fieldModel.getLastUpdated(), keyToValues);\n+    }\n+\n+    private void updateMapWithMissingField(String key, Map<String, FieldValueModel> databaseFields, Map<String, FieldValueModel> fieldModelFields) {\n+        if (databaseFields.containsKey(key)) {\n+            fieldModelFields.put(key, databaseFields.get(key));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQzMTQ0NA=="}, "originalCommit": {"oid": "b6ea82fbb9bc96c4880b900a001b342b6dbe543c"}, "originalPosition": 99}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1709, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}