{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2MjMxMzQw", "number": 958, "title": "Increasing coverage on database apis", "bodyText": "Increasing the test coverage of our alert.database.api package by adding in new unit tests. In the future I will split a new MR into fewer new test classes in order to make future PRs smaller.", "createdAt": "2020-04-20T18:37:13Z", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958", "merged": true, "mergeCommit": {"oid": "a23d739ec79fe4128d720f5e3ad5ddb0a6321354"}, "closed": true, "closedAt": "2020-04-21T19:44:23Z", "author": {"login": "ChomickiM"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcUFIrHAH2gAyNDA2MjMxMzQwOjM3ZmZjYTM4NzI2YWJlZWE4N2Y2OGQ5YTg5MzI5YjRmMmFmMjNjNTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZ46NPgFqTM5NzYxMjU5NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "37ffca38726abeea87f68d9a89329b4f2af23c51", "author": {"user": {"login": "ChomickiM", "name": "Martin"}}, "url": "https://github.com/blackducksoftware/blackduck-alert/commit/37ffca38726abeea87f68d9a89329b4f2af23c51", "committedDate": "2020-04-03T18:23:34Z", "message": "test: Adding new test and increasing test coverage for DefaultAuditUtilittyTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fe424e41585b743586321bac5314a74e7bff843", "author": {"user": {"login": "ChomickiM", "name": "Martin"}}, "url": "https://github.com/blackducksoftware/blackduck-alert/commit/9fe424e41585b743586321bac5314a74e7bff843", "committedDate": "2020-04-07T14:53:27Z", "message": "test: Refactoring DefaultAuditUtilityTest to increase method coverage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d837b4709e6217c4657aed1ad167e637b5fa27ed", "author": {"user": {"login": "ChomickiM", "name": "Martin"}}, "url": "https://github.com/blackducksoftware/blackduck-alert/commit/d837b4709e6217c4657aed1ad167e637b5fa27ed", "committedDate": "2020-04-08T18:27:18Z", "message": "test: Increasing test coverage for DefaultSystemStatusUtility"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef0e3cf12db9aa07bdf04144c14091c304eece23", "author": {"user": {"login": "ChomickiM", "name": "Martin"}}, "url": "https://github.com/blackducksoftware/blackduck-alert/commit/ef0e3cf12db9aa07bdf04144c14091c304eece23", "committedDate": "2020-04-09T19:29:21Z", "message": "refactor: Add constructor and changing public variable to private"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91907753baeef0fca69d9909a66b09572cccbcef", "author": {"user": {"login": "ChomickiM", "name": "Martin"}}, "url": "https://github.com/blackducksoftware/blackduck-alert/commit/91907753baeef0fca69d9909a66b09572cccbcef", "committedDate": "2020-04-10T13:21:53Z", "message": "test: Increasing test coverage for DefaultAuthenticationTypeAccessor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d454430ff2324b2ea5f9a92739fc02a8ffada790", "author": {"user": {"login": "ChomickiM", "name": "Martin"}}, "url": "https://github.com/blackducksoftware/blackduck-alert/commit/d454430ff2324b2ea5f9a92739fc02a8ffada790", "committedDate": "2020-04-15T14:18:41Z", "message": "test: Increasing test coverage on DefaultSettingsKeyAccessor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c5ba094637ed22f8d41aa874acad9a2e1199287", "author": {"user": {"login": "ChomickiM", "name": "Martin"}}, "url": "https://github.com/blackducksoftware/blackduck-alert/commit/9c5ba094637ed22f8d41aa874acad9a2e1199287", "committedDate": "2020-04-20T18:06:20Z", "message": "test: Increasing test coverage for DefaultDescriptorAccessor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e", "author": {"user": {"login": "ChomickiM", "name": "Martin"}}, "url": "https://github.com/blackducksoftware/blackduck-alert/commit/f855c6c40784106fd56df471fac6564d533acc8e", "committedDate": "2020-04-20T18:07:32Z", "message": "Merge remote-tracking branch 'origin/master' into mc_db_api_tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NzE0NTkz", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#pullrequestreview-396714593", "createdAt": "2020-04-20T18:40:34Z", "commit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODo0MDozNFrOGIiX5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODo0MDozNFrOGIiX5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNDk2NQ==", "bodyText": "We created these \"mock\" repositories for test purposes so that we can control the functionality within repository and do not have to mock out the returns from each of these methods since these repositories were easier to implement than others.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r411604965", "createdAt": "2020-04-20T18:40:34Z", "author": {"login": "ChomickiM"}, "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/mock/MockSettingsKeyRepository.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.synopsys.integration.alert.database.api.mock;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.springframework.data.domain.Example;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.domain.Sort;\n+\n+import com.synopsys.integration.alert.database.settings.SettingsKeyEntity;\n+import com.synopsys.integration.alert.database.settings.SettingsKeyRepository;\n+\n+public class MockSettingsKeyRepository implements SettingsKeyRepository {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NzE0Nzgx", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#pullrequestreview-396714781", "createdAt": "2020-04-20T18:40:49Z", "commit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODo0MDo0OVrOGIiYpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODo0MDo0OVrOGIiYpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNTE1Ng==", "bodyText": "Same as above.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r411605156", "createdAt": "2020-04-20T18:40:49Z", "author": {"login": "ChomickiM"}, "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/mock/MockSystemStatusRepository.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.synopsys.integration.alert.database.api.mock;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.springframework.data.domain.Example;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.domain.Sort;\n+\n+import com.synopsys.integration.alert.database.system.SystemStatus;\n+import com.synopsys.integration.alert.database.system.SystemStatusRepository;\n+\n+public class MockSystemStatusRepository implements SystemStatusRepository {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MjY5MzQ1", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#pullrequestreview-397269345", "createdAt": "2020-04-21T12:15:04Z", "commit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMjoxNTowNFrOGJCfww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMjoxNTowNFrOGJCfww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEzMTI2Nw==", "bodyText": "Do we want serialVersionUIDs explicitly defined for database entities? We are not maintaining backward-compatible POJOs (liquibase handles data migration, so we never need intermediate Java Objects), so I'm not convinced that we gain any value from having it.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412131267", "createdAt": "2020-04-21T12:15:04Z", "author": {"login": "gkillough"}, "path": "alert-database/src/main/java/com/synopsys/integration/alert/database/user/AuthenticationTypeEntity.java", "diffHunk": "@@ -31,13 +31,18 @@\n @Entity\n @Table(schema = \"alert\", name = \"authentication_type\")\n public class AuthenticationTypeEntity extends DatabaseEntity {\n+    private static final long serialVersionUID = -2308934073112918860L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MjcwNzAx", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#pullrequestreview-397270701", "createdAt": "2020-04-21T12:16:55Z", "commit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MjkzODY5", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#pullrequestreview-397293869", "createdAt": "2020-04-21T12:47:19Z", "commit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MzQ3Njk3", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#pullrequestreview-397347697", "createdAt": "2020-04-21T13:48:21Z", "commit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NDMwMzk4", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#pullrequestreview-397430398", "createdAt": "2020-04-21T15:11:41Z", "commit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToxMTo0MVrOGJLHGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToxMTo0MVrOGJLHGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3MjQxMA==", "bodyText": "You will get a compiler warning if the serialVersionUID is missing on classes that implement Serializable.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412272410", "createdAt": "2020-04-21T15:11:41Z", "author": {"login": "psantos1113"}, "path": "alert-database/src/main/java/com/synopsys/integration/alert/database/user/AuthenticationTypeEntity.java", "diffHunk": "@@ -31,13 +31,18 @@\n @Entity\n @Table(schema = \"alert\", name = \"authentication_type\")\n public class AuthenticationTypeEntity extends DatabaseEntity {\n+    private static final long serialVersionUID = -2308934073112918860L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEzMTI2Nw=="}, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NDgyNzIw", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#pullrequestreview-397482720", "createdAt": "2020-04-21T16:42:49Z", "commit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjo0Mjo0OVrOGJNyNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjo0Mjo0OVrOGJNyNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNjIxMw==", "bodyText": "How is this any different than the previous test? It looks like the assertions do not match the test name", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412316213", "createdAt": "2020-04-21T16:42:49Z", "author": {"login": "jamesrichard91"}, "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/DefaultDescriptorAccessorTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+package com.synopsys.integration.alert.database.api;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.alert.common.descriptor.DescriptorKey;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.enumeration.DescriptorType;\n+import com.synopsys.integration.alert.common.exception.AlertDatabaseConstraintException;\n+import com.synopsys.integration.alert.common.persistence.model.DefinedFieldModel;\n+import com.synopsys.integration.alert.common.persistence.model.RegisteredDescriptorModel;\n+import com.synopsys.integration.alert.database.configuration.ConfigContextEntity;\n+import com.synopsys.integration.alert.database.configuration.DefinedFieldEntity;\n+import com.synopsys.integration.alert.database.configuration.DescriptorTypeEntity;\n+import com.synopsys.integration.alert.database.configuration.RegisteredDescriptorEntity;\n+import com.synopsys.integration.alert.database.configuration.repository.ConfigContextRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.DefinedFieldRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.DescriptorTypeRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.RegisteredDescriptorRepository;\n+\n+public class DefaultDescriptorAccessorTest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultAuditUtility.class);\n+\n+    @Test\n+    public void getRegisteredDescriptorsTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findAll()).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptors();\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorByKeyTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorKey descriptorKey = createDescriptorKey(\"descriptorKey-test\");\n+        DescriptorKey emptyDescriptorKey = createDescriptorKey(\"bad-key\");\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findFirstByName(descriptorKey.getUniversalKey())).thenReturn(Optional.of(registeredDescriptorEntity));\n+        Mockito.when(registeredDescriptorRepository.findFirstByName(emptyDescriptorKey.getUniversalKey())).thenReturn(Optional.empty());\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModel = descriptorAccessor.getRegisteredDescriptorByKey(descriptorKey);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModelEmpty = descriptorAccessor.getRegisteredDescriptorByKey(emptyDescriptorKey);\n+\n+        assertTrue(registeredDescriptorModel.isPresent());\n+        assertFalse(registeredDescriptorModelEmpty.isPresent());\n+        assertEquals(name, registeredDescriptorModel.get().getName());\n+        assertEquals(descriptorType, registeredDescriptorModel.get().getType());\n+    }\n+\n+    @Test\n+    public void descriptorKeyFailureTest() throws Exception {\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(null, null, null, null);\n+        DescriptorKey descriptorKey = createDescriptorKey(\"\");\n+\n+        try {\n+            descriptorAccessor.getRegisteredDescriptorByKey(descriptorKey);\n+            fail();\n+        } catch (AlertDatabaseConstraintException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorsByTypeTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(1L);\n+\n+        Mockito.when(descriptorTypeRepository.findFirstByType(descriptorType.name())).thenReturn(Optional.of(descriptorTypeEntity));\n+        Mockito.when(registeredDescriptorRepository.findByTypeId(Mockito.any())).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(registeredDescriptorEntity.getTypeId())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorsByTypeMissingDescriptorTypeTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(1L);\n+\n+        Mockito.when(descriptorTypeRepository.findFirstByType(descriptorType.name())).thenReturn(Optional.empty());\n+        Mockito.when(descriptorTypeRepository.save(Mockito.any())).thenReturn(descriptorTypeEntity);\n+        Mockito.when(registeredDescriptorRepository.findByTypeId(Mockito.any())).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(registeredDescriptorEntity.getTypeId())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+\n+        assertEquals(1, registeredDescriptorModelList.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NDg1NDU5", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#pullrequestreview-397485459", "createdAt": "2020-04-21T16:46:09Z", "commit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjo0NjoxMFrOGJN6ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjo0NjoxMFrOGJN6ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxODM5NA==", "bodyText": "Instead of calling registeredDescriptorModel.get() over and over, you could create a local variable for the return of this method and use that variable instead.\nOptional<RegisteredDescriptorModel> registeredDescriptorModelOptional = descriptorAccessor.getRegisteredDescriptorById(descriptorId);\nRegisteredDescriptorModel registeredDescriptorModel = registeredDescriptorModelOptional.get();\nassertTrue(registeredDescriptorModel.isPresent());\nassertEquals(typeId, registeredDescriptorModel.getId());\nassertEquals(name, registeredDescriptorModel.getName());\nassertEquals(descriptorType, registeredDescriptorModel.getType());", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412318394", "createdAt": "2020-04-21T16:46:10Z", "author": {"login": "jamesrichard91"}, "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/DefaultDescriptorAccessorTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+package com.synopsys.integration.alert.database.api;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.alert.common.descriptor.DescriptorKey;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.enumeration.DescriptorType;\n+import com.synopsys.integration.alert.common.exception.AlertDatabaseConstraintException;\n+import com.synopsys.integration.alert.common.persistence.model.DefinedFieldModel;\n+import com.synopsys.integration.alert.common.persistence.model.RegisteredDescriptorModel;\n+import com.synopsys.integration.alert.database.configuration.ConfigContextEntity;\n+import com.synopsys.integration.alert.database.configuration.DefinedFieldEntity;\n+import com.synopsys.integration.alert.database.configuration.DescriptorTypeEntity;\n+import com.synopsys.integration.alert.database.configuration.RegisteredDescriptorEntity;\n+import com.synopsys.integration.alert.database.configuration.repository.ConfigContextRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.DefinedFieldRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.DescriptorTypeRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.RegisteredDescriptorRepository;\n+\n+public class DefaultDescriptorAccessorTest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultAuditUtility.class);\n+\n+    @Test\n+    public void getRegisteredDescriptorsTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findAll()).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptors();\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorByKeyTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorKey descriptorKey = createDescriptorKey(\"descriptorKey-test\");\n+        DescriptorKey emptyDescriptorKey = createDescriptorKey(\"bad-key\");\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findFirstByName(descriptorKey.getUniversalKey())).thenReturn(Optional.of(registeredDescriptorEntity));\n+        Mockito.when(registeredDescriptorRepository.findFirstByName(emptyDescriptorKey.getUniversalKey())).thenReturn(Optional.empty());\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModel = descriptorAccessor.getRegisteredDescriptorByKey(descriptorKey);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModelEmpty = descriptorAccessor.getRegisteredDescriptorByKey(emptyDescriptorKey);\n+\n+        assertTrue(registeredDescriptorModel.isPresent());\n+        assertFalse(registeredDescriptorModelEmpty.isPresent());\n+        assertEquals(name, registeredDescriptorModel.get().getName());\n+        assertEquals(descriptorType, registeredDescriptorModel.get().getType());\n+    }\n+\n+    @Test\n+    public void descriptorKeyFailureTest() throws Exception {\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(null, null, null, null);\n+        DescriptorKey descriptorKey = createDescriptorKey(\"\");\n+\n+        try {\n+            descriptorAccessor.getRegisteredDescriptorByKey(descriptorKey);\n+            fail();\n+        } catch (AlertDatabaseConstraintException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorsByTypeTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(1L);\n+\n+        Mockito.when(descriptorTypeRepository.findFirstByType(descriptorType.name())).thenReturn(Optional.of(descriptorTypeEntity));\n+        Mockito.when(registeredDescriptorRepository.findByTypeId(Mockito.any())).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(registeredDescriptorEntity.getTypeId())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorsByTypeMissingDescriptorTypeTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(1L);\n+\n+        Mockito.when(descriptorTypeRepository.findFirstByType(descriptorType.name())).thenReturn(Optional.empty());\n+        Mockito.when(descriptorTypeRepository.save(Mockito.any())).thenReturn(descriptorTypeEntity);\n+        Mockito.when(registeredDescriptorRepository.findByTypeId(Mockito.any())).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(registeredDescriptorEntity.getTypeId())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void descriptorTypeFailureTest() throws Exception {\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(null, null, null, null);\n+        DescriptorType descriptorType = null;\n+\n+        try {\n+            descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+            fail();\n+        } catch (AlertDatabaseConstraintException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorByIdTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+        final Long descriptorId = 2L;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(2L);\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findById(descriptorId)).thenReturn(Optional.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModel = descriptorAccessor.getRegisteredDescriptorById(descriptorId);\n+\n+        assertTrue(registeredDescriptorModel.isPresent());\n+        assertEquals(typeId, registeredDescriptorModel.get().getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 189}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NDg2OTky", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#pullrequestreview-397486992", "createdAt": "2020-04-21T16:47:52Z", "commit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjo0Nzo1M1rOGJOADw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjo0Nzo1M1rOGJOADw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxOTc1OQ==", "bodyText": "Instead of calling definedFieldModelList.get(0) repeatedly, try calling it once and create a local variable and reuse the variable.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412319759", "createdAt": "2020-04-21T16:47:53Z", "author": {"login": "jamesrichard91"}, "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/DefaultDescriptorAccessorTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+package com.synopsys.integration.alert.database.api;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.alert.common.descriptor.DescriptorKey;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.enumeration.DescriptorType;\n+import com.synopsys.integration.alert.common.exception.AlertDatabaseConstraintException;\n+import com.synopsys.integration.alert.common.persistence.model.DefinedFieldModel;\n+import com.synopsys.integration.alert.common.persistence.model.RegisteredDescriptorModel;\n+import com.synopsys.integration.alert.database.configuration.ConfigContextEntity;\n+import com.synopsys.integration.alert.database.configuration.DefinedFieldEntity;\n+import com.synopsys.integration.alert.database.configuration.DescriptorTypeEntity;\n+import com.synopsys.integration.alert.database.configuration.RegisteredDescriptorEntity;\n+import com.synopsys.integration.alert.database.configuration.repository.ConfigContextRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.DefinedFieldRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.DescriptorTypeRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.RegisteredDescriptorRepository;\n+\n+public class DefaultDescriptorAccessorTest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultAuditUtility.class);\n+\n+    @Test\n+    public void getRegisteredDescriptorsTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findAll()).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptors();\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorByKeyTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorKey descriptorKey = createDescriptorKey(\"descriptorKey-test\");\n+        DescriptorKey emptyDescriptorKey = createDescriptorKey(\"bad-key\");\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findFirstByName(descriptorKey.getUniversalKey())).thenReturn(Optional.of(registeredDescriptorEntity));\n+        Mockito.when(registeredDescriptorRepository.findFirstByName(emptyDescriptorKey.getUniversalKey())).thenReturn(Optional.empty());\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModel = descriptorAccessor.getRegisteredDescriptorByKey(descriptorKey);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModelEmpty = descriptorAccessor.getRegisteredDescriptorByKey(emptyDescriptorKey);\n+\n+        assertTrue(registeredDescriptorModel.isPresent());\n+        assertFalse(registeredDescriptorModelEmpty.isPresent());\n+        assertEquals(name, registeredDescriptorModel.get().getName());\n+        assertEquals(descriptorType, registeredDescriptorModel.get().getType());\n+    }\n+\n+    @Test\n+    public void descriptorKeyFailureTest() throws Exception {\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(null, null, null, null);\n+        DescriptorKey descriptorKey = createDescriptorKey(\"\");\n+\n+        try {\n+            descriptorAccessor.getRegisteredDescriptorByKey(descriptorKey);\n+            fail();\n+        } catch (AlertDatabaseConstraintException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorsByTypeTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(1L);\n+\n+        Mockito.when(descriptorTypeRepository.findFirstByType(descriptorType.name())).thenReturn(Optional.of(descriptorTypeEntity));\n+        Mockito.when(registeredDescriptorRepository.findByTypeId(Mockito.any())).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(registeredDescriptorEntity.getTypeId())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorsByTypeMissingDescriptorTypeTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(1L);\n+\n+        Mockito.when(descriptorTypeRepository.findFirstByType(descriptorType.name())).thenReturn(Optional.empty());\n+        Mockito.when(descriptorTypeRepository.save(Mockito.any())).thenReturn(descriptorTypeEntity);\n+        Mockito.when(registeredDescriptorRepository.findByTypeId(Mockito.any())).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(registeredDescriptorEntity.getTypeId())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void descriptorTypeFailureTest() throws Exception {\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(null, null, null, null);\n+        DescriptorType descriptorType = null;\n+\n+        try {\n+            descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+            fail();\n+        } catch (AlertDatabaseConstraintException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorByIdTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+        final Long descriptorId = 2L;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(2L);\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findById(descriptorId)).thenReturn(Optional.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModel = descriptorAccessor.getRegisteredDescriptorById(descriptorId);\n+\n+        assertTrue(registeredDescriptorModel.isPresent());\n+        assertEquals(typeId, registeredDescriptorModel.get().getId());\n+        assertEquals(name, registeredDescriptorModel.get().getName());\n+        assertEquals(descriptorType, registeredDescriptorModel.get().getType());\n+    }\n+\n+    @Test\n+    public void getFieldsForDescriptorTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final ConfigContextEnum configContextEnum = ConfigContextEnum.GLOBAL;\n+        final ConfigContextEnum invalidConfigContextEnum = ConfigContextEnum.DISTRIBUTION;\n+        final String definedFieldsKey = \"defined-field-key-test\";\n+        Boolean isSensitive = Boolean.TRUE;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorKey descriptorKey = createDescriptorKey(\"descriptorKey-test\");\n+        ConfigContextEntity configContextEntity = new ConfigContextEntity(configContextEnum.name());\n+        configContextEntity.setId(3L);\n+        DefinedFieldEntity definedFieldEntity = new DefinedFieldEntity(definedFieldsKey, isSensitive);\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DefinedFieldRepository definedFieldRepository = Mockito.mock(DefinedFieldRepository.class);\n+        ConfigContextRepository configContextRepository = Mockito.mock(ConfigContextRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findFirstByName(descriptorKey.getUniversalKey())).thenReturn(Optional.of(registeredDescriptorEntity));\n+        Mockito.when(configContextRepository.findFirstByContext(configContextEnum.name())).thenReturn(Optional.of(configContextEntity));\n+        //Used to test the optional expression\n+        Mockito.when(configContextRepository.findFirstByContext(invalidConfigContextEnum.name())).thenReturn(Optional.empty());\n+        Mockito.when(configContextRepository.save(Mockito.any())).thenReturn(configContextEntity);\n+        Mockito.when(definedFieldRepository.findByDescriptorIdAndContext(Mockito.any(), Mockito.any())).thenReturn(List.of(definedFieldEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, definedFieldRepository, configContextRepository, descriptorTypeRepository);\n+        List<DefinedFieldModel> definedFieldModelList = descriptorAccessor.getFieldsForDescriptor(descriptorKey, configContextEnum);\n+        List<DefinedFieldModel> emptyConfigContextDefinedFieldModelList = descriptorAccessor.getFieldsForDescriptor(descriptorKey, invalidConfigContextEnum);\n+\n+        assertEquals(1, definedFieldModelList.size());\n+        assertEquals(definedFieldsKey, definedFieldModelList.get(0).getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 227}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NTAwODky", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#pullrequestreview-397500892", "createdAt": "2020-04-21T17:04:02Z", "commit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzowNDowMlrOGJOzpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzowNDowMlrOGJOzpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMzMjk2Ng==", "bodyText": "I understand this is a Mock object for tests but I think it would be best to follow good conventions and make these fields private and create setters or some methods to add to these Map's.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412332966", "createdAt": "2020-04-21T17:04:02Z", "author": {"login": "jamesrichard91"}, "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/mock/MockSettingsKeyRepository.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.synopsys.integration.alert.database.api.mock;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.springframework.data.domain.Example;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.domain.Sort;\n+\n+import com.synopsys.integration.alert.database.settings.SettingsKeyEntity;\n+import com.synopsys.integration.alert.database.settings.SettingsKeyRepository;\n+\n+public class MockSettingsKeyRepository implements SettingsKeyRepository {\n+\n+    Map<String, SettingsKeyEntity> settingsKeyEntities = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NTAyNTc0", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#pullrequestreview-397502574", "createdAt": "2020-04-21T17:06:08Z", "commit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzowNjowOVrOGJO5VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzowNjowOVrOGJO5VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMzNDQyMQ==", "bodyText": "Same as my comment above. We should make this field private and expose a setter for this method. We should also avoid hardcoding the fields. This reduces the usability of the mock object in the tests.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412334421", "createdAt": "2020-04-21T17:06:09Z", "author": {"login": "jamesrichard91"}, "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/mock/MockSystemStatusRepository.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.synopsys.integration.alert.database.api.mock;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.springframework.data.domain.Example;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.domain.Sort;\n+\n+import com.synopsys.integration.alert.database.system.SystemStatus;\n+import com.synopsys.integration.alert.database.system.SystemStatusRepository;\n+\n+public class MockSystemStatusRepository implements SystemStatusRepository {\n+\n+    //Only methods that are used by a test are currently implemented, all others are left default.\n+    SystemStatus systemStatus = new SystemStatus(Boolean.FALSE, new Date());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NTAzNzcz", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#pullrequestreview-397503773", "createdAt": "2020-04-21T17:07:34Z", "commit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "429fc8f8904964d34bee672eacf0e569eca6db5d", "author": {"user": {"login": "ChomickiM", "name": "Martin"}}, "url": "https://github.com/blackducksoftware/blackduck-alert/commit/429fc8f8904964d34bee672eacf0e569eca6db5d", "committedDate": "2020-04-21T17:23:47Z", "message": "refactor: removing serialVersionUID from AuthenticationTypeEntity"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0c83910ef1e1ea9639e6aec87d03137fd0885c7", "author": {"user": {"login": "ChomickiM", "name": "Martin"}}, "url": "https://github.com/blackducksoftware/blackduck-alert/commit/f0c83910ef1e1ea9639e6aec87d03137fd0885c7", "committedDate": "2020-04-21T19:25:42Z", "message": "test: Improving tests based on PR feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NjEyNTk1", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#pullrequestreview-397612595", "createdAt": "2020-04-21T19:32:27Z", "commit": {"oid": "f0c83910ef1e1ea9639e6aec87d03137fd0885c7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2701, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}