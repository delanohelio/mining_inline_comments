{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0MTI4MTA1", "number": 1237, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNTozMjoxM1rOE0bY9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNjoyNzo0N1rOE0c7XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDEwMTY2OnYy", "diffSide": "RIGHT", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/workflow/processor/notification/NotificationProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNTozMjoxM1rOHsJapg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMToxODo1NlrOHsV_QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA1MzY3MA==", "bodyText": "this method is pretty much a duplicate of 79. I think you can create a private method that takes in a bifunction that performs the getMatchingEnabledJobs functionality.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516053670", "createdAt": "2020-11-02T15:32:13Z", "author": {"login": "bamandel"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/workflow/processor/notification/NotificationProcessor.java", "diffHunk": "@@ -71,18 +76,42 @@ public NotificationProcessor(ConfigurationAccessor configurationAccessor, JobAcc\n \n     public List<DistributionEvent> processNotifications(FrequencyType frequency, List<AlertNotificationModel> notifications) {\n         logger.info(\"Notifications to Process: {}\", notifications.size());\n-        List<ConfigurationJobModel> jobsForFrequency = jobAccessor.getJobsByFrequency(frequency);\n-        return processNotificationsForJobs(jobsForFrequency, notifications);\n+        SetMap<NotificationFilterModel, AlertNotificationModel> notificationFilterMap = extractNotificationInformation(notifications);\n+\n+        List<DistributionEvent> events = new ArrayList<>();\n+        for (Map.Entry<NotificationFilterModel, Set<AlertNotificationModel>> entry : notificationFilterMap.entrySet()) {\n+            NotificationFilterModel notificationFilterModel = entry.getKey();\n+            List<ConfigurationJobModel> matchingJobs = jobAccessor.getMatchingEnabledJobs(frequency, notificationFilterModel.getProviderConfigId(), notificationFilterModel.getNotificationType());\n+\n+            List<AlertNotificationModel> matchingNotifications = new ArrayList<>(entry.getValue());\n+            if (!matchingNotifications.isEmpty() && !matchingJobs.isEmpty()) {\n+                events.addAll(processNotificationsThatMatchFilter(notificationFilterModel, matchingJobs, matchingNotifications));\n+            }\n+        }\n+        return events;\n     }\n \n     public List<DistributionEvent> processNotifications(List<AlertNotificationModel> notifications) {\n+        // used in AuditEntryActions\n         // when a job is deleted use this method to send the same notification to the current set of jobs. i.e. audit\n         // FIXME consider paging\n-        List<ConfigurationJobModel> allJobs = jobAccessor.getAllJobs();\n-        return processNotificationsForJobs(allJobs, notifications);\n+        SetMap<NotificationFilterModel, AlertNotificationModel> notificationFilterMap = extractNotificationInformation(notifications);\n+\n+        List<DistributionEvent> events = new ArrayList<>();\n+        for (Map.Entry<NotificationFilterModel, Set<AlertNotificationModel>> entry : notificationFilterMap.entrySet()) {\n+            NotificationFilterModel notificationFilterModel = entry.getKey();\n+            List<ConfigurationJobModel> matchingJobs = jobAccessor.getMatchingEnabledJobs(notificationFilterModel.getProviderConfigId(), notificationFilterModel.getNotificationType());\n+\n+            List<AlertNotificationModel> matchingNotifications = new ArrayList<>(entry.getValue());\n+            if (!matchingNotifications.isEmpty() && !matchingJobs.isEmpty()) {\n+                events.addAll(processNotificationsThatMatchFilter(notificationFilterModel, matchingJobs, matchingNotifications));\n+            }\n+        }\n+        return events;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI1OTY0OQ==", "bodyText": "I will add an if statement to the method that takes the FrequencyType parameter and just have the other method call that. I can't use a Bifunction as you described because the getMatchingEnabledJobs in each method have a different number of parameters.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516259649", "createdAt": "2020-11-02T21:18:56Z", "author": {"login": "jamesrichard91"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/workflow/processor/notification/NotificationProcessor.java", "diffHunk": "@@ -71,18 +76,42 @@ public NotificationProcessor(ConfigurationAccessor configurationAccessor, JobAcc\n \n     public List<DistributionEvent> processNotifications(FrequencyType frequency, List<AlertNotificationModel> notifications) {\n         logger.info(\"Notifications to Process: {}\", notifications.size());\n-        List<ConfigurationJobModel> jobsForFrequency = jobAccessor.getJobsByFrequency(frequency);\n-        return processNotificationsForJobs(jobsForFrequency, notifications);\n+        SetMap<NotificationFilterModel, AlertNotificationModel> notificationFilterMap = extractNotificationInformation(notifications);\n+\n+        List<DistributionEvent> events = new ArrayList<>();\n+        for (Map.Entry<NotificationFilterModel, Set<AlertNotificationModel>> entry : notificationFilterMap.entrySet()) {\n+            NotificationFilterModel notificationFilterModel = entry.getKey();\n+            List<ConfigurationJobModel> matchingJobs = jobAccessor.getMatchingEnabledJobs(frequency, notificationFilterModel.getProviderConfigId(), notificationFilterModel.getNotificationType());\n+\n+            List<AlertNotificationModel> matchingNotifications = new ArrayList<>(entry.getValue());\n+            if (!matchingNotifications.isEmpty() && !matchingJobs.isEmpty()) {\n+                events.addAll(processNotificationsThatMatchFilter(notificationFilterModel, matchingJobs, matchingNotifications));\n+            }\n+        }\n+        return events;\n     }\n \n     public List<DistributionEvent> processNotifications(List<AlertNotificationModel> notifications) {\n+        // used in AuditEntryActions\n         // when a job is deleted use this method to send the same notification to the current set of jobs. i.e. audit\n         // FIXME consider paging\n-        List<ConfigurationJobModel> allJobs = jobAccessor.getAllJobs();\n-        return processNotificationsForJobs(allJobs, notifications);\n+        SetMap<NotificationFilterModel, AlertNotificationModel> notificationFilterMap = extractNotificationInformation(notifications);\n+\n+        List<DistributionEvent> events = new ArrayList<>();\n+        for (Map.Entry<NotificationFilterModel, Set<AlertNotificationModel>> entry : notificationFilterMap.entrySet()) {\n+            NotificationFilterModel notificationFilterModel = entry.getKey();\n+            List<ConfigurationJobModel> matchingJobs = jobAccessor.getMatchingEnabledJobs(notificationFilterModel.getProviderConfigId(), notificationFilterModel.getNotificationType());\n+\n+            List<AlertNotificationModel> matchingNotifications = new ArrayList<>(entry.getValue());\n+            if (!matchingNotifications.isEmpty() && !matchingJobs.isEmpty()) {\n+                events.addAll(processNotificationsThatMatchFilter(notificationFilterModel, matchingJobs, matchingNotifications));\n+            }\n+        }\n+        return events;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA1MzY3MA=="}, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDE1MzcwOnYy", "diffSide": "RIGHT", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/workflow/processor/notification/NotificationProcessor.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNTo0MzoxNVrOHsJ61Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTowODoxOFrOHsVrvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2MTkwOQ==", "bodyText": "Would we prefer streams over loops? We could convert this to a stream, map, then collect.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516061909", "createdAt": "2020-11-02T15:43:15Z", "author": {"login": "bamandel"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/workflow/processor/notification/NotificationProcessor.java", "diffHunk": "@@ -152,13 +225,32 @@ public NotificationProcessor(ConfigurationAccessor configurationAccessor, JobAcc\n         return List.of();\n     }\n \n-    private Optional<ConfigurationModel> retrieveProviderConfig(ConfigurationJobModel job) {\n+    private Optional<ConfigurationModel> retrieveProviderConfig(Long providerConfigID) {\n         try {\n-            return configurationAccessor.getConfigurationById(job.getProviderConfigIdAsLong());\n+            return configurationAccessor.getConfigurationById(providerConfigID);\n         } catch (AlertDatabaseConstraintException e) {\n-            logger.error(\"Could not retrieve the provider config for job: {}\", job.getName(), e);\n+            logger.error(\"Could not retrieve the provider config for ID: {}\", providerConfigID);\n+            logger.debug(e.getMessage(), e);\n             return Optional.empty();\n         }\n     }\n \n+    private SetMap<NotificationFilterModel, AlertNotificationModel> extractNotificationInformation(List<AlertNotificationModel> notifications) {\n+        SetMap<NotificationFilterModel, AlertNotificationModel> notificationFilterMap = SetMap.createDefault();\n+        for (AlertNotificationModel alertNotificationModel : notifications) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2NzMxMg==", "bodyText": "We could use streams streams aren't always as performant as regular for loops.  But if there are optimizations for streams in subsequent releases of Java the code won't automatically get those performance benefits.  I would say it depends on running the performance tests that were written before changing over to streams.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516167312", "createdAt": "2020-11-02T18:15:52Z", "author": {"login": "psantos1113"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/workflow/processor/notification/NotificationProcessor.java", "diffHunk": "@@ -152,13 +225,32 @@ public NotificationProcessor(ConfigurationAccessor configurationAccessor, JobAcc\n         return List.of();\n     }\n \n-    private Optional<ConfigurationModel> retrieveProviderConfig(ConfigurationJobModel job) {\n+    private Optional<ConfigurationModel> retrieveProviderConfig(Long providerConfigID) {\n         try {\n-            return configurationAccessor.getConfigurationById(job.getProviderConfigIdAsLong());\n+            return configurationAccessor.getConfigurationById(providerConfigID);\n         } catch (AlertDatabaseConstraintException e) {\n-            logger.error(\"Could not retrieve the provider config for job: {}\", job.getName(), e);\n+            logger.error(\"Could not retrieve the provider config for ID: {}\", providerConfigID);\n+            logger.debug(e.getMessage(), e);\n             return Optional.empty();\n         }\n     }\n \n+    private SetMap<NotificationFilterModel, AlertNotificationModel> extractNotificationInformation(List<AlertNotificationModel> notifications) {\n+        SetMap<NotificationFilterModel, AlertNotificationModel> notificationFilterMap = SetMap.createDefault();\n+        for (AlertNotificationModel alertNotificationModel : notifications) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2MTkwOQ=="}, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI1MTU0Mw==", "bodyText": "I would be curious how you would use a Stream here? Because we use the AlertNotificationModel to create a NotificationFilterModel and then put them both in the SetMap. Unless you are just suggesting I turn this for loop into\nnotifications.stream()\n            .forEach( alertNotificationModel -> {\n                NotificationFilterModel notificationFilterModel = extractNotificationInformation(alertNotificationModel);\n                notificationFilterMap.add(notificationFilterModel, alertNotificationModel);\n            });\nIs this preffered?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516251543", "createdAt": "2020-11-02T21:01:31Z", "author": {"login": "jamesrichard91"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/workflow/processor/notification/NotificationProcessor.java", "diffHunk": "@@ -152,13 +225,32 @@ public NotificationProcessor(ConfigurationAccessor configurationAccessor, JobAcc\n         return List.of();\n     }\n \n-    private Optional<ConfigurationModel> retrieveProviderConfig(ConfigurationJobModel job) {\n+    private Optional<ConfigurationModel> retrieveProviderConfig(Long providerConfigID) {\n         try {\n-            return configurationAccessor.getConfigurationById(job.getProviderConfigIdAsLong());\n+            return configurationAccessor.getConfigurationById(providerConfigID);\n         } catch (AlertDatabaseConstraintException e) {\n-            logger.error(\"Could not retrieve the provider config for job: {}\", job.getName(), e);\n+            logger.error(\"Could not retrieve the provider config for ID: {}\", providerConfigID);\n+            logger.debug(e.getMessage(), e);\n             return Optional.empty();\n         }\n     }\n \n+    private SetMap<NotificationFilterModel, AlertNotificationModel> extractNotificationInformation(List<AlertNotificationModel> notifications) {\n+        SetMap<NotificationFilterModel, AlertNotificationModel> notificationFilterMap = SetMap.createDefault();\n+        for (AlertNotificationModel alertNotificationModel : notifications) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2MTkwOQ=="}, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI1NDY1Mg==", "bodyText": "Oh you're right, it adds it to a completely separate object. Might as well leave it for now.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516254652", "createdAt": "2020-11-02T21:08:18Z", "author": {"login": "bamandel"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/workflow/processor/notification/NotificationProcessor.java", "diffHunk": "@@ -152,13 +225,32 @@ public NotificationProcessor(ConfigurationAccessor configurationAccessor, JobAcc\n         return List.of();\n     }\n \n-    private Optional<ConfigurationModel> retrieveProviderConfig(ConfigurationJobModel job) {\n+    private Optional<ConfigurationModel> retrieveProviderConfig(Long providerConfigID) {\n         try {\n-            return configurationAccessor.getConfigurationById(job.getProviderConfigIdAsLong());\n+            return configurationAccessor.getConfigurationById(providerConfigID);\n         } catch (AlertDatabaseConstraintException e) {\n-            logger.error(\"Could not retrieve the provider config for job: {}\", job.getName(), e);\n+            logger.error(\"Could not retrieve the provider config for ID: {}\", providerConfigID);\n+            logger.debug(e.getMessage(), e);\n             return Optional.empty();\n         }\n     }\n \n+    private SetMap<NotificationFilterModel, AlertNotificationModel> extractNotificationInformation(List<AlertNotificationModel> notifications) {\n+        SetMap<NotificationFilterModel, AlertNotificationModel> notificationFilterMap = SetMap.createDefault();\n+        for (AlertNotificationModel alertNotificationModel : notifications) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2MTkwOQ=="}, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDE3MjA5OnYy", "diffSide": "RIGHT", "path": "alert-database/src/main/java/com/synopsys/integration/alert/database/api/DefaultJobAccessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNTo0NzoxOVrOHsKGbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNTo0NzoxOVrOHsKGbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2NDg3OQ==", "bodyText": "I believe these can also use a common private method that is passed a bifunction. You would pass the findMatchingEnabledJobIds function in.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516064879", "createdAt": "2020-11-02T15:47:19Z", "author": {"login": "bamandel"}, "path": "alert-database/src/main/java/com/synopsys/integration/alert/database/api/DefaultJobAccessor.java", "diffHunk": "@@ -70,6 +71,28 @@ public DefaultJobAccessor(ConfigGroupRepository configGroupRepository, DefaultCo\n         return convertToJobModels(jobEntities);\n     }\n \n+    @Override\n+    public List<ConfigurationJobModel> getMatchingEnabledJobs(FrequencyType frequency, Long providerConfigId, NotificationType notificationType) {\n+        //TODO change this to return a page of results\n+        List<UUID> matchingJobIds = configGroupRepository.findMatchingEnabledJobIds(frequency.name(), String.valueOf(providerConfigId), notificationType.name());\n+        if (matchingJobIds.isEmpty()) {\n+            return List.of();\n+        }\n+        List<ConfigGroupEntity> jobEntities = configGroupRepository.findByJobIds(matchingJobIds);\n+        return convertToJobModels(jobEntities);\n+    }\n+\n+    @Override\n+    public List<ConfigurationJobModel> getMatchingEnabledJobs(Long providerConfigId, NotificationType notificationType) {\n+        //TODO change this to return a page of results\n+        List<UUID> matchingJobIds = configGroupRepository.findMatchingEnabledJobIds(String.valueOf(providerConfigId), notificationType.name());\n+        if (matchingJobIds.isEmpty()) {\n+            return List.of();\n+        }\n+        List<ConfigGroupEntity> jobEntities = configGroupRepository.findByJobIds(matchingJobIds);\n+        return convertToJobModels(jobEntities);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDE3NzYzOnYy", "diffSide": "RIGHT", "path": "alert-database/src/main/java/com/synopsys/integration/alert/database/api/StaticJobAccessor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNTo0ODozNVrOHsKKBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNTo0ODozNVrOHsKKBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2NTc5OA==", "bodyText": "This should be able to use a shared private method", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516065798", "createdAt": "2020-11-02T15:48:35Z", "author": {"login": "bamandel"}, "path": "alert-database/src/main/java/com/synopsys/integration/alert/database/api/StaticJobAccessor.java", "diffHunk": "@@ -168,6 +169,24 @@ public StaticJobAccessor(\n                    .collect(Collectors.toList());\n     }\n \n+    @Override\n+    public List<ConfigurationJobModel> getMatchingEnabledJobs(FrequencyType frequency, Long providerConfigId, NotificationType notificationType) {\n+        // TODO change this to return a page of jobs\n+        return distributionJobRepository.findMatchingEnabledJob(frequency.name(), providerConfigId, notificationType.name())\n+                   .stream()\n+                   .map(this::convertToConfigurationJobModel)\n+                   .collect(Collectors.toList());\n+    }\n+\n+    @Override\n+    public List<ConfigurationJobModel> getMatchingEnabledJobs(Long providerConfigId, NotificationType notificationType) {\n+        // TODO change this to return a page of jobs\n+        return distributionJobRepository.findMatchingEnabledJob(providerConfigId, notificationType.name())\n+                   .stream()\n+                   .map(this::convertToConfigurationJobModel)\n+                   .collect(Collectors.toList());\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDMwMTY4OnYy", "diffSide": "RIGHT", "path": "provider/src/main/java/com/synopsys/integration/alert/provider/blackduck/action/BlackDuckDistributionTestAction.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNjoxNjowNFrOHsLXbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTowNDo1OVrOHsVl5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4NTYxMw==", "bodyText": "Can this be changed to optional mapping? It would remove this if statement and you could orElse(null) at the end.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516085613", "createdAt": "2020-11-02T16:16:04Z", "author": {"login": "bamandel"}, "path": "provider/src/main/java/com/synopsys/integration/alert/provider/blackduck/action/BlackDuckDistributionTestAction.java", "diffHunk": "@@ -72,12 +74,15 @@ public MessageResult testConfig(String configId, FieldModel fieldModel, FieldUti\n                 .flatMap(projectNamePattern -> validatePatternMatchesProject(providerConfigId, projectNamePattern))\n                 .ifPresent(fieldStatuses::add);\n \n-            Optional<BlackDuckProperties> optionalBlackDuckProperties = configurationAccessor.getConfigurationById(providerConfigId)\n-                                                                            .map(blackDuckProvider::createStatefulProvider)\n-                                                                            .map(statefulProvider -> (BlackDuckProperties) statefulProvider.getProperties());\n-            if (optionalBlackDuckProperties.isPresent()) {\n-                BlackDuckProperties blackDuckProperties = optionalBlackDuckProperties.get();\n+            BlackDuckProperties blackDuckProperties = null;\n+            Optional<ConfigurationModel> providerConfigurationOptional = configurationAccessor.getConfigurationById(providerConfigId);\n+            if (providerConfigurationOptional.isPresent()) {\n+                ConfigurationModel providerConfiguration = providerConfigurationOptional.get();\n+                StatefulProvider statefulProvider = blackDuckProvider.createStatefulProvider(providerConfiguration);\n+                blackDuckProperties = (BlackDuckProperties) statefulProvider.getProperties();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI1MzE1Nw==", "bodyText": "blackDuckProvider.createStatefulProvider(providerConfiguration) throws an exception so we can't change this if block to use the Optional.map function.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516253157", "createdAt": "2020-11-02T21:04:59Z", "author": {"login": "jamesrichard91"}, "path": "provider/src/main/java/com/synopsys/integration/alert/provider/blackduck/action/BlackDuckDistributionTestAction.java", "diffHunk": "@@ -72,12 +74,15 @@ public MessageResult testConfig(String configId, FieldModel fieldModel, FieldUti\n                 .flatMap(projectNamePattern -> validatePatternMatchesProject(providerConfigId, projectNamePattern))\n                 .ifPresent(fieldStatuses::add);\n \n-            Optional<BlackDuckProperties> optionalBlackDuckProperties = configurationAccessor.getConfigurationById(providerConfigId)\n-                                                                            .map(blackDuckProvider::createStatefulProvider)\n-                                                                            .map(statefulProvider -> (BlackDuckProperties) statefulProvider.getProperties());\n-            if (optionalBlackDuckProperties.isPresent()) {\n-                BlackDuckProperties blackDuckProperties = optionalBlackDuckProperties.get();\n+            BlackDuckProperties blackDuckProperties = null;\n+            Optional<ConfigurationModel> providerConfigurationOptional = configurationAccessor.getConfigurationById(providerConfigId);\n+            if (providerConfigurationOptional.isPresent()) {\n+                ConfigurationModel providerConfiguration = providerConfigurationOptional.get();\n+                StatefulProvider statefulProvider = blackDuckProvider.createStatefulProvider(providerConfiguration);\n+                blackDuckProperties = (BlackDuckProperties) statefulProvider.getProperties();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4NTYxMw=="}, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDMwMzM0OnYy", "diffSide": "RIGHT", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/workflow/task/ScheduledTask.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNjoxNjoyN1rOHsLYYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTowNTozOVrOHsVnGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4NTg1Ng==", "bodyText": "I realize this is just for the patch, so this may not be an issue, but would it be a problem for customers in other timezones?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516085856", "createdAt": "2020-11-02T16:16:27Z", "author": {"login": "ChomickiM"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/workflow/task/ScheduledTask.java", "diffHunk": "@@ -42,7 +42,9 @@\n public abstract class ScheduledTask implements Runnable {\n     public static final String FORMAT_PATTERN = \"MM/dd/yyy hh:mm a\";\n     public static final String STOP_SCHEDULE_EXPRESSION = \"\";\n+    //Spring Cron documentation  https://riptutorial.com/spring/example/21209/cron-expression\n     public static final String EVERY_MINUTE_CRON_EXPRESSION = \"0 0/1 * 1/1 * *\";\n+    public static final String ONCE_DAILY_CRON_EXPRESSION = \"0 0 0 * * *\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2ODU2Mw==", "bodyText": "We are always using UTC timezone.  So it would run based on the UTC timezone.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516168563", "createdAt": "2020-11-02T18:18:11Z", "author": {"login": "psantos1113"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/workflow/task/ScheduledTask.java", "diffHunk": "@@ -42,7 +42,9 @@\n public abstract class ScheduledTask implements Runnable {\n     public static final String FORMAT_PATTERN = \"MM/dd/yyy hh:mm a\";\n     public static final String STOP_SCHEDULE_EXPRESSION = \"\";\n+    //Spring Cron documentation  https://riptutorial.com/spring/example/21209/cron-expression\n     public static final String EVERY_MINUTE_CRON_EXPRESSION = \"0 0/1 * 1/1 * *\";\n+    public static final String ONCE_DAILY_CRON_EXPRESSION = \"0 0 0 * * *\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4NTg1Ng=="}, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI1MzQ2Nw==", "bodyText": "Also this is not for the patch, this PR is for the current version of Alert.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516253467", "createdAt": "2020-11-02T21:05:39Z", "author": {"login": "jamesrichard91"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/workflow/task/ScheduledTask.java", "diffHunk": "@@ -42,7 +42,9 @@\n public abstract class ScheduledTask implements Runnable {\n     public static final String FORMAT_PATTERN = \"MM/dd/yyy hh:mm a\";\n     public static final String STOP_SCHEDULE_EXPRESSION = \"\";\n+    //Spring Cron documentation  https://riptutorial.com/spring/example/21209/cron-expression\n     public static final String EVERY_MINUTE_CRON_EXPRESSION = \"0 0/1 * 1/1 * *\";\n+    public static final String ONCE_DAILY_CRON_EXPRESSION = \"0 0 0 * * *\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4NTg1Ng=="}, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDM0OTU4OnYy", "diffSide": "RIGHT", "path": "workflow/src/main/java/com/synopsys/integration/alert/workflow/message/NotificationReceiver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNjoyNjo0OVrOHsL1DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTowNzoyMVrOHsVqKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA5MzE5Nw==", "bodyText": "Do you think this could be too verbose for info? We already mention processing events. I would prefer debug", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516093197", "createdAt": "2020-11-02T16:26:49Z", "author": {"login": "bamandel"}, "path": "workflow/src/main/java/com/synopsys/integration/alert/workflow/message/NotificationReceiver.java", "diffHunk": "@@ -64,9 +64,11 @@ public void handleEvent(NotificationEvent event) {\n                 logger.warn(\"Can not process a notification event without notification Id's.\");\n                 return;\n             }\n+            logger.debug(\"Event {}\", event);\n             logger.info(\"Processing event for {} notifications.\", event.getNotificationIds().size());\n             List<AlertNotificationModel> notifications = notificationAccessor.findByIds(event.getNotificationIds());\n             List<DistributionEvent> distributionEvents = notificationProcessor.processNotifications(FrequencyType.REAL_TIME, notifications);\n+            logger.info(\"Sending {} events for notifications.\", distributionEvents.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI1NDI1MQ==", "bodyText": "This is very helpful when debugging with the performance issues lately. And the logs serve different purposes. The log on line 68 says how many notifications are being processed and line 71  says how many events were created as a result.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516254251", "createdAt": "2020-11-02T21:07:21Z", "author": {"login": "jamesrichard91"}, "path": "workflow/src/main/java/com/synopsys/integration/alert/workflow/message/NotificationReceiver.java", "diffHunk": "@@ -64,9 +64,11 @@ public void handleEvent(NotificationEvent event) {\n                 logger.warn(\"Can not process a notification event without notification Id's.\");\n                 return;\n             }\n+            logger.debug(\"Event {}\", event);\n             logger.info(\"Processing event for {} notifications.\", event.getNotificationIds().size());\n             List<AlertNotificationModel> notifications = notificationAccessor.findByIds(event.getNotificationIds());\n             List<DistributionEvent> distributionEvents = notificationProcessor.processNotifications(FrequencyType.REAL_TIME, notifications);\n+            logger.info(\"Sending {} events for notifications.\", distributionEvents.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA5MzE5Nw=="}, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNDM1MzU3OnYy", "diffSide": "RIGHT", "path": "workflow/src/main/java/com/synopsys/integration/alert/workflow/scheduled/frequency/ProcessingTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNjoyNzo0N1rOHsL3lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMTowNzo0M1rOHsVqvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA5Mzg0NA==", "bodyText": "Should one of these be debug as well? We don't want to spam too much", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516093844", "createdAt": "2020-11-02T16:27:47Z", "author": {"login": "bamandel"}, "path": "workflow/src/main/java/com/synopsys/integration/alert/workflow/scheduled/frequency/ProcessingTask.java", "diffHunk": "@@ -72,7 +72,9 @@ public DateRange getDateRange() {\n     public void runTask() {\n         DateRange dateRange = getDateRange();\n         List<AlertNotificationModel> notificationList = read(dateRange);\n+        logger.info(\"Processing {} notifications.\", notificationList.size());\n         List<DistributionEvent> distributionEvents = notificationProcessor.processNotifications(getDigestType(), notificationList);\n+        logger.info(\"Sending {} events for notifications.\", distributionEvents.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI1NDM5Nw==", "bodyText": "Same as above.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1237#discussion_r516254397", "createdAt": "2020-11-02T21:07:43Z", "author": {"login": "jamesrichard91"}, "path": "workflow/src/main/java/com/synopsys/integration/alert/workflow/scheduled/frequency/ProcessingTask.java", "diffHunk": "@@ -72,7 +72,9 @@ public DateRange getDateRange() {\n     public void runTask() {\n         DateRange dateRange = getDateRange();\n         List<AlertNotificationModel> notificationList = read(dateRange);\n+        logger.info(\"Processing {} notifications.\", notificationList.size());\n         List<DistributionEvent> distributionEvents = notificationProcessor.processNotifications(getDigestType(), notificationList);\n+        logger.info(\"Sending {} events for notifications.\", distributionEvents.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA5Mzg0NA=="}, "originalCommit": {"oid": "f5d3f6cc1dfed1e5bbc9f76956cb3b7172fff057"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2336, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}