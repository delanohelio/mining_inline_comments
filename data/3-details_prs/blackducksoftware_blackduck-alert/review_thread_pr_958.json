{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2MjMxMzQw", "number": 958, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODo0MDozNFrODz3lTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzowNjowOVrOD0VmpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzE0NjM5OnYy", "diffSide": "RIGHT", "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/mock/MockSettingsKeyRepository.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODo0MDozNFrOGIiX5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODo0MDozNFrOGIiX5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNDk2NQ==", "bodyText": "We created these \"mock\" repositories for test purposes so that we can control the functionality within repository and do not have to mock out the returns from each of these methods since these repositories were easier to implement than others.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r411604965", "createdAt": "2020-04-20T18:40:34Z", "author": {"login": "ChomickiM"}, "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/mock/MockSettingsKeyRepository.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.synopsys.integration.alert.database.api.mock;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.springframework.data.domain.Example;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.domain.Sort;\n+\n+import com.synopsys.integration.alert.database.settings.SettingsKeyEntity;\n+import com.synopsys.integration.alert.database.settings.SettingsKeyRepository;\n+\n+public class MockSettingsKeyRepository implements SettingsKeyRepository {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzE0NzcwOnYy", "diffSide": "RIGHT", "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/mock/MockSystemStatusRepository.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODo0MDo0OVrOGIiYpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxODo0MDo0OVrOGIiYpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNTE1Ng==", "bodyText": "Same as above.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r411605156", "createdAt": "2020-04-20T18:40:49Z", "author": {"login": "ChomickiM"}, "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/mock/MockSystemStatusRepository.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.synopsys.integration.alert.database.api.mock;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.springframework.data.domain.Example;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.domain.Sort;\n+\n+import com.synopsys.integration.alert.database.system.SystemStatus;\n+import com.synopsys.integration.alert.database.system.SystemStatusRepository;\n+\n+public class MockSystemStatusRepository implements SystemStatusRepository {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MDczOTAwOnYy", "diffSide": "RIGHT", "path": "alert-database/src/main/java/com/synopsys/integration/alert/database/user/AuthenticationTypeEntity.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMjoxNTowNFrOGJCfww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToxMTo0MVrOGJLHGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEzMTI2Nw==", "bodyText": "Do we want serialVersionUIDs explicitly defined for database entities? We are not maintaining backward-compatible POJOs (liquibase handles data migration, so we never need intermediate Java Objects), so I'm not convinced that we gain any value from having it.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412131267", "createdAt": "2020-04-21T12:15:04Z", "author": {"login": "gkillough"}, "path": "alert-database/src/main/java/com/synopsys/integration/alert/database/user/AuthenticationTypeEntity.java", "diffHunk": "@@ -31,13 +31,18 @@\n @Entity\n @Table(schema = \"alert\", name = \"authentication_type\")\n public class AuthenticationTypeEntity extends DatabaseEntity {\n+    private static final long serialVersionUID = -2308934073112918860L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE2NTE0OA==", "bodyText": "I believe this was added as a save action, when I try to delete the serialVersionUID and save, it is added back in automatically.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412165148", "createdAt": "2020-04-21T13:03:18Z", "author": {"login": "ChomickiM"}, "path": "alert-database/src/main/java/com/synopsys/integration/alert/database/user/AuthenticationTypeEntity.java", "diffHunk": "@@ -31,13 +31,18 @@\n @Entity\n @Table(schema = \"alert\", name = \"authentication_type\")\n public class AuthenticationTypeEntity extends DatabaseEntity {\n+    private static final long serialVersionUID = -2308934073112918860L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEzMTI2Nw=="}, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI1NTM2Nw==", "bodyText": "Yes it was added by the save action.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412255367", "createdAt": "2020-04-21T14:52:11Z", "author": {"login": "jamesrichard91"}, "path": "alert-database/src/main/java/com/synopsys/integration/alert/database/user/AuthenticationTypeEntity.java", "diffHunk": "@@ -31,13 +31,18 @@\n @Entity\n @Table(schema = \"alert\", name = \"authentication_type\")\n public class AuthenticationTypeEntity extends DatabaseEntity {\n+    private static final long serialVersionUID = -2308934073112918860L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEzMTI2Nw=="}, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI1OTI3Mg==", "bodyText": "We may want to remove this rule from the save actions. It's not clear if we are getting any value from the serialVersionUID's as Gavin pointed out", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412259272", "createdAt": "2020-04-21T14:56:35Z", "author": {"login": "jamesrichard91"}, "path": "alert-database/src/main/java/com/synopsys/integration/alert/database/user/AuthenticationTypeEntity.java", "diffHunk": "@@ -31,13 +31,18 @@\n @Entity\n @Table(schema = \"alert\", name = \"authentication_type\")\n public class AuthenticationTypeEntity extends DatabaseEntity {\n+    private static final long serialVersionUID = -2308934073112918860L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEzMTI2Nw=="}, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3MjQxMA==", "bodyText": "You will get a compiler warning if the serialVersionUID is missing on classes that implement Serializable.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412272410", "createdAt": "2020-04-21T15:11:41Z", "author": {"login": "psantos1113"}, "path": "alert-database/src/main/java/com/synopsys/integration/alert/database/user/AuthenticationTypeEntity.java", "diffHunk": "@@ -31,13 +31,18 @@\n @Entity\n @Table(schema = \"alert\", name = \"authentication_type\")\n public class AuthenticationTypeEntity extends DatabaseEntity {\n+    private static final long serialVersionUID = -2308934073112918860L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEzMTI2Nw=="}, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTkzOTc3OnYy", "diffSide": "RIGHT", "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/DefaultDescriptorAccessorTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjo0Mjo0OVrOGJNyNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzoxNzowMFrOGJPXvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNjIxMw==", "bodyText": "How is this any different than the previous test? It looks like the assertions do not match the test name", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412316213", "createdAt": "2020-04-21T16:42:49Z", "author": {"login": "jamesrichard91"}, "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/DefaultDescriptorAccessorTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+package com.synopsys.integration.alert.database.api;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.alert.common.descriptor.DescriptorKey;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.enumeration.DescriptorType;\n+import com.synopsys.integration.alert.common.exception.AlertDatabaseConstraintException;\n+import com.synopsys.integration.alert.common.persistence.model.DefinedFieldModel;\n+import com.synopsys.integration.alert.common.persistence.model.RegisteredDescriptorModel;\n+import com.synopsys.integration.alert.database.configuration.ConfigContextEntity;\n+import com.synopsys.integration.alert.database.configuration.DefinedFieldEntity;\n+import com.synopsys.integration.alert.database.configuration.DescriptorTypeEntity;\n+import com.synopsys.integration.alert.database.configuration.RegisteredDescriptorEntity;\n+import com.synopsys.integration.alert.database.configuration.repository.ConfigContextRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.DefinedFieldRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.DescriptorTypeRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.RegisteredDescriptorRepository;\n+\n+public class DefaultDescriptorAccessorTest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultAuditUtility.class);\n+\n+    @Test\n+    public void getRegisteredDescriptorsTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findAll()).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptors();\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorByKeyTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorKey descriptorKey = createDescriptorKey(\"descriptorKey-test\");\n+        DescriptorKey emptyDescriptorKey = createDescriptorKey(\"bad-key\");\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findFirstByName(descriptorKey.getUniversalKey())).thenReturn(Optional.of(registeredDescriptorEntity));\n+        Mockito.when(registeredDescriptorRepository.findFirstByName(emptyDescriptorKey.getUniversalKey())).thenReturn(Optional.empty());\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModel = descriptorAccessor.getRegisteredDescriptorByKey(descriptorKey);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModelEmpty = descriptorAccessor.getRegisteredDescriptorByKey(emptyDescriptorKey);\n+\n+        assertTrue(registeredDescriptorModel.isPresent());\n+        assertFalse(registeredDescriptorModelEmpty.isPresent());\n+        assertEquals(name, registeredDescriptorModel.get().getName());\n+        assertEquals(descriptorType, registeredDescriptorModel.get().getType());\n+    }\n+\n+    @Test\n+    public void descriptorKeyFailureTest() throws Exception {\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(null, null, null, null);\n+        DescriptorKey descriptorKey = createDescriptorKey(\"\");\n+\n+        try {\n+            descriptorAccessor.getRegisteredDescriptorByKey(descriptorKey);\n+            fail();\n+        } catch (AlertDatabaseConstraintException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorsByTypeTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(1L);\n+\n+        Mockito.when(descriptorTypeRepository.findFirstByType(descriptorType.name())).thenReturn(Optional.of(descriptorTypeEntity));\n+        Mockito.when(registeredDescriptorRepository.findByTypeId(Mockito.any())).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(registeredDescriptorEntity.getTypeId())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorsByTypeMissingDescriptorTypeTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(1L);\n+\n+        Mockito.when(descriptorTypeRepository.findFirstByType(descriptorType.name())).thenReturn(Optional.empty());\n+        Mockito.when(descriptorTypeRepository.save(Mockito.any())).thenReturn(descriptorTypeEntity);\n+        Mockito.when(registeredDescriptorRepository.findByTypeId(Mockito.any())).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(registeredDescriptorEntity.getTypeId())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+\n+        assertEquals(1, registeredDescriptorModelList.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0MjIwNA==", "bodyText": "This test is testing for an Optional.empty case that is used by one of the private methods to increase its coverage, it is being passed on line 141 and as a result needed some other mocks. Because it will create a new descriptorTypeEntity I used the same setup as in the previous test after that.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412342204", "createdAt": "2020-04-21T17:17:00Z", "author": {"login": "ChomickiM"}, "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/DefaultDescriptorAccessorTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+package com.synopsys.integration.alert.database.api;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.alert.common.descriptor.DescriptorKey;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.enumeration.DescriptorType;\n+import com.synopsys.integration.alert.common.exception.AlertDatabaseConstraintException;\n+import com.synopsys.integration.alert.common.persistence.model.DefinedFieldModel;\n+import com.synopsys.integration.alert.common.persistence.model.RegisteredDescriptorModel;\n+import com.synopsys.integration.alert.database.configuration.ConfigContextEntity;\n+import com.synopsys.integration.alert.database.configuration.DefinedFieldEntity;\n+import com.synopsys.integration.alert.database.configuration.DescriptorTypeEntity;\n+import com.synopsys.integration.alert.database.configuration.RegisteredDescriptorEntity;\n+import com.synopsys.integration.alert.database.configuration.repository.ConfigContextRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.DefinedFieldRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.DescriptorTypeRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.RegisteredDescriptorRepository;\n+\n+public class DefaultDescriptorAccessorTest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultAuditUtility.class);\n+\n+    @Test\n+    public void getRegisteredDescriptorsTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findAll()).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptors();\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorByKeyTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorKey descriptorKey = createDescriptorKey(\"descriptorKey-test\");\n+        DescriptorKey emptyDescriptorKey = createDescriptorKey(\"bad-key\");\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findFirstByName(descriptorKey.getUniversalKey())).thenReturn(Optional.of(registeredDescriptorEntity));\n+        Mockito.when(registeredDescriptorRepository.findFirstByName(emptyDescriptorKey.getUniversalKey())).thenReturn(Optional.empty());\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModel = descriptorAccessor.getRegisteredDescriptorByKey(descriptorKey);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModelEmpty = descriptorAccessor.getRegisteredDescriptorByKey(emptyDescriptorKey);\n+\n+        assertTrue(registeredDescriptorModel.isPresent());\n+        assertFalse(registeredDescriptorModelEmpty.isPresent());\n+        assertEquals(name, registeredDescriptorModel.get().getName());\n+        assertEquals(descriptorType, registeredDescriptorModel.get().getType());\n+    }\n+\n+    @Test\n+    public void descriptorKeyFailureTest() throws Exception {\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(null, null, null, null);\n+        DescriptorKey descriptorKey = createDescriptorKey(\"\");\n+\n+        try {\n+            descriptorAccessor.getRegisteredDescriptorByKey(descriptorKey);\n+            fail();\n+        } catch (AlertDatabaseConstraintException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorsByTypeTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(1L);\n+\n+        Mockito.when(descriptorTypeRepository.findFirstByType(descriptorType.name())).thenReturn(Optional.of(descriptorTypeEntity));\n+        Mockito.when(registeredDescriptorRepository.findByTypeId(Mockito.any())).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(registeredDescriptorEntity.getTypeId())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorsByTypeMissingDescriptorTypeTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(1L);\n+\n+        Mockito.when(descriptorTypeRepository.findFirstByType(descriptorType.name())).thenReturn(Optional.empty());\n+        Mockito.when(descriptorTypeRepository.save(Mockito.any())).thenReturn(descriptorTypeEntity);\n+        Mockito.when(registeredDescriptorRepository.findByTypeId(Mockito.any())).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(registeredDescriptorEntity.getTypeId())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+\n+        assertEquals(1, registeredDescriptorModelList.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxNjIxMw=="}, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTk1NDUwOnYy", "diffSide": "RIGHT", "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/DefaultDescriptorAccessorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjo0NjoxMFrOGJN6ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjo0NjoxMFrOGJN6ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxODM5NA==", "bodyText": "Instead of calling registeredDescriptorModel.get() over and over, you could create a local variable for the return of this method and use that variable instead.\nOptional<RegisteredDescriptorModel> registeredDescriptorModelOptional = descriptorAccessor.getRegisteredDescriptorById(descriptorId);\nRegisteredDescriptorModel registeredDescriptorModel = registeredDescriptorModelOptional.get();\nassertTrue(registeredDescriptorModel.isPresent());\nassertEquals(typeId, registeredDescriptorModel.getId());\nassertEquals(name, registeredDescriptorModel.getName());\nassertEquals(descriptorType, registeredDescriptorModel.getType());", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412318394", "createdAt": "2020-04-21T16:46:10Z", "author": {"login": "jamesrichard91"}, "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/DefaultDescriptorAccessorTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+package com.synopsys.integration.alert.database.api;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.alert.common.descriptor.DescriptorKey;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.enumeration.DescriptorType;\n+import com.synopsys.integration.alert.common.exception.AlertDatabaseConstraintException;\n+import com.synopsys.integration.alert.common.persistence.model.DefinedFieldModel;\n+import com.synopsys.integration.alert.common.persistence.model.RegisteredDescriptorModel;\n+import com.synopsys.integration.alert.database.configuration.ConfigContextEntity;\n+import com.synopsys.integration.alert.database.configuration.DefinedFieldEntity;\n+import com.synopsys.integration.alert.database.configuration.DescriptorTypeEntity;\n+import com.synopsys.integration.alert.database.configuration.RegisteredDescriptorEntity;\n+import com.synopsys.integration.alert.database.configuration.repository.ConfigContextRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.DefinedFieldRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.DescriptorTypeRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.RegisteredDescriptorRepository;\n+\n+public class DefaultDescriptorAccessorTest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultAuditUtility.class);\n+\n+    @Test\n+    public void getRegisteredDescriptorsTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findAll()).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptors();\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorByKeyTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorKey descriptorKey = createDescriptorKey(\"descriptorKey-test\");\n+        DescriptorKey emptyDescriptorKey = createDescriptorKey(\"bad-key\");\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findFirstByName(descriptorKey.getUniversalKey())).thenReturn(Optional.of(registeredDescriptorEntity));\n+        Mockito.when(registeredDescriptorRepository.findFirstByName(emptyDescriptorKey.getUniversalKey())).thenReturn(Optional.empty());\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModel = descriptorAccessor.getRegisteredDescriptorByKey(descriptorKey);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModelEmpty = descriptorAccessor.getRegisteredDescriptorByKey(emptyDescriptorKey);\n+\n+        assertTrue(registeredDescriptorModel.isPresent());\n+        assertFalse(registeredDescriptorModelEmpty.isPresent());\n+        assertEquals(name, registeredDescriptorModel.get().getName());\n+        assertEquals(descriptorType, registeredDescriptorModel.get().getType());\n+    }\n+\n+    @Test\n+    public void descriptorKeyFailureTest() throws Exception {\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(null, null, null, null);\n+        DescriptorKey descriptorKey = createDescriptorKey(\"\");\n+\n+        try {\n+            descriptorAccessor.getRegisteredDescriptorByKey(descriptorKey);\n+            fail();\n+        } catch (AlertDatabaseConstraintException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorsByTypeTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(1L);\n+\n+        Mockito.when(descriptorTypeRepository.findFirstByType(descriptorType.name())).thenReturn(Optional.of(descriptorTypeEntity));\n+        Mockito.when(registeredDescriptorRepository.findByTypeId(Mockito.any())).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(registeredDescriptorEntity.getTypeId())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorsByTypeMissingDescriptorTypeTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(1L);\n+\n+        Mockito.when(descriptorTypeRepository.findFirstByType(descriptorType.name())).thenReturn(Optional.empty());\n+        Mockito.when(descriptorTypeRepository.save(Mockito.any())).thenReturn(descriptorTypeEntity);\n+        Mockito.when(registeredDescriptorRepository.findByTypeId(Mockito.any())).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(registeredDescriptorEntity.getTypeId())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void descriptorTypeFailureTest() throws Exception {\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(null, null, null, null);\n+        DescriptorType descriptorType = null;\n+\n+        try {\n+            descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+            fail();\n+        } catch (AlertDatabaseConstraintException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorByIdTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+        final Long descriptorId = 2L;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(2L);\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findById(descriptorId)).thenReturn(Optional.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModel = descriptorAccessor.getRegisteredDescriptorById(descriptorId);\n+\n+        assertTrue(registeredDescriptorModel.isPresent());\n+        assertEquals(typeId, registeredDescriptorModel.get().getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTk2MzkwOnYy", "diffSide": "RIGHT", "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/DefaultDescriptorAccessorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjo0Nzo1M1rOGJOADw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjo0Nzo1M1rOGJOADw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMxOTc1OQ==", "bodyText": "Instead of calling definedFieldModelList.get(0) repeatedly, try calling it once and create a local variable and reuse the variable.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412319759", "createdAt": "2020-04-21T16:47:53Z", "author": {"login": "jamesrichard91"}, "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/DefaultDescriptorAccessorTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+package com.synopsys.integration.alert.database.api;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.synopsys.integration.alert.common.descriptor.DescriptorKey;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.enumeration.DescriptorType;\n+import com.synopsys.integration.alert.common.exception.AlertDatabaseConstraintException;\n+import com.synopsys.integration.alert.common.persistence.model.DefinedFieldModel;\n+import com.synopsys.integration.alert.common.persistence.model.RegisteredDescriptorModel;\n+import com.synopsys.integration.alert.database.configuration.ConfigContextEntity;\n+import com.synopsys.integration.alert.database.configuration.DefinedFieldEntity;\n+import com.synopsys.integration.alert.database.configuration.DescriptorTypeEntity;\n+import com.synopsys.integration.alert.database.configuration.RegisteredDescriptorEntity;\n+import com.synopsys.integration.alert.database.configuration.repository.ConfigContextRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.DefinedFieldRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.DescriptorTypeRepository;\n+import com.synopsys.integration.alert.database.configuration.repository.RegisteredDescriptorRepository;\n+\n+public class DefaultDescriptorAccessorTest {\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultAuditUtility.class);\n+\n+    @Test\n+    public void getRegisteredDescriptorsTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findAll()).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptors();\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorByKeyTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorKey descriptorKey = createDescriptorKey(\"descriptorKey-test\");\n+        DescriptorKey emptyDescriptorKey = createDescriptorKey(\"bad-key\");\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findFirstByName(descriptorKey.getUniversalKey())).thenReturn(Optional.of(registeredDescriptorEntity));\n+        Mockito.when(registeredDescriptorRepository.findFirstByName(emptyDescriptorKey.getUniversalKey())).thenReturn(Optional.empty());\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModel = descriptorAccessor.getRegisteredDescriptorByKey(descriptorKey);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModelEmpty = descriptorAccessor.getRegisteredDescriptorByKey(emptyDescriptorKey);\n+\n+        assertTrue(registeredDescriptorModel.isPresent());\n+        assertFalse(registeredDescriptorModelEmpty.isPresent());\n+        assertEquals(name, registeredDescriptorModel.get().getName());\n+        assertEquals(descriptorType, registeredDescriptorModel.get().getType());\n+    }\n+\n+    @Test\n+    public void descriptorKeyFailureTest() throws Exception {\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(null, null, null, null);\n+        DescriptorKey descriptorKey = createDescriptorKey(\"\");\n+\n+        try {\n+            descriptorAccessor.getRegisteredDescriptorByKey(descriptorKey);\n+            fail();\n+        } catch (AlertDatabaseConstraintException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorsByTypeTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(1L);\n+\n+        Mockito.when(descriptorTypeRepository.findFirstByType(descriptorType.name())).thenReturn(Optional.of(descriptorTypeEntity));\n+        Mockito.when(registeredDescriptorRepository.findByTypeId(Mockito.any())).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(registeredDescriptorEntity.getTypeId())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorsByTypeMissingDescriptorTypeTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(1L);\n+\n+        Mockito.when(descriptorTypeRepository.findFirstByType(descriptorType.name())).thenReturn(Optional.empty());\n+        Mockito.when(descriptorTypeRepository.save(Mockito.any())).thenReturn(descriptorTypeEntity);\n+        Mockito.when(registeredDescriptorRepository.findByTypeId(Mockito.any())).thenReturn(List.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(registeredDescriptorEntity.getTypeId())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        List<RegisteredDescriptorModel> registeredDescriptorModelList = descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+\n+        assertEquals(1, registeredDescriptorModelList.size());\n+        assertEquals(name, registeredDescriptorModelList.get(0).getName());\n+        assertEquals(descriptorType, registeredDescriptorModelList.get(0).getType());\n+    }\n+\n+    @Test\n+    public void descriptorTypeFailureTest() throws Exception {\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(null, null, null, null);\n+        DescriptorType descriptorType = null;\n+\n+        try {\n+            descriptorAccessor.getRegisteredDescriptorsByType(descriptorType);\n+            fail();\n+        } catch (AlertDatabaseConstraintException e) {\n+            logger.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Test\n+    public void getRegisteredDescriptorByIdTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final DescriptorType descriptorType = DescriptorType.CHANNEL;\n+        final Long descriptorId = 2L;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorTypeEntity descriptorTypeEntity = new DescriptorTypeEntity(descriptorType.name());\n+        descriptorTypeEntity.setId(2L);\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findById(descriptorId)).thenReturn(Optional.of(registeredDescriptorEntity));\n+        Mockito.when(descriptorTypeRepository.findById(Mockito.any())).thenReturn(Optional.of(descriptorTypeEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, null, null, descriptorTypeRepository);\n+        Optional<RegisteredDescriptorModel> registeredDescriptorModel = descriptorAccessor.getRegisteredDescriptorById(descriptorId);\n+\n+        assertTrue(registeredDescriptorModel.isPresent());\n+        assertEquals(typeId, registeredDescriptorModel.get().getId());\n+        assertEquals(name, registeredDescriptorModel.get().getName());\n+        assertEquals(descriptorType, registeredDescriptorModel.get().getType());\n+    }\n+\n+    @Test\n+    public void getFieldsForDescriptorTest() throws Exception {\n+        final String name = \"name-test\";\n+        final Long typeId = 1L;\n+        final ConfigContextEnum configContextEnum = ConfigContextEnum.GLOBAL;\n+        final ConfigContextEnum invalidConfigContextEnum = ConfigContextEnum.DISTRIBUTION;\n+        final String definedFieldsKey = \"defined-field-key-test\";\n+        Boolean isSensitive = Boolean.TRUE;\n+\n+        RegisteredDescriptorEntity registeredDescriptorEntity = new RegisteredDescriptorEntity(name, typeId);\n+        registeredDescriptorEntity.setId(1L);\n+        DescriptorKey descriptorKey = createDescriptorKey(\"descriptorKey-test\");\n+        ConfigContextEntity configContextEntity = new ConfigContextEntity(configContextEnum.name());\n+        configContextEntity.setId(3L);\n+        DefinedFieldEntity definedFieldEntity = new DefinedFieldEntity(definedFieldsKey, isSensitive);\n+\n+        RegisteredDescriptorRepository registeredDescriptorRepository = Mockito.mock(RegisteredDescriptorRepository.class);\n+        DefinedFieldRepository definedFieldRepository = Mockito.mock(DefinedFieldRepository.class);\n+        ConfigContextRepository configContextRepository = Mockito.mock(ConfigContextRepository.class);\n+        DescriptorTypeRepository descriptorTypeRepository = Mockito.mock(DescriptorTypeRepository.class);\n+\n+        Mockito.when(registeredDescriptorRepository.findFirstByName(descriptorKey.getUniversalKey())).thenReturn(Optional.of(registeredDescriptorEntity));\n+        Mockito.when(configContextRepository.findFirstByContext(configContextEnum.name())).thenReturn(Optional.of(configContextEntity));\n+        //Used to test the optional expression\n+        Mockito.when(configContextRepository.findFirstByContext(invalidConfigContextEnum.name())).thenReturn(Optional.empty());\n+        Mockito.when(configContextRepository.save(Mockito.any())).thenReturn(configContextEntity);\n+        Mockito.when(definedFieldRepository.findByDescriptorIdAndContext(Mockito.any(), Mockito.any())).thenReturn(List.of(definedFieldEntity));\n+\n+        DefaultDescriptorAccessor descriptorAccessor = new DefaultDescriptorAccessor(registeredDescriptorRepository, definedFieldRepository, configContextRepository, descriptorTypeRepository);\n+        List<DefinedFieldModel> definedFieldModelList = descriptorAccessor.getFieldsForDescriptor(descriptorKey, configContextEnum);\n+        List<DefinedFieldModel> emptyConfigContextDefinedFieldModelList = descriptorAccessor.getFieldsForDescriptor(descriptorKey, invalidConfigContextEnum);\n+\n+        assertEquals(1, definedFieldModelList.size());\n+        assertEquals(definedFieldsKey, definedFieldModelList.get(0).getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 227}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjA1NTU1OnYy", "diffSide": "RIGHT", "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/mock/MockSettingsKeyRepository.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzowNDowMlrOGJOzpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzowNDowMlrOGJOzpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMzMjk2Ng==", "bodyText": "I understand this is a Mock object for tests but I think it would be best to follow good conventions and make these fields private and create setters or some methods to add to these Map's.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412332966", "createdAt": "2020-04-21T17:04:02Z", "author": {"login": "jamesrichard91"}, "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/mock/MockSettingsKeyRepository.java", "diffHunk": "@@ -0,0 +1,152 @@\n+package com.synopsys.integration.alert.database.api.mock;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.springframework.data.domain.Example;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.domain.Sort;\n+\n+import com.synopsys.integration.alert.database.settings.SettingsKeyEntity;\n+import com.synopsys.integration.alert.database.settings.SettingsKeyRepository;\n+\n+public class MockSettingsKeyRepository implements SettingsKeyRepository {\n+\n+    Map<String, SettingsKeyEntity> settingsKeyEntities = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjA2NTAxOnYy", "diffSide": "RIGHT", "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/mock/MockSystemStatusRepository.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzowNjowOVrOGJO5VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzowNjowOVrOGJO5VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMzNDQyMQ==", "bodyText": "Same as my comment above. We should make this field private and expose a setter for this method. We should also avoid hardcoding the fields. This reduces the usability of the mock object in the tests.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/958#discussion_r412334421", "createdAt": "2020-04-21T17:06:09Z", "author": {"login": "jamesrichard91"}, "path": "alert-database/src/test/java/com/synopsys/integration/alert/database/api/mock/MockSystemStatusRepository.java", "diffHunk": "@@ -0,0 +1,141 @@\n+package com.synopsys.integration.alert.database.api.mock;\n+\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.springframework.data.domain.Example;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.domain.Sort;\n+\n+import com.synopsys.integration.alert.database.system.SystemStatus;\n+import com.synopsys.integration.alert.database.system.SystemStatusRepository;\n+\n+public class MockSystemStatusRepository implements SystemStatusRepository {\n+\n+    //Only methods that are used by a test are currently implemented, all others are left default.\n+    SystemStatus systemStatus = new SystemStatus(Boolean.FALSE, new Date());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f855c6c40784106fd56df471fac6564d533acc8e"}, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1986, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}