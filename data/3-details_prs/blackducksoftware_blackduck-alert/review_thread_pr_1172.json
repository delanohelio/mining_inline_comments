{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4MjIzOTE3", "number": 1172, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMDo1MzoxM1rOEkPHbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDozOToyN1rOEkkh_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NDMxODU1OnYy", "diffSide": "RIGHT", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/CustomFunctionAction.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMDo1MzoxNFrOHTD0aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMjo1MToxNlrOHTghNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc0NzU2MA==", "bodyText": "So the assumption is that every \"function\" requires execute permission?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r489747560", "createdAt": "2020-09-16T20:53:14Z", "author": {"login": "jamesrichard91"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/CustomFunctionAction.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.action;\n+\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.server.ResponseStatusException;\n+\n+import com.synopsys.integration.alert.common.rest.HttpServletContentWrapper;\n+import com.synopsys.integration.alert.common.rest.ResponseFactory;\n+import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.alert.common.security.authorization.AuthorizationManager;\n+import com.synopsys.integration.exception.IntegrationException;\n+\n+public abstract class CustomFunctionAction<T> {\n+    public static final String API_FUNCTION_URL = \"/api/function\";\n+    private AuthorizationManager authorizationManager;\n+\n+    public CustomFunctionAction(AuthorizationManager authorizationManager) {\n+        this.authorizationManager = authorizationManager;\n+    }\n+\n+    public ActionResponse<T> createResponse(FieldModel fieldModel, HttpServletContentWrapper servletContentWrapper) {\n+        try {\n+            if (!authorizationManager.hasExecutePermission(fieldModel.getContext(), fieldModel.getDescriptorName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIxNTQ5MA==", "bodyText": "This is the same permission that we used to check in the CustomEndpointController in the past.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490215490", "createdAt": "2020-09-17T12:47:59Z", "author": {"login": "psantos1113"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/CustomFunctionAction.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.action;\n+\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.server.ResponseStatusException;\n+\n+import com.synopsys.integration.alert.common.rest.HttpServletContentWrapper;\n+import com.synopsys.integration.alert.common.rest.ResponseFactory;\n+import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.alert.common.security.authorization.AuthorizationManager;\n+import com.synopsys.integration.exception.IntegrationException;\n+\n+public abstract class CustomFunctionAction<T> {\n+    public static final String API_FUNCTION_URL = \"/api/function\";\n+    private AuthorizationManager authorizationManager;\n+\n+    public CustomFunctionAction(AuthorizationManager authorizationManager) {\n+        this.authorizationManager = authorizationManager;\n+    }\n+\n+    public ActionResponse<T> createResponse(FieldModel fieldModel, HttpServletContentWrapper servletContentWrapper) {\n+        try {\n+            if (!authorizationManager.hasExecutePermission(fieldModel.getContext(), fieldModel.getDescriptorName())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc0NzU2MA=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIxNzI1NA==", "bodyText": "I think it might be a good idea to create a SPIKE to determine if we should do this on a per-endpoint basis.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490217254", "createdAt": "2020-09-17T12:50:31Z", "author": {"login": "gkillough"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/CustomFunctionAction.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.action;\n+\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.server.ResponseStatusException;\n+\n+import com.synopsys.integration.alert.common.rest.HttpServletContentWrapper;\n+import com.synopsys.integration.alert.common.rest.ResponseFactory;\n+import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.alert.common.security.authorization.AuthorizationManager;\n+import com.synopsys.integration.exception.IntegrationException;\n+\n+public abstract class CustomFunctionAction<T> {\n+    public static final String API_FUNCTION_URL = \"/api/function\";\n+    private AuthorizationManager authorizationManager;\n+\n+    public CustomFunctionAction(AuthorizationManager authorizationManager) {\n+        this.authorizationManager = authorizationManager;\n+    }\n+\n+    public ActionResponse<T> createResponse(FieldModel fieldModel, HttpServletContentWrapper servletContentWrapper) {\n+        try {\n+            if (!authorizationManager.hasExecutePermission(fieldModel.getContext(), fieldModel.getDescriptorName())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc0NzU2MA=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIxNzc4Mg==", "bodyText": "Perhaps a protected method to perform the permissions check could be added to this class for now?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490217782", "createdAt": "2020-09-17T12:51:16Z", "author": {"login": "gkillough"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/CustomFunctionAction.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.action;\n+\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.server.ResponseStatusException;\n+\n+import com.synopsys.integration.alert.common.rest.HttpServletContentWrapper;\n+import com.synopsys.integration.alert.common.rest.ResponseFactory;\n+import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.alert.common.security.authorization.AuthorizationManager;\n+import com.synopsys.integration.exception.IntegrationException;\n+\n+public abstract class CustomFunctionAction<T> {\n+    public static final String API_FUNCTION_URL = \"/api/function\";\n+    private AuthorizationManager authorizationManager;\n+\n+    public CustomFunctionAction(AuthorizationManager authorizationManager) {\n+        this.authorizationManager = authorizationManager;\n+    }\n+\n+    public ActionResponse<T> createResponse(FieldModel fieldModel, HttpServletContentWrapper servletContentWrapper) {\n+        try {\n+            if (!authorizationManager.hasExecutePermission(fieldModel.getContext(), fieldModel.getDescriptorName())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc0NzU2MA=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NDM1MzI2OnYy", "diffSide": "RIGHT", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/field/LabelValueSelectOptions.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMTowNDowM1rOHTEJew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoyMjoxNVrOHTvqUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1Mjk1NQ==", "bodyText": "Is there a reason we are keeping this around? It seems like we have been changing the endpoints to return their own custom versions of FieldOptions. EX: ProviderProjectOptions.\nIt seems like the code is split between using this class as a general Option vs custom implementations of FieldOptions. Is the plan to use the class to replace those custom classes? or to replace this by creating more custom classes?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r489752955", "createdAt": "2020-09-16T21:04:03Z", "author": {"login": "jamesrichard91"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/field/LabelValueSelectOptions.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.descriptor.config.field;\n+\n+import java.util.List;\n+\n+public class LabelValueSelectOptions extends FieldOptions<LabelValueSelectOption> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIxOTMxNQ==", "bodyText": "If the other endpoints are returning FieldOptions<?> then I will change the usage to be consistent with what has been done.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490219315", "createdAt": "2020-09-17T12:53:36Z", "author": {"login": "psantos1113"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/field/LabelValueSelectOptions.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.descriptor.config.field;\n+\n+import java.util.List;\n+\n+public class LabelValueSelectOptions extends FieldOptions<LabelValueSelectOption> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1Mjk1NQ=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIzMzk5MQ==", "bodyText": "Look at most of the custom endpoints. 80% or more use this.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490233991", "createdAt": "2020-09-17T13:15:06Z", "author": {"login": "gkillough"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/field/LabelValueSelectOptions.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.descriptor.config.field;\n+\n+import java.util.List;\n+\n+public class LabelValueSelectOptions extends FieldOptions<LabelValueSelectOption> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1Mjk1NQ=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI2MDAxMA==", "bodyText": "Is that the distinction? The custom endpoints will use this class, while the other endpoints will create custom FieldOptions for the swagger?\nI just want to figure out what the difference is", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490260010", "createdAt": "2020-09-17T13:48:00Z", "author": {"login": "jamesrichard91"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/field/LabelValueSelectOptions.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.descriptor.config.field;\n+\n+import java.util.List;\n+\n+public class LabelValueSelectOptions extends FieldOptions<LabelValueSelectOption> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1Mjk1NQ=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NTg3Mw==", "bodyText": "The reason we have the specific types is because the response would be ActionResponse<FieldOptions> for the method.  In other places where I had a ActionResponse<List<SomeObject>> we wanted an object that wraps a list and return something like this ActionResponse<WrappedListObject>.\nSee this PR:\n#1158\nSince that was the preference of the team I created the following list wrapper objects:\nLabelValueSelectOptions\nProviderProjectOptions\nEmailAddressOptions\nNotificationFilterModelOptions\nProviderProjectOptions\nThis was done in this PR:\n#1160\nThe implementation was the same for each of these objects only the generic type was different.  So I created FieldOptions so I wouldn't write the same code over and over again.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490465873", "createdAt": "2020-09-17T18:22:15Z", "author": {"login": "psantos1113"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/field/LabelValueSelectOptions.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.descriptor.config.field;\n+\n+import java.util.List;\n+\n+public class LabelValueSelectOptions extends FieldOptions<LabelValueSelectOption> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1Mjk1NQ=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NDM2OTUwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/synopsys/integration/alert/channel/email/web/EmailAddressSelectOption.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMTowOTowN1rOHTEThQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzozNDoyNVrOHTt_5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NTUyNQ==", "bodyText": "We may want to discuss not exposing the optOut field, since it currently does not serve a functional purpose.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r489755525", "createdAt": "2020-09-16T21:09:07Z", "author": {"login": "jamesrichard91"}, "path": "src/main/java/com/synopsys/integration/alert/channel/email/web/EmailAddressSelectOption.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * blackduck-alert\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.channel.email.web;\n+\n+import com.synopsys.integration.alert.common.rest.model.AlertSerializableModel;\n+\n+public class EmailAddressSelectOption extends AlertSerializableModel {\n+    private String emailAddress;\n+    private Boolean optOut;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIxNzA1Mw==", "bodyText": "We can annotate it with JSONIgnore so that Jackson will not serialize it or if we aren't going to have optOut then we should remove it.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490217053", "createdAt": "2020-09-17T12:50:13Z", "author": {"login": "psantos1113"}, "path": "src/main/java/com/synopsys/integration/alert/channel/email/web/EmailAddressSelectOption.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * blackduck-alert\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.channel.email.web;\n+\n+import com.synopsys.integration.alert.common.rest.model.AlertSerializableModel;\n+\n+public class EmailAddressSelectOption extends AlertSerializableModel {\n+    private String emailAddress;\n+    private Boolean optOut;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NTUyNQ=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzODYzMQ==", "bodyText": "Alert is already serializing the optOut from the ProviderUserModel class. That's what the custom endpoint did in the past.  Since the custom endpoint dealt with email addresses I created this object to represent the email address data.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490438631", "createdAt": "2020-09-17T17:34:25Z", "author": {"login": "psantos1113"}, "path": "src/main/java/com/synopsys/integration/alert/channel/email/web/EmailAddressSelectOption.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * blackduck-alert\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.channel.email.web;\n+\n+import com.synopsys.integration.alert.common.rest.model.AlertSerializableModel;\n+\n+public class EmailAddressSelectOption extends AlertSerializableModel {\n+    private String emailAddress;\n+    private Boolean optOut;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NTUyNQ=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NDM4MzkxOnYy", "diffSide": "RIGHT", "path": "src/test/java/com/synopsys/integration/alert/component/settings/PasswordResetServiceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMToxMzo0NVrOHTEchQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMjo1MTozN1rOHTgiFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NzgyOQ==", "bodyText": "This seems odd. Why did this get changed to blackducksoftware?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r489757829", "createdAt": "2020-09-16T21:13:45Z", "author": {"login": "jamesrichard91"}, "path": "src/test/java/com/synopsys/integration/alert/component/settings/PasswordResetServiceTest.java", "diffHunk": "@@ -110,7 +110,7 @@ public void resetPasswordValidTestIT() throws AlertException {\n         addConfigurationFieldToMap(keyToFieldMap, EmailPropertyKeys.JAVAMAIL_PORT_KEY.getPropertyKey(), testProperties.getProperty(TestPropertyKey.TEST_EMAIL_SMTP_PORT));\n \n         String username = \"username\";\n-        UserModel userModel = UserModel.newUser(username, \"\", \"noreply@synopsys.com\", AuthenticationType.DATABASE, Set.of(), true);\n+        UserModel userModel = UserModel.newUser(username, \"\", \"noreply@blackducksoftware.com\", AuthenticationType.DATABASE, Set.of(), true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIxODAwNg==", "bodyText": "the mail server we use for testing cannot resolve noreply@synopsys.com but it can resolve noreply@blackducksoftware.com since that is the default set in black duck for the sysadmin user.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490218006", "createdAt": "2020-09-17T12:51:37Z", "author": {"login": "psantos1113"}, "path": "src/test/java/com/synopsys/integration/alert/component/settings/PasswordResetServiceTest.java", "diffHunk": "@@ -110,7 +110,7 @@ public void resetPasswordValidTestIT() throws AlertException {\n         addConfigurationFieldToMap(keyToFieldMap, EmailPropertyKeys.JAVAMAIL_PORT_KEY.getPropertyKey(), testProperties.getProperty(TestPropertyKey.TEST_EMAIL_SMTP_PORT));\n \n         String username = \"username\";\n-        UserModel userModel = UserModel.newUser(username, \"\", \"noreply@synopsys.com\", AuthenticationType.DATABASE, Set.of(), true);\n+        UserModel userModel = UserModel.newUser(username, \"\", \"noreply@blackducksoftware.com\", AuthenticationType.DATABASE, Set.of(), true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1NzgyOQ=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzMwMTQwOnYy", "diffSide": "RIGHT", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/ValidationActionResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMjo1MjoyNVrOHTgkHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMjo1MjoyNVrOHTgkHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIxODUyNw==", "bodyText": "There is a space before the colon.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490218527", "createdAt": "2020-09-17T12:52:25Z", "author": {"login": "gkillough"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/ValidationActionResponse.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.action;\n+\n+import java.util.Optional;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.springframework.http.HttpStatus;\n+\n+import com.synopsys.integration.alert.common.rest.model.ValidationResponseModel;\n+import com.synopsys.integration.rest.exception.IntegrationRestException;\n+\n+public class ValidationActionResponse extends ActionResponse<ValidationResponseModel> {\n+\n+    public static ValidationActionResponse createResponseFromIntegrationRestException(IntegrationRestException integrationRestException) {\n+        String exceptionMessage = integrationRestException.getMessage();\n+        String message = exceptionMessage;\n+        if (StringUtils.isNotBlank(integrationRestException.getHttpStatusMessage())) {\n+            message += \" : \" + integrationRestException.getHttpStatusMessage();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzMxNzAwOnYy", "diffSide": "RIGHT", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/api/AbstractConfigResourceActions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMjo1NjowMFrOHTgtqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMjo1NjowMFrOHTgtqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIyMDk3MQ==", "bodyText": "I'm still not in love with the naming here. createAfterChecks sounds like it will perform checks before creating IMO. createWithoutChecks seems like it would be more appropriate.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490220971", "createdAt": "2020-09-17T12:56:00Z", "author": {"login": "gkillough"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/api/AbstractConfigResourceActions.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.action.api;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.springframework.http.HttpStatus;\n+\n+import com.synopsys.integration.alert.common.action.ActionResponse;\n+import com.synopsys.integration.alert.common.action.ValidationActionResponse;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.exception.AlertException;\n+import com.synopsys.integration.alert.common.persistence.accessor.DescriptorAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.RegisteredDescriptorModel;\n+import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.alert.common.rest.model.ValidationResponseModel;\n+import com.synopsys.integration.alert.common.security.authorization.AuthorizationManager;\n+\n+public abstract class AbstractConfigResourceActions implements LongResourceActions<FieldModel>, TestAction<FieldModel>, ValidateAction<FieldModel> {\n+    private AuthorizationManager authorizationManager;\n+    private DescriptorAccessor descriptorAccessor;\n+\n+    public AbstractConfigResourceActions(AuthorizationManager authorizationManager, DescriptorAccessor descriptorAccessor) {\n+        this.authorizationManager = authorizationManager;\n+        this.descriptorAccessor = descriptorAccessor;\n+    }\n+\n+    protected abstract ActionResponse<FieldModel> createAfterChecks(FieldModel resource);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzMxOTMyOnYy", "diffSide": "RIGHT", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/api/AbstractConfigResourceActions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMjo1NjozNlrOHTgvKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMjo1NjozNlrOHTgvKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIyMTM1Mw==", "bodyText": "Can this method be final? Is there a reason not to make it final here?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490221353", "createdAt": "2020-09-17T12:56:36Z", "author": {"login": "gkillough"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/api/AbstractConfigResourceActions.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.action.api;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.springframework.http.HttpStatus;\n+\n+import com.synopsys.integration.alert.common.action.ActionResponse;\n+import com.synopsys.integration.alert.common.action.ValidationActionResponse;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.exception.AlertException;\n+import com.synopsys.integration.alert.common.persistence.accessor.DescriptorAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.RegisteredDescriptorModel;\n+import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.alert.common.rest.model.ValidationResponseModel;\n+import com.synopsys.integration.alert.common.security.authorization.AuthorizationManager;\n+\n+public abstract class AbstractConfigResourceActions implements LongResourceActions<FieldModel>, TestAction<FieldModel>, ValidateAction<FieldModel> {\n+    private AuthorizationManager authorizationManager;\n+    private DescriptorAccessor descriptorAccessor;\n+\n+    public AbstractConfigResourceActions(AuthorizationManager authorizationManager, DescriptorAccessor descriptorAccessor) {\n+        this.authorizationManager = authorizationManager;\n+        this.descriptorAccessor = descriptorAccessor;\n+    }\n+\n+    protected abstract ActionResponse<FieldModel> createAfterChecks(FieldModel resource);\n+\n+    protected abstract ActionResponse<FieldModel> deleteAfterChecks(Long id);\n+\n+    protected abstract ActionResponse<List<FieldModel>> readAllAfterChecks();\n+\n+    protected abstract ActionResponse<List<FieldModel>> readAllByContextAndDescriptorAfterChecks(String context, String descriptorName);\n+\n+    protected abstract Optional<FieldModel> findFieldModel(Long id);\n+\n+    protected abstract ValidationActionResponse testAfterChecks(FieldModel resource);\n+\n+    protected abstract ActionResponse<FieldModel> updateAfterChecks(Long id, FieldModel resource);\n+\n+    protected abstract ValidationActionResponse validateAfterChecks(FieldModel resource);\n+\n+    public ActionResponse<List<FieldModel>> getAllByContextAndDescriptor(String context, String descriptorName) {\n+        if (!authorizationManager.hasReadPermission(context, descriptorName)) {\n+            return ActionResponse.createForbiddenResponse();\n+        }\n+        return readAllByContextAndDescriptorAfterChecks(context, descriptorName);\n+    }\n+\n+    @Override\n+    public ActionResponse<FieldModel> create(FieldModel resource) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzMzMTQxOnYy", "diffSide": "RIGHT", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/api/AbstractJobResourceActions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMjo1OToxMVrOHTg2Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDozNjoyM1rOHTleDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIyMzE2Mg==", "bodyText": "@bamandel Did you create a ticket to investigate throwing AlertDatabaseConstraintException? I think no-args methods like this are definitely a good candidate to remove the exception.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490223162", "createdAt": "2020-09-17T12:59:11Z", "author": {"login": "gkillough"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/api/AbstractJobResourceActions.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.action.api;\n+\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+import org.springframework.http.HttpStatus;\n+\n+import com.synopsys.integration.alert.common.action.ActionResponse;\n+import com.synopsys.integration.alert.common.action.ValidationActionResponse;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.enumeration.DescriptorType;\n+import com.synopsys.integration.alert.common.exception.AlertDatabaseConstraintException;\n+import com.synopsys.integration.alert.common.persistence.accessor.DescriptorAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.RegisteredDescriptorModel;\n+import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.alert.common.rest.model.JobFieldModel;\n+import com.synopsys.integration.alert.common.rest.model.ValidationResponseModel;\n+import com.synopsys.integration.alert.common.security.authorization.AuthorizationManager;\n+\n+public abstract class AbstractJobResourceActions implements JobResourceActions, ValidateAction<JobFieldModel>, TestAction<JobFieldModel> {\n+    private static final EnumSet<DescriptorType> ALLOWED_JOB_DESCRIPTOR_TYPES = EnumSet.of(DescriptorType.PROVIDER, DescriptorType.CHANNEL);\n+    private AuthorizationManager authorizationManager;\n+    private DescriptorAccessor descriptorAccessor;\n+\n+    public AbstractJobResourceActions(AuthorizationManager authorizationManager, DescriptorAccessor descriptorAccessor) {\n+        this.authorizationManager = authorizationManager;\n+        this.descriptorAccessor = descriptorAccessor;\n+    }\n+\n+    protected abstract Optional<JobFieldModel> findJobFieldModel(UUID id);\n+\n+    protected abstract ActionResponse<JobFieldModel> createAfterChecks(JobFieldModel resource);\n+\n+    protected abstract ActionResponse<JobFieldModel> deleteAfterChecks(UUID id);\n+\n+    protected abstract ActionResponse<List<JobFieldModel>> readAllAfterChecks();\n+\n+    protected abstract ValidationActionResponse testAfterChecks(JobFieldModel resource);\n+\n+    protected abstract ActionResponse<JobFieldModel> updateAfterChecks(UUID id, JobFieldModel resource);\n+\n+    protected abstract ValidationActionResponse validateAfterChecks(JobFieldModel resource);\n+\n+    private Set<String> getDescriptorNames() {\n+        Set<String> descriptorNames = Set.of();\n+        try {\n+            descriptorNames = descriptorAccessor.getRegisteredDescriptors()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI5ODg5Mw==", "bodyText": "Yes, there's a Spike in 7.0.0 to investigate whether the exception is necessary.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490298893", "createdAt": "2020-09-17T14:36:23Z", "author": {"login": "bamandel"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/api/AbstractJobResourceActions.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.action.api;\n+\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+import org.springframework.http.HttpStatus;\n+\n+import com.synopsys.integration.alert.common.action.ActionResponse;\n+import com.synopsys.integration.alert.common.action.ValidationActionResponse;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.enumeration.DescriptorType;\n+import com.synopsys.integration.alert.common.exception.AlertDatabaseConstraintException;\n+import com.synopsys.integration.alert.common.persistence.accessor.DescriptorAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.RegisteredDescriptorModel;\n+import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.alert.common.rest.model.JobFieldModel;\n+import com.synopsys.integration.alert.common.rest.model.ValidationResponseModel;\n+import com.synopsys.integration.alert.common.security.authorization.AuthorizationManager;\n+\n+public abstract class AbstractJobResourceActions implements JobResourceActions, ValidateAction<JobFieldModel>, TestAction<JobFieldModel> {\n+    private static final EnumSet<DescriptorType> ALLOWED_JOB_DESCRIPTOR_TYPES = EnumSet.of(DescriptorType.PROVIDER, DescriptorType.CHANNEL);\n+    private AuthorizationManager authorizationManager;\n+    private DescriptorAccessor descriptorAccessor;\n+\n+    public AbstractJobResourceActions(AuthorizationManager authorizationManager, DescriptorAccessor descriptorAccessor) {\n+        this.authorizationManager = authorizationManager;\n+        this.descriptorAccessor = descriptorAccessor;\n+    }\n+\n+    protected abstract Optional<JobFieldModel> findJobFieldModel(UUID id);\n+\n+    protected abstract ActionResponse<JobFieldModel> createAfterChecks(JobFieldModel resource);\n+\n+    protected abstract ActionResponse<JobFieldModel> deleteAfterChecks(UUID id);\n+\n+    protected abstract ActionResponse<List<JobFieldModel>> readAllAfterChecks();\n+\n+    protected abstract ValidationActionResponse testAfterChecks(JobFieldModel resource);\n+\n+    protected abstract ActionResponse<JobFieldModel> updateAfterChecks(UUID id, JobFieldModel resource);\n+\n+    protected abstract ValidationActionResponse validateAfterChecks(JobFieldModel resource);\n+\n+    private Set<String> getDescriptorNames() {\n+        Set<String> descriptorNames = Set.of();\n+        try {\n+            descriptorNames = descriptorAccessor.getRegisteredDescriptors()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIyMzE2Mg=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzMzNjQyOnYy", "diffSide": "RIGHT", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/api/AbstractJobResourceActions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzowMDoxNVrOHTg5FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzowMDoxNVrOHTg5FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIyMzg5Mg==", "bodyText": "Same comment about final as is in the other ResourceActions abstract class.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490223892", "createdAt": "2020-09-17T13:00:15Z", "author": {"login": "gkillough"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/api/AbstractJobResourceActions.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.action.api;\n+\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+import org.springframework.http.HttpStatus;\n+\n+import com.synopsys.integration.alert.common.action.ActionResponse;\n+import com.synopsys.integration.alert.common.action.ValidationActionResponse;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.enumeration.DescriptorType;\n+import com.synopsys.integration.alert.common.exception.AlertDatabaseConstraintException;\n+import com.synopsys.integration.alert.common.persistence.accessor.DescriptorAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.RegisteredDescriptorModel;\n+import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.alert.common.rest.model.JobFieldModel;\n+import com.synopsys.integration.alert.common.rest.model.ValidationResponseModel;\n+import com.synopsys.integration.alert.common.security.authorization.AuthorizationManager;\n+\n+public abstract class AbstractJobResourceActions implements JobResourceActions, ValidateAction<JobFieldModel>, TestAction<JobFieldModel> {\n+    private static final EnumSet<DescriptorType> ALLOWED_JOB_DESCRIPTOR_TYPES = EnumSet.of(DescriptorType.PROVIDER, DescriptorType.CHANNEL);\n+    private AuthorizationManager authorizationManager;\n+    private DescriptorAccessor descriptorAccessor;\n+\n+    public AbstractJobResourceActions(AuthorizationManager authorizationManager, DescriptorAccessor descriptorAccessor) {\n+        this.authorizationManager = authorizationManager;\n+        this.descriptorAccessor = descriptorAccessor;\n+    }\n+\n+    protected abstract Optional<JobFieldModel> findJobFieldModel(UUID id);\n+\n+    protected abstract ActionResponse<JobFieldModel> createAfterChecks(JobFieldModel resource);\n+\n+    protected abstract ActionResponse<JobFieldModel> deleteAfterChecks(UUID id);\n+\n+    protected abstract ActionResponse<List<JobFieldModel>> readAllAfterChecks();\n+\n+    protected abstract ValidationActionResponse testAfterChecks(JobFieldModel resource);\n+\n+    protected abstract ActionResponse<JobFieldModel> updateAfterChecks(UUID id, JobFieldModel resource);\n+\n+    protected abstract ValidationActionResponse validateAfterChecks(JobFieldModel resource);\n+\n+    private Set<String> getDescriptorNames() {\n+        Set<String> descriptorNames = Set.of();\n+        try {\n+            descriptorNames = descriptorAccessor.getRegisteredDescriptors()\n+                                  .stream()\n+                                  .filter(descriptor -> ALLOWED_JOB_DESCRIPTOR_TYPES.contains(descriptor.getType()))\n+                                  .map(RegisteredDescriptorModel::getName)\n+                                  .collect(Collectors.toSet());\n+        } catch (AlertDatabaseConstraintException ex) {\n+            // ignore or add a logger.\n+        }\n+\n+        return descriptorNames;\n+    }\n+\n+    @Override\n+    public ActionResponse<JobFieldModel> create(JobFieldModel resource) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzM0MzU2OnYy", "diffSide": "RIGHT", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/api/LongResourceActions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzowMTo0NVrOHTg9Jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzowMTo0NVrOHTg9Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIyNDkzNA==", "bodyText": "I feel like LongIdResourceActions might be a better name. Thoughts?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490224934", "createdAt": "2020-09-17T13:01:45Z", "author": {"login": "gkillough"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/action/api/LongResourceActions.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.action.api;\n+\n+public interface LongResourceActions<T> extends ResourceActions<T, Long> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzM2MzgzOnYy", "diffSide": "RIGHT", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/field/endpoint/oauth/OAuthEndpointResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzowNjozMFrOHThJZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzowNjozMFrOHThJZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIyODA2OA==", "bodyText": "We have a class called AlertSerializableModel that extends Stringable and implements Serializable so that we don't have to extend both like this.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490228068", "createdAt": "2020-09-17T13:06:30Z", "author": {"login": "gkillough"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/field/endpoint/oauth/OAuthEndpointResponse.java", "diffHunk": "@@ -27,23 +27,16 @@\n import com.synopsys.integration.util.Stringable;\n \n public class OAuthEndpointResponse extends Stringable implements Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzQxODc1OnYy", "diffSide": "RIGHT", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/rest/api/BaseJobResourceController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzoxODo0NVrOHThqhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoxMjoyNlrOHTvVFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIzNjU1MQ==", "bodyText": "Should we do something similar here to abstract the id Type?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490236551", "createdAt": "2020-09-17T13:18:45Z", "author": {"login": "gkillough"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/rest/api/BaseJobResourceController.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.rest.api;\n+\n+import java.util.UUID;\n+\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.DeleteMapping;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.bind.annotation.PutMapping;\n+import org.springframework.web.bind.annotation.RequestBody;\n+import org.springframework.web.bind.annotation.ResponseStatus;\n+\n+import com.synopsys.integration.alert.common.rest.model.JobFieldModel;\n+\n+public interface BaseJobResourceController {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNzc4Ng==", "bodyText": "We'd have to abstract more than just the ID we'd have to abstract the request body as well. If that's something we really want to do we can do that in a smaller PR after the fact.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490417786", "createdAt": "2020-09-17T16:59:43Z", "author": {"login": "psantos1113"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/rest/api/BaseJobResourceController.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.rest.api;\n+\n+import java.util.UUID;\n+\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.DeleteMapping;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.bind.annotation.PutMapping;\n+import org.springframework.web.bind.annotation.RequestBody;\n+import org.springframework.web.bind.annotation.ResponseStatus;\n+\n+import com.synopsys.integration.alert.common.rest.model.JobFieldModel;\n+\n+public interface BaseJobResourceController {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIzNjU1MQ=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MDQzNw==", "bodyText": "Let's leave it out for now.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490460437", "createdAt": "2020-09-17T18:12:26Z", "author": {"login": "gkillough"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/rest/api/BaseJobResourceController.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.rest.api;\n+\n+import java.util.UUID;\n+\n+import org.springframework.http.HttpStatus;\n+import org.springframework.web.bind.annotation.DeleteMapping;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.bind.annotation.PutMapping;\n+import org.springframework.web.bind.annotation.RequestBody;\n+import org.springframework.web.bind.annotation.ResponseStatus;\n+\n+import com.synopsys.integration.alert.common.rest.model.JobFieldModel;\n+\n+public interface BaseJobResourceController {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIzNjU1MQ=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzQzMTgwOnYy", "diffSide": "RIGHT", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/rest/api/ValidateController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzoyMToxN1rOHThyNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo1ODowN1rOHTsqrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIzODUxOQ==", "bodyText": "This is trivial, but why was a different generic character used here rather than <T>?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490238519", "createdAt": "2020-09-17T13:21:17Z", "author": {"login": "gkillough"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/rest/api/ValidateController.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.rest.api;\n+\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.bind.annotation.RequestBody;\n+\n+import com.synopsys.integration.alert.common.rest.model.ValidationResponseModel;\n+\n+public interface ValidateController<S> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNjgxMg==", "bodyText": "There was initially in the first version going to be a generic for response R it was going to be ValidateController<S,R> but I didn't need the second type.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490416812", "createdAt": "2020-09-17T16:58:07Z", "author": {"login": "psantos1113"}, "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/rest/api/ValidateController.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.rest.api;\n+\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.bind.annotation.RequestBody;\n+\n+import com.synopsys.integration.alert.common.rest.model.ValidationResponseModel;\n+\n+public interface ValidateController<S> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDIzODUxOQ=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzUwOTA3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/synopsys/integration/alert/channel/jira/cloud/web/JiraCloudCustomEndpoint.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzozNTozMVrOHTijSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzozNTozMVrOHTijSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI1MTA4MQ==", "bodyText": "I know you didn't make this change, but can we change the wording to be \"Unable to confirm...\" rather than \"Was not able to confirm...\"?", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490251081", "createdAt": "2020-09-17T13:35:31Z", "author": {"login": "gkillough"}, "path": "src/main/java/com/synopsys/integration/alert/channel/jira/cloud/web/JiraCloudCustomEndpoint.java", "diffHunk": "@@ -81,20 +78,20 @@ public JiraCloudCustomEndpoint(JiraCloudChannelKey jiraChannelKey, CustomEndpoin\n             String accessToken = jiraProperties.getAccessToken();\n             Response response = jiraAppService.installMarketplaceCloudApp(JiraConstants.JIRA_APP_KEY, username, accessToken);\n             if (BooleanUtils.isTrue(response.isStatusCodeError())) {\n-                return responseFactory.createBadRequestResponse(\"\", \"The Jira Cloud server responded with error code: \" + response.getStatusCode());\n+                return new ActionResponse<>(HttpStatus.BAD_REQUEST, \"The Jira Cloud server responded with error code: \" + response.getStatusCode());\n             }\n             boolean jiraPluginInstalled = isJiraPluginInstalled(jiraAppService, accessToken, username, JiraConstants.JIRA_APP_KEY);\n             if (!jiraPluginInstalled) {\n-                return responseFactory.createNotFoundResponse(\"Was not able to confirm Jira Cloud successfully installed the Jira Cloud plugin. Please verify the installation on you Jira Cloud server.\");\n+                return new ActionResponse<>(HttpStatus.NOT_FOUND, \"Was not able to confirm Jira Cloud successfully installed the Jira Cloud plugin. Please verify the installation on you Jira Cloud server.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzY5NzE2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/synopsys/integration/alert/web/api/job/JobConfigActions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDoxMzo1MFrOHTkWrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzowMzo1MlrOHTs4kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI4MDYyMg==", "bodyText": "If this is missing, I believe we should return a 404 to conform to the RFC standard.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490280622", "createdAt": "2020-09-17T14:13:50Z", "author": {"login": "gkillough"}, "path": "src/main/java/com/synopsys/integration/alert/web/api/job/JobConfigActions.java", "diffHunk": "@@ -56,150 +62,183 @@\n import com.synopsys.integration.alert.common.exception.AlertMethodNotAllowedException;\n import com.synopsys.integration.alert.common.message.model.MessageResult;\n import com.synopsys.integration.alert.common.persistence.accessor.ConfigurationAccessor;\n+import com.synopsys.integration.alert.common.persistence.accessor.DescriptorAccessor;\n import com.synopsys.integration.alert.common.persistence.accessor.FieldAccessor;\n import com.synopsys.integration.alert.common.persistence.model.ConfigurationFieldModel;\n import com.synopsys.integration.alert.common.persistence.model.ConfigurationJobModel;\n import com.synopsys.integration.alert.common.persistence.model.ConfigurationModel;\n+import com.synopsys.integration.alert.common.persistence.model.PermissionKey;\n import com.synopsys.integration.alert.common.persistence.util.ConfigurationFieldModelConverter;\n import com.synopsys.integration.alert.common.rest.model.FieldModel;\n import com.synopsys.integration.alert.common.rest.model.FieldValueModel;\n import com.synopsys.integration.alert.common.rest.model.JobFieldModel;\n import com.synopsys.integration.alert.common.rest.model.JobFieldStatuses;\n+import com.synopsys.integration.alert.common.rest.model.ValidationResponseModel;\n+import com.synopsys.integration.alert.common.security.authorization.AuthorizationManager;\n+import com.synopsys.integration.alert.web.common.PKIXErrorResponseFactory;\n import com.synopsys.integration.alert.web.common.descriptor.DescriptorProcessor;\n import com.synopsys.integration.alert.web.common.field.FieldModelProcessor;\n import com.synopsys.integration.exception.IntegrationException;\n+import com.synopsys.integration.rest.exception.IntegrationRestException;\n \n @Component\n-public class JobConfigActions {\n+public class JobConfigActions extends AbstractJobResourceActions {\n     private final Logger logger = LoggerFactory.getLogger(JobConfigActions.class);\n     private final ConfigurationAccessor configurationAccessor;\n     private final FieldModelProcessor fieldModelProcessor;\n     private final DescriptorProcessor descriptorProcessor;\n     private final ConfigurationFieldModelConverter modelConverter;\n     private final GlobalConfigExistsValidator globalConfigExistsValidator;\n+    private final PKIXErrorResponseFactory pkixErrorResponseFactory;\n+    private final DescriptorMap descriptorMap;\n \n     @Autowired\n-    public JobConfigActions(ConfigurationAccessor configurationAccessor, FieldModelProcessor fieldModelProcessor, DescriptorProcessor descriptorProcessor, ConfigurationFieldModelConverter modelConverter,\n-        GlobalConfigExistsValidator globalConfigExistsValidator) {\n+    public JobConfigActions(AuthorizationManager authorizationManager, DescriptorAccessor descriptorAccessor, ConfigurationAccessor configurationAccessor, FieldModelProcessor fieldModelProcessor, DescriptorProcessor descriptorProcessor,\n+        ConfigurationFieldModelConverter modelConverter, GlobalConfigExistsValidator globalConfigExistsValidator, PKIXErrorResponseFactory pkixErrorResponseFactory, DescriptorMap descriptorMap) {\n+        super(authorizationManager, descriptorAccessor);\n         this.configurationAccessor = configurationAccessor;\n         this.fieldModelProcessor = fieldModelProcessor;\n         this.descriptorProcessor = descriptorProcessor;\n         this.modelConverter = modelConverter;\n         this.globalConfigExistsValidator = globalConfigExistsValidator;\n+        this.pkixErrorResponseFactory = pkixErrorResponseFactory;\n+        this.descriptorMap = descriptorMap;\n     }\n \n-    public boolean doesJobExist(UUID id) throws AlertDatabaseConstraintException {\n-        return null != id && configurationAccessor.getJobById(id).isPresent();\n-    }\n-\n-    public boolean doesJobExist(String id) throws AlertDatabaseConstraintException {\n-        return doesJobExist(UUID.fromString(id));\n-    }\n-\n-    public Optional<JobFieldModel> getJobById(UUID id) throws AlertException {\n-        Optional<ConfigurationJobModel> jobConfiguration = configurationAccessor.getJobById(id);\n-        if (jobConfiguration.isPresent()) {\n-            JobFieldModel jobFieldModel = readJobConfiguration(jobConfiguration.get());\n-            return Optional.of(jobFieldModel);\n+    @Override\n+    protected Optional<JobFieldModel> findJobFieldModel(UUID id) {\n+        try {\n+            Optional<ConfigurationJobModel> jobConfiguration = configurationAccessor.getJobById(id);\n+            if (jobConfiguration.isPresent()) {\n+                JobFieldModel jobFieldModel = readJobConfiguration(jobConfiguration.get());\n+                return Optional.of(jobFieldModel);\n+            }\n+        } catch (AlertException ex) {\n+            logger.error(String.format(\"Error finding job configuration id: %s\", id), ex);\n         }\n         return Optional.empty();\n     }\n \n-    public List<JobFieldModel> getAllJobs() throws AlertException {\n-        List<ConfigurationJobModel> allJobs = configurationAccessor.getAllJobs();\n-        List<JobFieldModel> jobFieldModels = new LinkedList<>();\n-        for (ConfigurationJobModel configurationJobModel : allJobs) {\n-            JobFieldModel jobFieldModel = readJobConfiguration(configurationJobModel);\n-            jobFieldModels.add(jobFieldModel);\n+    @Override\n+    protected ActionResponse<List<JobFieldModel>> readAllAfterChecks() {\n+        try {\n+            List<ConfigurationJobModel> allJobs = configurationAccessor.getAllJobs();\n+            List<JobFieldModel> jobFieldModels = new LinkedList<>();\n+            for (ConfigurationJobModel configurationJobModel : allJobs) {\n+                JobFieldModel jobFieldModel = readJobConfiguration(configurationJobModel);\n+                jobFieldModels.add(jobFieldModel);\n+            }\n+            return new ActionResponse<>(HttpStatus.OK, jobFieldModels);\n+        } catch (AlertException ex) {\n+            logger.error(\"Error reading all jobs\", ex);\n+            return new ActionResponse<>(HttpStatus.INTERNAL_SERVER_ERROR, ex.getMessage());\n         }\n-        return jobFieldModels;\n     }\n \n-    public void deleteJobById(UUID id) throws AlertException {\n-        Optional<ConfigurationJobModel> jobs = configurationAccessor.getJobById(id);\n-        if (jobs.isPresent()) {\n-            LinkedList<FieldModel> processedFieldModels = new LinkedList<>();\n-            ConfigurationJobModel configurationJobModel = jobs.get();\n-            for (ConfigurationModel configurationModel : configurationJobModel.getCopyOfConfigurations()) {\n-                FieldModel convertedFieldModel = modelConverter.convertToFieldModel(configurationModel);\n-                FieldModel fieldModel = fieldModelProcessor.performBeforeDeleteAction(convertedFieldModel);\n-                processedFieldModels.add(fieldModel);\n-            }\n-            configurationAccessor.deleteJob(configurationJobModel.getJobId());\n-            for (FieldModel fieldModel : processedFieldModels) {\n-                fieldModelProcessor.performAfterDeleteAction(fieldModel);\n+    @Override\n+    protected ActionResponse<JobFieldModel> deleteAfterChecks(UUID id) {\n+        try {\n+            Optional<ConfigurationJobModel> jobs = configurationAccessor.getJobById(id);\n+            if (jobs.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMDM3MA==", "bodyText": "We already check if the object is present and will return a 404 not found in the delete method of AbstractJobResourceAction.  The check for if present is because the getJobById returns an optional.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490420370", "createdAt": "2020-09-17T17:03:52Z", "author": {"login": "psantos1113"}, "path": "src/main/java/com/synopsys/integration/alert/web/api/job/JobConfigActions.java", "diffHunk": "@@ -56,150 +62,183 @@\n import com.synopsys.integration.alert.common.exception.AlertMethodNotAllowedException;\n import com.synopsys.integration.alert.common.message.model.MessageResult;\n import com.synopsys.integration.alert.common.persistence.accessor.ConfigurationAccessor;\n+import com.synopsys.integration.alert.common.persistence.accessor.DescriptorAccessor;\n import com.synopsys.integration.alert.common.persistence.accessor.FieldAccessor;\n import com.synopsys.integration.alert.common.persistence.model.ConfigurationFieldModel;\n import com.synopsys.integration.alert.common.persistence.model.ConfigurationJobModel;\n import com.synopsys.integration.alert.common.persistence.model.ConfigurationModel;\n+import com.synopsys.integration.alert.common.persistence.model.PermissionKey;\n import com.synopsys.integration.alert.common.persistence.util.ConfigurationFieldModelConverter;\n import com.synopsys.integration.alert.common.rest.model.FieldModel;\n import com.synopsys.integration.alert.common.rest.model.FieldValueModel;\n import com.synopsys.integration.alert.common.rest.model.JobFieldModel;\n import com.synopsys.integration.alert.common.rest.model.JobFieldStatuses;\n+import com.synopsys.integration.alert.common.rest.model.ValidationResponseModel;\n+import com.synopsys.integration.alert.common.security.authorization.AuthorizationManager;\n+import com.synopsys.integration.alert.web.common.PKIXErrorResponseFactory;\n import com.synopsys.integration.alert.web.common.descriptor.DescriptorProcessor;\n import com.synopsys.integration.alert.web.common.field.FieldModelProcessor;\n import com.synopsys.integration.exception.IntegrationException;\n+import com.synopsys.integration.rest.exception.IntegrationRestException;\n \n @Component\n-public class JobConfigActions {\n+public class JobConfigActions extends AbstractJobResourceActions {\n     private final Logger logger = LoggerFactory.getLogger(JobConfigActions.class);\n     private final ConfigurationAccessor configurationAccessor;\n     private final FieldModelProcessor fieldModelProcessor;\n     private final DescriptorProcessor descriptorProcessor;\n     private final ConfigurationFieldModelConverter modelConverter;\n     private final GlobalConfigExistsValidator globalConfigExistsValidator;\n+    private final PKIXErrorResponseFactory pkixErrorResponseFactory;\n+    private final DescriptorMap descriptorMap;\n \n     @Autowired\n-    public JobConfigActions(ConfigurationAccessor configurationAccessor, FieldModelProcessor fieldModelProcessor, DescriptorProcessor descriptorProcessor, ConfigurationFieldModelConverter modelConverter,\n-        GlobalConfigExistsValidator globalConfigExistsValidator) {\n+    public JobConfigActions(AuthorizationManager authorizationManager, DescriptorAccessor descriptorAccessor, ConfigurationAccessor configurationAccessor, FieldModelProcessor fieldModelProcessor, DescriptorProcessor descriptorProcessor,\n+        ConfigurationFieldModelConverter modelConverter, GlobalConfigExistsValidator globalConfigExistsValidator, PKIXErrorResponseFactory pkixErrorResponseFactory, DescriptorMap descriptorMap) {\n+        super(authorizationManager, descriptorAccessor);\n         this.configurationAccessor = configurationAccessor;\n         this.fieldModelProcessor = fieldModelProcessor;\n         this.descriptorProcessor = descriptorProcessor;\n         this.modelConverter = modelConverter;\n         this.globalConfigExistsValidator = globalConfigExistsValidator;\n+        this.pkixErrorResponseFactory = pkixErrorResponseFactory;\n+        this.descriptorMap = descriptorMap;\n     }\n \n-    public boolean doesJobExist(UUID id) throws AlertDatabaseConstraintException {\n-        return null != id && configurationAccessor.getJobById(id).isPresent();\n-    }\n-\n-    public boolean doesJobExist(String id) throws AlertDatabaseConstraintException {\n-        return doesJobExist(UUID.fromString(id));\n-    }\n-\n-    public Optional<JobFieldModel> getJobById(UUID id) throws AlertException {\n-        Optional<ConfigurationJobModel> jobConfiguration = configurationAccessor.getJobById(id);\n-        if (jobConfiguration.isPresent()) {\n-            JobFieldModel jobFieldModel = readJobConfiguration(jobConfiguration.get());\n-            return Optional.of(jobFieldModel);\n+    @Override\n+    protected Optional<JobFieldModel> findJobFieldModel(UUID id) {\n+        try {\n+            Optional<ConfigurationJobModel> jobConfiguration = configurationAccessor.getJobById(id);\n+            if (jobConfiguration.isPresent()) {\n+                JobFieldModel jobFieldModel = readJobConfiguration(jobConfiguration.get());\n+                return Optional.of(jobFieldModel);\n+            }\n+        } catch (AlertException ex) {\n+            logger.error(String.format(\"Error finding job configuration id: %s\", id), ex);\n         }\n         return Optional.empty();\n     }\n \n-    public List<JobFieldModel> getAllJobs() throws AlertException {\n-        List<ConfigurationJobModel> allJobs = configurationAccessor.getAllJobs();\n-        List<JobFieldModel> jobFieldModels = new LinkedList<>();\n-        for (ConfigurationJobModel configurationJobModel : allJobs) {\n-            JobFieldModel jobFieldModel = readJobConfiguration(configurationJobModel);\n-            jobFieldModels.add(jobFieldModel);\n+    @Override\n+    protected ActionResponse<List<JobFieldModel>> readAllAfterChecks() {\n+        try {\n+            List<ConfigurationJobModel> allJobs = configurationAccessor.getAllJobs();\n+            List<JobFieldModel> jobFieldModels = new LinkedList<>();\n+            for (ConfigurationJobModel configurationJobModel : allJobs) {\n+                JobFieldModel jobFieldModel = readJobConfiguration(configurationJobModel);\n+                jobFieldModels.add(jobFieldModel);\n+            }\n+            return new ActionResponse<>(HttpStatus.OK, jobFieldModels);\n+        } catch (AlertException ex) {\n+            logger.error(\"Error reading all jobs\", ex);\n+            return new ActionResponse<>(HttpStatus.INTERNAL_SERVER_ERROR, ex.getMessage());\n         }\n-        return jobFieldModels;\n     }\n \n-    public void deleteJobById(UUID id) throws AlertException {\n-        Optional<ConfigurationJobModel> jobs = configurationAccessor.getJobById(id);\n-        if (jobs.isPresent()) {\n-            LinkedList<FieldModel> processedFieldModels = new LinkedList<>();\n-            ConfigurationJobModel configurationJobModel = jobs.get();\n-            for (ConfigurationModel configurationModel : configurationJobModel.getCopyOfConfigurations()) {\n-                FieldModel convertedFieldModel = modelConverter.convertToFieldModel(configurationModel);\n-                FieldModel fieldModel = fieldModelProcessor.performBeforeDeleteAction(convertedFieldModel);\n-                processedFieldModels.add(fieldModel);\n-            }\n-            configurationAccessor.deleteJob(configurationJobModel.getJobId());\n-            for (FieldModel fieldModel : processedFieldModels) {\n-                fieldModelProcessor.performAfterDeleteAction(fieldModel);\n+    @Override\n+    protected ActionResponse<JobFieldModel> deleteAfterChecks(UUID id) {\n+        try {\n+            Optional<ConfigurationJobModel> jobs = configurationAccessor.getJobById(id);\n+            if (jobs.isPresent()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI4MDYyMg=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzcxMDY3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/synopsys/integration/alert/web/api/job/JobConfigActions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDoxNjoyNFrOHTkexw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzowNToxNFrOHTs7hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI4MjY5NQ==", "bodyText": "I think this should actually be a 404 case.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490282695", "createdAt": "2020-09-17T14:16:24Z", "author": {"login": "gkillough"}, "path": "src/main/java/com/synopsys/integration/alert/web/api/job/JobConfigActions.java", "diffHunk": "@@ -56,150 +62,183 @@\n import com.synopsys.integration.alert.common.exception.AlertMethodNotAllowedException;\n import com.synopsys.integration.alert.common.message.model.MessageResult;\n import com.synopsys.integration.alert.common.persistence.accessor.ConfigurationAccessor;\n+import com.synopsys.integration.alert.common.persistence.accessor.DescriptorAccessor;\n import com.synopsys.integration.alert.common.persistence.accessor.FieldAccessor;\n import com.synopsys.integration.alert.common.persistence.model.ConfigurationFieldModel;\n import com.synopsys.integration.alert.common.persistence.model.ConfigurationJobModel;\n import com.synopsys.integration.alert.common.persistence.model.ConfigurationModel;\n+import com.synopsys.integration.alert.common.persistence.model.PermissionKey;\n import com.synopsys.integration.alert.common.persistence.util.ConfigurationFieldModelConverter;\n import com.synopsys.integration.alert.common.rest.model.FieldModel;\n import com.synopsys.integration.alert.common.rest.model.FieldValueModel;\n import com.synopsys.integration.alert.common.rest.model.JobFieldModel;\n import com.synopsys.integration.alert.common.rest.model.JobFieldStatuses;\n+import com.synopsys.integration.alert.common.rest.model.ValidationResponseModel;\n+import com.synopsys.integration.alert.common.security.authorization.AuthorizationManager;\n+import com.synopsys.integration.alert.web.common.PKIXErrorResponseFactory;\n import com.synopsys.integration.alert.web.common.descriptor.DescriptorProcessor;\n import com.synopsys.integration.alert.web.common.field.FieldModelProcessor;\n import com.synopsys.integration.exception.IntegrationException;\n+import com.synopsys.integration.rest.exception.IntegrationRestException;\n \n @Component\n-public class JobConfigActions {\n+public class JobConfigActions extends AbstractJobResourceActions {\n     private final Logger logger = LoggerFactory.getLogger(JobConfigActions.class);\n     private final ConfigurationAccessor configurationAccessor;\n     private final FieldModelProcessor fieldModelProcessor;\n     private final DescriptorProcessor descriptorProcessor;\n     private final ConfigurationFieldModelConverter modelConverter;\n     private final GlobalConfigExistsValidator globalConfigExistsValidator;\n+    private final PKIXErrorResponseFactory pkixErrorResponseFactory;\n+    private final DescriptorMap descriptorMap;\n \n     @Autowired\n-    public JobConfigActions(ConfigurationAccessor configurationAccessor, FieldModelProcessor fieldModelProcessor, DescriptorProcessor descriptorProcessor, ConfigurationFieldModelConverter modelConverter,\n-        GlobalConfigExistsValidator globalConfigExistsValidator) {\n+    public JobConfigActions(AuthorizationManager authorizationManager, DescriptorAccessor descriptorAccessor, ConfigurationAccessor configurationAccessor, FieldModelProcessor fieldModelProcessor, DescriptorProcessor descriptorProcessor,\n+        ConfigurationFieldModelConverter modelConverter, GlobalConfigExistsValidator globalConfigExistsValidator, PKIXErrorResponseFactory pkixErrorResponseFactory, DescriptorMap descriptorMap) {\n+        super(authorizationManager, descriptorAccessor);\n         this.configurationAccessor = configurationAccessor;\n         this.fieldModelProcessor = fieldModelProcessor;\n         this.descriptorProcessor = descriptorProcessor;\n         this.modelConverter = modelConverter;\n         this.globalConfigExistsValidator = globalConfigExistsValidator;\n+        this.pkixErrorResponseFactory = pkixErrorResponseFactory;\n+        this.descriptorMap = descriptorMap;\n     }\n \n-    public boolean doesJobExist(UUID id) throws AlertDatabaseConstraintException {\n-        return null != id && configurationAccessor.getJobById(id).isPresent();\n-    }\n-\n-    public boolean doesJobExist(String id) throws AlertDatabaseConstraintException {\n-        return doesJobExist(UUID.fromString(id));\n-    }\n-\n-    public Optional<JobFieldModel> getJobById(UUID id) throws AlertException {\n-        Optional<ConfigurationJobModel> jobConfiguration = configurationAccessor.getJobById(id);\n-        if (jobConfiguration.isPresent()) {\n-            JobFieldModel jobFieldModel = readJobConfiguration(jobConfiguration.get());\n-            return Optional.of(jobFieldModel);\n+    @Override\n+    protected Optional<JobFieldModel> findJobFieldModel(UUID id) {\n+        try {\n+            Optional<ConfigurationJobModel> jobConfiguration = configurationAccessor.getJobById(id);\n+            if (jobConfiguration.isPresent()) {\n+                JobFieldModel jobFieldModel = readJobConfiguration(jobConfiguration.get());\n+                return Optional.of(jobFieldModel);\n+            }\n+        } catch (AlertException ex) {\n+            logger.error(String.format(\"Error finding job configuration id: %s\", id), ex);\n         }\n         return Optional.empty();\n     }\n \n-    public List<JobFieldModel> getAllJobs() throws AlertException {\n-        List<ConfigurationJobModel> allJobs = configurationAccessor.getAllJobs();\n-        List<JobFieldModel> jobFieldModels = new LinkedList<>();\n-        for (ConfigurationJobModel configurationJobModel : allJobs) {\n-            JobFieldModel jobFieldModel = readJobConfiguration(configurationJobModel);\n-            jobFieldModels.add(jobFieldModel);\n+    @Override\n+    protected ActionResponse<List<JobFieldModel>> readAllAfterChecks() {\n+        try {\n+            List<ConfigurationJobModel> allJobs = configurationAccessor.getAllJobs();\n+            List<JobFieldModel> jobFieldModels = new LinkedList<>();\n+            for (ConfigurationJobModel configurationJobModel : allJobs) {\n+                JobFieldModel jobFieldModel = readJobConfiguration(configurationJobModel);\n+                jobFieldModels.add(jobFieldModel);\n+            }\n+            return new ActionResponse<>(HttpStatus.OK, jobFieldModels);\n+        } catch (AlertException ex) {\n+            logger.error(\"Error reading all jobs\", ex);\n+            return new ActionResponse<>(HttpStatus.INTERNAL_SERVER_ERROR, ex.getMessage());\n         }\n-        return jobFieldModels;\n     }\n \n-    public void deleteJobById(UUID id) throws AlertException {\n-        Optional<ConfigurationJobModel> jobs = configurationAccessor.getJobById(id);\n-        if (jobs.isPresent()) {\n-            LinkedList<FieldModel> processedFieldModels = new LinkedList<>();\n-            ConfigurationJobModel configurationJobModel = jobs.get();\n-            for (ConfigurationModel configurationModel : configurationJobModel.getCopyOfConfigurations()) {\n-                FieldModel convertedFieldModel = modelConverter.convertToFieldModel(configurationModel);\n-                FieldModel fieldModel = fieldModelProcessor.performBeforeDeleteAction(convertedFieldModel);\n-                processedFieldModels.add(fieldModel);\n-            }\n-            configurationAccessor.deleteJob(configurationJobModel.getJobId());\n-            for (FieldModel fieldModel : processedFieldModels) {\n-                fieldModelProcessor.performAfterDeleteAction(fieldModel);\n+    @Override\n+    protected ActionResponse<JobFieldModel> deleteAfterChecks(UUID id) {\n+        try {\n+            Optional<ConfigurationJobModel> jobs = configurationAccessor.getJobById(id);\n+            if (jobs.isPresent()) {\n+                LinkedList<FieldModel> processedFieldModels = new LinkedList<>();\n+                ConfigurationJobModel configurationJobModel = jobs.get();\n+                for (ConfigurationModel configurationModel : configurationJobModel.getCopyOfConfigurations()) {\n+                    FieldModel convertedFieldModel = modelConverter.convertToFieldModel(configurationModel);\n+                    FieldModel fieldModel = fieldModelProcessor.performBeforeDeleteAction(convertedFieldModel);\n+                    processedFieldModels.add(fieldModel);\n+                }\n+                configurationAccessor.deleteJob(configurationJobModel.getJobId());\n+                for (FieldModel fieldModel : processedFieldModels) {\n+                    fieldModelProcessor.performAfterDeleteAction(fieldModel);\n+                }\n+\n             }\n+        } catch (AlertException ex) {\n+            logger.error(\"Error reading all jobs\", ex);\n+            return new ActionResponse<>(HttpStatus.INTERNAL_SERVER_ERROR, ex.getMessage());\n         }\n-    }\n \n-    public JobFieldModel saveJob(JobFieldModel jobFieldModel) throws AlertException {\n-        MessageResult validationResult = validateJob(jobFieldModel);\n-        validationResult.throwExceptionForFieldStatues();\n-        validateJobNameUnique(null, jobFieldModel);\n+        return new ActionResponse<>(HttpStatus.NO_CONTENT);\n+    }\n \n-        Set<String> descriptorNames = new HashSet<>();\n-        Set<ConfigurationFieldModel> configurationFieldModels = new HashSet<>();\n-        for (FieldModel fieldModel : jobFieldModel.getFieldModels()) {\n-            FieldModel beforeSaveEventFieldModel = fieldModelProcessor.performBeforeSaveAction(fieldModel);\n-            descriptorNames.add(beforeSaveEventFieldModel.getDescriptorName());\n-            Collection<ConfigurationFieldModel> savedFieldsModels = modelConverter.convertToConfigurationFieldModelMap(beforeSaveEventFieldModel).values();\n-            configurationFieldModels.addAll(savedFieldsModels);\n-        }\n-        ConfigurationJobModel savedJob = configurationAccessor.createJob(descriptorNames, configurationFieldModels);\n-        JobFieldModel savedJobFieldModel = convertToJobFieldModel(savedJob);\n+    @Override\n+    protected ActionResponse<JobFieldModel> createAfterChecks(JobFieldModel resource) {\n+        try {\n+            Set<String> descriptorNames = new HashSet<>();\n+            Set<ConfigurationFieldModel> configurationFieldModels = new HashSet<>();\n+            for (FieldModel fieldModel : resource.getFieldModels()) {\n+                FieldModel beforeSaveEventFieldModel = fieldModelProcessor.performBeforeSaveAction(fieldModel);\n+                descriptorNames.add(beforeSaveEventFieldModel.getDescriptorName());\n+                Collection<ConfigurationFieldModel> savedFieldsModels = modelConverter.convertToConfigurationFieldModelMap(beforeSaveEventFieldModel).values();\n+                configurationFieldModels.addAll(savedFieldsModels);\n+            }\n+            ConfigurationJobModel savedJob = configurationAccessor.createJob(descriptorNames, configurationFieldModels);\n+            JobFieldModel savedJobFieldModel = convertToJobFieldModel(savedJob);\n \n-        Set<FieldModel> updatedFieldModels = new HashSet<>();\n-        for (FieldModel fieldModel : savedJobFieldModel.getFieldModels()) {\n-            FieldModel updatedModel = fieldModelProcessor.performAfterSaveAction(fieldModel);\n-            updatedFieldModels.add(updatedModel);\n+            Set<FieldModel> updatedFieldModels = new HashSet<>();\n+            for (FieldModel fieldModel : savedJobFieldModel.getFieldModels()) {\n+                FieldModel updatedModel = fieldModelProcessor.performAfterSaveAction(fieldModel);\n+                updatedFieldModels.add(updatedModel);\n+            }\n+            savedJobFieldModel.setFieldModels(updatedFieldModels);\n+            return new ActionResponse<>(HttpStatus.OK, savedJobFieldModel);\n+        } catch (AlertException ex) {\n+            logger.error(\"Error creating job\", ex);\n+            return new ActionResponse<>(HttpStatus.INTERNAL_SERVER_ERROR, ex.getMessage());\n         }\n-        savedJobFieldModel.setFieldModels(updatedFieldModels);\n-        return savedJobFieldModel;\n     }\n \n-    public JobFieldModel updateJob(UUID id, JobFieldModel jobFieldModel) throws AlertException {\n-        MessageResult validationResult = validateJob(jobFieldModel);\n-        validationResult.throwExceptionForFieldStatues();\n-        validateJobNameUnique(id, jobFieldModel);\n-\n-        ConfigurationJobModel previousJob = configurationAccessor.getJobById(id)\n-                                                .orElseThrow(() -> new IllegalStateException(\"No previous job present when the only possible valid state for this stage of the method would require it\"));\n-        Map<String, FieldModel> descriptorAndContextToPreviousFieldModel = new HashMap<>();\n-        for (ConfigurationModel previousJobConfiguration : previousJob.getCopyOfConfigurations()) {\n-            FieldModel previousJobFieldModel = modelConverter.convertToFieldModel(previousJobConfiguration);\n-            descriptorAndContextToPreviousFieldModel.put(previousJobFieldModel.getDescriptorName() + previousJobFieldModel.getContext(), previousJobFieldModel);\n-        }\n+    @Override\n+    protected ActionResponse<JobFieldModel> updateAfterChecks(UUID id, JobFieldModel resource) {\n+        try {\n+            ConfigurationJobModel previousJob = configurationAccessor.getJobById(id)\n+                                                    .orElseThrow(() -> new IllegalStateException(\"No previous job present when the only possible valid state for this stage of the method would require it\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMTEyNQ==", "bodyText": "in the update method a 404 not found is already returned. If we are executing here and cannot find it it's an issue.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490421125", "createdAt": "2020-09-17T17:05:14Z", "author": {"login": "psantos1113"}, "path": "src/main/java/com/synopsys/integration/alert/web/api/job/JobConfigActions.java", "diffHunk": "@@ -56,150 +62,183 @@\n import com.synopsys.integration.alert.common.exception.AlertMethodNotAllowedException;\n import com.synopsys.integration.alert.common.message.model.MessageResult;\n import com.synopsys.integration.alert.common.persistence.accessor.ConfigurationAccessor;\n+import com.synopsys.integration.alert.common.persistence.accessor.DescriptorAccessor;\n import com.synopsys.integration.alert.common.persistence.accessor.FieldAccessor;\n import com.synopsys.integration.alert.common.persistence.model.ConfigurationFieldModel;\n import com.synopsys.integration.alert.common.persistence.model.ConfigurationJobModel;\n import com.synopsys.integration.alert.common.persistence.model.ConfigurationModel;\n+import com.synopsys.integration.alert.common.persistence.model.PermissionKey;\n import com.synopsys.integration.alert.common.persistence.util.ConfigurationFieldModelConverter;\n import com.synopsys.integration.alert.common.rest.model.FieldModel;\n import com.synopsys.integration.alert.common.rest.model.FieldValueModel;\n import com.synopsys.integration.alert.common.rest.model.JobFieldModel;\n import com.synopsys.integration.alert.common.rest.model.JobFieldStatuses;\n+import com.synopsys.integration.alert.common.rest.model.ValidationResponseModel;\n+import com.synopsys.integration.alert.common.security.authorization.AuthorizationManager;\n+import com.synopsys.integration.alert.web.common.PKIXErrorResponseFactory;\n import com.synopsys.integration.alert.web.common.descriptor.DescriptorProcessor;\n import com.synopsys.integration.alert.web.common.field.FieldModelProcessor;\n import com.synopsys.integration.exception.IntegrationException;\n+import com.synopsys.integration.rest.exception.IntegrationRestException;\n \n @Component\n-public class JobConfigActions {\n+public class JobConfigActions extends AbstractJobResourceActions {\n     private final Logger logger = LoggerFactory.getLogger(JobConfigActions.class);\n     private final ConfigurationAccessor configurationAccessor;\n     private final FieldModelProcessor fieldModelProcessor;\n     private final DescriptorProcessor descriptorProcessor;\n     private final ConfigurationFieldModelConverter modelConverter;\n     private final GlobalConfigExistsValidator globalConfigExistsValidator;\n+    private final PKIXErrorResponseFactory pkixErrorResponseFactory;\n+    private final DescriptorMap descriptorMap;\n \n     @Autowired\n-    public JobConfigActions(ConfigurationAccessor configurationAccessor, FieldModelProcessor fieldModelProcessor, DescriptorProcessor descriptorProcessor, ConfigurationFieldModelConverter modelConverter,\n-        GlobalConfigExistsValidator globalConfigExistsValidator) {\n+    public JobConfigActions(AuthorizationManager authorizationManager, DescriptorAccessor descriptorAccessor, ConfigurationAccessor configurationAccessor, FieldModelProcessor fieldModelProcessor, DescriptorProcessor descriptorProcessor,\n+        ConfigurationFieldModelConverter modelConverter, GlobalConfigExistsValidator globalConfigExistsValidator, PKIXErrorResponseFactory pkixErrorResponseFactory, DescriptorMap descriptorMap) {\n+        super(authorizationManager, descriptorAccessor);\n         this.configurationAccessor = configurationAccessor;\n         this.fieldModelProcessor = fieldModelProcessor;\n         this.descriptorProcessor = descriptorProcessor;\n         this.modelConverter = modelConverter;\n         this.globalConfigExistsValidator = globalConfigExistsValidator;\n+        this.pkixErrorResponseFactory = pkixErrorResponseFactory;\n+        this.descriptorMap = descriptorMap;\n     }\n \n-    public boolean doesJobExist(UUID id) throws AlertDatabaseConstraintException {\n-        return null != id && configurationAccessor.getJobById(id).isPresent();\n-    }\n-\n-    public boolean doesJobExist(String id) throws AlertDatabaseConstraintException {\n-        return doesJobExist(UUID.fromString(id));\n-    }\n-\n-    public Optional<JobFieldModel> getJobById(UUID id) throws AlertException {\n-        Optional<ConfigurationJobModel> jobConfiguration = configurationAccessor.getJobById(id);\n-        if (jobConfiguration.isPresent()) {\n-            JobFieldModel jobFieldModel = readJobConfiguration(jobConfiguration.get());\n-            return Optional.of(jobFieldModel);\n+    @Override\n+    protected Optional<JobFieldModel> findJobFieldModel(UUID id) {\n+        try {\n+            Optional<ConfigurationJobModel> jobConfiguration = configurationAccessor.getJobById(id);\n+            if (jobConfiguration.isPresent()) {\n+                JobFieldModel jobFieldModel = readJobConfiguration(jobConfiguration.get());\n+                return Optional.of(jobFieldModel);\n+            }\n+        } catch (AlertException ex) {\n+            logger.error(String.format(\"Error finding job configuration id: %s\", id), ex);\n         }\n         return Optional.empty();\n     }\n \n-    public List<JobFieldModel> getAllJobs() throws AlertException {\n-        List<ConfigurationJobModel> allJobs = configurationAccessor.getAllJobs();\n-        List<JobFieldModel> jobFieldModels = new LinkedList<>();\n-        for (ConfigurationJobModel configurationJobModel : allJobs) {\n-            JobFieldModel jobFieldModel = readJobConfiguration(configurationJobModel);\n-            jobFieldModels.add(jobFieldModel);\n+    @Override\n+    protected ActionResponse<List<JobFieldModel>> readAllAfterChecks() {\n+        try {\n+            List<ConfigurationJobModel> allJobs = configurationAccessor.getAllJobs();\n+            List<JobFieldModel> jobFieldModels = new LinkedList<>();\n+            for (ConfigurationJobModel configurationJobModel : allJobs) {\n+                JobFieldModel jobFieldModel = readJobConfiguration(configurationJobModel);\n+                jobFieldModels.add(jobFieldModel);\n+            }\n+            return new ActionResponse<>(HttpStatus.OK, jobFieldModels);\n+        } catch (AlertException ex) {\n+            logger.error(\"Error reading all jobs\", ex);\n+            return new ActionResponse<>(HttpStatus.INTERNAL_SERVER_ERROR, ex.getMessage());\n         }\n-        return jobFieldModels;\n     }\n \n-    public void deleteJobById(UUID id) throws AlertException {\n-        Optional<ConfigurationJobModel> jobs = configurationAccessor.getJobById(id);\n-        if (jobs.isPresent()) {\n-            LinkedList<FieldModel> processedFieldModels = new LinkedList<>();\n-            ConfigurationJobModel configurationJobModel = jobs.get();\n-            for (ConfigurationModel configurationModel : configurationJobModel.getCopyOfConfigurations()) {\n-                FieldModel convertedFieldModel = modelConverter.convertToFieldModel(configurationModel);\n-                FieldModel fieldModel = fieldModelProcessor.performBeforeDeleteAction(convertedFieldModel);\n-                processedFieldModels.add(fieldModel);\n-            }\n-            configurationAccessor.deleteJob(configurationJobModel.getJobId());\n-            for (FieldModel fieldModel : processedFieldModels) {\n-                fieldModelProcessor.performAfterDeleteAction(fieldModel);\n+    @Override\n+    protected ActionResponse<JobFieldModel> deleteAfterChecks(UUID id) {\n+        try {\n+            Optional<ConfigurationJobModel> jobs = configurationAccessor.getJobById(id);\n+            if (jobs.isPresent()) {\n+                LinkedList<FieldModel> processedFieldModels = new LinkedList<>();\n+                ConfigurationJobModel configurationJobModel = jobs.get();\n+                for (ConfigurationModel configurationModel : configurationJobModel.getCopyOfConfigurations()) {\n+                    FieldModel convertedFieldModel = modelConverter.convertToFieldModel(configurationModel);\n+                    FieldModel fieldModel = fieldModelProcessor.performBeforeDeleteAction(convertedFieldModel);\n+                    processedFieldModels.add(fieldModel);\n+                }\n+                configurationAccessor.deleteJob(configurationJobModel.getJobId());\n+                for (FieldModel fieldModel : processedFieldModels) {\n+                    fieldModelProcessor.performAfterDeleteAction(fieldModel);\n+                }\n+\n             }\n+        } catch (AlertException ex) {\n+            logger.error(\"Error reading all jobs\", ex);\n+            return new ActionResponse<>(HttpStatus.INTERNAL_SERVER_ERROR, ex.getMessage());\n         }\n-    }\n \n-    public JobFieldModel saveJob(JobFieldModel jobFieldModel) throws AlertException {\n-        MessageResult validationResult = validateJob(jobFieldModel);\n-        validationResult.throwExceptionForFieldStatues();\n-        validateJobNameUnique(null, jobFieldModel);\n+        return new ActionResponse<>(HttpStatus.NO_CONTENT);\n+    }\n \n-        Set<String> descriptorNames = new HashSet<>();\n-        Set<ConfigurationFieldModel> configurationFieldModels = new HashSet<>();\n-        for (FieldModel fieldModel : jobFieldModel.getFieldModels()) {\n-            FieldModel beforeSaveEventFieldModel = fieldModelProcessor.performBeforeSaveAction(fieldModel);\n-            descriptorNames.add(beforeSaveEventFieldModel.getDescriptorName());\n-            Collection<ConfigurationFieldModel> savedFieldsModels = modelConverter.convertToConfigurationFieldModelMap(beforeSaveEventFieldModel).values();\n-            configurationFieldModels.addAll(savedFieldsModels);\n-        }\n-        ConfigurationJobModel savedJob = configurationAccessor.createJob(descriptorNames, configurationFieldModels);\n-        JobFieldModel savedJobFieldModel = convertToJobFieldModel(savedJob);\n+    @Override\n+    protected ActionResponse<JobFieldModel> createAfterChecks(JobFieldModel resource) {\n+        try {\n+            Set<String> descriptorNames = new HashSet<>();\n+            Set<ConfigurationFieldModel> configurationFieldModels = new HashSet<>();\n+            for (FieldModel fieldModel : resource.getFieldModels()) {\n+                FieldModel beforeSaveEventFieldModel = fieldModelProcessor.performBeforeSaveAction(fieldModel);\n+                descriptorNames.add(beforeSaveEventFieldModel.getDescriptorName());\n+                Collection<ConfigurationFieldModel> savedFieldsModels = modelConverter.convertToConfigurationFieldModelMap(beforeSaveEventFieldModel).values();\n+                configurationFieldModels.addAll(savedFieldsModels);\n+            }\n+            ConfigurationJobModel savedJob = configurationAccessor.createJob(descriptorNames, configurationFieldModels);\n+            JobFieldModel savedJobFieldModel = convertToJobFieldModel(savedJob);\n \n-        Set<FieldModel> updatedFieldModels = new HashSet<>();\n-        for (FieldModel fieldModel : savedJobFieldModel.getFieldModels()) {\n-            FieldModel updatedModel = fieldModelProcessor.performAfterSaveAction(fieldModel);\n-            updatedFieldModels.add(updatedModel);\n+            Set<FieldModel> updatedFieldModels = new HashSet<>();\n+            for (FieldModel fieldModel : savedJobFieldModel.getFieldModels()) {\n+                FieldModel updatedModel = fieldModelProcessor.performAfterSaveAction(fieldModel);\n+                updatedFieldModels.add(updatedModel);\n+            }\n+            savedJobFieldModel.setFieldModels(updatedFieldModels);\n+            return new ActionResponse<>(HttpStatus.OK, savedJobFieldModel);\n+        } catch (AlertException ex) {\n+            logger.error(\"Error creating job\", ex);\n+            return new ActionResponse<>(HttpStatus.INTERNAL_SERVER_ERROR, ex.getMessage());\n         }\n-        savedJobFieldModel.setFieldModels(updatedFieldModels);\n-        return savedJobFieldModel;\n     }\n \n-    public JobFieldModel updateJob(UUID id, JobFieldModel jobFieldModel) throws AlertException {\n-        MessageResult validationResult = validateJob(jobFieldModel);\n-        validationResult.throwExceptionForFieldStatues();\n-        validateJobNameUnique(id, jobFieldModel);\n-\n-        ConfigurationJobModel previousJob = configurationAccessor.getJobById(id)\n-                                                .orElseThrow(() -> new IllegalStateException(\"No previous job present when the only possible valid state for this stage of the method would require it\"));\n-        Map<String, FieldModel> descriptorAndContextToPreviousFieldModel = new HashMap<>();\n-        for (ConfigurationModel previousJobConfiguration : previousJob.getCopyOfConfigurations()) {\n-            FieldModel previousJobFieldModel = modelConverter.convertToFieldModel(previousJobConfiguration);\n-            descriptorAndContextToPreviousFieldModel.put(previousJobFieldModel.getDescriptorName() + previousJobFieldModel.getContext(), previousJobFieldModel);\n-        }\n+    @Override\n+    protected ActionResponse<JobFieldModel> updateAfterChecks(UUID id, JobFieldModel resource) {\n+        try {\n+            ConfigurationJobModel previousJob = configurationAccessor.getJobById(id)\n+                                                    .orElseThrow(() -> new IllegalStateException(\"No previous job present when the only possible valid state for this stage of the method would require it\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI4MjY5NQ=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzgyNzE5OnYy", "diffSide": "RIGHT", "path": "src/main/js/store/actions/globalConfiguration.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDozOToyN1rOHTlpUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOToyNTo1NFrOHTx64Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMwMTc3Nw==", "bodyText": "Would this work? Or is the response.json() promise preventing this?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (response.status === 201) {\n          \n          \n            \n                                response.json()\n          \n          \n            \n                                    .then((responseData) => {\n          \n          \n            \n                                        const newId = responseData.id;\n          \n          \n            \n                                        const updatedConfig = FieldModelUtilities.updateFieldModelSingleValue(config, 'id', newId);\n          \n          \n            \n                                        dispatch(configUpdated(updatedConfig));\n          \n          \n            \n                                        dispatch(refreshConfig(newId));\n          \n          \n            \n                                    });\n          \n          \n            \n                            } else {\n          \n          \n            \n                                dispatch(refreshConfig(id));\n          \n          \n            \n                            }\n          \n          \n            \n                            let newId = id;\n          \n          \n            \n                            if (response.status === 201) {\n          \n          \n            \n                                response.json()\n          \n          \n            \n                                    .then((responseData) => {\n          \n          \n            \n                                       newId = responseData.id;\n          \n          \n            \n                                        const updatedConfig = FieldModelUtilities.updateFieldModelSingleValue(config, 'id', newId);\n          \n          \n            \n                                        dispatch(configUpdated(updatedConfig));\n          \n          \n            \n                                    });\n          \n          \n            \n                            }\n          \n          \n            \n                            dispatch(refreshConfig(newId));", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490301777", "createdAt": "2020-09-17T14:39:27Z", "author": {"login": "gkillough"}, "path": "src/main/js/store/actions/globalConfiguration.js", "diffHunk": "@@ -258,17 +303,29 @@ export function updateConfig(config) {\n             request = ConfigRequestBuilder.createNewConfigurationRequest(ConfigRequestBuilder.CONFIG_API_URL, csrfToken, config);\n         }\n         request.then((response) => {\n-            response.json()\n-                .then((responseData) => {\n-                    if (response.ok) {\n-                        const newId = responseData.id;\n-                        const updatedConfig = FieldModelUtilities.updateFieldModelSingleValue(config, 'id', newId);\n-                        dispatch(configUpdated(updatedConfig));\n-                        dispatch(refreshConfig(newId));\n-                    } else {\n-                        handleFailureResponse(dispatch, responseData, response.status);\n-                    }\n-                });\n+            if (response.ok) {\n+                if (response.status === 201) {\n+                    response.json()\n+                        .then((responseData) => {\n+                            const newId = responseData.id;\n+                            const updatedConfig = FieldModelUtilities.updateFieldModelSingleValue(config, 'id', newId);\n+                            dispatch(configUpdated(updatedConfig));\n+                            dispatch(refreshConfig(newId));\n+                        });\n+                } else {\n+                    dispatch(refreshConfig(id));\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUwMjg4MQ==", "bodyText": "You can't do your proposed change because the parsing of the responData happens in a .then.  It is a promise.  It executes at a different time than the dispatch(refreshConfig(newId) that is proposed on line 316.  It needs to be the way that it is written because of the promise that is processing the response body.", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1172#discussion_r490502881", "createdAt": "2020-09-17T19:25:54Z", "author": {"login": "psantos1113"}, "path": "src/main/js/store/actions/globalConfiguration.js", "diffHunk": "@@ -258,17 +303,29 @@ export function updateConfig(config) {\n             request = ConfigRequestBuilder.createNewConfigurationRequest(ConfigRequestBuilder.CONFIG_API_URL, csrfToken, config);\n         }\n         request.then((response) => {\n-            response.json()\n-                .then((responseData) => {\n-                    if (response.ok) {\n-                        const newId = responseData.id;\n-                        const updatedConfig = FieldModelUtilities.updateFieldModelSingleValue(config, 'id', newId);\n-                        dispatch(configUpdated(updatedConfig));\n-                        dispatch(refreshConfig(newId));\n-                    } else {\n-                        handleFailureResponse(dispatch, responseData, response.status);\n-                    }\n-                });\n+            if (response.ok) {\n+                if (response.status === 201) {\n+                    response.json()\n+                        .then((responseData) => {\n+                            const newId = responseData.id;\n+                            const updatedConfig = FieldModelUtilities.updateFieldModelSingleValue(config, 'id', newId);\n+                            dispatch(configUpdated(updatedConfig));\n+                            dispatch(refreshConfig(newId));\n+                        });\n+                } else {\n+                    dispatch(refreshConfig(id));\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMwMTc3Nw=="}, "originalCommit": {"oid": "35d1071b51a560107ca64341074fafb31f32d032"}, "originalPosition": 138}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1756, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}