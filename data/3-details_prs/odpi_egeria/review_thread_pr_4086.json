{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE5MDM5ODA4", "number": 4086, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo0ODozNVrOE3yYBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1NDozOVrOE3yhiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTMyNDg1OnYy", "diffSide": "RIGHT", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo0ODozNVrOHxVfjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo0ODozNVrOHxVfjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NDQxNA==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521494414", "createdAt": "2020-11-11T16:48:35Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -662,85 +665,96 @@ private void addColumnProperties(Set<LineageVertex> lineageVertices) {\n             return;\n         }\n \n-        lineageVertices.stream().filter(this::isColumn).forEach(lineageVertex -> {\n+        lineageVertices.stream().filter(this::needsAdditionalNodeContext).forEach(lineageVertex -> {\n             Vertex graphVertex = g.V().has(PROPERTY_KEY_ENTITY_GUID, lineageVertex.getGuid()).next();\n             Object vertexId = graphVertex.id();\n             Map<String, String> properties = new HashMap<>();\n \n             switch (lineageVertex.getNodeType()) {\n                 case TABULAR_COLUMN:\n-                    properties = getDataFileProperties(g, vertexId);\n+                    properties = getTabularColumnProperties(g, vertexId);\n                     break;\n                 case RELATIONAL_COLUMN:\n+                    properties = getRelationalColumnProperties(g, vertexId);\n+                    break;\n+                case RELATIONAL_TABLE:\n                     properties = getRelationalTableProperties(g, vertexId);\n                     break;\n+                case DATA_FILE:\n+                    properties = getDataFileProperties(g, vertexId);\n+                    break;\n+                case PROCESS:\n+                case NODE_LABEL_SUB_PROCESS:\n+                    properties = getProcessProperties(g, vertexId);\n+                    break;\n+                case GLOSSARY_TERM:\n+                case GLOSSARY_CATEGORY:\n+                    properties = getGlossaryTermProperties(g, vertexId);\n+                    break;\n             }\n             lineageVertex.setProperties(properties);\n         });\n     }\n \n-    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+\n+    private boolean needsAdditionalNodeContext(LineageVertex lineageVertex) {\n+        return Arrays.asList(DATA_FILE, Constants.RELATIONAL_TABLE, Constants.GLOSSARY_TERM, Constants.GLOSSARY_CATEGORY, Constants.PROCESS,\n+                Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN, NODE_LABEL_SUB_PROCESS).contains(lineageVertex.getNodeType());\n+    }\n+\n+    private Map<String, String> getRelationalColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(RELATIONAL_TABLE));\n         if (tableAsset.hasNext()) {\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(RELATIONAL_TABLE_KEY, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> relationalDBSchemaType =\n                 g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(2).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n         if (relationalDBSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n-                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-        }\n-\n-        Iterator<Vertex> deployedDatabaseSchema =\n-                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DEPLOYED_DB_SCHEMA_TYPE));\n-        if (deployedDatabaseSchema.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_DISPLAY_NAME,\n-                    deployedDatabaseSchema.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(SCHEMA_TYPE_KEY, relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).or(hasLabel(DATABASE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTMyNjY5OnYy", "diffSide": "RIGHT", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo0OTowMVrOHxVgsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo0OTowMVrOHxVgsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NDcwNw==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521494707", "createdAt": "2020-11-11T16:49:01Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -662,85 +665,96 @@ private void addColumnProperties(Set<LineageVertex> lineageVertices) {\n             return;\n         }\n \n-        lineageVertices.stream().filter(this::isColumn).forEach(lineageVertex -> {\n+        lineageVertices.stream().filter(this::needsAdditionalNodeContext).forEach(lineageVertex -> {\n             Vertex graphVertex = g.V().has(PROPERTY_KEY_ENTITY_GUID, lineageVertex.getGuid()).next();\n             Object vertexId = graphVertex.id();\n             Map<String, String> properties = new HashMap<>();\n \n             switch (lineageVertex.getNodeType()) {\n                 case TABULAR_COLUMN:\n-                    properties = getDataFileProperties(g, vertexId);\n+                    properties = getTabularColumnProperties(g, vertexId);\n                     break;\n                 case RELATIONAL_COLUMN:\n+                    properties = getRelationalColumnProperties(g, vertexId);\n+                    break;\n+                case RELATIONAL_TABLE:\n                     properties = getRelationalTableProperties(g, vertexId);\n                     break;\n+                case DATA_FILE:\n+                    properties = getDataFileProperties(g, vertexId);\n+                    break;\n+                case PROCESS:\n+                case NODE_LABEL_SUB_PROCESS:\n+                    properties = getProcessProperties(g, vertexId);\n+                    break;\n+                case GLOSSARY_TERM:\n+                case GLOSSARY_CATEGORY:\n+                    properties = getGlossaryTermProperties(g, vertexId);\n+                    break;\n             }\n             lineageVertex.setProperties(properties);\n         });\n     }\n \n-    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+\n+    private boolean needsAdditionalNodeContext(LineageVertex lineageVertex) {\n+        return Arrays.asList(DATA_FILE, Constants.RELATIONAL_TABLE, Constants.GLOSSARY_TERM, Constants.GLOSSARY_CATEGORY, Constants.PROCESS,\n+                Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN, NODE_LABEL_SUB_PROCESS).contains(lineageVertex.getNodeType());\n+    }\n+\n+    private Map<String, String> getRelationalColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(RELATIONAL_TABLE));\n         if (tableAsset.hasNext()) {\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(RELATIONAL_TABLE_KEY, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> relationalDBSchemaType =\n                 g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(2).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n         if (relationalDBSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n-                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-        }\n-\n-        Iterator<Vertex> deployedDatabaseSchema =\n-                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DEPLOYED_DB_SCHEMA_TYPE));\n-        if (deployedDatabaseSchema.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_DISPLAY_NAME,\n-                    deployedDatabaseSchema.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(SCHEMA_TYPE_KEY, relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).or(hasLabel(DATABASE));\n         if (database.hasNext()) {\n-            properties.put(PROPERTY_KEY_DATABASE_DISPLAY_NAME,\n+            properties.put(DATABASE_KEY,\n                     database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(5).hasLabel(CONNECTION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTMyNzQ3OnYy", "diffSide": "RIGHT", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo0OToxMlrOHxVhNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo0OToxMlrOHxVhNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NDgzNw==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521494837", "createdAt": "2020-11-11T16:49:12Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -662,85 +665,96 @@ private void addColumnProperties(Set<LineageVertex> lineageVertices) {\n             return;\n         }\n \n-        lineageVertices.stream().filter(this::isColumn).forEach(lineageVertex -> {\n+        lineageVertices.stream().filter(this::needsAdditionalNodeContext).forEach(lineageVertex -> {\n             Vertex graphVertex = g.V().has(PROPERTY_KEY_ENTITY_GUID, lineageVertex.getGuid()).next();\n             Object vertexId = graphVertex.id();\n             Map<String, String> properties = new HashMap<>();\n \n             switch (lineageVertex.getNodeType()) {\n                 case TABULAR_COLUMN:\n-                    properties = getDataFileProperties(g, vertexId);\n+                    properties = getTabularColumnProperties(g, vertexId);\n                     break;\n                 case RELATIONAL_COLUMN:\n+                    properties = getRelationalColumnProperties(g, vertexId);\n+                    break;\n+                case RELATIONAL_TABLE:\n                     properties = getRelationalTableProperties(g, vertexId);\n                     break;\n+                case DATA_FILE:\n+                    properties = getDataFileProperties(g, vertexId);\n+                    break;\n+                case PROCESS:\n+                case NODE_LABEL_SUB_PROCESS:\n+                    properties = getProcessProperties(g, vertexId);\n+                    break;\n+                case GLOSSARY_TERM:\n+                case GLOSSARY_CATEGORY:\n+                    properties = getGlossaryTermProperties(g, vertexId);\n+                    break;\n             }\n             lineageVertex.setProperties(properties);\n         });\n     }\n \n-    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+\n+    private boolean needsAdditionalNodeContext(LineageVertex lineageVertex) {\n+        return Arrays.asList(DATA_FILE, Constants.RELATIONAL_TABLE, Constants.GLOSSARY_TERM, Constants.GLOSSARY_CATEGORY, Constants.PROCESS,\n+                Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN, NODE_LABEL_SUB_PROCESS).contains(lineageVertex.getNodeType());\n+    }\n+\n+    private Map<String, String> getRelationalColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(RELATIONAL_TABLE));\n         if (tableAsset.hasNext()) {\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(RELATIONAL_TABLE_KEY, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> relationalDBSchemaType =\n                 g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(2).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n         if (relationalDBSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n-                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-        }\n-\n-        Iterator<Vertex> deployedDatabaseSchema =\n-                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DEPLOYED_DB_SCHEMA_TYPE));\n-        if (deployedDatabaseSchema.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_DISPLAY_NAME,\n-                    deployedDatabaseSchema.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(SCHEMA_TYPE_KEY, relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).or(hasLabel(DATABASE));\n         if (database.hasNext()) {\n-            properties.put(PROPERTY_KEY_DATABASE_DISPLAY_NAME,\n+            properties.put(DATABASE_KEY,\n                     database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(5).hasLabel(CONNECTION);\n         if (connection.hasNext()) {\n-            properties.put(PROPERTY_KEY_CONNECTION_NAME, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         return properties;\n     }\n \n-    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+    private Map<String, String> getTabularColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tabularSchemaType = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(TABULAR_SCHEMA_TYPE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTMyODI1OnYy", "diffSide": "RIGHT", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo0OToyMVrOHxVhqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo0OToyMVrOHxVhqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NDk1NA==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521494954", "createdAt": "2020-11-11T16:49:21Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -662,85 +665,96 @@ private void addColumnProperties(Set<LineageVertex> lineageVertices) {\n             return;\n         }\n \n-        lineageVertices.stream().filter(this::isColumn).forEach(lineageVertex -> {\n+        lineageVertices.stream().filter(this::needsAdditionalNodeContext).forEach(lineageVertex -> {\n             Vertex graphVertex = g.V().has(PROPERTY_KEY_ENTITY_GUID, lineageVertex.getGuid()).next();\n             Object vertexId = graphVertex.id();\n             Map<String, String> properties = new HashMap<>();\n \n             switch (lineageVertex.getNodeType()) {\n                 case TABULAR_COLUMN:\n-                    properties = getDataFileProperties(g, vertexId);\n+                    properties = getTabularColumnProperties(g, vertexId);\n                     break;\n                 case RELATIONAL_COLUMN:\n+                    properties = getRelationalColumnProperties(g, vertexId);\n+                    break;\n+                case RELATIONAL_TABLE:\n                     properties = getRelationalTableProperties(g, vertexId);\n                     break;\n+                case DATA_FILE:\n+                    properties = getDataFileProperties(g, vertexId);\n+                    break;\n+                case PROCESS:\n+                case NODE_LABEL_SUB_PROCESS:\n+                    properties = getProcessProperties(g, vertexId);\n+                    break;\n+                case GLOSSARY_TERM:\n+                case GLOSSARY_CATEGORY:\n+                    properties = getGlossaryTermProperties(g, vertexId);\n+                    break;\n             }\n             lineageVertex.setProperties(properties);\n         });\n     }\n \n-    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+\n+    private boolean needsAdditionalNodeContext(LineageVertex lineageVertex) {\n+        return Arrays.asList(DATA_FILE, Constants.RELATIONAL_TABLE, Constants.GLOSSARY_TERM, Constants.GLOSSARY_CATEGORY, Constants.PROCESS,\n+                Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN, NODE_LABEL_SUB_PROCESS).contains(lineageVertex.getNodeType());\n+    }\n+\n+    private Map<String, String> getRelationalColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(RELATIONAL_TABLE));\n         if (tableAsset.hasNext()) {\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(RELATIONAL_TABLE_KEY, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> relationalDBSchemaType =\n                 g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(2).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n         if (relationalDBSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n-                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-        }\n-\n-        Iterator<Vertex> deployedDatabaseSchema =\n-                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DEPLOYED_DB_SCHEMA_TYPE));\n-        if (deployedDatabaseSchema.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_DISPLAY_NAME,\n-                    deployedDatabaseSchema.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(SCHEMA_TYPE_KEY, relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).or(hasLabel(DATABASE));\n         if (database.hasNext()) {\n-            properties.put(PROPERTY_KEY_DATABASE_DISPLAY_NAME,\n+            properties.put(DATABASE_KEY,\n                     database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(5).hasLabel(CONNECTION);\n         if (connection.hasNext()) {\n-            properties.put(PROPERTY_KEY_CONNECTION_NAME, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         return properties;\n     }\n \n-    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+    private Map<String, String> getTabularColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tabularSchemaType = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(TABULAR_SCHEMA_TYPE));\n         if (tabularSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n+            properties.put(SCHEMA_TYPE_KEY,\n                     tabularSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> dataFileAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(2).or(hasLabel(DATA_FILE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTMyOTU5OnYy", "diffSide": "RIGHT", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo0OTozOVrOHxVidw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo0OTozOVrOHxVidw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NTE1OQ==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521495159", "createdAt": "2020-11-11T16:49:39Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -662,85 +665,96 @@ private void addColumnProperties(Set<LineageVertex> lineageVertices) {\n             return;\n         }\n \n-        lineageVertices.stream().filter(this::isColumn).forEach(lineageVertex -> {\n+        lineageVertices.stream().filter(this::needsAdditionalNodeContext).forEach(lineageVertex -> {\n             Vertex graphVertex = g.V().has(PROPERTY_KEY_ENTITY_GUID, lineageVertex.getGuid()).next();\n             Object vertexId = graphVertex.id();\n             Map<String, String> properties = new HashMap<>();\n \n             switch (lineageVertex.getNodeType()) {\n                 case TABULAR_COLUMN:\n-                    properties = getDataFileProperties(g, vertexId);\n+                    properties = getTabularColumnProperties(g, vertexId);\n                     break;\n                 case RELATIONAL_COLUMN:\n+                    properties = getRelationalColumnProperties(g, vertexId);\n+                    break;\n+                case RELATIONAL_TABLE:\n                     properties = getRelationalTableProperties(g, vertexId);\n                     break;\n+                case DATA_FILE:\n+                    properties = getDataFileProperties(g, vertexId);\n+                    break;\n+                case PROCESS:\n+                case NODE_LABEL_SUB_PROCESS:\n+                    properties = getProcessProperties(g, vertexId);\n+                    break;\n+                case GLOSSARY_TERM:\n+                case GLOSSARY_CATEGORY:\n+                    properties = getGlossaryTermProperties(g, vertexId);\n+                    break;\n             }\n             lineageVertex.setProperties(properties);\n         });\n     }\n \n-    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+\n+    private boolean needsAdditionalNodeContext(LineageVertex lineageVertex) {\n+        return Arrays.asList(DATA_FILE, Constants.RELATIONAL_TABLE, Constants.GLOSSARY_TERM, Constants.GLOSSARY_CATEGORY, Constants.PROCESS,\n+                Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN, NODE_LABEL_SUB_PROCESS).contains(lineageVertex.getNodeType());\n+    }\n+\n+    private Map<String, String> getRelationalColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(RELATIONAL_TABLE));\n         if (tableAsset.hasNext()) {\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(RELATIONAL_TABLE_KEY, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> relationalDBSchemaType =\n                 g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(2).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n         if (relationalDBSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n-                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-        }\n-\n-        Iterator<Vertex> deployedDatabaseSchema =\n-                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DEPLOYED_DB_SCHEMA_TYPE));\n-        if (deployedDatabaseSchema.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_DISPLAY_NAME,\n-                    deployedDatabaseSchema.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(SCHEMA_TYPE_KEY, relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).or(hasLabel(DATABASE));\n         if (database.hasNext()) {\n-            properties.put(PROPERTY_KEY_DATABASE_DISPLAY_NAME,\n+            properties.put(DATABASE_KEY,\n                     database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(5).hasLabel(CONNECTION);\n         if (connection.hasNext()) {\n-            properties.put(PROPERTY_KEY_CONNECTION_NAME, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         return properties;\n     }\n \n-    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+    private Map<String, String> getTabularColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tabularSchemaType = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(TABULAR_SCHEMA_TYPE));\n         if (tabularSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n+            properties.put(SCHEMA_TYPE_KEY,\n                     tabularSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> dataFileAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(2).or(hasLabel(DATA_FILE));\n         if (dataFileAsset.hasNext()) {\n             Vertex dataFileVertex = dataFileAsset.next();\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, dataFileVertex.property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-\n-            List<Vertex> folderVertices = getFolderVertices(g, dataFileVertex);\n+            properties.put(DATA_FILE_KEY, dataFileVertex.property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            List<Vertex> folderVertices = getFolderVertices(g, dataFileVertex.id());\n             if (CollectionUtils.isEmpty(folderVertices)) {\n                 return properties;\n             }\n             Object lastFolderVertexId = folderVertices.get(folderVertices.size() - 1).id();\n+            properties.put(FILE_FOLDER_KEY, String.join(\"/\", getFoldersPath(folderVertices)));\n \n             Iterator<Vertex> connection = g.V(lastFolderVertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(CONNECTION));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTM0NTMzOnYy", "diffSide": "RIGHT", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1Mzo0MVrOHxVsqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1Mzo0MVrOHxVsqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5Nzc2OQ==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521497769", "createdAt": "2020-11-11T16:53:41Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTM0NjI2OnYy", "diffSide": "RIGHT", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1Mzo1NFrOHxVtRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1Mzo1NFrOHxVtRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NzkyNQ==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521497925", "createdAt": "2020-11-11T16:53:54Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTM0Njc5OnYy", "diffSide": "RIGHT", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1NDowMlrOHxVtmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1NDowMlrOHxVtmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODAwOQ==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498009", "createdAt": "2020-11-11T16:54:02Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTM0NzIyOnYy", "diffSide": "RIGHT", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1NDowOFrOHxVt2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1NDowOFrOHxVt2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODA3Mw==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498073", "createdAt": "2020-11-11T16:54:08Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));\n+        if (database.hasNext()) {\n+            properties.put(DATABASE_KEY,\n+                    database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).hasLabel(CONNECTION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTM0ODAwOnYy", "diffSide": "RIGHT", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1NDoxOVrOHxVuWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1NDoxOVrOHxVuWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODIwMQ==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498201", "createdAt": "2020-11-11T16:54:19Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));\n+        if (database.hasNext()) {\n+            properties.put(DATABASE_KEY,\n+                    database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).hasLabel(CONNECTION);\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        List<Vertex> folderVertices = getFolderVertices(g, vertexId);\n+        if (CollectionUtils.isEmpty(folderVertices)) {\n+            return properties;\n+        }\n+        Object lastFolderVertexId = folderVertices.get(folderVertices.size() - 1).id();\n+        properties.put(FILE_FOLDER_KEY, String.join(\"/\", getFoldersPath(folderVertices)));\n+\n+        Iterator<Vertex> connection = g.V(lastFolderVertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(CONNECTION));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 228}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTM0ODMyOnYy", "diffSide": "RIGHT", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1NDoyNFrOHxVujg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1NDoyNFrOHxVujg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODI1NA==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498254", "createdAt": "2020-11-11T16:54:24Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));\n+        if (database.hasNext()) {\n+            properties.put(DATABASE_KEY,\n+                    database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).hasLabel(CONNECTION);\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        List<Vertex> folderVertices = getFolderVertices(g, vertexId);\n+        if (CollectionUtils.isEmpty(folderVertices)) {\n+            return properties;\n+        }\n+        Object lastFolderVertexId = folderVertices.get(folderVertices.size() - 1).id();\n+        properties.put(FILE_FOLDER_KEY, String.join(\"/\", getFoldersPath(folderVertices)));\n+\n+        Iterator<Vertex> connection = g.V(lastFolderVertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(CONNECTION));\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getProcessProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        GraphTraversal<Vertex, ? extends Property<Object>> qualifiedNameTraversal = g.V(vertexId).properties(PROPERTY_NAME_INSTANCEPROP_QUALIFIED_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTM0ODY5OnYy", "diffSide": "RIGHT", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1NDozMFrOHxVuwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1NDozMFrOHxVuwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODMwNg==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498306", "createdAt": "2020-11-11T16:54:30Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));\n+        if (database.hasNext()) {\n+            properties.put(DATABASE_KEY,\n+                    database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).hasLabel(CONNECTION);\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        List<Vertex> folderVertices = getFolderVertices(g, vertexId);\n+        if (CollectionUtils.isEmpty(folderVertices)) {\n+            return properties;\n+        }\n+        Object lastFolderVertexId = folderVertices.get(folderVertices.size() - 1).id();\n+        properties.put(FILE_FOLDER_KEY, String.join(\"/\", getFoldersPath(folderVertices)));\n+\n+        Iterator<Vertex> connection = g.V(lastFolderVertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(CONNECTION));\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getProcessProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        GraphTraversal<Vertex, ? extends Property<Object>> qualifiedNameTraversal = g.V(vertexId).properties(PROPERTY_NAME_INSTANCEPROP_QUALIFIED_NAME);\n+        if (qualifiedNameTraversal.hasNext()) {\n+            String value = (String) qualifiedNameTraversal.next().value();\n+            properties.put(PROPERTY_NAME_INSTANCEPROP_QUALIFIED_NAME, value);\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(8).or(hasLabel(CONNECTION));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTM0OTIzOnYy", "diffSide": "RIGHT", "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1NDozOVrOHxVvGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1NDozOVrOHxVvGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODM5NQ==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498395", "createdAt": "2020-11-11T16:54:39Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));\n+        if (database.hasNext()) {\n+            properties.put(DATABASE_KEY,\n+                    database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).hasLabel(CONNECTION);\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        List<Vertex> folderVertices = getFolderVertices(g, vertexId);\n+        if (CollectionUtils.isEmpty(folderVertices)) {\n+            return properties;\n+        }\n+        Object lastFolderVertexId = folderVertices.get(folderVertices.size() - 1).id();\n+        properties.put(FILE_FOLDER_KEY, String.join(\"/\", getFoldersPath(folderVertices)));\n+\n+        Iterator<Vertex> connection = g.V(lastFolderVertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(CONNECTION));\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getProcessProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        GraphTraversal<Vertex, ? extends Property<Object>> qualifiedNameTraversal = g.V(vertexId).properties(PROPERTY_NAME_INSTANCEPROP_QUALIFIED_NAME);\n+        if (qualifiedNameTraversal.hasNext()) {\n+            String value = (String) qualifiedNameTraversal.next().value();\n+            properties.put(PROPERTY_NAME_INSTANCEPROP_QUALIFIED_NAME, value);\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(8).or(hasLabel(CONNECTION));\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+        return properties;\n+    }\n+\n+    private Map<String, String> getGlossaryTermProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+        Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(GLOSSARY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 255}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2469, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}