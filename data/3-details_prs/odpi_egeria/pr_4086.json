{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE5MDM5ODA4", "number": 4086, "title": "add additional node context for lineage", "bodyText": "Signed-off-by: marius-patrascu marius-florin.patrascu@ing.com", "createdAt": "2020-11-11T08:33:04Z", "url": "https://github.com/odpi/egeria/pull/4086", "merged": true, "mergeCommit": {"oid": "2e26af72cb9f9f6884274529ab537b8dfd18a996"}, "closed": true, "closedAt": "2020-11-12T09:39:36Z", "author": {"login": "marius-patrascu"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdbZuN_AH2gAyNTE5MDM5ODA4OjI2ZGVmYmYwZWYwNDk3NzBhNTQ4NjAwNjQxMzA5ZjZkNzUwM2YxNDg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdbvS3UAFqTUyODkwNzYzMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "26defbf0ef049770a548600641309f6d7503f148", "author": {"user": {"login": "marius-patrascu", "name": null}}, "url": "https://github.com/odpi/egeria/commit/26defbf0ef049770a548600641309f6d7503f148", "committedDate": "2020-11-11T08:31:18Z", "message": "add additional node context for lineage\n\nSigned-off-by: marius-patrascu <marius-florin.patrascu@ing.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae6a77fdc95be97d035ddfbb2c879837242363b1", "author": {"user": {"login": "marius-patrascu", "name": null}}, "url": "https://github.com/odpi/egeria/commit/ae6a77fdc95be97d035ddfbb2c879837242363b1", "committedDate": "2020-11-11T08:33:11Z", "message": "Merge branch 'master' into implement-node-details-for-lineage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "947c871a26321bdb4a0e2552fd65d02cc7910583", "author": {"user": {"login": "marius-patrascu", "name": null}}, "url": "https://github.com/odpi/egeria/commit/947c871a26321bdb4a0e2552fd65d02cc7910583", "committedDate": "2020-11-11T10:16:41Z", "message": "Merge branch 'master' into implement-node-details-for-lineage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c00dd5315fa92e64790d260f79f35df587d22ddd", "author": {"user": {"login": "marius-patrascu", "name": null}}, "url": "https://github.com/odpi/egeria/commit/c00dd5315fa92e64790d260f79f35df587d22ddd", "committedDate": "2020-11-11T12:20:12Z", "message": "small refactoring\n\nSigned-off-by: marius-patrascu <marius-florin.patrascu@ing.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b16643ecdaccc19996c4ae892f83862074c987ba", "author": {"user": {"login": "marius-patrascu", "name": null}}, "url": "https://github.com/odpi/egeria/commit/b16643ecdaccc19996c4ae892f83862074c987ba", "committedDate": "2020-11-11T12:32:22Z", "message": "Merge branch 'master' of https://github.com/odpi/egeria into serialization-issue-on-remote-janusgraph\n\nSigned-off-by: marius-patrascu <marius-florin.patrascu@ing.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c665aa31a518363ec280ee2fe4e7352f2cde7ae", "author": {"user": {"login": "marius-patrascu", "name": null}}, "url": "https://github.com/odpi/egeria/commit/5c665aa31a518363ec280ee2fe4e7352f2cde7ae", "committedDate": "2020-11-11T13:19:23Z", "message": "Merge branch 'master' into implement-node-details-for-lineage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de", "author": {"user": {"login": "marius-patrascu", "name": null}}, "url": "https://github.com/odpi/egeria/commit/854e5a152793d6432c0a7eb57b9634e020c196de", "committedDate": "2020-11-11T13:58:21Z", "message": "Merge branch 'master' into implement-node-details-for-lineage"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4MzUxNDQ2", "url": "https://github.com/odpi/egeria/pull/4086#pullrequestreview-528351446", "createdAt": "2020-11-11T16:48:35Z", "commit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo0ODozNVrOHxVfjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNjo1NDozOVrOHxVvGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NDQxNA==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521494414", "createdAt": "2020-11-11T16:48:35Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -662,85 +665,96 @@ private void addColumnProperties(Set<LineageVertex> lineageVertices) {\n             return;\n         }\n \n-        lineageVertices.stream().filter(this::isColumn).forEach(lineageVertex -> {\n+        lineageVertices.stream().filter(this::needsAdditionalNodeContext).forEach(lineageVertex -> {\n             Vertex graphVertex = g.V().has(PROPERTY_KEY_ENTITY_GUID, lineageVertex.getGuid()).next();\n             Object vertexId = graphVertex.id();\n             Map<String, String> properties = new HashMap<>();\n \n             switch (lineageVertex.getNodeType()) {\n                 case TABULAR_COLUMN:\n-                    properties = getDataFileProperties(g, vertexId);\n+                    properties = getTabularColumnProperties(g, vertexId);\n                     break;\n                 case RELATIONAL_COLUMN:\n+                    properties = getRelationalColumnProperties(g, vertexId);\n+                    break;\n+                case RELATIONAL_TABLE:\n                     properties = getRelationalTableProperties(g, vertexId);\n                     break;\n+                case DATA_FILE:\n+                    properties = getDataFileProperties(g, vertexId);\n+                    break;\n+                case PROCESS:\n+                case NODE_LABEL_SUB_PROCESS:\n+                    properties = getProcessProperties(g, vertexId);\n+                    break;\n+                case GLOSSARY_TERM:\n+                case GLOSSARY_CATEGORY:\n+                    properties = getGlossaryTermProperties(g, vertexId);\n+                    break;\n             }\n             lineageVertex.setProperties(properties);\n         });\n     }\n \n-    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+\n+    private boolean needsAdditionalNodeContext(LineageVertex lineageVertex) {\n+        return Arrays.asList(DATA_FILE, Constants.RELATIONAL_TABLE, Constants.GLOSSARY_TERM, Constants.GLOSSARY_CATEGORY, Constants.PROCESS,\n+                Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN, NODE_LABEL_SUB_PROCESS).contains(lineageVertex.getNodeType());\n+    }\n+\n+    private Map<String, String> getRelationalColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(RELATIONAL_TABLE));\n         if (tableAsset.hasNext()) {\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(RELATIONAL_TABLE_KEY, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> relationalDBSchemaType =\n                 g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(2).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n         if (relationalDBSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n-                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-        }\n-\n-        Iterator<Vertex> deployedDatabaseSchema =\n-                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DEPLOYED_DB_SCHEMA_TYPE));\n-        if (deployedDatabaseSchema.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_DISPLAY_NAME,\n-                    deployedDatabaseSchema.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(SCHEMA_TYPE_KEY, relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).or(hasLabel(DATABASE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NDcwNw==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521494707", "createdAt": "2020-11-11T16:49:01Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -662,85 +665,96 @@ private void addColumnProperties(Set<LineageVertex> lineageVertices) {\n             return;\n         }\n \n-        lineageVertices.stream().filter(this::isColumn).forEach(lineageVertex -> {\n+        lineageVertices.stream().filter(this::needsAdditionalNodeContext).forEach(lineageVertex -> {\n             Vertex graphVertex = g.V().has(PROPERTY_KEY_ENTITY_GUID, lineageVertex.getGuid()).next();\n             Object vertexId = graphVertex.id();\n             Map<String, String> properties = new HashMap<>();\n \n             switch (lineageVertex.getNodeType()) {\n                 case TABULAR_COLUMN:\n-                    properties = getDataFileProperties(g, vertexId);\n+                    properties = getTabularColumnProperties(g, vertexId);\n                     break;\n                 case RELATIONAL_COLUMN:\n+                    properties = getRelationalColumnProperties(g, vertexId);\n+                    break;\n+                case RELATIONAL_TABLE:\n                     properties = getRelationalTableProperties(g, vertexId);\n                     break;\n+                case DATA_FILE:\n+                    properties = getDataFileProperties(g, vertexId);\n+                    break;\n+                case PROCESS:\n+                case NODE_LABEL_SUB_PROCESS:\n+                    properties = getProcessProperties(g, vertexId);\n+                    break;\n+                case GLOSSARY_TERM:\n+                case GLOSSARY_CATEGORY:\n+                    properties = getGlossaryTermProperties(g, vertexId);\n+                    break;\n             }\n             lineageVertex.setProperties(properties);\n         });\n     }\n \n-    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+\n+    private boolean needsAdditionalNodeContext(LineageVertex lineageVertex) {\n+        return Arrays.asList(DATA_FILE, Constants.RELATIONAL_TABLE, Constants.GLOSSARY_TERM, Constants.GLOSSARY_CATEGORY, Constants.PROCESS,\n+                Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN, NODE_LABEL_SUB_PROCESS).contains(lineageVertex.getNodeType());\n+    }\n+\n+    private Map<String, String> getRelationalColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(RELATIONAL_TABLE));\n         if (tableAsset.hasNext()) {\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(RELATIONAL_TABLE_KEY, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> relationalDBSchemaType =\n                 g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(2).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n         if (relationalDBSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n-                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-        }\n-\n-        Iterator<Vertex> deployedDatabaseSchema =\n-                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DEPLOYED_DB_SCHEMA_TYPE));\n-        if (deployedDatabaseSchema.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_DISPLAY_NAME,\n-                    deployedDatabaseSchema.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(SCHEMA_TYPE_KEY, relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).or(hasLabel(DATABASE));\n         if (database.hasNext()) {\n-            properties.put(PROPERTY_KEY_DATABASE_DISPLAY_NAME,\n+            properties.put(DATABASE_KEY,\n                     database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(5).hasLabel(CONNECTION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NDgzNw==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521494837", "createdAt": "2020-11-11T16:49:12Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -662,85 +665,96 @@ private void addColumnProperties(Set<LineageVertex> lineageVertices) {\n             return;\n         }\n \n-        lineageVertices.stream().filter(this::isColumn).forEach(lineageVertex -> {\n+        lineageVertices.stream().filter(this::needsAdditionalNodeContext).forEach(lineageVertex -> {\n             Vertex graphVertex = g.V().has(PROPERTY_KEY_ENTITY_GUID, lineageVertex.getGuid()).next();\n             Object vertexId = graphVertex.id();\n             Map<String, String> properties = new HashMap<>();\n \n             switch (lineageVertex.getNodeType()) {\n                 case TABULAR_COLUMN:\n-                    properties = getDataFileProperties(g, vertexId);\n+                    properties = getTabularColumnProperties(g, vertexId);\n                     break;\n                 case RELATIONAL_COLUMN:\n+                    properties = getRelationalColumnProperties(g, vertexId);\n+                    break;\n+                case RELATIONAL_TABLE:\n                     properties = getRelationalTableProperties(g, vertexId);\n                     break;\n+                case DATA_FILE:\n+                    properties = getDataFileProperties(g, vertexId);\n+                    break;\n+                case PROCESS:\n+                case NODE_LABEL_SUB_PROCESS:\n+                    properties = getProcessProperties(g, vertexId);\n+                    break;\n+                case GLOSSARY_TERM:\n+                case GLOSSARY_CATEGORY:\n+                    properties = getGlossaryTermProperties(g, vertexId);\n+                    break;\n             }\n             lineageVertex.setProperties(properties);\n         });\n     }\n \n-    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+\n+    private boolean needsAdditionalNodeContext(LineageVertex lineageVertex) {\n+        return Arrays.asList(DATA_FILE, Constants.RELATIONAL_TABLE, Constants.GLOSSARY_TERM, Constants.GLOSSARY_CATEGORY, Constants.PROCESS,\n+                Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN, NODE_LABEL_SUB_PROCESS).contains(lineageVertex.getNodeType());\n+    }\n+\n+    private Map<String, String> getRelationalColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(RELATIONAL_TABLE));\n         if (tableAsset.hasNext()) {\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(RELATIONAL_TABLE_KEY, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> relationalDBSchemaType =\n                 g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(2).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n         if (relationalDBSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n-                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-        }\n-\n-        Iterator<Vertex> deployedDatabaseSchema =\n-                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DEPLOYED_DB_SCHEMA_TYPE));\n-        if (deployedDatabaseSchema.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_DISPLAY_NAME,\n-                    deployedDatabaseSchema.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(SCHEMA_TYPE_KEY, relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).or(hasLabel(DATABASE));\n         if (database.hasNext()) {\n-            properties.put(PROPERTY_KEY_DATABASE_DISPLAY_NAME,\n+            properties.put(DATABASE_KEY,\n                     database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(5).hasLabel(CONNECTION);\n         if (connection.hasNext()) {\n-            properties.put(PROPERTY_KEY_CONNECTION_NAME, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         return properties;\n     }\n \n-    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+    private Map<String, String> getTabularColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tabularSchemaType = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(TABULAR_SCHEMA_TYPE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NDk1NA==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521494954", "createdAt": "2020-11-11T16:49:21Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -662,85 +665,96 @@ private void addColumnProperties(Set<LineageVertex> lineageVertices) {\n             return;\n         }\n \n-        lineageVertices.stream().filter(this::isColumn).forEach(lineageVertex -> {\n+        lineageVertices.stream().filter(this::needsAdditionalNodeContext).forEach(lineageVertex -> {\n             Vertex graphVertex = g.V().has(PROPERTY_KEY_ENTITY_GUID, lineageVertex.getGuid()).next();\n             Object vertexId = graphVertex.id();\n             Map<String, String> properties = new HashMap<>();\n \n             switch (lineageVertex.getNodeType()) {\n                 case TABULAR_COLUMN:\n-                    properties = getDataFileProperties(g, vertexId);\n+                    properties = getTabularColumnProperties(g, vertexId);\n                     break;\n                 case RELATIONAL_COLUMN:\n+                    properties = getRelationalColumnProperties(g, vertexId);\n+                    break;\n+                case RELATIONAL_TABLE:\n                     properties = getRelationalTableProperties(g, vertexId);\n                     break;\n+                case DATA_FILE:\n+                    properties = getDataFileProperties(g, vertexId);\n+                    break;\n+                case PROCESS:\n+                case NODE_LABEL_SUB_PROCESS:\n+                    properties = getProcessProperties(g, vertexId);\n+                    break;\n+                case GLOSSARY_TERM:\n+                case GLOSSARY_CATEGORY:\n+                    properties = getGlossaryTermProperties(g, vertexId);\n+                    break;\n             }\n             lineageVertex.setProperties(properties);\n         });\n     }\n \n-    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+\n+    private boolean needsAdditionalNodeContext(LineageVertex lineageVertex) {\n+        return Arrays.asList(DATA_FILE, Constants.RELATIONAL_TABLE, Constants.GLOSSARY_TERM, Constants.GLOSSARY_CATEGORY, Constants.PROCESS,\n+                Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN, NODE_LABEL_SUB_PROCESS).contains(lineageVertex.getNodeType());\n+    }\n+\n+    private Map<String, String> getRelationalColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(RELATIONAL_TABLE));\n         if (tableAsset.hasNext()) {\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(RELATIONAL_TABLE_KEY, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> relationalDBSchemaType =\n                 g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(2).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n         if (relationalDBSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n-                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-        }\n-\n-        Iterator<Vertex> deployedDatabaseSchema =\n-                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DEPLOYED_DB_SCHEMA_TYPE));\n-        if (deployedDatabaseSchema.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_DISPLAY_NAME,\n-                    deployedDatabaseSchema.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(SCHEMA_TYPE_KEY, relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).or(hasLabel(DATABASE));\n         if (database.hasNext()) {\n-            properties.put(PROPERTY_KEY_DATABASE_DISPLAY_NAME,\n+            properties.put(DATABASE_KEY,\n                     database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(5).hasLabel(CONNECTION);\n         if (connection.hasNext()) {\n-            properties.put(PROPERTY_KEY_CONNECTION_NAME, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         return properties;\n     }\n \n-    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+    private Map<String, String> getTabularColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tabularSchemaType = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(TABULAR_SCHEMA_TYPE));\n         if (tabularSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n+            properties.put(SCHEMA_TYPE_KEY,\n                     tabularSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> dataFileAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(2).or(hasLabel(DATA_FILE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NTE1OQ==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521495159", "createdAt": "2020-11-11T16:49:39Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -662,85 +665,96 @@ private void addColumnProperties(Set<LineageVertex> lineageVertices) {\n             return;\n         }\n \n-        lineageVertices.stream().filter(this::isColumn).forEach(lineageVertex -> {\n+        lineageVertices.stream().filter(this::needsAdditionalNodeContext).forEach(lineageVertex -> {\n             Vertex graphVertex = g.V().has(PROPERTY_KEY_ENTITY_GUID, lineageVertex.getGuid()).next();\n             Object vertexId = graphVertex.id();\n             Map<String, String> properties = new HashMap<>();\n \n             switch (lineageVertex.getNodeType()) {\n                 case TABULAR_COLUMN:\n-                    properties = getDataFileProperties(g, vertexId);\n+                    properties = getTabularColumnProperties(g, vertexId);\n                     break;\n                 case RELATIONAL_COLUMN:\n+                    properties = getRelationalColumnProperties(g, vertexId);\n+                    break;\n+                case RELATIONAL_TABLE:\n                     properties = getRelationalTableProperties(g, vertexId);\n                     break;\n+                case DATA_FILE:\n+                    properties = getDataFileProperties(g, vertexId);\n+                    break;\n+                case PROCESS:\n+                case NODE_LABEL_SUB_PROCESS:\n+                    properties = getProcessProperties(g, vertexId);\n+                    break;\n+                case GLOSSARY_TERM:\n+                case GLOSSARY_CATEGORY:\n+                    properties = getGlossaryTermProperties(g, vertexId);\n+                    break;\n             }\n             lineageVertex.setProperties(properties);\n         });\n     }\n \n-    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+\n+    private boolean needsAdditionalNodeContext(LineageVertex lineageVertex) {\n+        return Arrays.asList(DATA_FILE, Constants.RELATIONAL_TABLE, Constants.GLOSSARY_TERM, Constants.GLOSSARY_CATEGORY, Constants.PROCESS,\n+                Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN, NODE_LABEL_SUB_PROCESS).contains(lineageVertex.getNodeType());\n+    }\n+\n+    private Map<String, String> getRelationalColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(RELATIONAL_TABLE));\n         if (tableAsset.hasNext()) {\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(RELATIONAL_TABLE_KEY, tableAsset.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> relationalDBSchemaType =\n                 g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(2).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n         if (relationalDBSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n-                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-        }\n-\n-        Iterator<Vertex> deployedDatabaseSchema =\n-                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DEPLOYED_DB_SCHEMA_TYPE));\n-        if (deployedDatabaseSchema.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_DISPLAY_NAME,\n-                    deployedDatabaseSchema.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(SCHEMA_TYPE_KEY, relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).or(hasLabel(DATABASE));\n         if (database.hasNext()) {\n-            properties.put(PROPERTY_KEY_DATABASE_DISPLAY_NAME,\n+            properties.put(DATABASE_KEY,\n                     database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(5).hasLabel(CONNECTION);\n         if (connection.hasNext()) {\n-            properties.put(PROPERTY_KEY_CONNECTION_NAME, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         return properties;\n     }\n \n-    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+    private Map<String, String> getTabularColumnProperties(GraphTraversalSource g, Object vertexId) {\n         Map<String, String> properties = new HashMap<>();\n \n         Iterator<Vertex> tabularSchemaType = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(TABULAR_SCHEMA_TYPE));\n         if (tabularSchemaType.hasNext()) {\n-            properties.put(PROPERTY_KEY_SCHEMA_TYPE_DISPLAY_NAME,\n+            properties.put(SCHEMA_TYPE_KEY,\n                     tabularSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n         }\n \n         Iterator<Vertex> dataFileAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(2).or(hasLabel(DATA_FILE));\n         if (dataFileAsset.hasNext()) {\n             Vertex dataFileVertex = dataFileAsset.next();\n-            properties.put(PROPERTY_KEY_TABLE_DISPLAY_NAME, dataFileVertex.property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n-\n-            List<Vertex> folderVertices = getFolderVertices(g, dataFileVertex);\n+            properties.put(DATA_FILE_KEY, dataFileVertex.property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+            List<Vertex> folderVertices = getFolderVertices(g, dataFileVertex.id());\n             if (CollectionUtils.isEmpty(folderVertices)) {\n                 return properties;\n             }\n             Object lastFolderVertexId = folderVertices.get(folderVertices.size() - 1).id();\n+            properties.put(FILE_FOLDER_KEY, String.join(\"/\", getFoldersPath(folderVertices)));\n \n             Iterator<Vertex> connection = g.V(lastFolderVertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(CONNECTION));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5Nzc2OQ==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521497769", "createdAt": "2020-11-11T16:53:41Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5NzkyNQ==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521497925", "createdAt": "2020-11-11T16:53:54Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODAwOQ==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498009", "createdAt": "2020-11-11T16:54:02Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODA3Mw==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498073", "createdAt": "2020-11-11T16:54:08Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));\n+        if (database.hasNext()) {\n+            properties.put(DATABASE_KEY,\n+                    database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).hasLabel(CONNECTION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODIwMQ==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498201", "createdAt": "2020-11-11T16:54:19Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));\n+        if (database.hasNext()) {\n+            properties.put(DATABASE_KEY,\n+                    database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).hasLabel(CONNECTION);\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        List<Vertex> folderVertices = getFolderVertices(g, vertexId);\n+        if (CollectionUtils.isEmpty(folderVertices)) {\n+            return properties;\n+        }\n+        Object lastFolderVertexId = folderVertices.get(folderVertices.size() - 1).id();\n+        properties.put(FILE_FOLDER_KEY, String.join(\"/\", getFoldersPath(folderVertices)));\n+\n+        Iterator<Vertex> connection = g.V(lastFolderVertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(CONNECTION));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODI1NA==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498254", "createdAt": "2020-11-11T16:54:24Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));\n+        if (database.hasNext()) {\n+            properties.put(DATABASE_KEY,\n+                    database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).hasLabel(CONNECTION);\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        List<Vertex> folderVertices = getFolderVertices(g, vertexId);\n+        if (CollectionUtils.isEmpty(folderVertices)) {\n+            return properties;\n+        }\n+        Object lastFolderVertexId = folderVertices.get(folderVertices.size() - 1).id();\n+        properties.put(FILE_FOLDER_KEY, String.join(\"/\", getFoldersPath(folderVertices)));\n+\n+        Iterator<Vertex> connection = g.V(lastFolderVertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(CONNECTION));\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getProcessProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        GraphTraversal<Vertex, ? extends Property<Object>> qualifiedNameTraversal = g.V(vertexId).properties(PROPERTY_NAME_INSTANCEPROP_QUALIFIED_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODMwNg==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498306", "createdAt": "2020-11-11T16:54:30Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));\n+        if (database.hasNext()) {\n+            properties.put(DATABASE_KEY,\n+                    database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).hasLabel(CONNECTION);\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        List<Vertex> folderVertices = getFolderVertices(g, vertexId);\n+        if (CollectionUtils.isEmpty(folderVertices)) {\n+            return properties;\n+        }\n+        Object lastFolderVertexId = folderVertices.get(folderVertices.size() - 1).id();\n+        properties.put(FILE_FOLDER_KEY, String.join(\"/\", getFoldersPath(folderVertices)));\n+\n+        Iterator<Vertex> connection = g.V(lastFolderVertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(CONNECTION));\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getProcessProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        GraphTraversal<Vertex, ? extends Property<Object>> qualifiedNameTraversal = g.V(vertexId).properties(PROPERTY_NAME_INSTANCEPROP_QUALIFIED_NAME);\n+        if (qualifiedNameTraversal.hasNext()) {\n+            String value = (String) qualifiedNameTraversal.next().value();\n+            properties.put(PROPERTY_NAME_INSTANCEPROP_QUALIFIED_NAME, value);\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(8).or(hasLabel(CONNECTION));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQ5ODM5NQ==", "bodyText": "No commit", "url": "https://github.com/odpi/egeria/pull/4086#discussion_r521498395", "createdAt": "2020-11-11T16:54:39Z", "author": {"login": "lcpopa"}, "path": "open-metadata-implementation/adapters/open-connectors/governance-daemon-connectors/open-lineage-connectors/open-lineage-janus-connector/src/main/java/org/odpi/openmetadata/openconnectors/governancedaemonconnectors/openlineageconnectors/janusconnector/graph/LineageGraphConnectorHelper.java", "diffHunk": "@@ -752,18 +766,83 @@ private String getFoldersPath(List<Vertex> folderVertices) {\n                 .collect(Collectors.joining(\"/\"));\n     }\n \n-    private List<Vertex> getFolderVertices(GraphTraversalSource g, Vertex dataFileAsset) {\n+    private List<Vertex> getFolderVertices(GraphTraversalSource g, Object dataFileAssetId) {\n         GraphTraversal<Vertex, Vertex> fileFolders =\n-                g.V(dataFileAsset.id()).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n+                g.V(dataFileAssetId).emit().repeat(bothE().otherV().simplePath()).until(inE(FOLDER_HIERARCHY).count().is(0)).or(hasLabel(FILE_FOLDER));\n         List<Vertex> folderVertices = new ArrayList<>();\n         while (fileFolders.hasNext()) {\n             folderVertices.add(fileFolders.next());\n         }\n         return folderVertices;\n     }\n \n-    private boolean isColumn(LineageVertex lineageVertex) {\n-        return Arrays.asList(Constants.TABULAR_COLUMN, Constants.RELATIONAL_COLUMN).contains(lineageVertex.getNodeType());\n+    private Map<String, String> getRelationalTableProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        Iterator<Vertex> relationalDBSchemaType =\n+                g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(1).or(hasLabel(RELATIONAL_DB_SCHEMA_TYPE));\n+        if (relationalDBSchemaType.hasNext()) {\n+            properties.put(SCHEMA_TYPE_KEY,\n+                    relationalDBSchemaType.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> database = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(3).or(hasLabel(DATABASE));\n+        if (database.hasNext()) {\n+            properties.put(DATABASE_KEY,\n+                    database.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().outV().simplePath()).times(4).hasLabel(CONNECTION);\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getDataFileProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        List<Vertex> folderVertices = getFolderVertices(g, vertexId);\n+        if (CollectionUtils.isEmpty(folderVertices)) {\n+            return properties;\n+        }\n+        Object lastFolderVertexId = folderVertices.get(folderVertices.size() - 1).id();\n+        properties.put(FILE_FOLDER_KEY, String.join(\"/\", getFoldersPath(folderVertices)));\n+\n+        Iterator<Vertex> connection = g.V(lastFolderVertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(CONNECTION));\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+\n+        return properties;\n+\n+    }\n+\n+    private Map<String, String> getProcessProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+\n+        GraphTraversal<Vertex, ? extends Property<Object>> qualifiedNameTraversal = g.V(vertexId).properties(PROPERTY_NAME_INSTANCEPROP_QUALIFIED_NAME);\n+        if (qualifiedNameTraversal.hasNext()) {\n+            String value = (String) qualifiedNameTraversal.next().value();\n+            properties.put(PROPERTY_NAME_INSTANCEPROP_QUALIFIED_NAME, value);\n+        }\n+\n+        Iterator<Vertex> connection = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(8).or(hasLabel(CONNECTION));\n+        if (connection.hasNext()) {\n+            properties.put(CONNECTION_KEY, connection.next().property(PROPERTY_KEY_INSTANCEPROP_DISPLAY_NAME).value().toString());\n+        }\n+        return properties;\n+    }\n+\n+    private Map<String, String> getGlossaryTermProperties(GraphTraversalSource g, Object vertexId) {\n+        Map<String, String> properties = new HashMap<>();\n+        Iterator<Vertex> tableAsset = g.V(vertexId).emit().repeat(bothE().otherV().simplePath()).times(1).or(hasLabel(GLOSSARY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "originalPosition": 255}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4OTA3NjMz", "url": "https://github.com/odpi/egeria/pull/4086#pullrequestreview-528907633", "createdAt": "2020-11-12T09:39:20Z", "commit": {"oid": "854e5a152793d6432c0a7eb57b9634e020c196de"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3802, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}