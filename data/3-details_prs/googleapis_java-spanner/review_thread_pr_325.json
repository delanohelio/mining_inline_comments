{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2MjczNDY0", "number": 325, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNTo0NTozN1rOEqzqNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzozOToxN1rOEwHP4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMzIyMDM4OnYy", "diffSide": "LEFT", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/TransactionRunnerImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNTo0NTozN1rOHdOVYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNTo0NTozN1rOHdOVYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwNTYwMg==", "bodyText": "This is moved to the createTxnAsync method to be re-usable.", "url": "https://github.com/googleapis/java-spanner/pull/325#discussion_r500405602", "createdAt": "2020-10-06T15:45:37Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/TransactionRunnerImpl.java", "diffHunk": "@@ -190,36 +198,7 @@ void ensureTxn() {\n     ApiFuture<Void> ensureTxnAsync() {\n       final SettableApiFuture<Void> res = SettableApiFuture.create();\n       if (transactionId == null || isAborted()) {\n-        span.addAnnotation(\"Creating Transaction\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec71d71961701fc1304f9121e9d9b7cae2393d9"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMzIyNzczOnYy", "diffSide": "LEFT", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/TransactionRunnerImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNTo0NzoxMlrOHdOZ7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNTo0NzoxMlrOHdOZ7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwNjc2Nw==", "bodyText": "This block of code is moved to CommitRunnable", "url": "https://github.com/googleapis/java-spanner/pull/325#discussion_r500406767", "createdAt": "2020-10-06T15:47:12Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/TransactionRunnerImpl.java", "diffHunk": "@@ -246,87 +258,103 @@ void commit() {\n \n     ApiFuture<Timestamp> commitAsync() {\n       final SettableApiFuture<Timestamp> res = SettableApiFuture.create();\n-      final SettableApiFuture<Void> latch;\n+      final SettableApiFuture<Void> finishOps;\n+      CommitRequest.Builder builder = CommitRequest.newBuilder().setSession(session.getName());\n       synchronized (lock) {\n-        latch = finishedAsyncOperations;\n+        if (transactionIdFuture == null && transactionId == null) {\n+          finishOps = SettableApiFuture.create();\n+          createTxnAsync(finishOps);\n+        } else {\n+          finishOps = finishedAsyncOperations;\n+        }\n+        if (!mutations.isEmpty()) {\n+          List<com.google.spanner.v1.Mutation> mutationsProto = new ArrayList<>();\n+          Mutation.toProto(mutations, mutationsProto);\n+          builder.addAllMutations(mutationsProto);\n+        }\n+        // Ensure that no call to buffer mutations that would be lost can succeed.\n+        mutations = null;\n       }\n-      latch.addListener(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec71d71961701fc1304f9121e9d9b7cae2393d9"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODg1ODUyOnYy", "diffSide": "RIGHT", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/TransactionRunnerImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzozOToxN1rOHleSCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzozOToxN1rOHleSCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1NTQ5Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/googleapis/java-spanner/pull/325#discussion_r509055496", "createdAt": "2020-10-21T07:39:17Z", "author": {"login": "yoshi-code-bot"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/TransactionRunnerImpl.java", "diffHunk": "@@ -150,7 +151,15 @@ public void removeListener(Runnable listener) {\n     @GuardedBy(\"lock\")\n     private long retryDelayInMillis = -1L;\n \n-    private volatile ByteString transactionId;\n+    /**\n+     * transactionIdFuture will return the transaction id returned by the first statement in the\n+     * transaction if the BeginTransaction option is included with the first statement of the\n+     * transaction.\n+     */\n+    private volatile SettableApiFuture<ByteString> transactionIdFuture = null;\n+\n+    volatile ByteString transactionId;\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b816a6647106da2e346e3efaae4ab6dcc8d84740"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODg1ODU1OnYy", "diffSide": "RIGHT", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/InlineBeginTransactionTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzozOToxN1rOHleSCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzozOToxN1rOHleSCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1NTQ5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // The first PartialResultSet will be returned successfully, and then a DATA_LOSS exception will be returned.\n          \n          \n            \n                mockSpanner.setExecuteStreamingSqlExecutionTime(\n          \n          \n            \n                    SimulatedExecutionTime.ofStreamException(\n          \n          \n            \n                // The first PartialResultSet will be returned successfully, and then a DATA_LOSS exception will\n          \n          \n            \n                // be returned.\n          \n          \n            \n                    SimulatedExecutionTime.ofStreamException(Status.DATA_LOSS.asRuntimeException(), 1));", "url": "https://github.com/googleapis/java-spanner/pull/325#discussion_r509055499", "createdAt": "2020-10-21T07:39:17Z", "author": {"login": "yoshi-code-bot"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/InlineBeginTransactionTest.java", "diffHunk": "@@ -0,0 +1,1155 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n+\n+import com.google.api.core.ApiAsyncFunction;\n+import com.google.api.core.ApiFuture;\n+import com.google.api.core.ApiFutures;\n+import com.google.api.core.SettableApiFuture;\n+import com.google.api.gax.grpc.testing.LocalChannelProvider;\n+import com.google.cloud.NoCredentials;\n+import com.google.cloud.spanner.AsyncResultSet.CallbackResponse;\n+import com.google.cloud.spanner.AsyncResultSet.ReadyCallback;\n+import com.google.cloud.spanner.AsyncRunner.AsyncWork;\n+import com.google.cloud.spanner.AsyncTransactionManager.AsyncTransactionFunction;\n+import com.google.cloud.spanner.AsyncTransactionManager.AsyncTransactionStep;\n+import com.google.cloud.spanner.AsyncTransactionManager.CommitTimestampFuture;\n+import com.google.cloud.spanner.AsyncTransactionManager.TransactionContextFuture;\n+import com.google.cloud.spanner.MockSpannerServiceImpl.SimulatedExecutionTime;\n+import com.google.cloud.spanner.MockSpannerServiceImpl.StatementResult;\n+import com.google.cloud.spanner.TransactionRunner.TransactionCallable;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.AbstractMessage;\n+import com.google.protobuf.ListValue;\n+import com.google.spanner.v1.BeginTransactionRequest;\n+import com.google.spanner.v1.CommitRequest;\n+import com.google.spanner.v1.ExecuteBatchDmlRequest;\n+import com.google.spanner.v1.ExecuteSqlRequest;\n+import com.google.spanner.v1.ReadRequest;\n+import com.google.spanner.v1.ResultSetMetadata;\n+import com.google.spanner.v1.RollbackRequest;\n+import com.google.spanner.v1.StructType;\n+import com.google.spanner.v1.StructType.Field;\n+import com.google.spanner.v1.TypeCode;\n+import io.grpc.Server;\n+import io.grpc.Status;\n+import io.grpc.inprocess.InProcessServerBuilder;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class InlineBeginTransactionTest {\n+  @Parameter public Executor executor;\n+\n+  @Parameters(name = \"executor = {0}\")\n+  public static Collection<Object[]> data() {\n+    return Arrays.asList(\n+        new Object[][] {\n+          {MoreExecutors.directExecutor()},\n+          {Executors.newSingleThreadExecutor()},\n+          {Executors.newFixedThreadPool(4)}\n+        });\n+  }\n+\n+  private static MockSpannerServiceImpl mockSpanner;\n+  private static Server server;\n+  private static LocalChannelProvider channelProvider;\n+  private static final Statement UPDATE_STATEMENT =\n+      Statement.of(\"UPDATE FOO SET BAR=1 WHERE BAZ=2\");\n+  private static final Statement INVALID_UPDATE_STATEMENT =\n+      Statement.of(\"UPDATE NON_EXISTENT_TABLE SET BAR=1 WHERE BAZ=2\");\n+  private static final long UPDATE_COUNT = 1L;\n+  private static final Statement SELECT1 = Statement.of(\"SELECT 1 AS COL1\");\n+  private static final ResultSetMetadata SELECT1_METADATA =\n+      ResultSetMetadata.newBuilder()\n+          .setRowType(\n+              StructType.newBuilder()\n+                  .addFields(\n+                      Field.newBuilder()\n+                          .setName(\"COL1\")\n+                          .setType(\n+                              com.google.spanner.v1.Type.newBuilder()\n+                                  .setCode(TypeCode.INT64)\n+                                  .build())\n+                          .build())\n+                  .build())\n+          .build();\n+  private static final com.google.spanner.v1.ResultSet SELECT1_RESULTSET =\n+      com.google.spanner.v1.ResultSet.newBuilder()\n+          .addRows(\n+              ListValue.newBuilder()\n+                  .addValues(com.google.protobuf.Value.newBuilder().setStringValue(\"1\").build())\n+                  .build())\n+          .setMetadata(SELECT1_METADATA)\n+          .build();\n+  private static final Statement INVALID_SELECT = Statement.of(\"SELECT * FROM NON_EXISTING_TABLE\");\n+  private static final Statement READ_STATEMENT = Statement.of(\"SELECT ID FROM FOO WHERE 1=1\");\n+\n+  private Spanner spanner;\n+\n+  @BeforeClass\n+  public static void startStaticServer() throws IOException {\n+    mockSpanner = new MockSpannerServiceImpl();\n+    mockSpanner.setAbortProbability(0.0D); // We don't want any unpredictable aborted transactions.\n+    mockSpanner.putStatementResult(StatementResult.update(UPDATE_STATEMENT, UPDATE_COUNT));\n+    mockSpanner.putStatementResult(StatementResult.query(SELECT1, SELECT1_RESULTSET));\n+    mockSpanner.putStatementResult(StatementResult.query(READ_STATEMENT, SELECT1_RESULTSET));\n+    mockSpanner.putStatementResult(\n+        StatementResult.exception(\n+            INVALID_UPDATE_STATEMENT,\n+            Status.INVALID_ARGUMENT\n+                .withDescription(\"invalid update statement\")\n+                .asRuntimeException()));\n+    mockSpanner.putStatementResult(\n+        StatementResult.exception(\n+            INVALID_SELECT,\n+            Status.INVALID_ARGUMENT\n+                .withDescription(\"invalid select statement\")\n+                .asRuntimeException()));\n+\n+    String uniqueName = InProcessServerBuilder.generateName();\n+    server =\n+        InProcessServerBuilder.forName(uniqueName)\n+            // We need to use a real executor for timeouts to occur.\n+            .scheduledExecutorService(new ScheduledThreadPoolExecutor(1))\n+            .addService(mockSpanner)\n+            .build()\n+            .start();\n+    channelProvider = LocalChannelProvider.create(uniqueName);\n+  }\n+\n+  @AfterClass\n+  public static void stopServer() throws InterruptedException {\n+    server.shutdown();\n+    server.awaitTermination();\n+  }\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    mockSpanner.reset();\n+    mockSpanner.removeAllExecutionTimes();\n+    // Create a Spanner instance that will inline BeginTransaction calls. It also has no prepared\n+    // sessions in the pool to prevent session preparing from interfering with test cases.\n+    spanner =\n+        SpannerOptions.newBuilder()\n+            .setProjectId(\"[PROJECT]\")\n+            .setChannelProvider(channelProvider)\n+            .setCredentials(NoCredentials.getInstance())\n+            .build()\n+            .getService();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    spanner.close();\n+    mockSpanner.reset();\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTx() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    return transaction.executeUpdate(UPDATE_STATEMENT);\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(UPDATE_COUNT);\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxAborted() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    final AtomicBoolean firstAttempt = new AtomicBoolean(true);\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    long res = transaction.executeUpdate(UPDATE_STATEMENT);\n+                    if (firstAttempt.getAndSet(false)) {\n+                      mockSpanner.abortTransaction(transaction);\n+                    }\n+                    return res;\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(UPDATE_COUNT);\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(2);\n+    // We have started 2 transactions, because the first transaction aborted during the commit.\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(2);\n+    assertThat(countTransactionsStarted()).isEqualTo(2);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithQuery() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    try (ResultSet rs = transaction.executeQuery(SELECT1)) {\n+                      while (rs.next()) {\n+                        return rs.getLong(0);\n+                      }\n+                    }\n+                    return 0L;\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(1L);\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithRead() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    try (ResultSet rs =\n+                        transaction.read(\"FOO\", KeySet.all(), Arrays.asList(\"ID\"))) {\n+                      while (rs.next()) {\n+                        return rs.getLong(0);\n+                      }\n+                    }\n+                    return 0L;\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(1L);\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ReadRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithBatchDml() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long[] updateCounts =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<long[]>() {\n+                  @Override\n+                  public long[] run(TransactionContext transaction) throws Exception {\n+                    return transaction.batchUpdate(\n+                        Arrays.asList(UPDATE_STATEMENT, UPDATE_STATEMENT));\n+                  }\n+                });\n+    assertThat(updateCounts).asList().containsExactly(UPDATE_COUNT, UPDATE_COUNT);\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteBatchDmlRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithError() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    try {\n+                      transaction.executeUpdate(INVALID_UPDATE_STATEMENT);\n+                      fail(\"missing expected exception\");\n+                    } catch (SpannerException e) {\n+                      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+                    }\n+                    return transaction.executeUpdate(UPDATE_STATEMENT);\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(UPDATE_COUNT);\n+    // The transaction will be retried because the first statement that also tried to include the\n+    // BeginTransaction statement failed and did not return a transaction. That forces a retry of\n+    // the entire transaction with an explicit BeginTransaction RPC.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(1);\n+    // The update statement will be executed 3 times:\n+    // 1. The invalid update statement will be executed during the first attempt and fail. The\n+    // second update statement will not be executed, as the transaction runner sees that the initial\n+    // statement failed and did not return a valid transaction id.\n+    // 2. The invalid update statement is executed again during the retry.\n+    // 3. The valid update statement is only executed after the first statement succeeded.\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(3);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    // The first update will start a transaction, but then fail the update statement. This will\n+    // start a transaction on the mock server, but that transaction will never be returned to the\n+    // client.\n+    assertThat(countTransactionsStarted()).isEqualTo(2);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithErrorOnFirstStatement_andThenErrorOnBeginTransaction() {\n+    mockSpanner.setBeginTransactionExecutionTime(\n+        SimulatedExecutionTime.ofException(\n+            Status.INTERNAL\n+                .withDescription(\"Begin transaction failed due to an internal error\")\n+                .asRuntimeException()));\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    try {\n+      client\n+          .readWriteTransaction()\n+          .run(\n+              new TransactionCallable<Void>() {\n+                @Override\n+                public Void run(TransactionContext transaction) throws Exception {\n+                  try {\n+                    transaction.executeUpdate(INVALID_UPDATE_STATEMENT);\n+                    fail(\"missing expected exception\");\n+                  } catch (SpannerException e) {\n+                    assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+                  }\n+                  return null;\n+                }\n+              });\n+      fail(\"Missing expected exception\");\n+    } catch (SpannerException e) {\n+      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INTERNAL);\n+      assertThat(e.getMessage()).contains(\"Begin transaction failed due to an internal error\");\n+    }\n+    // The transaction will be retried because the first statement that also tried to include the\n+    // BeginTransaction statement failed and did not return a transaction. That forces a retry of\n+    // the entire transaction with an explicit BeginTransaction RPC.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(0);\n+    // The explicit BeginTransaction RPC failed, so only one transaction was started.\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithUncaughtError() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    try {\n+      client\n+          .readWriteTransaction()\n+          .run(\n+              new TransactionCallable<Long>() {\n+                @Override\n+                public Long run(TransactionContext transaction) throws Exception {\n+                  return transaction.executeUpdate(INVALID_UPDATE_STATEMENT);\n+                }\n+              });\n+      fail(\"missing expected exception\");\n+    } catch (SpannerException e) {\n+      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+    }\n+    // The first update will start a transaction, but then fail the update statement. This will\n+    // start a transaction on the mock server, but that transaction will never be returned to the\n+    // client.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(1);\n+    // No rollback request will be initiated because the client does not receive any transaction id.\n+    assertThat(countRequests(RollbackRequest.class)).isEqualTo(0);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithUncaughtErrorAfterSuccessfulBegin() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    try {\n+      client\n+          .readWriteTransaction()\n+          .run(\n+              new TransactionCallable<Long>() {\n+                @Override\n+                public Long run(TransactionContext transaction) throws Exception {\n+                  // This statement will start a transaction.\n+                  transaction.executeUpdate(UPDATE_STATEMENT);\n+                  // This statement will fail and cause a rollback as the exception is not caught.\n+                  return transaction.executeUpdate(INVALID_UPDATE_STATEMENT);\n+                }\n+              });\n+      fail(\"missing expected exception\");\n+    } catch (SpannerException e) {\n+      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+    }\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(2);\n+    assertThat(countRequests(RollbackRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxBatchDmlWithErrorOnFirstStatement() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    Void res =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Void>() {\n+                  @Override\n+                  public Void run(TransactionContext transaction) throws Exception {\n+                    try {\n+                      transaction.batchUpdate(\n+                          ImmutableList.of(INVALID_UPDATE_STATEMENT, UPDATE_STATEMENT));\n+                      fail(\"missing expected exception\");\n+                    } catch (SpannerBatchUpdateException e) {\n+                      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+                      assertThat(e.getUpdateCounts()).hasLength(0);\n+                    }\n+                    return null;\n+                  }\n+                });\n+    assertThat(res).isNull();\n+    // The first statement failed and could not return a transaction. The entire transaction is\n+    // therefore retried with an explicit BeginTransaction RPC.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(ExecuteBatchDmlRequest.class)).isEqualTo(2);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(2);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxBatchDmlWithErrorOnSecondStatement() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    try {\n+                      transaction.batchUpdate(\n+                          ImmutableList.of(UPDATE_STATEMENT, INVALID_UPDATE_STATEMENT));\n+                      fail(\"missing expected exception\");\n+                      // The following line is needed as the compiler does not know that this is\n+                      // unreachable.\n+                      return -1L;\n+                    } catch (SpannerBatchUpdateException e) {\n+                      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+                      assertThat(e.getUpdateCounts()).hasLength(1);\n+                      return e.getUpdateCounts()[0];\n+                    }\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(UPDATE_COUNT);\n+    // Although the batch DML returned an error, that error was for the second statement. That means\n+    // that the transaction was started by the first statement.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteBatchDmlRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithErrorOnStreamingSql() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    Void res =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Void>() {\n+                  @Override\n+                  public Void run(TransactionContext transaction) throws Exception {\n+                    try (ResultSet rs = transaction.executeQuery(INVALID_SELECT)) {\n+                      while (rs.next()) {}\n+                      fail(\"missing expected exception\");\n+                    } catch (SpannerException e) {\n+                      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+                    }\n+                    return null;\n+                  }\n+                });\n+    assertThat(res).isNull();\n+    // The transaction will be retried because the first statement that also tried to include the\n+    // BeginTransaction statement failed and did not return a transaction. That forces a retry of\n+    // the entire transaction with an explicit BeginTransaction RPC.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(2);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    // The first update will start a transaction, but then fail the update statement. This will\n+    // start a transaction on the mock server, but that transaction will never be returned to the\n+    // client.\n+    assertThat(countTransactionsStarted()).isEqualTo(2);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithErrorOnSecondPartialResultSet() {\n+    final Statement statement = Statement.of(\"SELECT * FROM BROKEN_TABLE\");\n+    RandomResultSetGenerator generator = new RandomResultSetGenerator(2);\n+    mockSpanner.putStatementResult(StatementResult.query(statement, generator.generate()));\n+    // The first PartialResultSet will be returned successfully, and then a DATA_LOSS exception will be returned.\n+    mockSpanner.setExecuteStreamingSqlExecutionTime(\n+        SimulatedExecutionTime.ofStreamException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b816a6647106da2e346e3efaae4ab6dcc8d84740"}, "originalPosition": 551}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODg1ODU4OnYy", "diffSide": "RIGHT", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/MockSpannerServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzozOToxN1rOHleSDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzozOToxN1rOHleSDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1NTUwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/googleapis/java-spanner/pull/325#discussion_r509055502", "createdAt": "2020-10-21T07:39:17Z", "author": {"login": "yoshi-code-bot"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/MockSpannerServiceImpl.java", "diffHunk": "@@ -1917,6 +1917,10 @@ public void waitForLastRequestToBe(Class<? extends AbstractMessage> type, long t\n     }\n   }\n \n+  public List<ByteString> getTransactionsStarted() {\n+    return new ArrayList<>(transactionsStarted);\n+  }\n+  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b816a6647106da2e346e3efaae4ab6dcc8d84740"}, "originalPosition": 84}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3142, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}