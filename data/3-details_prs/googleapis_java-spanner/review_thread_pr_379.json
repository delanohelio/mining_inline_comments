{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1NDE0Mzg2", "number": 379, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNDo1Mjo0OFrOEY4-0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwMzo1ODowNFrOEbZbjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NTM0ODY2OnYy", "diffSide": "LEFT", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/spi/v1/SpannerRpc.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNDo1Mjo0OFrOHBZpCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwODo0MTo0NFrOHBfrSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzMDczMQ==", "bodyText": "Why do we remove this? This seems to be related to the failed test:\n[ERROR] 7002: com.google.cloud.spanner.spi.v1.GapicSpannerRpc: Method 'public com.google.spanner.v1.ResultSet executePartitionedDml(com.google.spanner.v1.ExecuteSqlRequest, java.util.Map)' has been removed\n[ERROR] 7002: com.google.cloud.spanner.spi.v1.SpannerRpc: Method 'public com.google.spanner.v1.ResultSet executePartitionedDml(com.google.spanner.v1.ExecuteSqlRequest, java.util.Map)' has been removed", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r471230731", "createdAt": "2020-08-17T04:52:48Z", "author": {"login": "hengfengli"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/spi/v1/SpannerRpc.java", "diffHunk": "@@ -287,8 +287,6 @@ StreamingCall read(\n   ApiFuture<ResultSet> executeQueryAsync(\n       ExecuteSqlRequest request, @Nullable Map<Option, ?> options);\n \n-  ResultSet executePartitionedDml(ExecuteSqlRequest request, @Nullable Map<Option, ?> options);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd2715702423eedc8c9e907e6ccf1e33876f6074"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMyOTYxMA==", "bodyText": "This method is no longer used (instead the client library uses the streaming version), but the removal of it should be moved to a separate PR. I've reverted this change. That should also fix the clirr build failure.", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r471329610", "createdAt": "2020-08-17T08:41:44Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/spi/v1/SpannerRpc.java", "diffHunk": "@@ -287,8 +287,6 @@ StreamingCall read(\n   ApiFuture<ResultSet> executeQueryAsync(\n       ExecuteSqlRequest request, @Nullable Map<Option, ?> options);\n \n-  ResultSet executePartitionedDml(ExecuteSqlRequest request, @Nullable Map<Option, ?> options);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzMDczMQ=="}, "originalCommit": {"oid": "dd2715702423eedc8c9e907e6ccf1e33876f6074"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NTM3NTQxOnYy", "diffSide": "RIGHT", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/spi/v1/GapicSpannerRpcTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNToxMToxM1rOHBZ4PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwODo0MjoxOFrOHBfskg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzNDYyMA==", "bodyText": "udate to update", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r471234620", "createdAt": "2020-08-17T05:11:13Z", "author": {"login": "hengfengli"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/spi/v1/GapicSpannerRpcTest.java", "diffHunk": "@@ -336,11 +367,93 @@ public void testNoCallCredentials() {\n             .setCredentials(STATIC_CREDENTIALS)\n             .build();\n     GapicSpannerRpc rpc = new GapicSpannerRpc(options);\n-    assertThat(rpc.newCallContext(optionsMap, \"/some/resource\").getCallOptions().getCredentials())\n+    assertThat(\n+            rpc.newCallContext(\n+                    optionsMap,\n+                    \"/some/resource\",\n+                    GetSessionRequest.getDefaultInstance(),\n+                    SpannerGrpc.getGetSessionMethod())\n+                .getCallOptions()\n+                .getCredentials())\n         .isNull();\n     rpc.shutdown();\n   }\n \n+  private static final class TimeoutHolder {\n+    private Duration timeout;\n+  }\n+\n+  @Test\n+  public void testCallContextTimeout() {\n+    // Create a CallContextConfigurator that uses a variable timeout value.\n+    final TimeoutHolder timeoutHolder = new TimeoutHolder();\n+    CallContextConfigurator configurator =\n+        new CallContextConfigurator() {\n+          @Override\n+          public <ReqT, RespT> ApiCallContext configure(\n+              ApiCallContext context, ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+            // Only configure a timeout for the ExecuteSql method when the request has a ,\n+            // as this method is used for executing DML statements.\n+            if (request instanceof ExecuteSqlRequest\n+                && method.equals(SpannerGrpc.getExecuteSqlMethod())) {\n+              ExecuteSqlRequest sqlRequest = (ExecuteSqlRequest) request;\n+              // Sequence numbers are only assigned for DML statements, which means that\n+              // this is an udate statement.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd2715702423eedc8c9e907e6ccf1e33876f6074"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMyOTkzOA==", "bodyText": "Fixed.", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r471329938", "createdAt": "2020-08-17T08:42:18Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/spi/v1/GapicSpannerRpcTest.java", "diffHunk": "@@ -336,11 +367,93 @@ public void testNoCallCredentials() {\n             .setCredentials(STATIC_CREDENTIALS)\n             .build();\n     GapicSpannerRpc rpc = new GapicSpannerRpc(options);\n-    assertThat(rpc.newCallContext(optionsMap, \"/some/resource\").getCallOptions().getCredentials())\n+    assertThat(\n+            rpc.newCallContext(\n+                    optionsMap,\n+                    \"/some/resource\",\n+                    GetSessionRequest.getDefaultInstance(),\n+                    SpannerGrpc.getGetSessionMethod())\n+                .getCallOptions()\n+                .getCredentials())\n         .isNull();\n     rpc.shutdown();\n   }\n \n+  private static final class TimeoutHolder {\n+    private Duration timeout;\n+  }\n+\n+  @Test\n+  public void testCallContextTimeout() {\n+    // Create a CallContextConfigurator that uses a variable timeout value.\n+    final TimeoutHolder timeoutHolder = new TimeoutHolder();\n+    CallContextConfigurator configurator =\n+        new CallContextConfigurator() {\n+          @Override\n+          public <ReqT, RespT> ApiCallContext configure(\n+              ApiCallContext context, ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+            // Only configure a timeout for the ExecuteSql method when the request has a ,\n+            // as this method is used for executing DML statements.\n+            if (request instanceof ExecuteSqlRequest\n+                && method.equals(SpannerGrpc.getExecuteSqlMethod())) {\n+              ExecuteSqlRequest sqlRequest = (ExecuteSqlRequest) request;\n+              // Sequence numbers are only assigned for DML statements, which means that\n+              // this is an udate statement.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzNDYyMA=="}, "originalCommit": {"oid": "dd2715702423eedc8c9e907e6ccf1e33876f6074"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NTM3NjcyOnYy", "diffSide": "RIGHT", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/spi/v1/GapicSpannerRpcTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNToxMTo1OVrOHBZ47A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxMzozODo1OFrOHBpJNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzNDc5Ng==", "bodyText": "This sentence is not finished yet.", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r471234796", "createdAt": "2020-08-17T05:11:59Z", "author": {"login": "hengfengli"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/spi/v1/GapicSpannerRpcTest.java", "diffHunk": "@@ -336,11 +367,93 @@ public void testNoCallCredentials() {\n             .setCredentials(STATIC_CREDENTIALS)\n             .build();\n     GapicSpannerRpc rpc = new GapicSpannerRpc(options);\n-    assertThat(rpc.newCallContext(optionsMap, \"/some/resource\").getCallOptions().getCredentials())\n+    assertThat(\n+            rpc.newCallContext(\n+                    optionsMap,\n+                    \"/some/resource\",\n+                    GetSessionRequest.getDefaultInstance(),\n+                    SpannerGrpc.getGetSessionMethod())\n+                .getCallOptions()\n+                .getCredentials())\n         .isNull();\n     rpc.shutdown();\n   }\n \n+  private static final class TimeoutHolder {\n+    private Duration timeout;\n+  }\n+\n+  @Test\n+  public void testCallContextTimeout() {\n+    // Create a CallContextConfigurator that uses a variable timeout value.\n+    final TimeoutHolder timeoutHolder = new TimeoutHolder();\n+    CallContextConfigurator configurator =\n+        new CallContextConfigurator() {\n+          @Override\n+          public <ReqT, RespT> ApiCallContext configure(\n+              ApiCallContext context, ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+            // Only configure a timeout for the ExecuteSql method when the request has a ,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd2715702423eedc8c9e907e6ccf1e33876f6074"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ4NDcyNA==", "bodyText": "Done.", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r471484724", "createdAt": "2020-08-17T13:38:58Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/spi/v1/GapicSpannerRpcTest.java", "diffHunk": "@@ -336,11 +367,93 @@ public void testNoCallCredentials() {\n             .setCredentials(STATIC_CREDENTIALS)\n             .build();\n     GapicSpannerRpc rpc = new GapicSpannerRpc(options);\n-    assertThat(rpc.newCallContext(optionsMap, \"/some/resource\").getCallOptions().getCredentials())\n+    assertThat(\n+            rpc.newCallContext(\n+                    optionsMap,\n+                    \"/some/resource\",\n+                    GetSessionRequest.getDefaultInstance(),\n+                    SpannerGrpc.getGetSessionMethod())\n+                .getCallOptions()\n+                .getCredentials())\n         .isNull();\n     rpc.shutdown();\n   }\n \n+  private static final class TimeoutHolder {\n+    private Duration timeout;\n+  }\n+\n+  @Test\n+  public void testCallContextTimeout() {\n+    // Create a CallContextConfigurator that uses a variable timeout value.\n+    final TimeoutHolder timeoutHolder = new TimeoutHolder();\n+    CallContextConfigurator configurator =\n+        new CallContextConfigurator() {\n+          @Override\n+          public <ReqT, RespT> ApiCallContext configure(\n+              ApiCallContext context, ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+            // Only configure a timeout for the ExecuteSql method when the request has a ,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzNDc5Ng=="}, "originalCommit": {"oid": "dd2715702423eedc8c9e907e6ccf1e33876f6074"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NTQyNjM3OnYy", "diffSide": "RIGHT", "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/DatabaseClientImplTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwNTo0MDoyNlrOHBaU-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QwODo0Mzo1M1rOHBfvyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI0MTk3Nw==", "bodyText": "So this given timeout is for every ExecuteQuery inside this context? If two ExecuteQuery calls are inside this context, each of them will be limited by the 1ns timeout, right?", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r471241977", "createdAt": "2020-08-17T05:40:26Z", "author": {"login": "hengfengli"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/DatabaseClientImplTest.java", "diffHunk": "@@ -1548,4 +1550,40 @@ public void testReadDoesNotIncludeStatement() {\n       assertThat(e.getMessage()).doesNotContain(\"Statement:\");\n     }\n   }\n+\n+  @Test\n+  public void testSpecificTimeout() {\n+    mockSpanner.setExecuteStreamingSqlExecutionTime(\n+        SimulatedExecutionTime.ofMinimumAndRandomTime(10000, 0));\n+    final DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(TEST_PROJECT, TEST_INSTANCE, TEST_DATABASE));\n+    Context.current()\n+        .withValue(\n+            SpannerOptions.CALL_CONTEXT_CONFIGURATOR_KEY,\n+            SpannerCallContextTimeoutConfigurator.create()\n+                .withExecuteQueryTimeout(Duration.ofNanos(1L)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd2715702423eedc8c9e907e6ccf1e33876f6074"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMzMDc2Mw==", "bodyText": "Correct.", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r471330763", "createdAt": "2020-08-17T08:43:53Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/DatabaseClientImplTest.java", "diffHunk": "@@ -1548,4 +1550,40 @@ public void testReadDoesNotIncludeStatement() {\n       assertThat(e.getMessage()).doesNotContain(\"Statement:\");\n     }\n   }\n+\n+  @Test\n+  public void testSpecificTimeout() {\n+    mockSpanner.setExecuteStreamingSqlExecutionTime(\n+        SimulatedExecutionTime.ofMinimumAndRandomTime(10000, 0));\n+    final DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(TEST_PROJECT, TEST_INSTANCE, TEST_DATABASE));\n+    Context.current()\n+        .withValue(\n+            SpannerOptions.CALL_CONTEXT_CONFIGURATOR_KEY,\n+            SpannerCallContextTimeoutConfigurator.create()\n+                .withExecuteQueryTimeout(Duration.ofNanos(1L)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI0MTk3Nw=="}, "originalCommit": {"oid": "dd2715702423eedc8c9e907e6ccf1e33876f6074"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTYzNjYxOnYy", "diffSide": "RIGHT", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SpannerOptions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwMzo1ODowNFrOHFTy2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMjoyNTozM1rOHGVnYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTMyOTI0MQ==", "bodyText": "nit (don't have to change this, just a suggestion): it might be easier to test this / encapsulate the logic if we use a visitor pattern.", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r475329241", "createdAt": "2020-08-24T03:58:04Z", "author": {"login": "thiagotnunes"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SpannerOptions.java", "diffHunk": "@@ -121,6 +129,324 @@\n     CallCredentials getCallCredentials();\n   }\n \n+  /** Context key for the {@link CallContextConfigurator} to use. */\n+  public static final Context.Key<CallContextConfigurator> CALL_CONTEXT_CONFIGURATOR_KEY =\n+      Context.key(\"call-context-configurator\");\n+\n+  /**\n+   * {@link CallContextConfigurator} can be used to modify the {@link ApiCallContext} for one or\n+   * more specific RPCs. This can be used to set specific timeout value for RPCs or use specific\n+   * {@link CallCredentials} for an RPC. The {@link CallContextConfigurator} must be set as a value\n+   * on the {@link Context} using the {@link SpannerOptions#CALL_CONTEXT_CONFIGURATOR_KEY} key.\n+   *\n+   * <p>This API is meant for advanced users. Most users should instead use the {@link\n+   * SpannerCallContextTimeoutConfigurator} for setting timeouts per RPC.\n+   *\n+   * <p>Example usage:\n+   *\n+   * <pre>{@code\n+   * CallContextConfigurator configurator =\n+   *     new CallContextConfigurator() {\n+   *       public <ReqT, RespT> ApiCallContext configure(\n+   *           ApiCallContext context, ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+   *         if (method == SpannerGrpc.getExecuteBatchDmlMethod()) {\n+   *           return GrpcCallContext.createDefault()\n+   *               .withCallOptions(CallOptions.DEFAULT.withDeadlineAfter(60L, TimeUnit.SECONDS));\n+   *         }\n+   *         return null;\n+   *       }\n+   *     };\n+   * Context context =\n+   *     Context.current().withValue(SpannerOptions.CALL_CONTEXT_CONFIGURATOR_KEY, configurator);\n+   * context.run(\n+   *     new Runnable() {\n+   *       public void run() {\n+   *         try {\n+   *           client\n+   *               .readWriteTransaction()\n+   *               .run(\n+   *                   new TransactionCallable<long[]>() {\n+   *                     public long[] run(TransactionContext transaction) throws Exception {\n+   *                       return transaction.batchUpdate(\n+   *                           ImmutableList.of(statement1, statement2));\n+   *                     }\n+   *                   });\n+   *         } catch (SpannerException e) {\n+   *           if (e.getErrorCode() == ErrorCode.DEADLINE_EXCEEDED) {\n+   *             // handle timeout exception.\n+   *           }\n+   *         }\n+   *       }\n+   *     });\n+   * }</pre>\n+   */\n+  public static interface CallContextConfigurator {\n+    /**\n+     * Configure a {@link ApiCallContext} for a specific RPC call.\n+     *\n+     * @param context The default context. This can be used to inspect the current values.\n+     * @param request The request that will be sent.\n+     * @param method The method that is being called.\n+     * @return An {@link ApiCallContext} that will be merged with the default {@link\n+     *     ApiCallContext}. If <code>null</code> is returned, no changes to the default {@link\n+     *     ApiCallContext} will be made.\n+     */\n+    @Nullable\n+    <ReqT, RespT> ApiCallContext configure(\n+        ApiCallContext context, ReqT request, MethodDescriptor<ReqT, RespT> method);\n+  }\n+\n+  private enum SpannerMethod {\n+    COMMIT {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getCommitMethod();\n+      }\n+    },\n+    ROLLBACK {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getRollbackMethod();\n+      }\n+    },\n+\n+    EXECUTE_QUERY {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        // This also matches with Partitioned DML calls, but that call will override any timeout\n+        // settings anyway.\n+        return method == SpannerGrpc.getExecuteStreamingSqlMethod();\n+      }\n+    },\n+    READ {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getStreamingReadMethod();\n+      }\n+    },\n+    EXECUTE_UPDATE {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        if (method == SpannerGrpc.getExecuteSqlMethod()) {\n+          ExecuteSqlRequest sqlRequest = (ExecuteSqlRequest) request;\n+          return sqlRequest.getSeqno() != 0L;\n+        }\n+        return false;\n+      }\n+    },\n+    BATCH_UPDATE {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getExecuteBatchDmlMethod();\n+      }\n+    },\n+\n+    PARTITION_QUERY {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getPartitionQueryMethod();\n+      }\n+    },\n+    PARTITION_READ {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getPartitionReadMethod();\n+      }\n+    };\n+\n+    abstract <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method);\n+\n+    static <ReqT, RespT> SpannerMethod valueOf(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+      for (SpannerMethod m : SpannerMethod.values()) {\n+        if (m.isMethod(request, method)) {\n+          return m;\n+        }\n+      }\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Helper class to configure timeouts for specific Spanner RPCs. The {@link\n+   * SpannerCallContextTimeoutConfigurator} must be set as a value on the {@link Context} using the\n+   * {@link SpannerOptions#CALL_CONTEXT_CONFIGURATOR_KEY} key.\n+   *\n+   * <p>Example usage:\n+   *\n+   * <pre>{@code\n+   * // Create a context with a ExecuteQuery timeout of 10 seconds.\n+   * Context context =\n+   *     Context.current()\n+   *         .withValue(\n+   *             SpannerOptions.CALL_CONTEXT_CONFIGURATOR_KEY,\n+   *             SpannerCallContextTimeoutConfigurator.create()\n+   *                 .withExecuteQueryTimeout(Duration.ofSeconds(10L)));\n+   * context.run(\n+   *     new Runnable() {\n+   *       public void run() {\n+   *         try (ResultSet rs =\n+   *             client\n+   *                 .singleUse()\n+   *                 .executeQuery(\n+   *                     Statement.of(\n+   *                         \"SELECT SingerId, FirstName, LastName FROM Singers ORDER BY LastName\"))) {\n+   *           while (rs.next()) {\n+   *             System.out.printf(\"%d %s %s%n\", rs.getLong(0), rs.getString(1), rs.getString(2));\n+   *           }\n+   *         } catch (SpannerException e) {\n+   *           if (e.getErrorCode() == ErrorCode.DEADLINE_EXCEEDED) {\n+   *             // Handle timeout.\n+   *           }\n+   *         }\n+   *       }\n+   *     });\n+   * }</pre>\n+   */\n+  public static class SpannerCallContextTimeoutConfigurator implements CallContextConfigurator {\n+    private Duration commitTimeout;\n+    private Duration rollbackTimeout;\n+\n+    private Duration executeQueryTimeout;\n+    private Duration executeUpdateTimeout;\n+    private Duration batchUpdateTimeout;\n+    private Duration readTimeout;\n+\n+    private Duration partitionQueryTimeout;\n+    private Duration partitionReadTimeout;\n+\n+    public static SpannerCallContextTimeoutConfigurator create() {\n+      return new SpannerCallContextTimeoutConfigurator();\n+    }\n+\n+    private SpannerCallContextTimeoutConfigurator() {}\n+\n+    @Override\n+    public <ReqT, RespT> ApiCallContext configure(\n+        ApiCallContext context, ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+      SpannerMethod spannerMethod = SpannerMethod.valueOf(request, method);\n+      if (spannerMethod == null) {\n+        return null;\n+      }\n+      switch (SpannerMethod.valueOf(request, method)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4571e58a8a6b44fba75e86cb0e77ecf6e3fd2086"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwNzY1MA==", "bodyText": "That's probably a good idea. We would still need some kind of lookup table for the timeout / method combination (i.e. keeping them in a hash map or something), but it might make it somewhat simpler. I'll do that in a separate PR, as it won't change the public interface of it.", "url": "https://github.com/googleapis/java-spanner/pull/379#discussion_r476407650", "createdAt": "2020-08-25T12:25:33Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SpannerOptions.java", "diffHunk": "@@ -121,6 +129,324 @@\n     CallCredentials getCallCredentials();\n   }\n \n+  /** Context key for the {@link CallContextConfigurator} to use. */\n+  public static final Context.Key<CallContextConfigurator> CALL_CONTEXT_CONFIGURATOR_KEY =\n+      Context.key(\"call-context-configurator\");\n+\n+  /**\n+   * {@link CallContextConfigurator} can be used to modify the {@link ApiCallContext} for one or\n+   * more specific RPCs. This can be used to set specific timeout value for RPCs or use specific\n+   * {@link CallCredentials} for an RPC. The {@link CallContextConfigurator} must be set as a value\n+   * on the {@link Context} using the {@link SpannerOptions#CALL_CONTEXT_CONFIGURATOR_KEY} key.\n+   *\n+   * <p>This API is meant for advanced users. Most users should instead use the {@link\n+   * SpannerCallContextTimeoutConfigurator} for setting timeouts per RPC.\n+   *\n+   * <p>Example usage:\n+   *\n+   * <pre>{@code\n+   * CallContextConfigurator configurator =\n+   *     new CallContextConfigurator() {\n+   *       public <ReqT, RespT> ApiCallContext configure(\n+   *           ApiCallContext context, ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+   *         if (method == SpannerGrpc.getExecuteBatchDmlMethod()) {\n+   *           return GrpcCallContext.createDefault()\n+   *               .withCallOptions(CallOptions.DEFAULT.withDeadlineAfter(60L, TimeUnit.SECONDS));\n+   *         }\n+   *         return null;\n+   *       }\n+   *     };\n+   * Context context =\n+   *     Context.current().withValue(SpannerOptions.CALL_CONTEXT_CONFIGURATOR_KEY, configurator);\n+   * context.run(\n+   *     new Runnable() {\n+   *       public void run() {\n+   *         try {\n+   *           client\n+   *               .readWriteTransaction()\n+   *               .run(\n+   *                   new TransactionCallable<long[]>() {\n+   *                     public long[] run(TransactionContext transaction) throws Exception {\n+   *                       return transaction.batchUpdate(\n+   *                           ImmutableList.of(statement1, statement2));\n+   *                     }\n+   *                   });\n+   *         } catch (SpannerException e) {\n+   *           if (e.getErrorCode() == ErrorCode.DEADLINE_EXCEEDED) {\n+   *             // handle timeout exception.\n+   *           }\n+   *         }\n+   *       }\n+   *     });\n+   * }</pre>\n+   */\n+  public static interface CallContextConfigurator {\n+    /**\n+     * Configure a {@link ApiCallContext} for a specific RPC call.\n+     *\n+     * @param context The default context. This can be used to inspect the current values.\n+     * @param request The request that will be sent.\n+     * @param method The method that is being called.\n+     * @return An {@link ApiCallContext} that will be merged with the default {@link\n+     *     ApiCallContext}. If <code>null</code> is returned, no changes to the default {@link\n+     *     ApiCallContext} will be made.\n+     */\n+    @Nullable\n+    <ReqT, RespT> ApiCallContext configure(\n+        ApiCallContext context, ReqT request, MethodDescriptor<ReqT, RespT> method);\n+  }\n+\n+  private enum SpannerMethod {\n+    COMMIT {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getCommitMethod();\n+      }\n+    },\n+    ROLLBACK {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getRollbackMethod();\n+      }\n+    },\n+\n+    EXECUTE_QUERY {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        // This also matches with Partitioned DML calls, but that call will override any timeout\n+        // settings anyway.\n+        return method == SpannerGrpc.getExecuteStreamingSqlMethod();\n+      }\n+    },\n+    READ {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getStreamingReadMethod();\n+      }\n+    },\n+    EXECUTE_UPDATE {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        if (method == SpannerGrpc.getExecuteSqlMethod()) {\n+          ExecuteSqlRequest sqlRequest = (ExecuteSqlRequest) request;\n+          return sqlRequest.getSeqno() != 0L;\n+        }\n+        return false;\n+      }\n+    },\n+    BATCH_UPDATE {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getExecuteBatchDmlMethod();\n+      }\n+    },\n+\n+    PARTITION_QUERY {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getPartitionQueryMethod();\n+      }\n+    },\n+    PARTITION_READ {\n+      @Override\n+      <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+        return method == SpannerGrpc.getPartitionReadMethod();\n+      }\n+    };\n+\n+    abstract <ReqT, RespT> boolean isMethod(ReqT request, MethodDescriptor<ReqT, RespT> method);\n+\n+    static <ReqT, RespT> SpannerMethod valueOf(ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+      for (SpannerMethod m : SpannerMethod.values()) {\n+        if (m.isMethod(request, method)) {\n+          return m;\n+        }\n+      }\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Helper class to configure timeouts for specific Spanner RPCs. The {@link\n+   * SpannerCallContextTimeoutConfigurator} must be set as a value on the {@link Context} using the\n+   * {@link SpannerOptions#CALL_CONTEXT_CONFIGURATOR_KEY} key.\n+   *\n+   * <p>Example usage:\n+   *\n+   * <pre>{@code\n+   * // Create a context with a ExecuteQuery timeout of 10 seconds.\n+   * Context context =\n+   *     Context.current()\n+   *         .withValue(\n+   *             SpannerOptions.CALL_CONTEXT_CONFIGURATOR_KEY,\n+   *             SpannerCallContextTimeoutConfigurator.create()\n+   *                 .withExecuteQueryTimeout(Duration.ofSeconds(10L)));\n+   * context.run(\n+   *     new Runnable() {\n+   *       public void run() {\n+   *         try (ResultSet rs =\n+   *             client\n+   *                 .singleUse()\n+   *                 .executeQuery(\n+   *                     Statement.of(\n+   *                         \"SELECT SingerId, FirstName, LastName FROM Singers ORDER BY LastName\"))) {\n+   *           while (rs.next()) {\n+   *             System.out.printf(\"%d %s %s%n\", rs.getLong(0), rs.getString(1), rs.getString(2));\n+   *           }\n+   *         } catch (SpannerException e) {\n+   *           if (e.getErrorCode() == ErrorCode.DEADLINE_EXCEEDED) {\n+   *             // Handle timeout.\n+   *           }\n+   *         }\n+   *       }\n+   *     });\n+   * }</pre>\n+   */\n+  public static class SpannerCallContextTimeoutConfigurator implements CallContextConfigurator {\n+    private Duration commitTimeout;\n+    private Duration rollbackTimeout;\n+\n+    private Duration executeQueryTimeout;\n+    private Duration executeUpdateTimeout;\n+    private Duration batchUpdateTimeout;\n+    private Duration readTimeout;\n+\n+    private Duration partitionQueryTimeout;\n+    private Duration partitionReadTimeout;\n+\n+    public static SpannerCallContextTimeoutConfigurator create() {\n+      return new SpannerCallContextTimeoutConfigurator();\n+    }\n+\n+    private SpannerCallContextTimeoutConfigurator() {}\n+\n+    @Override\n+    public <ReqT, RespT> ApiCallContext configure(\n+        ApiCallContext context, ReqT request, MethodDescriptor<ReqT, RespT> method) {\n+      SpannerMethod spannerMethod = SpannerMethod.valueOf(request, method);\n+      if (spannerMethod == null) {\n+        return null;\n+      }\n+      switch (SpannerMethod.valueOf(request, method)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTMyOTI0MQ=="}, "originalCommit": {"oid": "4571e58a8a6b44fba75e86cb0e77ecf6e3fd2086"}, "originalPosition": 239}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3161, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}