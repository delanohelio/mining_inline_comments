{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2MjczNDY0", "number": 325, "title": "feat: inline begin transaction", "bodyText": "Description\nThe Spanner client library will normally prepare a fraction of the sessions in the session pool with a read/write transaction. These sessions are used when an application requests a read/write transaction. This eliminates the need for a BeginTransaction RPC to be executed as part of a transaction, as the call has already been executed in advance by the session pool.\nThis can however be less efficient in some specific cases:\n\nWhen the number of read/write transactions that are needed is higher than the number of transactions the session pool is able to prepare in advance.\nWhen the fraction of read/write transactions is higher than what has been configured by the user (the default is 0.2).\n\nCloud Spanner also supports starting a new transaction as part of a query or DML statement. This eliminates the need for a separate round-trip to the server for starting a transaction. This PR adds the possibility to instruct the Spanner client to start read/write transactions by including this option in the first query/update statement of a read/write transaction, instead of preparing the read/write transactions in the session pool. This can improve the overall read/write transaction execution performance.\nIncluding the BeginTransaction option with the first query or update statement of a transaction does require the client to block any other statement on the same transaction until the first statement has finished. This means that this strategy could perform less well in case of a read/write transaction that includes multiple parallel reads and/or writes.\nTechnical Implementation\nThe change in this PR is implemented along the following lines:\n\nRead/write transactions that use inline BeginTransaction will no longer take a write-prepared session from the pool. That is no longer needed, as the first statement on the transaction will include a BeginTransaction option.\nAll statements that are executed on a transaction will call the method getTransactionSelector(). This method will always return the selector to use for the statement. That selector will either be a BeginTransaction option if no transaction has yet been started, or a TransactionId if a transaction has been started.\nIf the method determines that a new transaction must be started, it creates a future that will hold the transaction id that will be returned.\nIf the method determines that there is no transaction id available yet, but another statement has already sent a BeginTransaction option, it will wait for the transaction id to be returned by calling get() on the transaction id future. (The statement cannot proceed, as there is no transaction id available yet, and only one statement should include a BeginTransaction option.)\nWhen the statement that included the BeginTransaction option finishes, it will call onTransactionMetadata(..). This will set the transactionId and transactionIdFuture and allow other statements to proceed.\nIf the statement that included the BeginTransaction option causes an error, it will call onError(..) and propagate the error to the calling method. The onError(..) method will set an Aborted error on the transactionIdFuture to propagate an Aborted error to any subsequent statement that might either be waiting for a transaction id to come available, or will request one later. This will ensure that if the first error is caught and handled by the transaction, the following statement will cause an Aborted error and cause the entire transaction to retry. See this test case for an example.", "createdAt": "2020-07-08T14:15:50Z", "url": "https://github.com/googleapis/java-spanner/pull/325", "merged": true, "mergeCommit": {"oid": "d08d3debb6457548bb6b04335b7a2d2227369211"}, "closed": true, "closedAt": "2020-10-23T00:39:52Z", "author": {"login": "olavloite"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc1g0M_gBqjM1NTM3NTc2MjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdUpRHBgH2gAyNDQ2MjczNDY0OjI4Mjc3ZmY4NWFhZTQ1NDYxNGViMTQ3MzNkYjk5ZmFiOGRiMWRjYmM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1308aec98b52dddf82ea520b84438b005978e98a", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/1308aec98b52dddf82ea520b84438b005978e98a", "committedDate": "2020-07-08T14:37:40Z", "message": "fix: invalid dml statement can still return tx id"}, "afterCommit": {"oid": "ec5b49e705bd40daed9953ded11d5a470da6fd16", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/ec5b49e705bd40daed9953ded11d5a470da6fd16", "committedDate": "2020-07-16T15:17:49Z", "message": "bench: add benchmarks for inline begin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fb15fee2dcf09f672c94b3d353924d64c6b42e9", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/9fb15fee2dcf09f672c94b3d353924d64c6b42e9", "committedDate": "2020-07-30T13:30:27Z", "message": "feat: inline begin tx with first statement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b8d9dc0e855f64ef4e145a4d469f70ada2917c4", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/6b8d9dc0e855f64ef4e145a4d469f70ada2917c4", "committedDate": "2020-07-30T13:30:27Z", "message": "feat: support inlining BeginTransaction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59ff2aa93a4ffebbfed78bc65fa6447220ff0b28", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/59ff2aa93a4ffebbfed78bc65fa6447220ff0b28", "committedDate": "2020-07-30T13:30:27Z", "message": "fix: invalid dml statement can still return tx id"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d4446f51dede347634b08d20a78ef9b790f0e05", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/4d4446f51dede347634b08d20a78ef9b790f0e05", "committedDate": "2020-07-30T13:30:27Z", "message": "bench: add benchmarks for inline begin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48a5db577dab88594dd7a823e86bdcfcf40ea75f", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/48a5db577dab88594dd7a823e86bdcfcf40ea75f", "committedDate": "2020-07-30T13:30:27Z", "message": "feat: add inline begin for async runner"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "261c9113f3408a627f5899fa808e619400bd41dc", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/261c9113f3408a627f5899fa808e619400bd41dc", "committedDate": "2020-07-30T13:30:27Z", "message": "test: add additional tests and ITs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af5066978406e106c72a113d2547f6b9309d12ad", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/af5066978406e106c72a113d2547f6b9309d12ad", "committedDate": "2020-07-30T14:27:38Z", "message": "test: add tests for error during tx"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "93b72f23306eb016759165e5e317dce97a14d40f", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/93b72f23306eb016759165e5e317dce97a14d40f", "committedDate": "2020-07-17T18:10:22Z", "message": "test: add additional tests and ITs"}, "afterCommit": {"oid": "af5066978406e106c72a113d2547f6b9309d12ad", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/af5066978406e106c72a113d2547f6b9309d12ad", "committedDate": "2020-07-30T14:27:38Z", "message": "test: add tests for error during tx"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f30334e839baaf556279e948bb632562627a6461", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/f30334e839baaf556279e948bb632562627a6461", "committedDate": "2020-07-30T14:43:58Z", "message": "test: use statement with same error code on emulator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4d2e767239e563af25be5f42a4922b5ef43d410", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/a4d2e767239e563af25be5f42a4922b5ef43d410", "committedDate": "2020-07-30T14:54:49Z", "message": "test: skip test on emulator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1817afade2005d3a3dbf61e25d096767b2ebfcb3", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/1817afade2005d3a3dbf61e25d096767b2ebfcb3", "committedDate": "2020-07-30T18:57:02Z", "message": "test: constraint error causes transaction to be invalidated"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61cc2072724f908d9eb21bc3cd9ea378d02e9d51", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/61cc2072724f908d9eb21bc3cd9ea378d02e9d51", "committedDate": "2020-07-31T13:50:40Z", "message": "fix: retry transaction if first statements fails and had BeginTransaction option"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bdff48168636bb1160416e8a635980320a338a6", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/3bdff48168636bb1160416e8a635980320a338a6", "committedDate": "2020-07-31T14:34:47Z", "message": "fix: handle aborted exceptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "057839f0e173580e9b2542308f71d58a0b19a513", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/057839f0e173580e9b2542308f71d58a0b19a513", "committedDate": "2020-09-16T08:24:57Z", "message": "Merge branch 'master' into inline-begin-tx"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3148a080e32e9b27c35c056638df865fa13497f", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/b3148a080e32e9b27c35c056638df865fa13497f", "committedDate": "2020-09-16T09:19:13Z", "message": "test: add additional tests for corner cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f508bdb182d0694021864ccd0107c9572039e36f", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/f508bdb182d0694021864ccd0107c9572039e36f", "committedDate": "2020-09-16T15:34:26Z", "message": "feat: use single-use tx for idem-potent mutations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9e938fb9fc73a44e22e423e90b3ded6ba66148a", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/d9e938fb9fc73a44e22e423e90b3ded6ba66148a", "committedDate": "2020-09-17T14:54:38Z", "message": "fix: remove check for idempotent mutations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a28f6122f3576b09da87f4731cb198c250b7106", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/8a28f6122f3576b09da87f4731cb198c250b7106", "committedDate": "2020-09-28T08:24:20Z", "message": "Merge branch 'master' into inline-begin-tx"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bec71d71961701fc1304f9121e9d9b7cae2393d9", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/bec71d71961701fc1304f9121e9d9b7cae2393d9", "committedDate": "2020-10-05T08:09:53Z", "message": "Merge branch 'master' into inline-begin-tx"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzMTA5NTk3", "url": "https://github.com/googleapis/java-spanner/pull/325#pullrequestreview-503109597", "createdAt": "2020-10-06T15:45:37Z", "commit": {"oid": "bec71d71961701fc1304f9121e9d9b7cae2393d9"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNTo0NTozN1rOHdOVYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNTo0NzoxMlrOHdOZ7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwNTYwMg==", "bodyText": "This is moved to the createTxnAsync method to be re-usable.", "url": "https://github.com/googleapis/java-spanner/pull/325#discussion_r500405602", "createdAt": "2020-10-06T15:45:37Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/TransactionRunnerImpl.java", "diffHunk": "@@ -190,36 +198,7 @@ void ensureTxn() {\n     ApiFuture<Void> ensureTxnAsync() {\n       final SettableApiFuture<Void> res = SettableApiFuture.create();\n       if (transactionId == null || isAborted()) {\n-        span.addAnnotation(\"Creating Transaction\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec71d71961701fc1304f9121e9d9b7cae2393d9"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwNjc2Nw==", "bodyText": "This block of code is moved to CommitRunnable", "url": "https://github.com/googleapis/java-spanner/pull/325#discussion_r500406767", "createdAt": "2020-10-06T15:47:12Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/TransactionRunnerImpl.java", "diffHunk": "@@ -246,87 +258,103 @@ void commit() {\n \n     ApiFuture<Timestamp> commitAsync() {\n       final SettableApiFuture<Timestamp> res = SettableApiFuture.create();\n-      final SettableApiFuture<Void> latch;\n+      final SettableApiFuture<Void> finishOps;\n+      CommitRequest.Builder builder = CommitRequest.newBuilder().setSession(session.getName());\n       synchronized (lock) {\n-        latch = finishedAsyncOperations;\n+        if (transactionIdFuture == null && transactionId == null) {\n+          finishOps = SettableApiFuture.create();\n+          createTxnAsync(finishOps);\n+        } else {\n+          finishOps = finishedAsyncOperations;\n+        }\n+        if (!mutations.isEmpty()) {\n+          List<com.google.spanner.v1.Mutation> mutationsProto = new ArrayList<>();\n+          Mutation.toProto(mutations, mutationsProto);\n+          builder.addAllMutations(mutationsProto);\n+        }\n+        // Ensure that no call to buffer mutations that would be lost can succeed.\n+        mutations = null;\n       }\n-      latch.addListener(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec71d71961701fc1304f9121e9d9b7cae2393d9"}, "originalPosition": 134}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07346f02e1974a6800144c7ec03b24a61ed429bd", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/07346f02e1974a6800144c7ec03b24a61ed429bd", "committedDate": "2020-10-06T15:55:53Z", "message": "chore: remove commented code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MzU0MjI3", "url": "https://github.com/googleapis/java-spanner/pull/325#pullrequestreview-505354227", "createdAt": "2020-10-09T04:21:30Z", "commit": {"oid": "07346f02e1974a6800144c7ec03b24a61ed429bd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2768f69db13c155bbe3ee24b3440c0f3d2b67b67", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/2768f69db13c155bbe3ee24b3440c0f3d2b67b67", "committedDate": "2020-10-21T06:03:39Z", "message": "feat!: remove session pool preparing (#515)\n\n* feat: remove session pool preparing\r\n\r\n* fix: fix integration tests\r\n\r\n* test: fix malformed retry loop in test case\r\n\r\n* fix: review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b816a6647106da2e346e3efaae4ab6dcc8d84740", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/b816a6647106da2e346e3efaae4ab6dcc8d84740", "committedDate": "2020-10-21T07:36:46Z", "message": "Merge branch 'master' into inline-begin-tx"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMzg3OTUy", "url": "https://github.com/googleapis/java-spanner/pull/325#pullrequestreview-513387952", "createdAt": "2020-10-21T07:39:16Z", "commit": {"oid": "b816a6647106da2e346e3efaae4ab6dcc8d84740"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzozOToxN1rOHleSCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzozOToxN1rOHleSDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1NTQ5Ng==", "bodyText": "Suggested change", "url": "https://github.com/googleapis/java-spanner/pull/325#discussion_r509055496", "createdAt": "2020-10-21T07:39:17Z", "author": {"login": "yoshi-code-bot"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/TransactionRunnerImpl.java", "diffHunk": "@@ -150,7 +151,15 @@ public void removeListener(Runnable listener) {\n     @GuardedBy(\"lock\")\n     private long retryDelayInMillis = -1L;\n \n-    private volatile ByteString transactionId;\n+    /**\n+     * transactionIdFuture will return the transaction id returned by the first statement in the\n+     * transaction if the BeginTransaction option is included with the first statement of the\n+     * transaction.\n+     */\n+    private volatile SettableApiFuture<ByteString> transactionIdFuture = null;\n+\n+    volatile ByteString transactionId;\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b816a6647106da2e346e3efaae4ab6dcc8d84740"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1NTQ5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // The first PartialResultSet will be returned successfully, and then a DATA_LOSS exception will be returned.\n          \n          \n            \n                mockSpanner.setExecuteStreamingSqlExecutionTime(\n          \n          \n            \n                    SimulatedExecutionTime.ofStreamException(\n          \n          \n            \n                // The first PartialResultSet will be returned successfully, and then a DATA_LOSS exception will\n          \n          \n            \n                // be returned.\n          \n          \n            \n                    SimulatedExecutionTime.ofStreamException(Status.DATA_LOSS.asRuntimeException(), 1));", "url": "https://github.com/googleapis/java-spanner/pull/325#discussion_r509055499", "createdAt": "2020-10-21T07:39:17Z", "author": {"login": "yoshi-code-bot"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/InlineBeginTransactionTest.java", "diffHunk": "@@ -0,0 +1,1155 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n+\n+import com.google.api.core.ApiAsyncFunction;\n+import com.google.api.core.ApiFuture;\n+import com.google.api.core.ApiFutures;\n+import com.google.api.core.SettableApiFuture;\n+import com.google.api.gax.grpc.testing.LocalChannelProvider;\n+import com.google.cloud.NoCredentials;\n+import com.google.cloud.spanner.AsyncResultSet.CallbackResponse;\n+import com.google.cloud.spanner.AsyncResultSet.ReadyCallback;\n+import com.google.cloud.spanner.AsyncRunner.AsyncWork;\n+import com.google.cloud.spanner.AsyncTransactionManager.AsyncTransactionFunction;\n+import com.google.cloud.spanner.AsyncTransactionManager.AsyncTransactionStep;\n+import com.google.cloud.spanner.AsyncTransactionManager.CommitTimestampFuture;\n+import com.google.cloud.spanner.AsyncTransactionManager.TransactionContextFuture;\n+import com.google.cloud.spanner.MockSpannerServiceImpl.SimulatedExecutionTime;\n+import com.google.cloud.spanner.MockSpannerServiceImpl.StatementResult;\n+import com.google.cloud.spanner.TransactionRunner.TransactionCallable;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.protobuf.AbstractMessage;\n+import com.google.protobuf.ListValue;\n+import com.google.spanner.v1.BeginTransactionRequest;\n+import com.google.spanner.v1.CommitRequest;\n+import com.google.spanner.v1.ExecuteBatchDmlRequest;\n+import com.google.spanner.v1.ExecuteSqlRequest;\n+import com.google.spanner.v1.ReadRequest;\n+import com.google.spanner.v1.ResultSetMetadata;\n+import com.google.spanner.v1.RollbackRequest;\n+import com.google.spanner.v1.StructType;\n+import com.google.spanner.v1.StructType.Field;\n+import com.google.spanner.v1.TypeCode;\n+import io.grpc.Server;\n+import io.grpc.Status;\n+import io.grpc.inprocess.InProcessServerBuilder;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class InlineBeginTransactionTest {\n+  @Parameter public Executor executor;\n+\n+  @Parameters(name = \"executor = {0}\")\n+  public static Collection<Object[]> data() {\n+    return Arrays.asList(\n+        new Object[][] {\n+          {MoreExecutors.directExecutor()},\n+          {Executors.newSingleThreadExecutor()},\n+          {Executors.newFixedThreadPool(4)}\n+        });\n+  }\n+\n+  private static MockSpannerServiceImpl mockSpanner;\n+  private static Server server;\n+  private static LocalChannelProvider channelProvider;\n+  private static final Statement UPDATE_STATEMENT =\n+      Statement.of(\"UPDATE FOO SET BAR=1 WHERE BAZ=2\");\n+  private static final Statement INVALID_UPDATE_STATEMENT =\n+      Statement.of(\"UPDATE NON_EXISTENT_TABLE SET BAR=1 WHERE BAZ=2\");\n+  private static final long UPDATE_COUNT = 1L;\n+  private static final Statement SELECT1 = Statement.of(\"SELECT 1 AS COL1\");\n+  private static final ResultSetMetadata SELECT1_METADATA =\n+      ResultSetMetadata.newBuilder()\n+          .setRowType(\n+              StructType.newBuilder()\n+                  .addFields(\n+                      Field.newBuilder()\n+                          .setName(\"COL1\")\n+                          .setType(\n+                              com.google.spanner.v1.Type.newBuilder()\n+                                  .setCode(TypeCode.INT64)\n+                                  .build())\n+                          .build())\n+                  .build())\n+          .build();\n+  private static final com.google.spanner.v1.ResultSet SELECT1_RESULTSET =\n+      com.google.spanner.v1.ResultSet.newBuilder()\n+          .addRows(\n+              ListValue.newBuilder()\n+                  .addValues(com.google.protobuf.Value.newBuilder().setStringValue(\"1\").build())\n+                  .build())\n+          .setMetadata(SELECT1_METADATA)\n+          .build();\n+  private static final Statement INVALID_SELECT = Statement.of(\"SELECT * FROM NON_EXISTING_TABLE\");\n+  private static final Statement READ_STATEMENT = Statement.of(\"SELECT ID FROM FOO WHERE 1=1\");\n+\n+  private Spanner spanner;\n+\n+  @BeforeClass\n+  public static void startStaticServer() throws IOException {\n+    mockSpanner = new MockSpannerServiceImpl();\n+    mockSpanner.setAbortProbability(0.0D); // We don't want any unpredictable aborted transactions.\n+    mockSpanner.putStatementResult(StatementResult.update(UPDATE_STATEMENT, UPDATE_COUNT));\n+    mockSpanner.putStatementResult(StatementResult.query(SELECT1, SELECT1_RESULTSET));\n+    mockSpanner.putStatementResult(StatementResult.query(READ_STATEMENT, SELECT1_RESULTSET));\n+    mockSpanner.putStatementResult(\n+        StatementResult.exception(\n+            INVALID_UPDATE_STATEMENT,\n+            Status.INVALID_ARGUMENT\n+                .withDescription(\"invalid update statement\")\n+                .asRuntimeException()));\n+    mockSpanner.putStatementResult(\n+        StatementResult.exception(\n+            INVALID_SELECT,\n+            Status.INVALID_ARGUMENT\n+                .withDescription(\"invalid select statement\")\n+                .asRuntimeException()));\n+\n+    String uniqueName = InProcessServerBuilder.generateName();\n+    server =\n+        InProcessServerBuilder.forName(uniqueName)\n+            // We need to use a real executor for timeouts to occur.\n+            .scheduledExecutorService(new ScheduledThreadPoolExecutor(1))\n+            .addService(mockSpanner)\n+            .build()\n+            .start();\n+    channelProvider = LocalChannelProvider.create(uniqueName);\n+  }\n+\n+  @AfterClass\n+  public static void stopServer() throws InterruptedException {\n+    server.shutdown();\n+    server.awaitTermination();\n+  }\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    mockSpanner.reset();\n+    mockSpanner.removeAllExecutionTimes();\n+    // Create a Spanner instance that will inline BeginTransaction calls. It also has no prepared\n+    // sessions in the pool to prevent session preparing from interfering with test cases.\n+    spanner =\n+        SpannerOptions.newBuilder()\n+            .setProjectId(\"[PROJECT]\")\n+            .setChannelProvider(channelProvider)\n+            .setCredentials(NoCredentials.getInstance())\n+            .build()\n+            .getService();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    spanner.close();\n+    mockSpanner.reset();\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTx() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    return transaction.executeUpdate(UPDATE_STATEMENT);\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(UPDATE_COUNT);\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxAborted() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    final AtomicBoolean firstAttempt = new AtomicBoolean(true);\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    long res = transaction.executeUpdate(UPDATE_STATEMENT);\n+                    if (firstAttempt.getAndSet(false)) {\n+                      mockSpanner.abortTransaction(transaction);\n+                    }\n+                    return res;\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(UPDATE_COUNT);\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(2);\n+    // We have started 2 transactions, because the first transaction aborted during the commit.\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(2);\n+    assertThat(countTransactionsStarted()).isEqualTo(2);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithQuery() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    try (ResultSet rs = transaction.executeQuery(SELECT1)) {\n+                      while (rs.next()) {\n+                        return rs.getLong(0);\n+                      }\n+                    }\n+                    return 0L;\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(1L);\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithRead() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    try (ResultSet rs =\n+                        transaction.read(\"FOO\", KeySet.all(), Arrays.asList(\"ID\"))) {\n+                      while (rs.next()) {\n+                        return rs.getLong(0);\n+                      }\n+                    }\n+                    return 0L;\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(1L);\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ReadRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithBatchDml() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long[] updateCounts =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<long[]>() {\n+                  @Override\n+                  public long[] run(TransactionContext transaction) throws Exception {\n+                    return transaction.batchUpdate(\n+                        Arrays.asList(UPDATE_STATEMENT, UPDATE_STATEMENT));\n+                  }\n+                });\n+    assertThat(updateCounts).asList().containsExactly(UPDATE_COUNT, UPDATE_COUNT);\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteBatchDmlRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithError() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    try {\n+                      transaction.executeUpdate(INVALID_UPDATE_STATEMENT);\n+                      fail(\"missing expected exception\");\n+                    } catch (SpannerException e) {\n+                      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+                    }\n+                    return transaction.executeUpdate(UPDATE_STATEMENT);\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(UPDATE_COUNT);\n+    // The transaction will be retried because the first statement that also tried to include the\n+    // BeginTransaction statement failed and did not return a transaction. That forces a retry of\n+    // the entire transaction with an explicit BeginTransaction RPC.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(1);\n+    // The update statement will be executed 3 times:\n+    // 1. The invalid update statement will be executed during the first attempt and fail. The\n+    // second update statement will not be executed, as the transaction runner sees that the initial\n+    // statement failed and did not return a valid transaction id.\n+    // 2. The invalid update statement is executed again during the retry.\n+    // 3. The valid update statement is only executed after the first statement succeeded.\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(3);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    // The first update will start a transaction, but then fail the update statement. This will\n+    // start a transaction on the mock server, but that transaction will never be returned to the\n+    // client.\n+    assertThat(countTransactionsStarted()).isEqualTo(2);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithErrorOnFirstStatement_andThenErrorOnBeginTransaction() {\n+    mockSpanner.setBeginTransactionExecutionTime(\n+        SimulatedExecutionTime.ofException(\n+            Status.INTERNAL\n+                .withDescription(\"Begin transaction failed due to an internal error\")\n+                .asRuntimeException()));\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    try {\n+      client\n+          .readWriteTransaction()\n+          .run(\n+              new TransactionCallable<Void>() {\n+                @Override\n+                public Void run(TransactionContext transaction) throws Exception {\n+                  try {\n+                    transaction.executeUpdate(INVALID_UPDATE_STATEMENT);\n+                    fail(\"missing expected exception\");\n+                  } catch (SpannerException e) {\n+                    assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+                  }\n+                  return null;\n+                }\n+              });\n+      fail(\"Missing expected exception\");\n+    } catch (SpannerException e) {\n+      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INTERNAL);\n+      assertThat(e.getMessage()).contains(\"Begin transaction failed due to an internal error\");\n+    }\n+    // The transaction will be retried because the first statement that also tried to include the\n+    // BeginTransaction statement failed and did not return a transaction. That forces a retry of\n+    // the entire transaction with an explicit BeginTransaction RPC.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(0);\n+    // The explicit BeginTransaction RPC failed, so only one transaction was started.\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithUncaughtError() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    try {\n+      client\n+          .readWriteTransaction()\n+          .run(\n+              new TransactionCallable<Long>() {\n+                @Override\n+                public Long run(TransactionContext transaction) throws Exception {\n+                  return transaction.executeUpdate(INVALID_UPDATE_STATEMENT);\n+                }\n+              });\n+      fail(\"missing expected exception\");\n+    } catch (SpannerException e) {\n+      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+    }\n+    // The first update will start a transaction, but then fail the update statement. This will\n+    // start a transaction on the mock server, but that transaction will never be returned to the\n+    // client.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(1);\n+    // No rollback request will be initiated because the client does not receive any transaction id.\n+    assertThat(countRequests(RollbackRequest.class)).isEqualTo(0);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithUncaughtErrorAfterSuccessfulBegin() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    try {\n+      client\n+          .readWriteTransaction()\n+          .run(\n+              new TransactionCallable<Long>() {\n+                @Override\n+                public Long run(TransactionContext transaction) throws Exception {\n+                  // This statement will start a transaction.\n+                  transaction.executeUpdate(UPDATE_STATEMENT);\n+                  // This statement will fail and cause a rollback as the exception is not caught.\n+                  return transaction.executeUpdate(INVALID_UPDATE_STATEMENT);\n+                }\n+              });\n+      fail(\"missing expected exception\");\n+    } catch (SpannerException e) {\n+      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+    }\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(2);\n+    assertThat(countRequests(RollbackRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxBatchDmlWithErrorOnFirstStatement() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    Void res =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Void>() {\n+                  @Override\n+                  public Void run(TransactionContext transaction) throws Exception {\n+                    try {\n+                      transaction.batchUpdate(\n+                          ImmutableList.of(INVALID_UPDATE_STATEMENT, UPDATE_STATEMENT));\n+                      fail(\"missing expected exception\");\n+                    } catch (SpannerBatchUpdateException e) {\n+                      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+                      assertThat(e.getUpdateCounts()).hasLength(0);\n+                    }\n+                    return null;\n+                  }\n+                });\n+    assertThat(res).isNull();\n+    // The first statement failed and could not return a transaction. The entire transaction is\n+    // therefore retried with an explicit BeginTransaction RPC.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(ExecuteBatchDmlRequest.class)).isEqualTo(2);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(2);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxBatchDmlWithErrorOnSecondStatement() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    long updateCount =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Long>() {\n+                  @Override\n+                  public Long run(TransactionContext transaction) throws Exception {\n+                    try {\n+                      transaction.batchUpdate(\n+                          ImmutableList.of(UPDATE_STATEMENT, INVALID_UPDATE_STATEMENT));\n+                      fail(\"missing expected exception\");\n+                      // The following line is needed as the compiler does not know that this is\n+                      // unreachable.\n+                      return -1L;\n+                    } catch (SpannerBatchUpdateException e) {\n+                      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+                      assertThat(e.getUpdateCounts()).hasLength(1);\n+                      return e.getUpdateCounts()[0];\n+                    }\n+                  }\n+                });\n+    assertThat(updateCount).isEqualTo(UPDATE_COUNT);\n+    // Although the batch DML returned an error, that error was for the second statement. That means\n+    // that the transaction was started by the first statement.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(0);\n+    assertThat(countRequests(ExecuteBatchDmlRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    assertThat(countTransactionsStarted()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithErrorOnStreamingSql() {\n+    DatabaseClient client =\n+        spanner.getDatabaseClient(DatabaseId.of(\"[PROJECT]\", \"[INSTANCE]\", \"[DATABASE]\"));\n+    Void res =\n+        client\n+            .readWriteTransaction()\n+            .run(\n+                new TransactionCallable<Void>() {\n+                  @Override\n+                  public Void run(TransactionContext transaction) throws Exception {\n+                    try (ResultSet rs = transaction.executeQuery(INVALID_SELECT)) {\n+                      while (rs.next()) {}\n+                      fail(\"missing expected exception\");\n+                    } catch (SpannerException e) {\n+                      assertThat(e.getErrorCode()).isEqualTo(ErrorCode.INVALID_ARGUMENT);\n+                    }\n+                    return null;\n+                  }\n+                });\n+    assertThat(res).isNull();\n+    // The transaction will be retried because the first statement that also tried to include the\n+    // BeginTransaction statement failed and did not return a transaction. That forces a retry of\n+    // the entire transaction with an explicit BeginTransaction RPC.\n+    assertThat(countRequests(BeginTransactionRequest.class)).isEqualTo(1);\n+    assertThat(countRequests(ExecuteSqlRequest.class)).isEqualTo(2);\n+    assertThat(countRequests(CommitRequest.class)).isEqualTo(1);\n+    // The first update will start a transaction, but then fail the update statement. This will\n+    // start a transaction on the mock server, but that transaction will never be returned to the\n+    // client.\n+    assertThat(countTransactionsStarted()).isEqualTo(2);\n+  }\n+\n+  @Test\n+  public void testInlinedBeginTxWithErrorOnSecondPartialResultSet() {\n+    final Statement statement = Statement.of(\"SELECT * FROM BROKEN_TABLE\");\n+    RandomResultSetGenerator generator = new RandomResultSetGenerator(2);\n+    mockSpanner.putStatementResult(StatementResult.query(statement, generator.generate()));\n+    // The first PartialResultSet will be returned successfully, and then a DATA_LOSS exception will be returned.\n+    mockSpanner.setExecuteStreamingSqlExecutionTime(\n+        SimulatedExecutionTime.ofStreamException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b816a6647106da2e346e3efaae4ab6dcc8d84740"}, "originalPosition": 551}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1NTUwMg==", "bodyText": "Suggested change", "url": "https://github.com/googleapis/java-spanner/pull/325#discussion_r509055502", "createdAt": "2020-10-21T07:39:17Z", "author": {"login": "yoshi-code-bot"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/MockSpannerServiceImpl.java", "diffHunk": "@@ -1917,6 +1917,10 @@ public void waitForLastRequestToBe(Class<? extends AbstractMessage> type, long t\n     }\n   }\n \n+  public List<ByteString> getTransactionsStarted() {\n+    return new ArrayList<>(transactionsStarted);\n+  }\n+  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b816a6647106da2e346e3efaae4ab6dcc8d84740"}, "originalPosition": 84}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24ea415052e4af5d258bfdac4eed50a541818cc9", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/24ea415052e4af5d258bfdac4eed50a541818cc9", "committedDate": "2020-10-21T07:43:41Z", "message": "chore: run formatter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28277ff85aae454614eb14733db99fab8db1dcbc", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/28277ff85aae454614eb14733db99fab8db1dcbc", "committedDate": "2020-10-21T08:40:31Z", "message": "test: fix integration test that relied on data from other test case"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 794, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}