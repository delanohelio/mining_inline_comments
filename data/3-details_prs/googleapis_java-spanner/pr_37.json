{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzNDk2MzEz", "number": 37, "title": "test: [WIP] add Commit Timestamp java integration tests for cloud spanner", "bodyText": "Adds java integration tests which test the cloud spanner functionality around commit timestamps that are written atomically as part of a transaction.", "createdAt": "2020-01-16T07:25:32Z", "url": "https://github.com/googleapis/java-spanner/pull/37", "merged": true, "mergeCommit": {"oid": "5a4fc749d20fe8719a3fc6524fc1456b6dacf649"}, "closed": true, "closedAt": "2020-01-23T04:49:40Z", "author": {"login": "agasheesh"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb61AOWgBqjI5NTM0NTU3OTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb8xBsZgFqTM0NjM5NzAzNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1cdc69610b838a9627ea4c09c1c2a2cedc57d2c3", "author": {"user": {"login": "agasheesh", "name": "Asheesh Agrawal"}}, "url": "https://github.com/googleapis/java-spanner/commit/1cdc69610b838a9627ea4c09c1c2a2cedc57d2c3", "committedDate": "2020-01-16T07:23:55Z", "message": "Add Commit Timestamp java integration tests for cloud spanner"}, "afterCommit": {"oid": "ec3d74aeae9bbbb68ba6d71e21bd7103762f04c7", "author": {"user": {"login": "agasheesh", "name": "Asheesh Agrawal"}}, "url": "https://github.com/googleapis/java-spanner/commit/ec3d74aeae9bbbb68ba6d71e21bd7103762f04c7", "committedDate": "2020-01-16T07:26:56Z", "message": "test: add Commit Timestamp java integration tests for cloud spanner"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "618e3342ffa67784cd5946157689d4890bc286cb", "author": {"user": {"login": "agasheesh", "name": "Asheesh Agrawal"}}, "url": "https://github.com/googleapis/java-spanner/commit/618e3342ffa67784cd5946157689d4890bc286cb", "committedDate": "2020-01-16T07:34:26Z", "message": "test: add license header to commit timestamp java integration tests"}, "afterCommit": {"oid": "a58652628192f91c5749658925568de9afd15438", "author": {"user": {"login": "agasheesh", "name": "Asheesh Agrawal"}}, "url": "https://github.com/googleapis/java-spanner/commit/a58652628192f91c5749658925568de9afd15438", "committedDate": "2020-01-16T08:06:28Z", "message": "test: add Commit Timestamp java integration tests for cloud spanner"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzOTMzOTA4", "url": "https://github.com/googleapis/java-spanner/pull/37#pullrequestreview-343933908", "createdAt": "2020-01-16T14:05:04Z", "commit": {"oid": "a58652628192f91c5749658925568de9afd15438"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNDowNTowNFrOFeaaAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQxNDoyMjowNVrOFea9JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzNDI0Mw==", "bodyText": "Could we also add an assertion that the commit timestamp returned by the write(...) method is equal to the commit timestamp written to these columns?", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r367434243", "createdAt": "2020-01-16T14:05:04Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/it/ITCommitTimestampTest.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Copyright 2017 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.it;\n+\n+import static com.google.cloud.spanner.SpannerMatchers.isSpannerException;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Database;\n+import com.google.cloud.spanner.DatabaseAdminClient;\n+import com.google.cloud.spanner.DatabaseClient;\n+import com.google.cloud.spanner.ErrorCode;\n+import com.google.cloud.spanner.IntegrationTest;\n+import com.google.cloud.spanner.IntegrationTestEnv;\n+import com.google.cloud.spanner.Key;\n+import com.google.cloud.spanner.Mutation;\n+import com.google.cloud.spanner.SpannerExceptionFactory;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.TimestampBound;\n+import com.google.cloud.spanner.Value;\n+import com.google.cloud.spanner.testing.RemoteSpannerHelper;\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.concurrent.ExecutionException;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Integration test for commit timestamp of Cloud Spanner. */\n+@Category(IntegrationTest.class)\n+@RunWith(JUnit4.class)\n+public class ITCommitTimestampTest {\n+  @ClassRule public static IntegrationTestEnv env = new IntegrationTestEnv();\n+  @Rule public final ExpectedException expectedException = ExpectedException.none();\n+  private Database db;\n+  private DatabaseClient client;\n+  private DatabaseAdminClient dbAdminClient;\n+  private RemoteSpannerHelper testHelper;\n+  private String instanceId;\n+  private String databaseId;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    testHelper = env.getTestHelper();\n+    db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T (\"\n+                + \"K  STRING(MAX) NOT NULL,\"\n+                + \"T1   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T2   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T3   TIMESTAMP,\"\n+                + \") PRIMARY KEY (K)\");\n+    client = testHelper.getDatabaseClient(db);\n+    dbAdminClient = testHelper.getClient().getDatabaseAdminClient();\n+    instanceId = testHelper.getInstanceId().getInstance();\n+    databaseId = db.getId().getDatabase();\n+  }\n+\n+  private Timestamp write(Mutation m) {\n+    return client.write(Arrays.asList(m));\n+  }\n+\n+  private Struct readRow(DatabaseClient client, String table, Key key, String... columns) {\n+    return client.singleUse(TimestampBound.strong()).readRow(table, key, Arrays.asList(columns));\n+  }\n+\n+  @Test\n+  public void writeCommitTimestamp() {\n+    // 1. timestamps auto populated and returned should be the same\n+    Timestamp commitTimestamp =\n+        write(\n+            Mutation.newInsertOrUpdateBuilder(\"T\")\n+                .set(\"K\")\n+                .to(\"a\")\n+                .set(\"T1\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .set(\"T2\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .build());\n+    Struct row = readRow(client, \"T\", Key.of(\"a\"), \"T1\", \"T2\");\n+    assertThat(row.getTimestamp(0)).isEqualTo(commitTimestamp);\n+    assertThat(row.getTimestamp(1)).isEqualTo(commitTimestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58652628192f91c5749658925568de9afd15438"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzOTE4NQ==", "bodyText": "I would prefer these comments in Javadoc style and placed before the @Test annotation, i.e.:\n/**\n * 1) Write timestamps in the past\n * 2) ...\n*/\n@Test\npublic void interleavedTable() throws Exception {", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r367439185", "createdAt": "2020-01-16T14:14:36Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/it/ITCommitTimestampTest.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Copyright 2017 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.it;\n+\n+import static com.google.cloud.spanner.SpannerMatchers.isSpannerException;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Database;\n+import com.google.cloud.spanner.DatabaseAdminClient;\n+import com.google.cloud.spanner.DatabaseClient;\n+import com.google.cloud.spanner.ErrorCode;\n+import com.google.cloud.spanner.IntegrationTest;\n+import com.google.cloud.spanner.IntegrationTestEnv;\n+import com.google.cloud.spanner.Key;\n+import com.google.cloud.spanner.Mutation;\n+import com.google.cloud.spanner.SpannerExceptionFactory;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.TimestampBound;\n+import com.google.cloud.spanner.Value;\n+import com.google.cloud.spanner.testing.RemoteSpannerHelper;\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.concurrent.ExecutionException;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Integration test for commit timestamp of Cloud Spanner. */\n+@Category(IntegrationTest.class)\n+@RunWith(JUnit4.class)\n+public class ITCommitTimestampTest {\n+  @ClassRule public static IntegrationTestEnv env = new IntegrationTestEnv();\n+  @Rule public final ExpectedException expectedException = ExpectedException.none();\n+  private Database db;\n+  private DatabaseClient client;\n+  private DatabaseAdminClient dbAdminClient;\n+  private RemoteSpannerHelper testHelper;\n+  private String instanceId;\n+  private String databaseId;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    testHelper = env.getTestHelper();\n+    db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T (\"\n+                + \"K  STRING(MAX) NOT NULL,\"\n+                + \"T1   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T2   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T3   TIMESTAMP,\"\n+                + \") PRIMARY KEY (K)\");\n+    client = testHelper.getDatabaseClient(db);\n+    dbAdminClient = testHelper.getClient().getDatabaseAdminClient();\n+    instanceId = testHelper.getInstanceId().getInstance();\n+    databaseId = db.getId().getDatabase();\n+  }\n+\n+  private Timestamp write(Mutation m) {\n+    return client.write(Arrays.asList(m));\n+  }\n+\n+  private Struct readRow(DatabaseClient client, String table, Key key, String... columns) {\n+    return client.singleUse(TimestampBound.strong()).readRow(table, key, Arrays.asList(columns));\n+  }\n+\n+  @Test\n+  public void writeCommitTimestamp() {\n+    // 1. timestamps auto populated and returned should be the same\n+    Timestamp commitTimestamp =\n+        write(\n+            Mutation.newInsertOrUpdateBuilder(\"T\")\n+                .set(\"K\")\n+                .to(\"a\")\n+                .set(\"T1\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .set(\"T2\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .build());\n+    Struct row = readRow(client, \"T\", Key.of(\"a\"), \"T1\", \"T2\");\n+    assertThat(row.getTimestamp(0)).isEqualTo(commitTimestamp);\n+    assertThat(row.getTimestamp(1)).isEqualTo(commitTimestamp);\n+\n+    // 2. attempt to write CommitTimestamp to not enabled column should fail\n+    // error_catalog error CommitTimestampOptionNotEnabled\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"allow_commit_timestamp column option is not\");\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T3\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+  }\n+\n+  @Test\n+  public void consistency() {\n+    // 1. timestamps populated are consistent in order\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T1\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"b\")\n+            .set(\"T1\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+    Struct row1 = readRow(client, \"T\", Key.of(\"a\"), \"T1\");\n+    Struct row2 = readRow(client, \"T\", Key.of(\"b\"), \"T1\");\n+    assertThat(row2.getTimestamp(0)).isGreaterThan(row1.getTimestamp(0));\n+  }\n+\n+  @Test\n+  public void schemaChangeTimestampInFuture() throws Exception {\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T3\")\n+            .to(Timestamp.MAX_VALUE)\n+            .build());\n+\n+    // error_catalog error CommitTimestampNotInFuture\n+    expectedException.expectCause(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"has a timestamp in the future at key\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (allow_commit_timestamp=true)\";\n+    try {\n+      dbAdminClient\n+          .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+          .get();\n+    } catch (ExecutionException e) {\n+      throw SpannerExceptionFactory.newSpannerException(e.getCause());\n+    }\n+  }\n+\n+  @Test\n+  public void insertTimestampInFuture() {\n+    // error_catalog error TimestampInFuture\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"in the future\");\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T1\")\n+            .to(Timestamp.MAX_VALUE)\n+            .build());\n+  }\n+\n+  @Test\n+  public void invalidColumnOption() throws Exception {\n+    // error_catalog error DDLStatementWithError\n+    expectedException.expectCause(isSpannerException(ErrorCode.INVALID_ARGUMENT));\n+    expectedException.expectMessage(\"Option: bogus is unknown.\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (bogus=null)\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  @Test\n+  public void invalidColumnOptionValue() throws Exception {\n+    // error_catalog error DDLStatementWithErrors\n+    expectedException.expectCause(isSpannerException(ErrorCode.INVALID_ARGUMENT));\n+    expectedException.expectMessage(\"Errors parsing Spanner DDL statement\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (allow_commit_timestamp=bogus)\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  @Test\n+  public void invalidColumnType() throws Exception {\n+    // error_catalog error OptionErrorList\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"Option only allowed on TIMESTAMP columns\");\n+    String statement = \"ALTER TABLE T ADD COLUMN T4 INT64 OPTIONS (allow_commit_timestamp=true)\";\n+    try {\n+      dbAdminClient\n+          .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+          .get();\n+    } catch (ExecutionException e) {\n+      throw SpannerExceptionFactory.newSpannerException(e.getCause());\n+    }\n+  }\n+\n+  private void alterColumnOption(String databaseId, String table, String opt) throws Exception {\n+    String statement =\n+        \"ALTER TABLE \"\n+            + table\n+            + \" ALTER COLUMN ts\"\n+            + \" SET OPTIONS (allow_commit_timestamp=\"\n+            + opt\n+            + \")\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  private void writeAndVerify(DatabaseClient client, Timestamp ts) {\n+    Timestamp commitTimestamp =\n+        client.write(\n+            Arrays.asList(\n+                Mutation.newInsertOrUpdateBuilder(\"T1\").set(\"ts\").to(ts).build(),\n+                Mutation.newInsertOrUpdateBuilder(\"T2\").set(\"ts\").to(ts).build(),\n+                Mutation.newInsertOrUpdateBuilder(\"T3\").set(\"ts\").to(ts).build()));\n+    if (ts == Value.COMMIT_TIMESTAMP) {\n+      ts = commitTimestamp;\n+    }\n+    assertThat(readRow(client, \"T1\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+    assertThat(readRow(client, \"T2\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+    assertThat(readRow(client, \"T3\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+  }\n+\n+  @Test\n+  // 1) Write timestamps in the past", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58652628192f91c5749658925568de9afd15438"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0MDQ5MA==", "bodyText": "Using TimeUnit.MICROSECONDS.convert(Instant.now().toEpochMilli(), TimeUnit.MILLISECONDS) instead of millis * 1000 reduces the chances of ever making a calculation mistake when converting time values between different units.\nAlso: Using the actual current system time makes this test case depend on the fact that the local system time will not be lagging behind the time of the backend. I think it would be better to use a fixed time here as well, or at least add a negative value to the current local system time to reduce the probability that a small discrepancy between the two would make the test case fail.", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r367440490", "createdAt": "2020-01-16T14:17:03Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/it/ITCommitTimestampTest.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Copyright 2017 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.it;\n+\n+import static com.google.cloud.spanner.SpannerMatchers.isSpannerException;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Database;\n+import com.google.cloud.spanner.DatabaseAdminClient;\n+import com.google.cloud.spanner.DatabaseClient;\n+import com.google.cloud.spanner.ErrorCode;\n+import com.google.cloud.spanner.IntegrationTest;\n+import com.google.cloud.spanner.IntegrationTestEnv;\n+import com.google.cloud.spanner.Key;\n+import com.google.cloud.spanner.Mutation;\n+import com.google.cloud.spanner.SpannerExceptionFactory;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.TimestampBound;\n+import com.google.cloud.spanner.Value;\n+import com.google.cloud.spanner.testing.RemoteSpannerHelper;\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.concurrent.ExecutionException;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Integration test for commit timestamp of Cloud Spanner. */\n+@Category(IntegrationTest.class)\n+@RunWith(JUnit4.class)\n+public class ITCommitTimestampTest {\n+  @ClassRule public static IntegrationTestEnv env = new IntegrationTestEnv();\n+  @Rule public final ExpectedException expectedException = ExpectedException.none();\n+  private Database db;\n+  private DatabaseClient client;\n+  private DatabaseAdminClient dbAdminClient;\n+  private RemoteSpannerHelper testHelper;\n+  private String instanceId;\n+  private String databaseId;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    testHelper = env.getTestHelper();\n+    db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T (\"\n+                + \"K  STRING(MAX) NOT NULL,\"\n+                + \"T1   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T2   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T3   TIMESTAMP,\"\n+                + \") PRIMARY KEY (K)\");\n+    client = testHelper.getDatabaseClient(db);\n+    dbAdminClient = testHelper.getClient().getDatabaseAdminClient();\n+    instanceId = testHelper.getInstanceId().getInstance();\n+    databaseId = db.getId().getDatabase();\n+  }\n+\n+  private Timestamp write(Mutation m) {\n+    return client.write(Arrays.asList(m));\n+  }\n+\n+  private Struct readRow(DatabaseClient client, String table, Key key, String... columns) {\n+    return client.singleUse(TimestampBound.strong()).readRow(table, key, Arrays.asList(columns));\n+  }\n+\n+  @Test\n+  public void writeCommitTimestamp() {\n+    // 1. timestamps auto populated and returned should be the same\n+    Timestamp commitTimestamp =\n+        write(\n+            Mutation.newInsertOrUpdateBuilder(\"T\")\n+                .set(\"K\")\n+                .to(\"a\")\n+                .set(\"T1\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .set(\"T2\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .build());\n+    Struct row = readRow(client, \"T\", Key.of(\"a\"), \"T1\", \"T2\");\n+    assertThat(row.getTimestamp(0)).isEqualTo(commitTimestamp);\n+    assertThat(row.getTimestamp(1)).isEqualTo(commitTimestamp);\n+\n+    // 2. attempt to write CommitTimestamp to not enabled column should fail\n+    // error_catalog error CommitTimestampOptionNotEnabled\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"allow_commit_timestamp column option is not\");\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T3\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+  }\n+\n+  @Test\n+  public void consistency() {\n+    // 1. timestamps populated are consistent in order\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T1\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"b\")\n+            .set(\"T1\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+    Struct row1 = readRow(client, \"T\", Key.of(\"a\"), \"T1\");\n+    Struct row2 = readRow(client, \"T\", Key.of(\"b\"), \"T1\");\n+    assertThat(row2.getTimestamp(0)).isGreaterThan(row1.getTimestamp(0));\n+  }\n+\n+  @Test\n+  public void schemaChangeTimestampInFuture() throws Exception {\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T3\")\n+            .to(Timestamp.MAX_VALUE)\n+            .build());\n+\n+    // error_catalog error CommitTimestampNotInFuture\n+    expectedException.expectCause(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"has a timestamp in the future at key\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (allow_commit_timestamp=true)\";\n+    try {\n+      dbAdminClient\n+          .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+          .get();\n+    } catch (ExecutionException e) {\n+      throw SpannerExceptionFactory.newSpannerException(e.getCause());\n+    }\n+  }\n+\n+  @Test\n+  public void insertTimestampInFuture() {\n+    // error_catalog error TimestampInFuture\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"in the future\");\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T1\")\n+            .to(Timestamp.MAX_VALUE)\n+            .build());\n+  }\n+\n+  @Test\n+  public void invalidColumnOption() throws Exception {\n+    // error_catalog error DDLStatementWithError\n+    expectedException.expectCause(isSpannerException(ErrorCode.INVALID_ARGUMENT));\n+    expectedException.expectMessage(\"Option: bogus is unknown.\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (bogus=null)\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  @Test\n+  public void invalidColumnOptionValue() throws Exception {\n+    // error_catalog error DDLStatementWithErrors\n+    expectedException.expectCause(isSpannerException(ErrorCode.INVALID_ARGUMENT));\n+    expectedException.expectMessage(\"Errors parsing Spanner DDL statement\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (allow_commit_timestamp=bogus)\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  @Test\n+  public void invalidColumnType() throws Exception {\n+    // error_catalog error OptionErrorList\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"Option only allowed on TIMESTAMP columns\");\n+    String statement = \"ALTER TABLE T ADD COLUMN T4 INT64 OPTIONS (allow_commit_timestamp=true)\";\n+    try {\n+      dbAdminClient\n+          .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+          .get();\n+    } catch (ExecutionException e) {\n+      throw SpannerExceptionFactory.newSpannerException(e.getCause());\n+    }\n+  }\n+\n+  private void alterColumnOption(String databaseId, String table, String opt) throws Exception {\n+    String statement =\n+        \"ALTER TABLE \"\n+            + table\n+            + \" ALTER COLUMN ts\"\n+            + \" SET OPTIONS (allow_commit_timestamp=\"\n+            + opt\n+            + \")\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  private void writeAndVerify(DatabaseClient client, Timestamp ts) {\n+    Timestamp commitTimestamp =\n+        client.write(\n+            Arrays.asList(\n+                Mutation.newInsertOrUpdateBuilder(\"T1\").set(\"ts\").to(ts).build(),\n+                Mutation.newInsertOrUpdateBuilder(\"T2\").set(\"ts\").to(ts).build(),\n+                Mutation.newInsertOrUpdateBuilder(\"T3\").set(\"ts\").to(ts).build()));\n+    if (ts == Value.COMMIT_TIMESTAMP) {\n+      ts = commitTimestamp;\n+    }\n+    assertThat(readRow(client, \"T1\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+    assertThat(readRow(client, \"T2\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+    assertThat(readRow(client, \"T3\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+  }\n+\n+  @Test\n+  // 1) Write timestamps in the past\n+  // 2) Set all interleaved tables allow_commmit_timestamp=true\n+  // 3) Use commit timestamp in all tables\n+  // 4) Set all interleaved tables allow_commmit_timestamp=null\n+  // 5) Write timestamps in the future\n+  public void interleavedTable() throws Exception {\n+    Database db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T1 (ts TIMESTAMP) PRIMARY KEY (ts)\",\n+            \"CREATE TABLE T2 (ts TIMESTAMP) PRIMARY KEY (ts), INTERLEAVE IN PARENT T1\",\n+            \"CREATE TABLE T3 (ts TIMESTAMP) PRIMARY KEY (ts), INTERLEAVE IN PARENT T2\");\n+    DatabaseClient client = testHelper.getDatabaseClient(db);\n+    String databaseId = db.getId().getDatabase();\n+\n+    Timestamp timeNow = Timestamp.ofTimeMicroseconds(Instant.now().toEpochMilli() * 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58652628192f91c5749658925568de9afd15438"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0Mjc0Mg==", "bodyText": "Same as above.", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r367442742", "createdAt": "2020-01-16T14:21:11Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/it/ITCommitTimestampTest.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Copyright 2017 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.it;\n+\n+import static com.google.cloud.spanner.SpannerMatchers.isSpannerException;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Database;\n+import com.google.cloud.spanner.DatabaseAdminClient;\n+import com.google.cloud.spanner.DatabaseClient;\n+import com.google.cloud.spanner.ErrorCode;\n+import com.google.cloud.spanner.IntegrationTest;\n+import com.google.cloud.spanner.IntegrationTestEnv;\n+import com.google.cloud.spanner.Key;\n+import com.google.cloud.spanner.Mutation;\n+import com.google.cloud.spanner.SpannerExceptionFactory;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.TimestampBound;\n+import com.google.cloud.spanner.Value;\n+import com.google.cloud.spanner.testing.RemoteSpannerHelper;\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.concurrent.ExecutionException;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Integration test for commit timestamp of Cloud Spanner. */\n+@Category(IntegrationTest.class)\n+@RunWith(JUnit4.class)\n+public class ITCommitTimestampTest {\n+  @ClassRule public static IntegrationTestEnv env = new IntegrationTestEnv();\n+  @Rule public final ExpectedException expectedException = ExpectedException.none();\n+  private Database db;\n+  private DatabaseClient client;\n+  private DatabaseAdminClient dbAdminClient;\n+  private RemoteSpannerHelper testHelper;\n+  private String instanceId;\n+  private String databaseId;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    testHelper = env.getTestHelper();\n+    db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T (\"\n+                + \"K  STRING(MAX) NOT NULL,\"\n+                + \"T1   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T2   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T3   TIMESTAMP,\"\n+                + \") PRIMARY KEY (K)\");\n+    client = testHelper.getDatabaseClient(db);\n+    dbAdminClient = testHelper.getClient().getDatabaseAdminClient();\n+    instanceId = testHelper.getInstanceId().getInstance();\n+    databaseId = db.getId().getDatabase();\n+  }\n+\n+  private Timestamp write(Mutation m) {\n+    return client.write(Arrays.asList(m));\n+  }\n+\n+  private Struct readRow(DatabaseClient client, String table, Key key, String... columns) {\n+    return client.singleUse(TimestampBound.strong()).readRow(table, key, Arrays.asList(columns));\n+  }\n+\n+  @Test\n+  public void writeCommitTimestamp() {\n+    // 1. timestamps auto populated and returned should be the same\n+    Timestamp commitTimestamp =\n+        write(\n+            Mutation.newInsertOrUpdateBuilder(\"T\")\n+                .set(\"K\")\n+                .to(\"a\")\n+                .set(\"T1\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .set(\"T2\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .build());\n+    Struct row = readRow(client, \"T\", Key.of(\"a\"), \"T1\", \"T2\");\n+    assertThat(row.getTimestamp(0)).isEqualTo(commitTimestamp);\n+    assertThat(row.getTimestamp(1)).isEqualTo(commitTimestamp);\n+\n+    // 2. attempt to write CommitTimestamp to not enabled column should fail\n+    // error_catalog error CommitTimestampOptionNotEnabled\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"allow_commit_timestamp column option is not\");\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T3\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+  }\n+\n+  @Test\n+  public void consistency() {\n+    // 1. timestamps populated are consistent in order\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T1\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"b\")\n+            .set(\"T1\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+    Struct row1 = readRow(client, \"T\", Key.of(\"a\"), \"T1\");\n+    Struct row2 = readRow(client, \"T\", Key.of(\"b\"), \"T1\");\n+    assertThat(row2.getTimestamp(0)).isGreaterThan(row1.getTimestamp(0));\n+  }\n+\n+  @Test\n+  public void schemaChangeTimestampInFuture() throws Exception {\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T3\")\n+            .to(Timestamp.MAX_VALUE)\n+            .build());\n+\n+    // error_catalog error CommitTimestampNotInFuture\n+    expectedException.expectCause(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"has a timestamp in the future at key\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (allow_commit_timestamp=true)\";\n+    try {\n+      dbAdminClient\n+          .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+          .get();\n+    } catch (ExecutionException e) {\n+      throw SpannerExceptionFactory.newSpannerException(e.getCause());\n+    }\n+  }\n+\n+  @Test\n+  public void insertTimestampInFuture() {\n+    // error_catalog error TimestampInFuture\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"in the future\");\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T1\")\n+            .to(Timestamp.MAX_VALUE)\n+            .build());\n+  }\n+\n+  @Test\n+  public void invalidColumnOption() throws Exception {\n+    // error_catalog error DDLStatementWithError\n+    expectedException.expectCause(isSpannerException(ErrorCode.INVALID_ARGUMENT));\n+    expectedException.expectMessage(\"Option: bogus is unknown.\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (bogus=null)\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  @Test\n+  public void invalidColumnOptionValue() throws Exception {\n+    // error_catalog error DDLStatementWithErrors\n+    expectedException.expectCause(isSpannerException(ErrorCode.INVALID_ARGUMENT));\n+    expectedException.expectMessage(\"Errors parsing Spanner DDL statement\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (allow_commit_timestamp=bogus)\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  @Test\n+  public void invalidColumnType() throws Exception {\n+    // error_catalog error OptionErrorList\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"Option only allowed on TIMESTAMP columns\");\n+    String statement = \"ALTER TABLE T ADD COLUMN T4 INT64 OPTIONS (allow_commit_timestamp=true)\";\n+    try {\n+      dbAdminClient\n+          .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+          .get();\n+    } catch (ExecutionException e) {\n+      throw SpannerExceptionFactory.newSpannerException(e.getCause());\n+    }\n+  }\n+\n+  private void alterColumnOption(String databaseId, String table, String opt) throws Exception {\n+    String statement =\n+        \"ALTER TABLE \"\n+            + table\n+            + \" ALTER COLUMN ts\"\n+            + \" SET OPTIONS (allow_commit_timestamp=\"\n+            + opt\n+            + \")\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  private void writeAndVerify(DatabaseClient client, Timestamp ts) {\n+    Timestamp commitTimestamp =\n+        client.write(\n+            Arrays.asList(\n+                Mutation.newInsertOrUpdateBuilder(\"T1\").set(\"ts\").to(ts).build(),\n+                Mutation.newInsertOrUpdateBuilder(\"T2\").set(\"ts\").to(ts).build(),\n+                Mutation.newInsertOrUpdateBuilder(\"T3\").set(\"ts\").to(ts).build()));\n+    if (ts == Value.COMMIT_TIMESTAMP) {\n+      ts = commitTimestamp;\n+    }\n+    assertThat(readRow(client, \"T1\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+    assertThat(readRow(client, \"T2\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+    assertThat(readRow(client, \"T3\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+  }\n+\n+  @Test\n+  // 1) Write timestamps in the past\n+  // 2) Set all interleaved tables allow_commmit_timestamp=true\n+  // 3) Use commit timestamp in all tables\n+  // 4) Set all interleaved tables allow_commmit_timestamp=null\n+  // 5) Write timestamps in the future\n+  public void interleavedTable() throws Exception {\n+    Database db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T1 (ts TIMESTAMP) PRIMARY KEY (ts)\",\n+            \"CREATE TABLE T2 (ts TIMESTAMP) PRIMARY KEY (ts), INTERLEAVE IN PARENT T1\",\n+            \"CREATE TABLE T3 (ts TIMESTAMP) PRIMARY KEY (ts), INTERLEAVE IN PARENT T2\");\n+    DatabaseClient client = testHelper.getDatabaseClient(db);\n+    String databaseId = db.getId().getDatabase();\n+\n+    Timestamp timeNow = Timestamp.ofTimeMicroseconds(Instant.now().toEpochMilli() * 1000);\n+    Timestamp timeFuture =\n+        Timestamp.ofTimeMicroseconds(\n+            Instant.now().plus(Duration.ofDays(300)).toEpochMilli() * 1000);\n+\n+    writeAndVerify(client, timeNow);\n+\n+    alterColumnOption(databaseId, \"T1\", \"true\");\n+    alterColumnOption(databaseId, \"T2\", \"true\");\n+    alterColumnOption(databaseId, \"T3\", \"true\");\n+    writeAndVerify(client, Value.COMMIT_TIMESTAMP);\n+\n+    alterColumnOption(databaseId, \"T1\", \"null\");\n+    alterColumnOption(databaseId, \"T2\", \"null\");\n+    alterColumnOption(databaseId, \"T3\", \"null\");\n+    writeAndVerify(client, timeFuture);\n+  }\n+\n+  @Test\n+  // In interleaved table, use of commit timestamp in child table is not allowed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58652628192f91c5749658925568de9afd15438"}, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0Mjk5OA==", "bodyText": "Not supported in Java 7, use org.threeten.bp.Duration instead.", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r367442998", "createdAt": "2020-01-16T14:21:41Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/it/ITCommitTimestampTest.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Copyright 2017 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.it;\n+\n+import static com.google.cloud.spanner.SpannerMatchers.isSpannerException;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Database;\n+import com.google.cloud.spanner.DatabaseAdminClient;\n+import com.google.cloud.spanner.DatabaseClient;\n+import com.google.cloud.spanner.ErrorCode;\n+import com.google.cloud.spanner.IntegrationTest;\n+import com.google.cloud.spanner.IntegrationTestEnv;\n+import com.google.cloud.spanner.Key;\n+import com.google.cloud.spanner.Mutation;\n+import com.google.cloud.spanner.SpannerExceptionFactory;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.TimestampBound;\n+import com.google.cloud.spanner.Value;\n+import com.google.cloud.spanner.testing.RemoteSpannerHelper;\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58652628192f91c5749658925568de9afd15438"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0MzExMQ==", "bodyText": "Same as above.", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r367443111", "createdAt": "2020-01-16T14:21:52Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/it/ITCommitTimestampTest.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Copyright 2017 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.it;\n+\n+import static com.google.cloud.spanner.SpannerMatchers.isSpannerException;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Database;\n+import com.google.cloud.spanner.DatabaseAdminClient;\n+import com.google.cloud.spanner.DatabaseClient;\n+import com.google.cloud.spanner.ErrorCode;\n+import com.google.cloud.spanner.IntegrationTest;\n+import com.google.cloud.spanner.IntegrationTestEnv;\n+import com.google.cloud.spanner.Key;\n+import com.google.cloud.spanner.Mutation;\n+import com.google.cloud.spanner.SpannerExceptionFactory;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.TimestampBound;\n+import com.google.cloud.spanner.Value;\n+import com.google.cloud.spanner.testing.RemoteSpannerHelper;\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.time.Instant;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58652628192f91c5749658925568de9afd15438"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQ0MzIzNw==", "bodyText": "Same as above.", "url": "https://github.com/googleapis/java-spanner/pull/37#discussion_r367443237", "createdAt": "2020-01-16T14:22:05Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/it/ITCommitTimestampTest.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*\n+ * Copyright 2017 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner.it;\n+\n+import static com.google.cloud.spanner.SpannerMatchers.isSpannerException;\n+import static com.google.common.truth.Truth.assertThat;\n+\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Database;\n+import com.google.cloud.spanner.DatabaseAdminClient;\n+import com.google.cloud.spanner.DatabaseClient;\n+import com.google.cloud.spanner.ErrorCode;\n+import com.google.cloud.spanner.IntegrationTest;\n+import com.google.cloud.spanner.IntegrationTestEnv;\n+import com.google.cloud.spanner.Key;\n+import com.google.cloud.spanner.Mutation;\n+import com.google.cloud.spanner.SpannerExceptionFactory;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.TimestampBound;\n+import com.google.cloud.spanner.Value;\n+import com.google.cloud.spanner.testing.RemoteSpannerHelper;\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.concurrent.ExecutionException;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Integration test for commit timestamp of Cloud Spanner. */\n+@Category(IntegrationTest.class)\n+@RunWith(JUnit4.class)\n+public class ITCommitTimestampTest {\n+  @ClassRule public static IntegrationTestEnv env = new IntegrationTestEnv();\n+  @Rule public final ExpectedException expectedException = ExpectedException.none();\n+  private Database db;\n+  private DatabaseClient client;\n+  private DatabaseAdminClient dbAdminClient;\n+  private RemoteSpannerHelper testHelper;\n+  private String instanceId;\n+  private String databaseId;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    testHelper = env.getTestHelper();\n+    db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T (\"\n+                + \"K  STRING(MAX) NOT NULL,\"\n+                + \"T1   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T2   TIMESTAMP OPTIONS (allow_commit_timestamp = true),\"\n+                + \"T3   TIMESTAMP,\"\n+                + \") PRIMARY KEY (K)\");\n+    client = testHelper.getDatabaseClient(db);\n+    dbAdminClient = testHelper.getClient().getDatabaseAdminClient();\n+    instanceId = testHelper.getInstanceId().getInstance();\n+    databaseId = db.getId().getDatabase();\n+  }\n+\n+  private Timestamp write(Mutation m) {\n+    return client.write(Arrays.asList(m));\n+  }\n+\n+  private Struct readRow(DatabaseClient client, String table, Key key, String... columns) {\n+    return client.singleUse(TimestampBound.strong()).readRow(table, key, Arrays.asList(columns));\n+  }\n+\n+  @Test\n+  public void writeCommitTimestamp() {\n+    // 1. timestamps auto populated and returned should be the same\n+    Timestamp commitTimestamp =\n+        write(\n+            Mutation.newInsertOrUpdateBuilder(\"T\")\n+                .set(\"K\")\n+                .to(\"a\")\n+                .set(\"T1\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .set(\"T2\")\n+                .to(Value.COMMIT_TIMESTAMP)\n+                .build());\n+    Struct row = readRow(client, \"T\", Key.of(\"a\"), \"T1\", \"T2\");\n+    assertThat(row.getTimestamp(0)).isEqualTo(commitTimestamp);\n+    assertThat(row.getTimestamp(1)).isEqualTo(commitTimestamp);\n+\n+    // 2. attempt to write CommitTimestamp to not enabled column should fail\n+    // error_catalog error CommitTimestampOptionNotEnabled\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"allow_commit_timestamp column option is not\");\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T3\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+  }\n+\n+  @Test\n+  public void consistency() {\n+    // 1. timestamps populated are consistent in order\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T1\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"b\")\n+            .set(\"T1\")\n+            .to(Value.COMMIT_TIMESTAMP)\n+            .build());\n+    Struct row1 = readRow(client, \"T\", Key.of(\"a\"), \"T1\");\n+    Struct row2 = readRow(client, \"T\", Key.of(\"b\"), \"T1\");\n+    assertThat(row2.getTimestamp(0)).isGreaterThan(row1.getTimestamp(0));\n+  }\n+\n+  @Test\n+  public void schemaChangeTimestampInFuture() throws Exception {\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T3\")\n+            .to(Timestamp.MAX_VALUE)\n+            .build());\n+\n+    // error_catalog error CommitTimestampNotInFuture\n+    expectedException.expectCause(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"has a timestamp in the future at key\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (allow_commit_timestamp=true)\";\n+    try {\n+      dbAdminClient\n+          .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+          .get();\n+    } catch (ExecutionException e) {\n+      throw SpannerExceptionFactory.newSpannerException(e.getCause());\n+    }\n+  }\n+\n+  @Test\n+  public void insertTimestampInFuture() {\n+    // error_catalog error TimestampInFuture\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"in the future\");\n+    write(\n+        Mutation.newInsertOrUpdateBuilder(\"T\")\n+            .set(\"K\")\n+            .to(\"a\")\n+            .set(\"T1\")\n+            .to(Timestamp.MAX_VALUE)\n+            .build());\n+  }\n+\n+  @Test\n+  public void invalidColumnOption() throws Exception {\n+    // error_catalog error DDLStatementWithError\n+    expectedException.expectCause(isSpannerException(ErrorCode.INVALID_ARGUMENT));\n+    expectedException.expectMessage(\"Option: bogus is unknown.\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (bogus=null)\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  @Test\n+  public void invalidColumnOptionValue() throws Exception {\n+    // error_catalog error DDLStatementWithErrors\n+    expectedException.expectCause(isSpannerException(ErrorCode.INVALID_ARGUMENT));\n+    expectedException.expectMessage(\"Errors parsing Spanner DDL statement\");\n+    String statement = \"ALTER TABLE T ALTER COLUMN T3 SET OPTIONS (allow_commit_timestamp=bogus)\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  @Test\n+  public void invalidColumnType() throws Exception {\n+    // error_catalog error OptionErrorList\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\"Option only allowed on TIMESTAMP columns\");\n+    String statement = \"ALTER TABLE T ADD COLUMN T4 INT64 OPTIONS (allow_commit_timestamp=true)\";\n+    try {\n+      dbAdminClient\n+          .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+          .get();\n+    } catch (ExecutionException e) {\n+      throw SpannerExceptionFactory.newSpannerException(e.getCause());\n+    }\n+  }\n+\n+  private void alterColumnOption(String databaseId, String table, String opt) throws Exception {\n+    String statement =\n+        \"ALTER TABLE \"\n+            + table\n+            + \" ALTER COLUMN ts\"\n+            + \" SET OPTIONS (allow_commit_timestamp=\"\n+            + opt\n+            + \")\";\n+    dbAdminClient\n+        .updateDatabaseDdl(instanceId, databaseId, ImmutableList.of(statement), null)\n+        .get();\n+  }\n+\n+  private void writeAndVerify(DatabaseClient client, Timestamp ts) {\n+    Timestamp commitTimestamp =\n+        client.write(\n+            Arrays.asList(\n+                Mutation.newInsertOrUpdateBuilder(\"T1\").set(\"ts\").to(ts).build(),\n+                Mutation.newInsertOrUpdateBuilder(\"T2\").set(\"ts\").to(ts).build(),\n+                Mutation.newInsertOrUpdateBuilder(\"T3\").set(\"ts\").to(ts).build()));\n+    if (ts == Value.COMMIT_TIMESTAMP) {\n+      ts = commitTimestamp;\n+    }\n+    assertThat(readRow(client, \"T1\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+    assertThat(readRow(client, \"T2\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+    assertThat(readRow(client, \"T3\", Key.of(ts), \"ts\").getTimestamp(0)).isEqualTo(ts);\n+  }\n+\n+  @Test\n+  // 1) Write timestamps in the past\n+  // 2) Set all interleaved tables allow_commmit_timestamp=true\n+  // 3) Use commit timestamp in all tables\n+  // 4) Set all interleaved tables allow_commmit_timestamp=null\n+  // 5) Write timestamps in the future\n+  public void interleavedTable() throws Exception {\n+    Database db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T1 (ts TIMESTAMP) PRIMARY KEY (ts)\",\n+            \"CREATE TABLE T2 (ts TIMESTAMP) PRIMARY KEY (ts), INTERLEAVE IN PARENT T1\",\n+            \"CREATE TABLE T3 (ts TIMESTAMP) PRIMARY KEY (ts), INTERLEAVE IN PARENT T2\");\n+    DatabaseClient client = testHelper.getDatabaseClient(db);\n+    String databaseId = db.getId().getDatabase();\n+\n+    Timestamp timeNow = Timestamp.ofTimeMicroseconds(Instant.now().toEpochMilli() * 1000);\n+    Timestamp timeFuture =\n+        Timestamp.ofTimeMicroseconds(\n+            Instant.now().plus(Duration.ofDays(300)).toEpochMilli() * 1000);\n+\n+    writeAndVerify(client, timeNow);\n+\n+    alterColumnOption(databaseId, \"T1\", \"true\");\n+    alterColumnOption(databaseId, \"T2\", \"true\");\n+    alterColumnOption(databaseId, \"T3\", \"true\");\n+    writeAndVerify(client, Value.COMMIT_TIMESTAMP);\n+\n+    alterColumnOption(databaseId, \"T1\", \"null\");\n+    alterColumnOption(databaseId, \"T2\", \"null\");\n+    alterColumnOption(databaseId, \"T3\", \"null\");\n+    writeAndVerify(client, timeFuture);\n+  }\n+\n+  @Test\n+  // In interleaved table, use of commit timestamp in child table is not allowed\n+  // if parent tables are not allow_commmit_timestamp=true\n+  public void interleavedTableHierarchy1() {\n+    Database db =\n+        testHelper.createTestDatabase(\n+            \"CREATE TABLE T1 (ts TIMESTAMP) PRIMARY KEY (ts)\",\n+            \"CREATE TABLE T2 (ts TIMESTAMP) PRIMARY KEY (ts), INTERLEAVE IN PARENT T1\",\n+            \"CREATE TABLE T3 (ts TIMESTAMP OPTIONS (allow_commit_timestamp = true)) \"\n+                + \"PRIMARY KEY (ts), INTERLEAVE IN PARENT T2\");\n+    DatabaseClient client = testHelper.getDatabaseClient(db);\n+    db.getId().getDatabase();\n+\n+    // error_catalog error CommitTimestampOptionNotEnabled\n+    expectedException.expect(isSpannerException(ErrorCode.FAILED_PRECONDITION));\n+    expectedException.expectMessage(\n+        \"corresponding shared key columns in this table's interleaved table hierarchy\");\n+    client.write(\n+        Arrays.asList(\n+            Mutation.newInsertOrUpdateBuilder(\"T3\").set(\"ts\").to(Value.COMMIT_TIMESTAMP).build()));\n+  }\n+\n+  @Test\n+  // In interleaved table, use of commit timestamp in parent table is not", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a58652628192f91c5749658925568de9afd15438"}, "originalPosition": 298}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56cd23e93a492f9b927214439c180dfc9e5d7e94", "author": {"user": {"login": "agasheesh", "name": "Asheesh Agrawal"}}, "url": "https://github.com/googleapis/java-spanner/commit/56cd23e93a492f9b927214439c180dfc9e5d7e94", "committedDate": "2020-01-22T00:29:41Z", "message": "test: add Commit Timestamp java integration tests for cloud spanner"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cc3cd788e8a0d9987bebb1ab8eecea1ccaf3cf3e", "author": {"user": {"login": "yoshi-automation", "name": "Yoshi Automation Bot"}}, "url": "https://github.com/googleapis/java-spanner/commit/cc3cd788e8a0d9987bebb1ab8eecea1ccaf3cf3e", "committedDate": "2020-01-22T00:27:19Z", "message": "chore(regen): update common renovate configuration"}, "afterCommit": {"oid": "56cd23e93a492f9b927214439c180dfc9e5d7e94", "author": {"user": {"login": "agasheesh", "name": "Asheesh Agrawal"}}, "url": "https://github.com/googleapis/java-spanner/commit/56cd23e93a492f9b927214439c180dfc9e5d7e94", "committedDate": "2020-01-22T00:29:41Z", "message": "test: add Commit Timestamp java integration tests for cloud spanner"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24faebe561fc561308f1587eba85efdcf34fc86b", "author": {"user": {"login": "agasheesh", "name": "Asheesh Agrawal"}}, "url": "https://github.com/googleapis/java-spanner/commit/24faebe561fc561308f1587eba85efdcf34fc86b", "committedDate": "2020-01-22T00:38:14Z", "message": "Use org.threeten.bp library instead of java.time for Java 7 compatibility"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d920e968233662d9a16c8dd74ed94f5a2ebcb819", "author": {"user": {"login": "agasheesh", "name": "Asheesh Agrawal"}}, "url": "https://github.com/googleapis/java-spanner/commit/d920e968233662d9a16c8dd74ed94f5a2ebcb819", "committedDate": "2020-01-22T00:53:10Z", "message": "test: Fix java comment documentation style to use @Test annotation right before function name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03bd9effbc7d39a6b40792092c3b783235f4a025", "author": {"user": {"login": "agasheesh", "name": "Asheesh Agrawal"}}, "url": "https://github.com/googleapis/java-spanner/commit/03bd9effbc7d39a6b40792092c3b783235f4a025", "committedDate": "2020-01-22T01:02:19Z", "message": "Fix formatting error in imports"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2Mzk3MDM3", "url": "https://github.com/googleapis/java-spanner/pull/37#pullrequestreview-346397037", "createdAt": "2020-01-22T07:57:35Z", "commit": {"oid": "03bd9effbc7d39a6b40792092c3b783235f4a025"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 904, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}