{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4NDQ0Njkx", "number": 81, "title": "feat: add async api", "bodyText": "Adds an async API to the Spanner client library. Most notable changes:\nAll calls to the session pool are now non-blocking\nThis also applies to the current API, which means that the following statements will always be non-blocking, regardless whether a session was already available in the session pool or not:\nDatabase client = spanner.getDatabaseClient(...);\nResultSet rs = client.singleUse().executeQuery(Statement.Of(\"SELECT 1\"));\nInstead, the first call to ResultSet#next() will be blocking:\n\nIt will potentially block until a session could be returned from the pool.\nIt will block until the executeStreamingSql call has returned the first results.\n\nAdds Async methods to ReadContext\nThe ReadContext interface is extended with the following methods:\n\nreadAsync(...)\nreadUsingIndexAsync(...)\nexecuteQueryAsync(...)\nreadRowAsync(...)\nreadRowUsingIndexAsync(...)\n\nThe first three of the above methods return an AsyncResultSet. AsyncResultSet is an extension of the existing ResultSet interface that allows the user to register a callback that will be called asynchronously for each row in the result set.\nThe latter two methods return instances of ApiFuture<Struct>.\nPoint for discussion:\nIt would also be possible to add the setCallback(...) method to the existing ResultSet interface instead of creating an additional AsyncResultSet interface. That would mean that we would not need to add the -Async methods above. Instead, all ResultSets could be consumed asynchronously by calling the setCallback(...) method.\nAdds AsyncRunner\nThe method DatabaseClient#runAsync() is added which returns an AsyncRunner. This runner can be used to execute a read/write transaction asynchronously.", "createdAt": "2020-02-21T19:49:00Z", "url": "https://github.com/googleapis/java-spanner/pull/81", "merged": true, "mergeCommit": {"oid": "462839b625e58e235581b8ba10b398e1d222eaaf"}, "closed": true, "closedAt": "2020-06-30T18:45:22Z", "author": {"login": "olavloite"}, "timelineItems": {"totalCount": 67, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIKpFSABqjMwNzQ4MTc2MzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABekdXiUgFqTY5MzI4OTY5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f2d4e601be98dc8b9646ff71ab9da9a857912fae", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/f2d4e601be98dc8b9646ff71ab9da9a857912fae", "committedDate": "2020-02-26T15:47:52Z", "message": "feat: keep session checked out until async finishes"}, "afterCommit": {"oid": "987b77f337b98033541651f6f294b295e4b734a8", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/987b77f337b98033541651f6f294b295e4b734a8", "committedDate": "2020-02-26T18:01:07Z", "message": "fix: fix span test cases after rebase"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "987b77f337b98033541651f6f294b295e4b734a8", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/987b77f337b98033541651f6f294b295e4b734a8", "committedDate": "2020-02-26T18:01:07Z", "message": "fix: fix span test cases after rebase"}, "afterCommit": {"oid": "80d023a9ac598a1036c25f058bd2097c75911f0b", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/80d023a9ac598a1036c25f058bd2097c75911f0b", "committedDate": "2020-02-28T13:15:50Z", "message": "fix: make async runner wait for async operations"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fb1fdc4bda549bf457e9ac08a9b020544ec50504", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/fb1fdc4bda549bf457e9ac08a9b020544ec50504", "committedDate": "2020-02-28T20:54:49Z", "message": "tests: fix flaky tests"}, "afterCommit": {"oid": "54c1951412b5bd2a0b0759ff1e45f29befe20721", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/54c1951412b5bd2a0b0759ff1e45f29befe20721", "committedDate": "2020-03-16T13:54:46Z", "message": "rebase: rebase on current master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5e8df8c8b3cc17f5abe60d89994a5074e1f5db5", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/e5e8df8c8b3cc17f5abe60d89994a5074e1f5db5", "committedDate": "2020-03-20T16:17:39Z", "message": "feat: add async api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7db649ed353ac7812ee6dc418978101152e8d5e", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/c7db649ed353ac7812ee6dc418978101152e8d5e", "committedDate": "2020-03-20T16:17:39Z", "message": "feat: session pool is non-blocking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e485709e46a8dbc231f851cfead5aaa3c48056ef", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/e485709e46a8dbc231f851cfead5aaa3c48056ef", "committedDate": "2020-03-20T16:17:39Z", "message": "tests: fix integration tests that assumed tx was blocking\n\nSome integration tests started transactions without executing a query,\nand expected these transactions to fail. However, as the client is\nnow non-blocking up until the first call to ResultSet#next(), no\nexception would occur."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3ebeb313fadfb37016998f5b03e261d58306f6f", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/e3ebeb313fadfb37016998f5b03e261d58306f6f", "committedDate": "2020-03-20T16:17:39Z", "message": "feat: add read methods support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54629ad2724bc7d643c1141d0a08dc00db9708bd", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/54629ad2724bc7d643c1141d0a08dc00db9708bd", "committedDate": "2020-03-20T16:17:39Z", "message": "tests: test async runner"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a10b646b416ab61c079f00294e20529ca9f7b9c", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/8a10b646b416ab61c079f00294e20529ca9f7b9c", "committedDate": "2020-03-20T16:17:39Z", "message": "feat: create async runner"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91253cf7dbd943a5162fab209bdb54607b321bdf", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/91253cf7dbd943a5162fab209bdb54607b321bdf", "committedDate": "2020-03-20T16:17:39Z", "message": "tests: centralize some commonly used test objects"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2d28cd6601706fd3f5b32a35dc4d7745eb417b8", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/a2d28cd6601706fd3f5b32a35dc4d7745eb417b8", "committedDate": "2020-03-20T16:17:39Z", "message": "feat: keep session checked out until async finishes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a63e62560a1c7b266fc896f1133b03925b69875", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/2a63e62560a1c7b266fc896f1133b03925b69875", "committedDate": "2020-03-20T16:20:31Z", "message": "fix: fix span test cases after rebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d58bc366dc3c9317a5b6419c2fb4a616e38b39a", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/9d58bc366dc3c9317a5b6419c2fb4a616e38b39a", "committedDate": "2020-03-20T16:20:31Z", "message": "fix: fix async runner tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f796325b2c9f38bd2afe839604abc262a9ae48b", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/4f796325b2c9f38bd2afe839604abc262a9ae48b", "committedDate": "2020-03-20T16:20:31Z", "message": "fix: make async runner wait for async operations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfd1802183bfe7d16d00b9acc163fb1283922148", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/cfd1802183bfe7d16d00b9acc163fb1283922148", "committedDate": "2020-03-20T16:20:31Z", "message": "examples: add example integration test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2e28a577aa007133c723ea2d7fc785d66053c3a", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/a2e28a577aa007133c723ea2d7fc785d66053c3a", "committedDate": "2020-03-20T16:20:31Z", "message": "examples: add more examples"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa61e7d14a3cd2a26a396107ce2b5a551a8587ba", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/fa61e7d14a3cd2a26a396107ce2b5a551a8587ba", "committedDate": "2020-03-20T16:20:31Z", "message": "tests: fix flaky tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc53dbf2a62f199466da10655c2c355b36745144", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/fc53dbf2a62f199466da10655c2c355b36745144", "committedDate": "2020-03-20T16:21:19Z", "message": "rebase: rebase on current master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0eee1f64f3767574608237f31d7a8cb1d7df6601", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/0eee1f64f3767574608237f31d7a8cb1d7df6601", "committedDate": "2020-03-20T16:25:57Z", "message": "fix: run code formatter"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "54c1951412b5bd2a0b0759ff1e45f29befe20721", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/54c1951412b5bd2a0b0759ff1e45f29befe20721", "committedDate": "2020-03-16T13:54:46Z", "message": "rebase: rebase on current master"}, "afterCommit": {"oid": "0eee1f64f3767574608237f31d7a8cb1d7df6601", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/0eee1f64f3767574608237f31d7a8cb1d7df6601", "committedDate": "2020-03-20T16:25:57Z", "message": "fix: run code formatter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3d2ffc49f2c6a73b08af77d420b12a3ff2065ab", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/d3d2ffc49f2c6a73b08af77d420b12a3ff2065ab", "committedDate": "2020-03-26T15:08:12Z", "message": "feat: add support for poller"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e01ca71854f6d7e39ad0e9cf6bb184c2699a7b9", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/2e01ca71854f6d7e39ad0e9cf6bb184c2699a7b9", "committedDate": "2020-04-02T06:40:53Z", "message": "tests: support more param types"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e63f2b02bd487a9b74e851f5af82e2ac85ec1cb", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/5e63f2b02bd487a9b74e851f5af82e2ac85ec1cb", "committedDate": "2020-04-08T05:02:36Z", "message": "fix: fix race conditions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abe455e7e8bd2483ff419419f0ebe1b152c73ae8", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/abe455e7e8bd2483ff419419f0ebe1b152c73ae8", "committedDate": "2020-04-09T16:20:10Z", "message": "feat: return ApiFuture to monitor end of AsyncResultSet"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc091e8d97ae2b01aea73571164ae746d81d8597", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/cc091e8d97ae2b01aea73571164ae746d81d8597", "committedDate": "2020-04-19T18:21:33Z", "message": "feat: add helper method for create test result sets"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "944c701de1d5da6cedcf1e062ecda38e95984071", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/944c701de1d5da6cedcf1e062ecda38e95984071", "committedDate": "2020-04-21T15:28:57Z", "message": "merge: merge latest changes from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d75f9795e2782bd7d628da289e3c2f5103aa8136", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/d75f9795e2782bd7d628da289e3c2f5103aa8136", "committedDate": "2020-04-21T19:43:29Z", "message": "feat: add batchUpdateAsync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f06e845181ac240dbd5ec664f702946c321bd84", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/7f06e845181ac240dbd5ec664f702946c321bd84", "committedDate": "2020-04-26T09:17:32Z", "message": "fix: add ignored interface differences"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1b0615f382fbbe21298f84d612e3718f55b1b6b", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/c1b0615f382fbbe21298f84d612e3718f55b1b6b", "committedDate": "2020-04-26T09:29:46Z", "message": "merge: merge master into async branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00b83d2ef88fa5ccee369809033a55cfbe9e298f", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/00b83d2ef88fa5ccee369809033a55cfbe9e298f", "committedDate": "2020-04-26T20:33:24Z", "message": "refactor: use future as waiter in SessionPool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ea27d7e4d11866e6f7fd880cadc1076c4f61c28", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/2ea27d7e4d11866e6f7fd880cadc1076c4f61c28", "committedDate": "2020-04-27T08:33:19Z", "message": "Merge branch 'master' into async-api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17fb940bfb56d10a673ce20d7d17b8bd2dd38dc7", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/17fb940bfb56d10a673ce20d7d17b8bd2dd38dc7", "committedDate": "2020-04-29T07:17:46Z", "message": "merge: merge with latest from master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51b511349e094ae5bac9225a9d22d6d9cad1c212", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/51b511349e094ae5bac9225a9d22d6d9cad1c212", "committedDate": "2020-04-29T07:25:39Z", "message": "format: run code formatter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a03380be0c2a720131615f793a4b807adc593b9d", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/a03380be0c2a720131615f793a4b807adc593b9d", "committedDate": "2020-04-29T08:23:42Z", "message": "tests: fix test case + remove commented code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bc3a135382517e3e08097bb5e669946496d3028", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/8bc3a135382517e3e08097bb5e669946496d3028", "committedDate": "2020-04-29T13:01:58Z", "message": "fix: AsyncResultSet should throw Cancelled"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0927957750e144e5f24c6263c67b14d117560256", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/0927957750e144e5f24c6263c67b14d117560256", "committedDate": "2020-05-06T13:53:03Z", "message": "Merge branch 'master' into async-api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e486c54a913797d73e9f83c00491812f5deb7d6d", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/e486c54a913797d73e9f83c00491812f5deb7d6d", "committedDate": "2020-05-11T13:05:54Z", "message": "feat: expose DatabaseId.of(String name)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/a7dd1dd3376784cf24e8aeb64a7155e26b9192d5", "committedDate": "2020-05-12T11:37:08Z", "message": "deps: set version to 1.53 to match bom"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NDgxODk2", "url": "https://github.com/googleapis/java-spanner/pull/81#pullrequestreview-427481896", "createdAt": "2020-06-09T19:38:58Z", "commit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxOTozODo1OFrOGhZaFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMzoxODo0NFrOGhjeTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3MjQ3MA==", "bodyText": "All maven versions look downgraded (after rebase?).", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437672470", "createdAt": "2020-06-09T19:38:58Z", "author": {"login": "elefeint"}, "path": "google-cloud-spanner-bom/pom.xml", "diffHunk": "@@ -3,7 +3,7 @@\n   <modelVersion>4.0.0</modelVersion>\n   <groupId>com.google.cloud</groupId>\n   <artifactId>google-cloud-spanner-bom</artifactId>\n-  <version>1.54.0</version><!-- {x-version-update:google-cloud-spanner:current} -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4MzM3Mg==", "bodyText": "Would this loop execute at most twice? Wondering if the while loop is necessary here.", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437683372", "createdAt": "2020-06-09T19:59:28Z", "author": {"login": "elefeint"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AbstractReadContext.java", "diffHunk": "@@ -666,4 +752,52 @@ private Struct consumeSingleRow(ResultSet resultSet) {\n     }\n     return row;\n   }\n+\n+  private ApiFuture<Struct> consumeSingleRowAsync(AsyncResultSet resultSet) {\n+    SettableApiFuture<Struct> result = SettableApiFuture.create();\n+    // We can safely use a directExecutor here, as we will only be consuming one row, and we will\n+    // not be doing any blocking stuff in the handler.\n+    resultSet.setCallback(MoreExecutors.directExecutor(), ConsumeSingleRowCallback.create(result));\n+    return result;\n+  }\n+\n+  /**\n+   * {@link ReadyCallback} for returning the first row in a result set as a future {@link Struct}.\n+   */\n+  static class ConsumeSingleRowCallback implements ReadyCallback {\n+    private final SettableApiFuture<Struct> result;\n+    private Struct row;\n+\n+    static ConsumeSingleRowCallback create(SettableApiFuture<Struct> result) {\n+      return new ConsumeSingleRowCallback(result);\n+    }\n+\n+    private ConsumeSingleRowCallback(SettableApiFuture<Struct> result) {\n+      this.result = result;\n+    }\n+\n+    @Override\n+    public CallbackResponse cursorReady(AsyncResultSet resultSet) {\n+      try {\n+        while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NTg0MQ==", "bodyText": "Even though tryNext() returns an enum, can we add a default case with a fallthough comment along the lines of \"this should never happen\"? Or even an exception in case the enum grows over time?\nhttps://google.github.io/styleguide/javaguide.html#s4.8.4.3-switch-default", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437685841", "createdAt": "2020-06-09T20:04:12Z", "author": {"login": "elefeint"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AbstractReadContext.java", "diffHunk": "@@ -666,4 +752,52 @@ private Struct consumeSingleRow(ResultSet resultSet) {\n     }\n     return row;\n   }\n+\n+  private ApiFuture<Struct> consumeSingleRowAsync(AsyncResultSet resultSet) {\n+    SettableApiFuture<Struct> result = SettableApiFuture.create();\n+    // We can safely use a directExecutor here, as we will only be consuming one row, and we will\n+    // not be doing any blocking stuff in the handler.\n+    resultSet.setCallback(MoreExecutors.directExecutor(), ConsumeSingleRowCallback.create(result));\n+    return result;\n+  }\n+\n+  /**\n+   * {@link ReadyCallback} for returning the first row in a result set as a future {@link Struct}.\n+   */\n+  static class ConsumeSingleRowCallback implements ReadyCallback {\n+    private final SettableApiFuture<Struct> result;\n+    private Struct row;\n+\n+    static ConsumeSingleRowCallback create(SettableApiFuture<Struct> result) {\n+      return new ConsumeSingleRowCallback(result);\n+    }\n+\n+    private ConsumeSingleRowCallback(SettableApiFuture<Struct> result) {\n+      this.result = result;\n+    }\n+\n+    @Override\n+    public CallbackResponse cursorReady(AsyncResultSet resultSet) {\n+      try {\n+        while (true) {\n+          switch (resultSet.tryNext()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NzI5OA==", "bodyText": "Synchronous caller? For asynchronous scenario, we'd return CallbackResponse.CONTINUE and let the callback be invoked again.", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437687298", "createdAt": "2020-06-09T20:07:02Z", "author": {"login": "elefeint"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncResultSet.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.base.Function;\n+import com.google.common.collect.ImmutableList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+/** Interface for result sets returned by async query methods. */\n+public interface AsyncResultSet extends ResultSet {\n+\n+  /**\n+   * Interface for receiving asynchronous callbacks when new data is ready. See {@link\n+   * AsyncResultSet#setCallback(Executor, ReadyCallback)}.\n+   */\n+  public static interface ReadyCallback {\n+    CallbackResponse cursorReady(AsyncResultSet resultSet);\n+  }\n+\n+  /** Response code from {@code tryNext()}. */\n+  public enum CursorState {\n+    /** Cursor has been moved to a new row. */\n+    OK,\n+    /** Read is complete, all rows have been consumed, and there are no more. */\n+    DONE,\n+    /** No further information known at this time, thus current row not available. */\n+    NOT_READY\n+  }\n+\n+  /**\n+   * Non-blocking call that attempts to step the cursor to the next position in the stream. The\n+   * cursor may be inspected only if the cursor returns {@code CursorState.OK}.\n+   *\n+   * <p>A caller will typically call {@link #tryNext()} in a loop inside the ReadyCallback,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY5MjI4Ng==", "bodyText": "nit: add newline before exception declaration? It does not seem to belong to the same visual member declaration block.", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437692286", "createdAt": "2020-06-09T20:16:35Z", "author": {"login": "elefeint"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncResultSetImpl.java", "diffHunk": "@@ -0,0 +1,567 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.api.core.ListenableFutureToApiFuture;\n+import com.google.api.core.SettableApiFuture;\n+import com.google.api.gax.core.ExecutorProvider;\n+import com.google.cloud.spanner.AbstractReadContext.ListenableAsyncResultSet;\n+import com.google.common.base.Function;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.spanner.v1.ResultSetStats;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+/** Default implementation for {@link AsyncResultSet}. */\n+class AsyncResultSetImpl extends ForwardingStructReader implements ListenableAsyncResultSet {\n+\n+  /** State of an {@link AsyncResultSetImpl}. */\n+  private enum State {\n+    INITIALIZED,\n+    /** SYNC indicates that the {@link ResultSet} is used in sync pattern. */\n+    SYNC,\n+    CONSUMING,\n+    RUNNING,\n+    PAUSED,\n+    CANCELLED(true),\n+    DONE(true);\n+\n+    /** Does this state mean that the result set should permanently stop producing rows. */\n+    private final boolean shouldStop;\n+\n+    private State() {\n+      shouldStop = false;\n+    }\n+\n+    private State(boolean shouldStop) {\n+      this.shouldStop = shouldStop;\n+    }\n+  }\n+\n+  static final int DEFAULT_BUFFER_SIZE = 10;\n+  private static final int MAX_WAIT_FOR_BUFFER_CONSUMPTION = 10;\n+  private static final SpannerException CANCELLED_EXCEPTION =\n+      SpannerExceptionFactory.newSpannerException(\n+          ErrorCode.CANCELLED, \"This AsyncResultSet has been cancelled\");\n+\n+  private final Object monitor = new Object();\n+  private boolean closed;\n+\n+  /**\n+   * {@link ExecutorProvider} provides executor services that are used to fetch data from the\n+   * backend and put these into the buffer for further consumption by the callback.\n+   */\n+  private final ExecutorProvider executorProvider;\n+\n+  private final ListeningScheduledExecutorService service;\n+\n+  private final BlockingDeque<Struct> buffer;\n+  private Struct currentRow;\n+  /** The underlying synchronous {@link ResultSet} that is producing the rows. */\n+  private final ResultSet delegateResultSet;\n+  /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgyMzgzMQ==", "bodyText": "Non-actionable comment on your TODO above: we can in the future set up reactive streams test cases -- for example, there are Project Reactor operators that keep a certain percentage of a buffer full at all times, so refilling it not when empty but when down to the last N%.", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437823831", "createdAt": "2020-06-10T02:24:29Z", "author": {"login": "elefeint"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncResultSetImpl.java", "diffHunk": "@@ -0,0 +1,567 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.api.core.ListenableFutureToApiFuture;\n+import com.google.api.core.SettableApiFuture;\n+import com.google.api.gax.core.ExecutorProvider;\n+import com.google.cloud.spanner.AbstractReadContext.ListenableAsyncResultSet;\n+import com.google.common.base.Function;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.spanner.v1.ResultSetStats;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+/** Default implementation for {@link AsyncResultSet}. */\n+class AsyncResultSetImpl extends ForwardingStructReader implements ListenableAsyncResultSet {\n+\n+  /** State of an {@link AsyncResultSetImpl}. */\n+  private enum State {\n+    INITIALIZED,\n+    /** SYNC indicates that the {@link ResultSet} is used in sync pattern. */\n+    SYNC,\n+    CONSUMING,\n+    RUNNING,\n+    PAUSED,\n+    CANCELLED(true),\n+    DONE(true);\n+\n+    /** Does this state mean that the result set should permanently stop producing rows. */\n+    private final boolean shouldStop;\n+\n+    private State() {\n+      shouldStop = false;\n+    }\n+\n+    private State(boolean shouldStop) {\n+      this.shouldStop = shouldStop;\n+    }\n+  }\n+\n+  static final int DEFAULT_BUFFER_SIZE = 10;\n+  private static final int MAX_WAIT_FOR_BUFFER_CONSUMPTION = 10;\n+  private static final SpannerException CANCELLED_EXCEPTION =\n+      SpannerExceptionFactory.newSpannerException(\n+          ErrorCode.CANCELLED, \"This AsyncResultSet has been cancelled\");\n+\n+  private final Object monitor = new Object();\n+  private boolean closed;\n+\n+  /**\n+   * {@link ExecutorProvider} provides executor services that are used to fetch data from the\n+   * backend and put these into the buffer for further consumption by the callback.\n+   */\n+  private final ExecutorProvider executorProvider;\n+\n+  private final ListeningScheduledExecutorService service;\n+\n+  private final BlockingDeque<Struct> buffer;\n+  private Struct currentRow;\n+  /** The underlying synchronous {@link ResultSet} that is producing the rows. */\n+  private final ResultSet delegateResultSet;\n+  /**\n+   * Any exception that occurs while executing the query and iterating over the result set will be\n+   * stored in this variable and propagated to the user through {@link #tryNext()}.\n+   */\n+  private volatile SpannerException executionException;\n+\n+  /**\n+   * Executor for callbacks. Regardless of the type of executor that is provided, the {@link\n+   * AsyncResultSetImpl} will ensure that at most 1 callback call will be active at any one time.\n+   */\n+  private Executor executor;\n+\n+  private ReadyCallback callback;\n+\n+  /**\n+   * Listeners that will be called when the {@link AsyncResultSetImpl} has finished fetching all\n+   * rows and any underlying transaction or session can be closed.\n+   */\n+  private Collection<Runnable> listeners = new LinkedList<>();\n+\n+  private State state = State.INITIALIZED;\n+\n+  /**\n+   * {@link #finished} indicates whether all the results from the underlying result set have been\n+   * read.\n+   */\n+  private volatile boolean finished;\n+\n+  private volatile ApiFuture<Void> result;\n+\n+  /**\n+   * {@link #cursorReturnedDoneOrException} indicates whether {@link #tryNext()} has returned {@link\n+   * CursorState#DONE} or a {@link SpannerException}.\n+   */\n+  private volatile boolean cursorReturnedDoneOrException;\n+\n+  /**\n+   * {@link #pausedLatch} is used to pause the producer when the {@link AsyncResultSet} is paused.\n+   * The production of rows that are put into the buffer is only paused once the buffer is full.\n+   */\n+  private volatile CountDownLatch pausedLatch = new CountDownLatch(1);\n+  /**\n+   * {@link #bufferConsumptionLatch} is used to pause the producer when the buffer is full and the\n+   * consumer needs some time to catch up.\n+   */\n+  private volatile CountDownLatch bufferConsumptionLatch = new CountDownLatch(0);\n+  /**\n+   * {@link #consumingLatch} is used to pause the producer when all rows have been put into the\n+   * buffer, but the consumer (the callback) has not yet received and processed all rows.\n+   */\n+  private volatile CountDownLatch consumingLatch = new CountDownLatch(0);\n+\n+  AsyncResultSetImpl(ExecutorProvider executorProvider, ResultSet delegate, int bufferSize) {\n+    super(delegate);\n+    this.buffer = new LinkedBlockingDeque<>(bufferSize);\n+    this.executorProvider = executorProvider;\n+    this.service = MoreExecutors.listeningDecorator(executorProvider.getExecutor());\n+    this.delegateResultSet = delegate;\n+  }\n+\n+  /**\n+   * Closes the {@link AsyncResultSet}. {@link #close()} is non-blocking and may be called multiple\n+   * times without side effects. An {@link AsyncResultSet} may be closed before all rows have been\n+   * returned to the callback, and calling {@link #tryNext()} on a closed {@link AsyncResultSet} is\n+   * allowed as long as this is done from within a {@link ReadyCallback}. Calling {@link #resume()}\n+   * on a closed {@link AsyncResultSet} is also allowed.\n+   */\n+  @Override\n+  public void close() {\n+    synchronized (monitor) {\n+      if (this.closed) {\n+        return;\n+      }\n+      if (state == State.INITIALIZED || state == State.SYNC) {\n+        delegateResultSet.close();\n+      }\n+      this.closed = true;\n+    }\n+  }\n+\n+  /**\n+   * Adds a listener that will be called when no more rows will be read from the underlying {@link\n+   * ResultSet}, either because all rows have been read, or because {@link\n+   * ReadyCallback#cursorReady(AsyncResultSet)} returned {@link CallbackResponse#DONE}.\n+   */\n+  @Override\n+  public void addListener(Runnable listener) {\n+    Preconditions.checkState(state == State.INITIALIZED);\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeListener(Runnable listener) {\n+    Preconditions.checkState(state == State.INITIALIZED);\n+    listeners.remove(listener);\n+  }\n+\n+  /**\n+   * Tries to advance this {@link AsyncResultSet} to the next row. This method may only be called\n+   * from within a {@link ReadyCallback}.\n+   */\n+  @Override\n+  public CursorState tryNext() throws SpannerException {\n+    synchronized (monitor) {\n+      if (state == State.CANCELLED) {\n+        cursorReturnedDoneOrException = true;\n+        throw CANCELLED_EXCEPTION;\n+      }\n+      if (buffer.isEmpty() && executionException != null) {\n+        cursorReturnedDoneOrException = true;\n+        throw executionException;\n+      }\n+      Preconditions.checkState(\n+          this.callback != null, \"tryNext may only be called after a callback has been set.\");\n+      Preconditions.checkState(\n+          this.state == State.CONSUMING,\n+          \"tryNext may only be called from a DataReady callback. Current state: \"\n+              + this.state.name());\n+\n+      if (finished && buffer.isEmpty()) {\n+        cursorReturnedDoneOrException = true;\n+        return CursorState.DONE;\n+      }\n+    }\n+    if (!buffer.isEmpty()) {\n+      // Set the next row from the buffer as the current row of the StructReader.\n+      replaceDelegate(currentRow = buffer.pop());\n+      synchronized (monitor) {\n+        bufferConsumptionLatch.countDown();\n+      }\n+      return CursorState.OK;\n+    }\n+    return CursorState.NOT_READY;\n+  }\n+\n+  /**\n+   * {@link CallbackRunnable} calls the {@link ReadyCallback} registered for this {@link\n+   * AsyncResultSet}.\n+   */\n+  private class CallbackRunnable implements Runnable {\n+    @Override\n+    public void run() {\n+      try {\n+        while (true) {\n+          synchronized (monitor) {\n+            if (cursorReturnedDoneOrException) {\n+              break;\n+            }\n+          }\n+          CallbackResponse response;\n+          try {\n+            response = callback.cursorReady(AsyncResultSetImpl.this);\n+          } catch (Throwable e) {\n+            synchronized (monitor) {\n+              if (cursorReturnedDoneOrException\n+                  && state == State.CANCELLED\n+                  && e instanceof SpannerException\n+                  && ((SpannerException) e).getErrorCode() == ErrorCode.CANCELLED) {\n+                // The callback did not catch the cancelled exception (which it should have), but\n+                // we'll keep the cancelled state.\n+                return;\n+              }\n+              executionException = SpannerExceptionFactory.newSpannerException(e);\n+              cursorReturnedDoneOrException = true;\n+            }\n+            return;\n+          }\n+          synchronized (monitor) {\n+            if (state == State.CANCELLED) {\n+              if (cursorReturnedDoneOrException) {\n+                return;\n+              }\n+            } else {\n+              switch (response) {\n+                case DONE:\n+                  state = State.DONE;\n+                  return;\n+                case PAUSE:\n+                  state = State.PAUSED;\n+                  // Make sure no-one else is waiting on the current pause latch and create a new\n+                  // one.\n+                  pausedLatch.countDown();\n+                  pausedLatch = new CountDownLatch(1);\n+                  return;\n+                case CONTINUE:\n+                  if (buffer.isEmpty()) {\n+                    // Call the callback once more if the entire result set has been processed but\n+                    // the callback has not yet received a CursorState.DONE or a CANCELLED error.\n+                    if (finished && !cursorReturnedDoneOrException) {\n+                      break;\n+                    }\n+                    state = State.RUNNING;\n+                    return;\n+                  }\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\"Unknown response: \" + response);\n+              }\n+            }\n+          }\n+        }\n+      } finally {\n+        synchronized (monitor) {\n+          // Count down all latches that the producer might be waiting on.\n+          consumingLatch.countDown();\n+          while (bufferConsumptionLatch.getCount() > 0L) {\n+            bufferConsumptionLatch.countDown();\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  private final CallbackRunnable callbackRunnable = new CallbackRunnable();\n+\n+  /**\n+   * {@link ProduceRowsCallable} reads data from the underlying {@link ResultSet}, places these in\n+   * the buffer and dispatches the {@link CallbackRunnable} when data is ready to be consumed.\n+   */\n+  private class ProduceRowsCallable implements Callable<Void> {\n+    @Override\n+    public Void call() throws Exception {\n+      boolean stop = false;\n+      boolean hasNext = false;\n+      try {\n+        hasNext = delegateResultSet.next();\n+      } catch (Throwable e) {\n+        synchronized (monitor) {\n+          executionException = SpannerExceptionFactory.newSpannerException(e);\n+        }\n+      }\n+      try {\n+        while (!stop && hasNext) {\n+          try {\n+            synchronized (monitor) {\n+              stop = state.shouldStop;\n+            }\n+            if (!stop) {\n+              while (buffer.remainingCapacity() == 0 && !stop) {\n+                waitIfPaused();\n+                // The buffer is full and we should let the callback consume a number of rows before\n+                // we proceed with producing any more rows to prevent us from potentially waiting on\n+                // a full buffer repeatedly.\n+                // Wait until at least half of the buffer is available, or if it's a bigger buffer,\n+                // wait until at least 10 rows can be placed in it.\n+                // TODO: Make this more dynamic / configurable?\n+                startCallbackWithBufferLatchIfNecessary(\n+                    Math.min(\n+                        Math.min(buffer.size() / 2 + 1, buffer.size()),\n+                        MAX_WAIT_FOR_BUFFER_CONSUMPTION));\n+                bufferConsumptionLatch.await();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgyNDM3Mw==", "bodyText": "Log at INFO-level that the exception has been ignored?", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437824373", "createdAt": "2020-06-10T02:26:30Z", "author": {"login": "elefeint"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncResultSetImpl.java", "diffHunk": "@@ -0,0 +1,567 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.api.core.ListenableFutureToApiFuture;\n+import com.google.api.core.SettableApiFuture;\n+import com.google.api.gax.core.ExecutorProvider;\n+import com.google.cloud.spanner.AbstractReadContext.ListenableAsyncResultSet;\n+import com.google.common.base.Function;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.spanner.v1.ResultSetStats;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingDeque;\n+\n+/** Default implementation for {@link AsyncResultSet}. */\n+class AsyncResultSetImpl extends ForwardingStructReader implements ListenableAsyncResultSet {\n+\n+  /** State of an {@link AsyncResultSetImpl}. */\n+  private enum State {\n+    INITIALIZED,\n+    /** SYNC indicates that the {@link ResultSet} is used in sync pattern. */\n+    SYNC,\n+    CONSUMING,\n+    RUNNING,\n+    PAUSED,\n+    CANCELLED(true),\n+    DONE(true);\n+\n+    /** Does this state mean that the result set should permanently stop producing rows. */\n+    private final boolean shouldStop;\n+\n+    private State() {\n+      shouldStop = false;\n+    }\n+\n+    private State(boolean shouldStop) {\n+      this.shouldStop = shouldStop;\n+    }\n+  }\n+\n+  static final int DEFAULT_BUFFER_SIZE = 10;\n+  private static final int MAX_WAIT_FOR_BUFFER_CONSUMPTION = 10;\n+  private static final SpannerException CANCELLED_EXCEPTION =\n+      SpannerExceptionFactory.newSpannerException(\n+          ErrorCode.CANCELLED, \"This AsyncResultSet has been cancelled\");\n+\n+  private final Object monitor = new Object();\n+  private boolean closed;\n+\n+  /**\n+   * {@link ExecutorProvider} provides executor services that are used to fetch data from the\n+   * backend and put these into the buffer for further consumption by the callback.\n+   */\n+  private final ExecutorProvider executorProvider;\n+\n+  private final ListeningScheduledExecutorService service;\n+\n+  private final BlockingDeque<Struct> buffer;\n+  private Struct currentRow;\n+  /** The underlying synchronous {@link ResultSet} that is producing the rows. */\n+  private final ResultSet delegateResultSet;\n+  /**\n+   * Any exception that occurs while executing the query and iterating over the result set will be\n+   * stored in this variable and propagated to the user through {@link #tryNext()}.\n+   */\n+  private volatile SpannerException executionException;\n+\n+  /**\n+   * Executor for callbacks. Regardless of the type of executor that is provided, the {@link\n+   * AsyncResultSetImpl} will ensure that at most 1 callback call will be active at any one time.\n+   */\n+  private Executor executor;\n+\n+  private ReadyCallback callback;\n+\n+  /**\n+   * Listeners that will be called when the {@link AsyncResultSetImpl} has finished fetching all\n+   * rows and any underlying transaction or session can be closed.\n+   */\n+  private Collection<Runnable> listeners = new LinkedList<>();\n+\n+  private State state = State.INITIALIZED;\n+\n+  /**\n+   * {@link #finished} indicates whether all the results from the underlying result set have been\n+   * read.\n+   */\n+  private volatile boolean finished;\n+\n+  private volatile ApiFuture<Void> result;\n+\n+  /**\n+   * {@link #cursorReturnedDoneOrException} indicates whether {@link #tryNext()} has returned {@link\n+   * CursorState#DONE} or a {@link SpannerException}.\n+   */\n+  private volatile boolean cursorReturnedDoneOrException;\n+\n+  /**\n+   * {@link #pausedLatch} is used to pause the producer when the {@link AsyncResultSet} is paused.\n+   * The production of rows that are put into the buffer is only paused once the buffer is full.\n+   */\n+  private volatile CountDownLatch pausedLatch = new CountDownLatch(1);\n+  /**\n+   * {@link #bufferConsumptionLatch} is used to pause the producer when the buffer is full and the\n+   * consumer needs some time to catch up.\n+   */\n+  private volatile CountDownLatch bufferConsumptionLatch = new CountDownLatch(0);\n+  /**\n+   * {@link #consumingLatch} is used to pause the producer when all rows have been put into the\n+   * buffer, but the consumer (the callback) has not yet received and processed all rows.\n+   */\n+  private volatile CountDownLatch consumingLatch = new CountDownLatch(0);\n+\n+  AsyncResultSetImpl(ExecutorProvider executorProvider, ResultSet delegate, int bufferSize) {\n+    super(delegate);\n+    this.buffer = new LinkedBlockingDeque<>(bufferSize);\n+    this.executorProvider = executorProvider;\n+    this.service = MoreExecutors.listeningDecorator(executorProvider.getExecutor());\n+    this.delegateResultSet = delegate;\n+  }\n+\n+  /**\n+   * Closes the {@link AsyncResultSet}. {@link #close()} is non-blocking and may be called multiple\n+   * times without side effects. An {@link AsyncResultSet} may be closed before all rows have been\n+   * returned to the callback, and calling {@link #tryNext()} on a closed {@link AsyncResultSet} is\n+   * allowed as long as this is done from within a {@link ReadyCallback}. Calling {@link #resume()}\n+   * on a closed {@link AsyncResultSet} is also allowed.\n+   */\n+  @Override\n+  public void close() {\n+    synchronized (monitor) {\n+      if (this.closed) {\n+        return;\n+      }\n+      if (state == State.INITIALIZED || state == State.SYNC) {\n+        delegateResultSet.close();\n+      }\n+      this.closed = true;\n+    }\n+  }\n+\n+  /**\n+   * Adds a listener that will be called when no more rows will be read from the underlying {@link\n+   * ResultSet}, either because all rows have been read, or because {@link\n+   * ReadyCallback#cursorReady(AsyncResultSet)} returned {@link CallbackResponse#DONE}.\n+   */\n+  @Override\n+  public void addListener(Runnable listener) {\n+    Preconditions.checkState(state == State.INITIALIZED);\n+    listeners.add(listener);\n+  }\n+\n+  @Override\n+  public void removeListener(Runnable listener) {\n+    Preconditions.checkState(state == State.INITIALIZED);\n+    listeners.remove(listener);\n+  }\n+\n+  /**\n+   * Tries to advance this {@link AsyncResultSet} to the next row. This method may only be called\n+   * from within a {@link ReadyCallback}.\n+   */\n+  @Override\n+  public CursorState tryNext() throws SpannerException {\n+    synchronized (monitor) {\n+      if (state == State.CANCELLED) {\n+        cursorReturnedDoneOrException = true;\n+        throw CANCELLED_EXCEPTION;\n+      }\n+      if (buffer.isEmpty() && executionException != null) {\n+        cursorReturnedDoneOrException = true;\n+        throw executionException;\n+      }\n+      Preconditions.checkState(\n+          this.callback != null, \"tryNext may only be called after a callback has been set.\");\n+      Preconditions.checkState(\n+          this.state == State.CONSUMING,\n+          \"tryNext may only be called from a DataReady callback. Current state: \"\n+              + this.state.name());\n+\n+      if (finished && buffer.isEmpty()) {\n+        cursorReturnedDoneOrException = true;\n+        return CursorState.DONE;\n+      }\n+    }\n+    if (!buffer.isEmpty()) {\n+      // Set the next row from the buffer as the current row of the StructReader.\n+      replaceDelegate(currentRow = buffer.pop());\n+      synchronized (monitor) {\n+        bufferConsumptionLatch.countDown();\n+      }\n+      return CursorState.OK;\n+    }\n+    return CursorState.NOT_READY;\n+  }\n+\n+  /**\n+   * {@link CallbackRunnable} calls the {@link ReadyCallback} registered for this {@link\n+   * AsyncResultSet}.\n+   */\n+  private class CallbackRunnable implements Runnable {\n+    @Override\n+    public void run() {\n+      try {\n+        while (true) {\n+          synchronized (monitor) {\n+            if (cursorReturnedDoneOrException) {\n+              break;\n+            }\n+          }\n+          CallbackResponse response;\n+          try {\n+            response = callback.cursorReady(AsyncResultSetImpl.this);\n+          } catch (Throwable e) {\n+            synchronized (monitor) {\n+              if (cursorReturnedDoneOrException\n+                  && state == State.CANCELLED\n+                  && e instanceof SpannerException\n+                  && ((SpannerException) e).getErrorCode() == ErrorCode.CANCELLED) {\n+                // The callback did not catch the cancelled exception (which it should have), but\n+                // we'll keep the cancelled state.\n+                return;\n+              }\n+              executionException = SpannerExceptionFactory.newSpannerException(e);\n+              cursorReturnedDoneOrException = true;\n+            }\n+            return;\n+          }\n+          synchronized (monitor) {\n+            if (state == State.CANCELLED) {\n+              if (cursorReturnedDoneOrException) {\n+                return;\n+              }\n+            } else {\n+              switch (response) {\n+                case DONE:\n+                  state = State.DONE;\n+                  return;\n+                case PAUSE:\n+                  state = State.PAUSED;\n+                  // Make sure no-one else is waiting on the current pause latch and create a new\n+                  // one.\n+                  pausedLatch.countDown();\n+                  pausedLatch = new CountDownLatch(1);\n+                  return;\n+                case CONTINUE:\n+                  if (buffer.isEmpty()) {\n+                    // Call the callback once more if the entire result set has been processed but\n+                    // the callback has not yet received a CursorState.DONE or a CANCELLED error.\n+                    if (finished && !cursorReturnedDoneOrException) {\n+                      break;\n+                    }\n+                    state = State.RUNNING;\n+                    return;\n+                  }\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\"Unknown response: \" + response);\n+              }\n+            }\n+          }\n+        }\n+      } finally {\n+        synchronized (monitor) {\n+          // Count down all latches that the producer might be waiting on.\n+          consumingLatch.countDown();\n+          while (bufferConsumptionLatch.getCount() > 0L) {\n+            bufferConsumptionLatch.countDown();\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  private final CallbackRunnable callbackRunnable = new CallbackRunnable();\n+\n+  /**\n+   * {@link ProduceRowsCallable} reads data from the underlying {@link ResultSet}, places these in\n+   * the buffer and dispatches the {@link CallbackRunnable} when data is ready to be consumed.\n+   */\n+  private class ProduceRowsCallable implements Callable<Void> {\n+    @Override\n+    public Void call() throws Exception {\n+      boolean stop = false;\n+      boolean hasNext = false;\n+      try {\n+        hasNext = delegateResultSet.next();\n+      } catch (Throwable e) {\n+        synchronized (monitor) {\n+          executionException = SpannerExceptionFactory.newSpannerException(e);\n+        }\n+      }\n+      try {\n+        while (!stop && hasNext) {\n+          try {\n+            synchronized (monitor) {\n+              stop = state.shouldStop;\n+            }\n+            if (!stop) {\n+              while (buffer.remainingCapacity() == 0 && !stop) {\n+                waitIfPaused();\n+                // The buffer is full and we should let the callback consume a number of rows before\n+                // we proceed with producing any more rows to prevent us from potentially waiting on\n+                // a full buffer repeatedly.\n+                // Wait until at least half of the buffer is available, or if it's a bigger buffer,\n+                // wait until at least 10 rows can be placed in it.\n+                // TODO: Make this more dynamic / configurable?\n+                startCallbackWithBufferLatchIfNecessary(\n+                    Math.min(\n+                        Math.min(buffer.size() / 2 + 1, buffer.size()),\n+                        MAX_WAIT_FOR_BUFFER_CONSUMPTION));\n+                bufferConsumptionLatch.await();\n+                synchronized (monitor) {\n+                  stop = state.shouldStop;\n+                }\n+              }\n+            }\n+            if (!stop) {\n+              buffer.put(delegateResultSet.getCurrentRowAsStruct());\n+              startCallbackIfNecessary();\n+            }\n+            hasNext = delegateResultSet.next();\n+          } catch (Throwable e) {\n+            synchronized (monitor) {\n+              executionException = SpannerExceptionFactory.newSpannerException(e);\n+              stop = true;\n+            }\n+          }\n+        }\n+        // We don't need any more data from the underlying result set, so we close it as soon as\n+        // possible. Any error that might occur during this will be ignored.\n+        try {\n+          delegateResultSet.close();\n+        } catch (Throwable t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 359}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgyODQwMg==", "bodyText": "Out of scope for this PR: should there be a concept of \"giving up\" if the session could not be replaced after N tries?", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437828402", "createdAt": "2020-06-10T02:41:50Z", "author": {"login": "elefeint"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -125,53 +135,117 @@ Instant instant() {\n     }\n   }\n \n+  private abstract static class CachedResultSetSupplier implements Supplier<ResultSet> {\n+    private ResultSet cached;\n+\n+    abstract ResultSet load();\n+\n+    ResultSet reload() {\n+      return cached = load();\n+    }\n+\n+    @Override\n+    public ResultSet get() {\n+      if (cached == null) {\n+        cached = load();\n+      }\n+      return cached;\n+    }\n+  }\n+\n   /**\n    * Wrapper around {@code ReadContext} that releases the session to the pool once the call is\n    * finished, if it is a single use context.\n    */\n   private static class AutoClosingReadContext<T extends ReadContext> implements ReadContext {\n-    private final Function<PooledSession, T> readContextDelegateSupplier;\n+    /**\n+     * {@link AsyncResultSet} implementation that keeps track of the async operations that are still\n+     * running for this {@link ReadContext} and that should finish before the {@link ReadContext}\n+     * releases its session back into the pool.\n+     */\n+    private class AutoClosingReadContextAsyncResultSetImpl extends AsyncResultSetImpl {\n+      private AutoClosingReadContextAsyncResultSetImpl(\n+          ExecutorProvider executorProvider, ResultSet delegate, int bufferRows) {\n+        super(executorProvider, delegate, bufferRows);\n+      }\n+\n+      @Override\n+      public ApiFuture<Void> setCallback(Executor exec, ReadyCallback cb) {\n+        Runnable listener =\n+            new Runnable() {\n+              @Override\n+              public void run() {\n+                synchronized (lock) {\n+                  if (asyncOperationsCount.decrementAndGet() == 0) {\n+                    if (closed) {\n+                      // All async operations for this read context have finished.\n+                      AutoClosingReadContext.this.close();\n+                    }\n+                  }\n+                }\n+              }\n+            };\n+        try {\n+          asyncOperationsCount.incrementAndGet();\n+          addListener(listener);\n+          return super.setCallback(exec, cb);\n+        } catch (Throwable t) {\n+          removeListener(listener);\n+          asyncOperationsCount.decrementAndGet();\n+          throw t;\n+        }\n+      }\n+    }\n+\n+    private final Function<PooledSessionFuture, T> readContextDelegateSupplier;\n     private T readContextDelegate;\n     private final SessionPool sessionPool;\n-    private PooledSession session;\n     private final boolean isSingleUse;\n-    private boolean closed;\n+    private final AtomicInteger asyncOperationsCount = new AtomicInteger();\n+\n+    private Object lock = new Object();\n+\n+    @GuardedBy(\"lock\")\n     private boolean sessionUsedForQuery = false;\n \n+    @GuardedBy(\"lock\")\n+    private PooledSessionFuture session;\n+\n+    @GuardedBy(\"lock\")\n+    private boolean closed;\n+\n+    @GuardedBy(\"lock\")\n+    private boolean delegateClosed;\n+\n     private AutoClosingReadContext(\n-        Function<PooledSession, T> delegateSupplier,\n+        Function<PooledSessionFuture, T> delegateSupplier,\n         SessionPool sessionPool,\n-        PooledSession session,\n+        PooledSessionFuture session,\n         boolean isSingleUse) {\n       this.readContextDelegateSupplier = delegateSupplier;\n       this.sessionPool = sessionPool;\n       this.session = session;\n       this.isSingleUse = isSingleUse;\n-      while (true) {\n-        try {\n-          this.readContextDelegate = readContextDelegateSupplier.apply(this.session);\n-          break;\n-        } catch (SessionNotFoundException e) {\n-          replaceSessionIfPossible(e);\n-        }\n-      }\n     }\n \n     T getReadContextDelegate() {\n+      synchronized (lock) {\n+        if (readContextDelegate == null) {\n+          while (true) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgyOTE3NA==", "bodyText": "Same question as above about giving up. As is currently, the exception will keep getting replaced by the latest one  but never actually bubble up to any calling code.", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437829174", "createdAt": "2020-06-10T02:44:49Z", "author": {"login": "elefeint"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -180,8 +254,18 @@ public boolean next() throws SpannerException {\n             try {\n               return internalNext();\n             } catch (SessionNotFoundException e) {\n-              replaceSessionIfPossible(e);\n-              replaceDelegate(resultSetSupplier.get());\n+              while (true) {\n+                // Keep the replace-if-possible outside the try-block to let the exception bubble up\n+                // if it's too late to replace the session.\n+                replaceSessionIfPossible(e);\n+                try {\n+                  replaceDelegate(resultSetSupplier.reload());\n+                  break;\n+                } catch (SessionNotFoundException snfe) {\n+                  e = snfe;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzMTIxMg==", "bodyText": "Remove stray commented line.", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437831212", "createdAt": "2020-06-10T02:52:31Z", "author": {"login": "elefeint"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -463,39 +717,41 @@ public void close() {\n \n     private TransactionManager delegate;\n     private final SessionPool sessionPool;\n-    private PooledSession session;\n+    private PooledSessionFuture session;\n     private boolean closed;\n     private boolean restartedAfterSessionNotFound;\n \n-    AutoClosingTransactionManager(SessionPool sessionPool, PooledSession session) {\n+    AutoClosingTransactionManager(SessionPool sessionPool, PooledSessionFuture session) {\n       this.sessionPool = sessionPool;\n       this.session = session;\n-      this.delegate = session.delegate.transactionManager();\n+      //      this.delegate = session.delegate.transactionManager();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 625}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzMTg2MA==", "bodyText": "This call to get() looks like it will block waiting for results of the async work?", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437831860", "createdAt": "2020-06-10T02:55:22Z", "author": {"login": "elefeint"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -589,37 +851,104 @@ private SessionPoolTransactionRunner(SessionPool sessionPool, PooledSession sess\n         T result;\n         while (true) {\n           try {\n-            result = runner.run(callable);\n+            result = getRunner().run(callable);\n             break;\n           } catch (SessionNotFoundException e) {\n             session = sessionPool.replaceReadWriteSession(e, session);\n-            runner = session.delegate.readWriteTransaction();\n+            runner = session.get().delegate.readWriteTransaction();\n           }\n         }\n-        session.markUsed();\n+        session.get().markUsed();\n         return result;\n       } catch (SpannerException e) {\n-        throw session.lastException = e;\n+        throw session.get().lastException = e;\n       } finally {\n         session.close();\n       }\n     }\n \n     @Override\n     public Timestamp getCommitTimestamp() {\n-      return runner.getCommitTimestamp();\n+      return getRunner().getCommitTimestamp();\n     }\n \n     @Override\n     public TransactionRunner allowNestedTransaction() {\n-      runner.allowNestedTransaction();\n+      getRunner().allowNestedTransaction();\n       return this;\n     }\n   }\n \n+  private static class SessionPoolAsyncRunner implements AsyncRunner {\n+    private final SessionPool sessionPool;\n+    private volatile PooledSessionFuture session;\n+    private final SettableApiFuture<Timestamp> commitTimestamp = SettableApiFuture.create();\n+\n+    private SessionPoolAsyncRunner(SessionPool sessionPool, PooledSessionFuture session) {\n+      this.sessionPool = sessionPool;\n+      this.session = session;\n+    }\n+\n+    @Override\n+    public <R> ApiFuture<R> runAsync(final AsyncWork<R> work, Executor executor) {\n+      final SettableApiFuture<R> res = SettableApiFuture.create();\n+      executor.execute(\n+          new Runnable() {\n+            @Override\n+            public void run() {\n+              SpannerException se = null;\n+              R r = null;\n+              AsyncRunner runner = null;\n+              while (true) {\n+                try {\n+                  runner = session.get().runAsync();\n+                  r = runner.runAsync(work, MoreExecutors.directExecutor()).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 764}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzMjgyMA==", "bodyText": "Log at INFO? Might be useful for diagnosing subtle issues.", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437832820", "createdAt": "2020-06-10T02:59:12Z", "author": {"login": "elefeint"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -806,6 +1107,176 @@ public TransactionRunner readWriteTransaction() {\n       return new SessionPoolTransactionRunner(SessionPool.this, this);\n     }\n \n+    @Override\n+    public TransactionManager transactionManager() {\n+      return new AutoClosingTransactionManager(SessionPool.this, this);\n+    }\n+\n+    @Override\n+    public AsyncRunner runAsync() {\n+      return new SessionPoolAsyncRunner(SessionPool.this, this);\n+    }\n+\n+    @Override\n+    public long executePartitionedUpdate(Statement stmt) {\n+      try {\n+        return get().executePartitionedUpdate(stmt);\n+      } finally {\n+        close();\n+      }\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return get().getName();\n+    }\n+\n+    @Override\n+    public void prepareReadWriteTransaction() {\n+      get().prepareReadWriteTransaction();\n+    }\n+\n+    @Override\n+    public void close() {\n+      synchronized (lock) {\n+        leakedException = null;\n+        checkedOutSessions.remove(this);\n+      }\n+      get().close();\n+    }\n+\n+    @Override\n+    public ApiFuture<Empty> asyncClose() {\n+      synchronized (lock) {\n+        leakedException = null;\n+        checkedOutSessions.remove(this);\n+      }\n+      return get().asyncClose();\n+    }\n+\n+    @Override\n+    public PooledSession get() {\n+      if (inUse.compareAndSet(false, true)) {\n+        try {\n+          PooledSession res = super.get();\n+          synchronized (lock) {\n+            res.markBusy(span);\n+            span.addAnnotation(sessionAnnotation(res));\n+            incrementNumSessionsInUse();\n+            checkedOutSessions.add(this);\n+          }\n+          initialized.countDown();\n+        } catch (Throwable e) {\n+          initialized.countDown();\n+          // ignore and fallthrough.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 1059}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNjIzNw==", "bodyText": "This is a really long anonymous class implementation. Would it make sense to externalize it to a top-level class or at least least a nested class to improve readability of checkoutSession()?", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437836237", "createdAt": "2020-06-10T03:13:57Z", "author": {"login": "elefeint"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -1485,129 +1956,204 @@ PooledSession getReadSession() throws SpannerException {\n    *       to the pool which is then write prepared.\n    * </ol>\n    */\n-  PooledSession getReadWriteSession() {\n+  PooledSessionFuture getReadWriteSession() {\n     Span span = Tracing.getTracer().getCurrentSpan();\n     span.addAnnotation(\"Acquiring read write session\");\n     PooledSession sess = null;\n-    // Loop to retry SessionNotFoundExceptions that might occur during in-process prepare of a\n-    // session.\n-    while (true) {\n-      Waiter waiter = null;\n-      boolean inProcessPrepare = stopAutomaticPrepare;\n-      synchronized (lock) {\n-        if (closureFuture != null) {\n-          span.addAnnotation(\"Pool has been closed\");\n-          throw new IllegalStateException(\"Pool has been closed\");\n-        }\n-        if (resourceNotFoundException != null) {\n-          span.addAnnotation(\"Database has been deleted\");\n-          throw SpannerExceptionFactory.newSpannerException(\n-              ErrorCode.NOT_FOUND,\n-              String.format(\n-                  \"The session pool has been invalidated because a previous RPC returned 'Database not found': %s\",\n-                  resourceNotFoundException.getMessage()),\n-              resourceNotFoundException);\n-        }\n-        sess = writePreparedSessions.poll();\n-        if (sess == null) {\n-          if (!inProcessPrepare && numSessionsBeingPrepared <= prepareThreadPoolSize) {\n-            if (numSessionsBeingPrepared <= readWriteWaiters.size()) {\n-              PooledSession readSession = readSessions.poll();\n-              if (readSession != null) {\n-                span.addAnnotation(\n-                    \"Acquired read only session. Preparing for read write transaction\");\n-                prepareSession(readSession);\n-              } else {\n-                span.addAnnotation(\"No session available\");\n-                maybeCreateSession();\n-              }\n-            }\n-          } else {\n-            inProcessPrepare = true;\n-            numSessionsInProcessPrepared++;\n+    WaiterFuture waiter = null;\n+    boolean inProcessPrepare = stopAutomaticPrepare;\n+    synchronized (lock) {\n+      if (closureFuture != null) {\n+        span.addAnnotation(\"Pool has been closed\");\n+        throw new IllegalStateException(\"Pool has been closed\");\n+      }\n+      if (resourceNotFoundException != null) {\n+        span.addAnnotation(\"Database has been deleted\");\n+        throw SpannerExceptionFactory.newSpannerException(\n+            ErrorCode.NOT_FOUND,\n+            String.format(\n+                \"The session pool has been invalidated because a previous RPC returned 'Database not found': %s\",\n+                resourceNotFoundException.getMessage()),\n+            resourceNotFoundException);\n+      }\n+      sess = writePreparedSessions.poll();\n+      if (sess == null) {\n+        if (!inProcessPrepare && numSessionsBeingPrepared <= prepareThreadPoolSize) {\n+          if (numSessionsBeingPrepared <= readWriteWaiters.size()) {\n             PooledSession readSession = readSessions.poll();\n             if (readSession != null) {\n-              // Create a read/write transaction in-process if there is already a queue for prepared\n-              // sessions. This is more efficient than doing it asynchronously, as it scales with\n-              // the number of user threads. The thread pool for asynchronously preparing sessions\n-              // is fixed.\n               span.addAnnotation(\n-                  \"Acquired read only session. Preparing in-process for read write transaction\");\n-              sess = readSession;\n+                  \"Acquired read only session. Preparing for read write transaction\");\n+              prepareSession(readSession);\n             } else {\n               span.addAnnotation(\"No session available\");\n               maybeCreateSession();\n             }\n           }\n-          if (sess == null) {\n-            waiter = new Waiter();\n-            if (inProcessPrepare) {\n-              // inProcessPrepare=true means that we have already determined that the queue for\n-              // preparing read/write sessions is larger than the number of threads in the prepare\n-              // thread pool, and that it's more efficient to do the prepare in-process. We will\n-              // therefore create a waiter for a read-only session, even though a read/write session\n-              // has been requested.\n-              readWaiters.add(waiter);\n-            } else {\n-              readWriteWaiters.add(waiter);\n-            }\n-          }\n         } else {\n-          span.addAnnotation(\"Acquired read write session\");\n-        }\n-      }\n-      if (waiter != null) {\n-        logger.log(\n-            Level.FINE,\n-            \"No session available in the pool. Blocking for one to become available/created\");\n-        span.addAnnotation(\"Waiting for read write session to be available\");\n-        sess = waiter.take();\n-      }\n-      if (inProcessPrepare) {\n-        try {\n-          sess.prepareReadWriteTransaction();\n-          // Session prepare succeeded, restart automatic prepare if it had been stopped.\n-          synchronized (lock) {\n-            stopAutomaticPrepare = false;\n-          }\n-        } catch (Throwable t) {\n-          SpannerException e = newSpannerException(t);\n-          if (!isClosed()) {\n-            handlePrepareSessionFailure(e, sess, false);\n+          inProcessPrepare = true;\n+          numSessionsInProcessPrepared++;\n+          PooledSession readSession = readSessions.poll();\n+          if (readSession != null) {\n+            // Create a read/write transaction in-process if there is already a queue for prepared\n+            // sessions. This is more efficient than doing it asynchronously, as it scales with\n+            // the number of user threads. The thread pool for asynchronously preparing sessions\n+            // is fixed.\n+            span.addAnnotation(\n+                \"Acquired read only session. Preparing in-process for read write transaction\");\n+            sess = readSession;\n+          } else {\n+            span.addAnnotation(\"No session available\");\n+            maybeCreateSession();\n           }\n-          sess = null;\n-          if (!isSessionNotFound(e)) {\n-            throw e;\n+        }\n+        if (sess == null) {\n+          waiter = new WaiterFuture();\n+          if (inProcessPrepare) {\n+            // inProcessPrepare=true means that we have already determined that the queue for\n+            // preparing read/write sessions is larger than the number of threads in the prepare\n+            // thread pool, and that it's more efficient to do the prepare in-process. We will\n+            // therefore create a waiter for a read-only session, even though a read/write session\n+            // has been requested.\n+            readWaiters.add(waiter);\n+          } else {\n+            readWriteWaiters.add(waiter);\n           }\n         }\n+      } else {\n+        span.addAnnotation(\"Acquired read write session\");\n       }\n-      if (sess != null) {\n-        break;\n-      }\n+      return checkoutSession(span, sess, waiter, true, inProcessPrepare);\n     }\n-    sess.markBusy();\n-    incrementNumSessionsInUse();\n-    span.addAnnotation(sessionAnnotation(sess));\n-    return sess;\n   }\n \n-  PooledSession replaceReadSession(SessionNotFoundException e, PooledSession session) {\n+  private PooledSessionFuture checkoutSession(\n+      final Span span,\n+      final PooledSession readySession,\n+      WaiterFuture waiter,\n+      boolean write,\n+      final boolean inProcessPrepare) {\n+    Future<PooledSession> sessionFuture;\n+    if (waiter != null) {\n+      logger.log(\n+          Level.FINE,\n+          \"No session available in the pool. Blocking for one to become available/created\");\n+      span.addAnnotation(\n+          String.format(\n+              \"Waiting for %s session to be available\", write ? \"read write\" : \"read only\"));\n+      sessionFuture = waiter;\n+    } else {\n+      sessionFuture = ApiFutures.immediateFuture(readySession);\n+    }\n+    SimpleForwardingFuture<PooledSession> forwardingFuture =\n+        new SimpleForwardingFuture<SessionPool.PooledSession>(sessionFuture) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 1563}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzNzM4OA==", "bodyText": "Should we specify \"spanner\" in the thread prefix? It can be hard to troubleshoot where wild threadpools come from when an application uses multiple client libraries..", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437837388", "createdAt": "2020-06-10T03:18:44Z", "author": {"login": "elefeint"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SpannerOptions.java", "diffHunk": "@@ -134,6 +143,66 @@ public ServiceRpc create(SpannerOptions options) {\n     }\n   }\n \n+  private static final AtomicInteger DEFAULT_POOL_COUNT = new AtomicInteger();\n+\n+  /** {@link ExecutorProvider} that is used for {@link AsyncResultSet}. */\n+  interface CloseableExecutorProvider extends ExecutorProvider, AutoCloseable {\n+    /** Overridden to suppress the throws declaration of the super interface. */\n+    @Override\n+    public void close();\n+  }\n+\n+  static class FixedCloseableExecutorProvider implements CloseableExecutorProvider {\n+    private final ScheduledExecutorService executor;\n+\n+    private FixedCloseableExecutorProvider(ScheduledExecutorService executor) {\n+      this.executor = Preconditions.checkNotNull(executor);\n+    }\n+\n+    @Override\n+    public void close() {\n+      executor.shutdown();\n+    }\n+\n+    @Override\n+    public ScheduledExecutorService getExecutor() {\n+      return executor;\n+    }\n+\n+    @Override\n+    public boolean shouldAutoClose() {\n+      return false;\n+    }\n+\n+    /** Creates a FixedCloseableExecutorProvider. */\n+    static FixedCloseableExecutorProvider create(ScheduledExecutorService executor) {\n+      return new FixedCloseableExecutorProvider(executor);\n+    }\n+  }\n+\n+  /**\n+   * Default {@link ExecutorProvider} for high-level async calls that need an executor. The default\n+   * uses a cached thread pool containing a max of 8 threads. The pool is lazily initialized and\n+   * will not create any threads if the user application does not use any async methods. It will\n+   * also scale down the thread usage if the async load allows for that.\n+   */\n+  @VisibleForTesting\n+  static CloseableExecutorProvider createDefaultAsyncExecutorProvider() {\n+    return createAsyncExecutorProvider(8, 60L, TimeUnit.SECONDS);\n+  }\n+\n+  @VisibleForTesting\n+  static CloseableExecutorProvider createAsyncExecutorProvider(\n+      int poolSize, long keepAliveTime, TimeUnit unit) {\n+    String format = String.format(\"async-pool-%d-thread-%%d\", DEFAULT_POOL_COUNT.incrementAndGet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 96}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c662ed75db1d9e4630ef0d7289f95fb86b081925", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/c662ed75db1d9e4630ef0d7289f95fb86b081925", "committedDate": "2020-06-10T08:35:16Z", "message": "feat: steps to add async support for tx manager"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NTIxMjU1", "url": "https://github.com/googleapis/java-spanner/pull/81#pullrequestreview-427521255", "createdAt": "2020-06-09T20:36:46Z", "commit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMDozNjo0N1rOGhbPtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMTo1MDowM1rOGhdq-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcwMjU4Mw==", "bodyText": "minor nit: I would suggest organizing the order of the nested members here - either to move all nested classes/interfaces to the bottom or move them closer to the first place they're used; for example ReadyCallback can be moved closer to setCallback", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437702583", "createdAt": "2020-06-09T20:36:47Z", "author": {"login": "dzou"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncResultSet.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.base.Function;\n+import com.google.common.collect.ImmutableList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+/** Interface for result sets returned by async query methods. */\n+public interface AsyncResultSet extends ResultSet {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcwNTQ2MQ==", "bodyText": "Should this begin with <p>The transaction runner; looks like the paragraph was cut off from the starting sentence.", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437705461", "createdAt": "2020-06-09T20:42:09Z", "author": {"login": "dzou"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncRunner.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.cloud.Timestamp;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+public interface AsyncRunner {\n+\n+  interface AsyncWork<R> {\n+    /**\n+     * Performs a single transaction attempt. All reads/writes should be performed using {@code\n+     * txn}.\n+     *\n+     * <p>Implementations of this method should not attempt to commit the transaction directly:\n+     * returning normally will result in the runner attempting to commit the transaction once the\n+     * returned future completes, retrying on abort.\n+     *\n+     * <p>In most cases, the implementation will not need to catch {@code SpannerException}s from\n+     * Spanner operations, instead letting these propagate to the framework. The transaction runner\n+     *\n+     * <p>will take appropriate action based on the type of exception. In particular,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxMDQzMA==", "bodyText": "For readability, you could rename the variable r to response to give hint on what R is.", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437710430", "createdAt": "2020-06-09T20:49:06Z", "author": {"login": "dzou"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncRunnerImpl.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.api.core.SettableApiFuture;\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.TransactionRunner.TransactionCallable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+class AsyncRunnerImpl implements AsyncRunner {\n+  private final TransactionRunnerImpl delegate;\n+  private final SettableApiFuture<Timestamp> commitTimestamp = SettableApiFuture.create();\n+\n+  AsyncRunnerImpl(TransactionRunnerImpl delegate) {\n+    this.delegate = delegate;\n+  }\n+\n+  @Override\n+  public <R> ApiFuture<R> runAsync(final AsyncWork<R> work, Executor executor) {\n+    final SettableApiFuture<R> res = SettableApiFuture.create();\n+    executor.execute(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              R r =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxMTQzMw==", "bodyText": "Might need to add a short sentence clarifying the type R (which I assume refers to the response object type?).", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437711433", "createdAt": "2020-06-09T20:50:17Z", "author": {"login": "dzou"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncRunner.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.cloud.Timestamp;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+public interface AsyncRunner {\n+\n+  interface AsyncWork<R> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxNjc1NQ==", "bodyText": "For this call - instead of calling .get() directly, should you instead set the value of the settable future in a callback? Something like:\nwork.doWorkAsync(transaction).addCallback((result) -> res.set(result));\n\nI might be misunderstanding this though.", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437716755", "createdAt": "2020-06-09T20:56:40Z", "author": {"login": "dzou"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncRunnerImpl.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.api.core.SettableApiFuture;\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.TransactionRunner.TransactionCallable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+class AsyncRunnerImpl implements AsyncRunner {\n+  private final TransactionRunnerImpl delegate;\n+  private final SettableApiFuture<Timestamp> commitTimestamp = SettableApiFuture.create();\n+\n+  AsyncRunnerImpl(TransactionRunnerImpl delegate) {\n+    this.delegate = delegate;\n+  }\n+\n+  @Override\n+  public <R> ApiFuture<R> runAsync(final AsyncWork<R> work, Executor executor) {\n+    final SettableApiFuture<R> res = SettableApiFuture.create();\n+    executor.execute(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              R r =\n+                  delegate.run(\n+                      new TransactionCallable<R>() {\n+                        @Override\n+                        public R run(TransactionContext transaction) throws Exception {\n+                          try {\n+                            return work.doWorkAsync(transaction).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxNzQyNQ==", "bodyText": "Might be nice to move this to a separate private static helper method to reduce levels of nesting.", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437717425", "createdAt": "2020-06-09T20:57:28Z", "author": {"login": "dzou"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncRunnerImpl.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.api.core.SettableApiFuture;\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.TransactionRunner.TransactionCallable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+class AsyncRunnerImpl implements AsyncRunner {\n+  private final TransactionRunnerImpl delegate;\n+  private final SettableApiFuture<Timestamp> commitTimestamp = SettableApiFuture.create();\n+\n+  AsyncRunnerImpl(TransactionRunnerImpl delegate) {\n+    this.delegate = delegate;\n+  }\n+\n+  @Override\n+  public <R> ApiFuture<R> runAsync(final AsyncWork<R> work, Executor executor) {\n+    final SettableApiFuture<R> res = SettableApiFuture.create();\n+    executor.execute(\n+        new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              R r =\n+                  delegate.run(\n+                      new TransactionCallable<R>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyMTMwOA==", "bodyText": "No issues here - just wondering what use-cases a forwarding result set helps with.", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437721308", "createdAt": "2020-06-09T21:03:32Z", "author": {"login": "dzou"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/ForwardingAsyncResultSet.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.base.Function;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import java.util.concurrent.Executor;\n+\n+/** Forwarding implementation of {@link AsyncResultSet} that forwards all calls to a delegate. */\n+public class ForwardingAsyncResultSet extends ForwardingResultSet implements AsyncResultSet {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyNTAyMA==", "bodyText": "I saw that several of the ForwardingXReaders were modified to use suppliers - Just curious what was the rationale behind the decision? I suppose it must be covering a caching use case.", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437725020", "createdAt": "2020-06-09T21:11:03Z", "author": {"login": "dzou"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/ForwardingStructReader.java", "diffHunk": "@@ -20,14 +20,20 @@\n import com.google.cloud.Date;\n import com.google.cloud.Timestamp;\n import com.google.common.base.Preconditions;\n+import com.google.common.base.Supplier;\n+import com.google.common.base.Suppliers;\n import java.util.List;\n \n /** Forwarding implements of StructReader */\n public class ForwardingStructReader implements StructReader {\n \n-  private StructReader delegate;\n+  private Supplier<? extends StructReader> delegate;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyNjUwOA==", "bodyText": "No-op method could be removed? If it was intentionally no-op for override, you can add a comment to clarify reason.", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437726508", "createdAt": "2020-06-09T21:14:21Z", "author": {"login": "dzou"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java", "diffHunk": "@@ -101,4 +102,7 @@ long executePartitionedUpdate(final Statement statement, final Duration timeout)\n   public void invalidate() {\n     isValid = false;\n   }\n+\n+  @Override\n+  public void setSpan(Span span) {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzczMDg2NQ==", "bodyText": "public static is redundant for inner interfaces; seems like you may omit public from the enums too.", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437730865", "createdAt": "2020-06-09T21:23:43Z", "author": {"login": "dzou"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncResultSet.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.base.Function;\n+import com.google.common.collect.ImmutableList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+/** Interface for result sets returned by async query methods. */\n+public interface AsyncResultSet extends ResultSet {\n+\n+  /**\n+   * Interface for receiving asynchronous callbacks when new data is ready. See {@link\n+   * AsyncResultSet#setCallback(Executor, ReadyCallback)}.\n+   */\n+  public static interface ReadyCallback {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzczODY0Mg==", "bodyText": "If this is true, is there any penalty for writing a callback which consumes one result at a time and returns CONTINUE? (No usage of while(true) to consume everything in the resultset).\nSomething like:\n    public CallbackResponse cursorReady(AsyncResultSet rs) {\n      switch(rs.tryNext()) {\n        case OK:\n          System.out.println(rs.getRow());\n          return CallbackResponse.CONTINUE;\n        case NOT_READY:\n          return CallbackResponse.CONTINUE;\n      }\n      return CallbackResponse.DONE;\n    }\n\nI find this more intuitive than trying to remember that the resultset might have multiple rows of available data that should be consumed before calling CONTINUE. Curious what your thoughts are.", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437738642", "createdAt": "2020-06-09T21:41:07Z", "author": {"login": "dzou"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/AsyncResultSet.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 Google LLC\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.cloud.spanner;\n+\n+import com.google.api.core.ApiFuture;\n+import com.google.common.base.Function;\n+import com.google.common.collect.ImmutableList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+/** Interface for result sets returned by async query methods. */\n+public interface AsyncResultSet extends ResultSet {\n+\n+  /**\n+   * Interface for receiving asynchronous callbacks when new data is ready. See {@link\n+   * AsyncResultSet#setCallback(Executor, ReadyCallback)}.\n+   */\n+  public static interface ReadyCallback {\n+    CallbackResponse cursorReady(AsyncResultSet resultSet);\n+  }\n+\n+  /** Response code from {@code tryNext()}. */\n+  public enum CursorState {\n+    /** Cursor has been moved to a new row. */\n+    OK,\n+    /** Read is complete, all rows have been consumed, and there are no more. */\n+    DONE,\n+    /** No further information known at this time, thus current row not available. */\n+    NOT_READY\n+  }\n+\n+  /**\n+   * Non-blocking call that attempts to step the cursor to the next position in the stream. The\n+   * cursor may be inspected only if the cursor returns {@code CursorState.OK}.\n+   *\n+   * <p>A caller will typically call {@link #tryNext()} in a loop inside the ReadyCallback,\n+   * consuming all results available. For more information see {@link #setCallback(Executor,\n+   * ReadyCallback)}.\n+   *\n+   * <p>Currently this method may only be called if a ReadyCallback has been registered. This is for\n+   * safety purposes only, and may be relaxed in future.\n+   *\n+   * @return current cursor readiness state\n+   * @throws SpannerException When an unrecoverable problem downstream occurs. Once this occurs you\n+   *     will get no further callbacks. You should return CallbackResponse.DONE back from callback.\n+   */\n+  CursorState tryNext() throws SpannerException;\n+\n+  /**\n+   * Register a callback with the ResultSet to be made aware when more data is available, changing\n+   * the usage pattern from sync to async. Details:\n+   *\n+   * <ul>\n+   *   <li>The callback will be called at least once.\n+   *   <li>The callback is run each time more results are available, or when we discover that there\n+   *       will be no more results. (unless paused, see below). Spurious callbacks are possible, see\n+   *       below.\n+   *   <li>Spanner guarantees that one callback is ever outstanding at a time. Also, future\n+   *       callbacks guarantee the \"happens before\" property with previous callbacks.\n+   *   <li>A callback normally consumes all available data in the ResultSet, and then returns {@link\n+   *       CallbackResponse#CONTINUE}.\n+   *   <li>If a callback returns {@link CallbackResponse#CONTINUE} with data still in the ResultSet,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0MDA3NQ==", "bodyText": "How are these executors shutdown after the async resultset is consumed or no longer used?", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437740075", "createdAt": "2020-06-09T21:44:42Z", "author": {"login": "dzou"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/ResultSets.java", "diffHunk": "@@ -41,6 +43,21 @@ public static ResultSet forRows(Type type, Iterable<Struct> rows) {\n     return new PrePopulatedResultSet(type, rows);\n   }\n \n+  /** Converts the given {@link ResultSet} to an {@link AsyncResultSet}. */\n+  public static AsyncResultSet toAsyncResultSet(ResultSet delegate) {\n+    return new AsyncResultSetImpl(\n+        InstantiatingExecutorProvider.newBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0MjMzMA==", "bodyText": "Can this condition be written as if (asyncOperationsCount.decrementAndGet() == 0 && closed)?", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r437742330", "createdAt": "2020-06-09T21:50:03Z", "author": {"login": "dzou"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -125,53 +135,117 @@ Instant instant() {\n     }\n   }\n \n+  private abstract static class CachedResultSetSupplier implements Supplier<ResultSet> {\n+    private ResultSet cached;\n+\n+    abstract ResultSet load();\n+\n+    ResultSet reload() {\n+      return cached = load();\n+    }\n+\n+    @Override\n+    public ResultSet get() {\n+      if (cached == null) {\n+        cached = load();\n+      }\n+      return cached;\n+    }\n+  }\n+\n   /**\n    * Wrapper around {@code ReadContext} that releases the session to the pool once the call is\n    * finished, if it is a single use context.\n    */\n   private static class AutoClosingReadContext<T extends ReadContext> implements ReadContext {\n-    private final Function<PooledSession, T> readContextDelegateSupplier;\n+    /**\n+     * {@link AsyncResultSet} implementation that keeps track of the async operations that are still\n+     * running for this {@link ReadContext} and that should finish before the {@link ReadContext}\n+     * releases its session back into the pool.\n+     */\n+    private class AutoClosingReadContextAsyncResultSetImpl extends AsyncResultSetImpl {\n+      private AutoClosingReadContextAsyncResultSetImpl(\n+          ExecutorProvider executorProvider, ResultSet delegate, int bufferRows) {\n+        super(executorProvider, delegate, bufferRows);\n+      }\n+\n+      @Override\n+      public ApiFuture<Void> setCallback(Executor exec, ReadyCallback cb) {\n+        Runnable listener =\n+            new Runnable() {\n+              @Override\n+              public void run() {\n+                synchronized (lock) {\n+                  if (asyncOperationsCount.decrementAndGet() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7dd1dd3376784cf24e8aeb64a7155e26b9192d5"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "226f91bcaf0178c62d49156e6d973c26e66d3676", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/226f91bcaf0178c62d49156e6d973c26e66d3676", "committedDate": "2020-06-11T16:30:44Z", "message": "review: process review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a10b61c54c0b0f8a79a5d8a2733424213e512823", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/a10b61c54c0b0f8a79a5d8a2733424213e512823", "committedDate": "2020-06-11T17:00:53Z", "message": "fix: run formatter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64b8a349a85a9a16404939f3e9384eeb9f9b8eda", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/64b8a349a85a9a16404939f3e9384eeb9f9b8eda", "committedDate": "2020-06-11T17:02:19Z", "message": "chore: remove unused code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3354344a4d1ce961e076b0ecddc036323da5e85b", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/3354344a4d1ce961e076b0ecddc036323da5e85b", "committedDate": "2020-06-11T18:47:36Z", "message": "clirr: add ignored differences to clirr"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b2a6a4af0d382a18c051dd968560df2532cc7a4", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/2b2a6a4af0d382a18c051dd968560df2532cc7a4", "committedDate": "2020-06-12T05:46:21Z", "message": "Merge branch 'master' into async-api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fada1c780452a251507048b6580d168cb84b9a0", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/1fada1c780452a251507048b6580d168cb84b9a0", "committedDate": "2020-06-12T09:17:21Z", "message": "fix: call listeners after all rows have been consumed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35743e6a8dc2949c9fd2d37a57233aa7a9b05759", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/35743e6a8dc2949c9fd2d37a57233aa7a9b05759", "committedDate": "2020-06-12T20:43:51Z", "message": "feat: towards AsyncTransactionManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48de42e7385d23514c8ae4b2ef11caa7f5ed2dd1", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/48de42e7385d23514c8ae4b2ef11caa7f5ed2dd1", "committedDate": "2020-06-13T06:14:18Z", "message": "Merge branch 'master' into async-api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "888edd819565eff78c3a48fbdca58de57d9c8869", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/888edd819565eff78c3a48fbdca58de57d9c8869", "committedDate": "2020-06-13T13:43:49Z", "message": "fix: session leaks + code format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2a7176d994aacc0b413d6cf19b2da42fae0f2bd", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/b2a7176d994aacc0b413d6cf19b2da42fae0f2bd", "committedDate": "2020-06-13T14:48:15Z", "message": "fix: more session leak fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fba270fbf62f73bc0489a2ce8626e5b011ff1416", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/fba270fbf62f73bc0489a2ce8626e5b011ff1416", "committedDate": "2020-06-14T20:10:40Z", "message": "feat: further work on AsyncTransactionManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a0ad3ff5db6c35d7a36a277d6b9154d47dd9c42", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/8a0ad3ff5db6c35d7a36a277d6b9154d47dd9c42", "committedDate": "2020-06-15T06:22:39Z", "message": "fix: fix test failures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80224575e37ed9d0d906ae2de5d1bfbc1d35e370", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/80224575e37ed9d0d906ae2de5d1bfbc1d35e370", "committedDate": "2020-06-15T20:29:03Z", "message": "fix: fix several race conditions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e84d344896c53f2f18a4ad2e7cb9b58bc5b4e46", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/5e84d344896c53f2f18a4ad2e7cb9b58bc5b4e46", "committedDate": "2020-06-15T21:40:59Z", "message": "tests: increase test timeout"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "707382b112d164768147119e527e9ace16db9391", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/707382b112d164768147119e527e9ace16db9391", "committedDate": "2020-06-21T05:54:53Z", "message": "Merge branch 'master' into async-api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fcf37fda8ca063231d13055225f63f48d1508a4d", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/fcf37fda8ca063231d13055225f63f48d1508a4d", "committedDate": "2020-06-21T10:48:19Z", "message": "feat: further towards AsyncTransactionManager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "910b6c7d0eb62666061efaf25e43c2de42b0bc83", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/910b6c7d0eb62666061efaf25e43c2de42b0bc83", "committedDate": "2020-06-21T16:15:49Z", "message": "feat: require executor for transaction functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86f85c0545368160b7d5f93fb0492792f3337014", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/86f85c0545368160b7d5f93fb0492792f3337014", "committedDate": "2020-06-21T18:06:31Z", "message": "revert: remove async connection api from branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5af48f511da94df8dec03a276f42a0908f6d1cd", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/f5af48f511da94df8dec03a276f42a0908f6d1cd", "committedDate": "2020-06-21T18:30:38Z", "message": "chore: run code formatter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b38d16481c121c183aa1b781d50ee1f476954b2f", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/b38d16481c121c183aa1b781d50ee1f476954b2f", "committedDate": "2020-06-21T18:50:01Z", "message": "chore: fix flaky test case"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5NjYwMDU2", "url": "https://github.com/googleapis/java-spanner/pull/81#pullrequestreview-439660056", "createdAt": "2020-06-30T04:23:44Z", "commit": {"oid": "b38d16481c121c183aa1b781d50ee1f476954b2f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fda9f011f634fbd5ec5f1b7259d1e148dcb6c510", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/fda9f011f634fbd5ec5f1b7259d1e148dcb6c510", "committedDate": "2020-06-30T15:47:37Z", "message": "Merge branch 'master' into async-api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eee881a80e106cd878bd61b1f96419a989937e0a", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/eee881a80e106cd878bd61b1f96419a989937e0a", "committedDate": "2020-06-30T16:34:44Z", "message": "tests: fix ITs for emulator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1ef6405d49286055f2f27ebc0861bb3ac7f9296", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/a1ef6405d49286055f2f27ebc0861bb3ac7f9296", "committedDate": "2020-06-30T17:10:39Z", "message": "fix: SpannerOptions.toBuilder().host should override emulatorHost"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea45612620d9d5807f4de936aaf90a8e9c26833a", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/ea45612620d9d5807f4de936aaf90a8e9c26833a", "committedDate": "2020-06-30T17:57:25Z", "message": "tests: fix potentially hanging test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjkzMjg5Njkw", "url": "https://github.com/googleapis/java-spanner/pull/81#pullrequestreview-693289690", "createdAt": "2021-06-26T08:02:37Z", "commit": {"oid": "ea45612620d9d5807f4de936aaf90a8e9c26833a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNlQwODowMjozN1rOJ0mhWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yNlQwODowMjozN1rOJ0mhWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTEzNjg1Nw==", "bodyText": "how do we set asyncExecutorProvider?", "url": "https://github.com/googleapis/java-spanner/pull/81#discussion_r659136857", "createdAt": "2021-06-26T08:02:37Z", "author": {"login": "pravsingh"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SpannerImpl.java", "diffHunk": "@@ -140,6 +149,13 @@ QueryOptions getDefaultQueryOptions(DatabaseId databaseId) {\n     return getOptions().getDefaultQueryOptions(databaseId);\n   }\n \n+  /**\n+   * Returns the {@link ExecutorProvider} to use for async methods that need a background executor.\n+   */\n+  public ExecutorProvider getAsyncExecutorProvider() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea45612620d9d5807f4de936aaf90a8e9c26833a"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 871, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}