{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM3MDY3NjUx", "number": 287, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNTowNTowNlrOEJ7pOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNTowNTowNlrOEJ7pOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4ODQ5ODUxOnYy", "diffSide": "RIGHT", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwNTowNTowNlrOGqr1ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNDoyNjoyMlrOGq_BIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxMTU3OQ==", "bodyText": "nit: I don't know if you need to check for the resumeToken != null condition since you always init it to EMPTY and only update it if it's not null.", "url": "https://github.com/googleapis/java-spanner/pull/287#discussion_r447411579", "createdAt": "2020-06-30T05:05:06Z", "author": {"login": "skuruppu"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java", "diffHunk": "@@ -60,41 +72,88 @@ private ByteString initTransaction() {\n \n   /**\n    * Executes the {@link Statement} using a partitioned dml transaction with automatic retry if the\n-   * transaction was aborted.\n+   * transaction was aborted. The update method uses the ExecuteStreamingSql RPC to execute the\n+   * statement, and will retry the stream if an {@link UnavailableException} is thrown, using the\n+   * last seen resume token if the server returns any.\n    */\n-  long executePartitionedUpdate(final Statement statement) {\n+  long executeStreamingPartitionedUpdate(final Statement statement, Duration timeout) {\n     checkState(isValid, \"Partitioned DML has been invalidated by a new operation on the session\");\n-    Callable<com.google.spanner.v1.ResultSet> callable =\n-        new Callable<com.google.spanner.v1.ResultSet>() {\n-          @Override\n-          public com.google.spanner.v1.ResultSet call() throws Exception {\n-            ByteString transactionId = initTransaction();\n-            final ExecuteSqlRequest.Builder builder =\n-                ExecuteSqlRequest.newBuilder()\n-                    .setSql(statement.getSql())\n-                    .setQueryMode(QueryMode.NORMAL)\n-                    .setSession(session.getName())\n-                    .setTransaction(TransactionSelector.newBuilder().setId(transactionId).build());\n-            Map<String, Value> stmtParameters = statement.getParameters();\n-            if (!stmtParameters.isEmpty()) {\n-              com.google.protobuf.Struct.Builder paramsBuilder = builder.getParamsBuilder();\n-              for (Map.Entry<String, Value> param : stmtParameters.entrySet()) {\n-                paramsBuilder.putFields(param.getKey(), param.getValue().toProto());\n-                builder.putParamTypes(param.getKey(), param.getValue().getType().toProto());\n+    log.log(Level.FINER, \"Starting PartitionedUpdate statement\");\n+    boolean foundStats = false;\n+    long updateCount = 0L;\n+    Duration remainingTimeout = timeout;\n+    Stopwatch stopWatch = Stopwatch.createStarted();\n+    try {\n+      // Loop to catch AbortedExceptions.\n+      while (true) {\n+        ByteString resumeToken = ByteString.EMPTY;\n+        try {\n+          ByteString transactionId = initTransaction();\n+          final ExecuteSqlRequest.Builder builder =\n+              ExecuteSqlRequest.newBuilder()\n+                  .setSql(statement.getSql())\n+                  .setQueryMode(QueryMode.NORMAL)\n+                  .setSession(session.getName())\n+                  .setTransaction(TransactionSelector.newBuilder().setId(transactionId).build());\n+          Map<String, Value> stmtParameters = statement.getParameters();\n+          if (!stmtParameters.isEmpty()) {\n+            com.google.protobuf.Struct.Builder paramsBuilder = builder.getParamsBuilder();\n+            for (Map.Entry<String, Value> param : stmtParameters.entrySet()) {\n+              paramsBuilder.putFields(param.getKey(), param.getValue().toProto());\n+              builder.putParamTypes(param.getKey(), param.getValue().getType().toProto());\n+            }\n+          }\n+          while (true) {\n+            remainingTimeout =\n+                remainingTimeout.minus(stopWatch.elapsed(TimeUnit.MILLISECONDS), ChronoUnit.MILLIS);\n+            try {\n+              builder.setResumeToken(resumeToken);\n+              ServerStream<PartialResultSet> stream =\n+                  rpc.executeStreamingPartitionedDml(\n+                      builder.build(), session.getOptions(), remainingTimeout);\n+              for (PartialResultSet rs : stream) {\n+                if (rs.getResumeToken() != null && !ByteString.EMPTY.equals(rs.getResumeToken())) {\n+                  resumeToken = rs.getResumeToken();\n+                }\n+                if (rs.hasStats()) {\n+                  foundStats = true;\n+                  updateCount += rs.getStats().getRowCountLowerBound();\n+                }\n+              }\n+              break;\n+            } catch (UnavailableException e) {\n+              // Retry the stream in the same transaction if the stream breaks with\n+              // UnavailableException and we have a resume token. Otherwise, we just retry the\n+              // entire transaction.\n+              if (resumeToken != null && !ByteString.EMPTY.equals(resumeToken)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52f91e3af1c20030b0f416ce0789447866065cfb"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzcyNTg1Ng==", "bodyText": "Good point, done.", "url": "https://github.com/googleapis/java-spanner/pull/287#discussion_r447725856", "createdAt": "2020-06-30T14:26:22Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/PartitionedDMLTransaction.java", "diffHunk": "@@ -60,41 +72,88 @@ private ByteString initTransaction() {\n \n   /**\n    * Executes the {@link Statement} using a partitioned dml transaction with automatic retry if the\n-   * transaction was aborted.\n+   * transaction was aborted. The update method uses the ExecuteStreamingSql RPC to execute the\n+   * statement, and will retry the stream if an {@link UnavailableException} is thrown, using the\n+   * last seen resume token if the server returns any.\n    */\n-  long executePartitionedUpdate(final Statement statement) {\n+  long executeStreamingPartitionedUpdate(final Statement statement, Duration timeout) {\n     checkState(isValid, \"Partitioned DML has been invalidated by a new operation on the session\");\n-    Callable<com.google.spanner.v1.ResultSet> callable =\n-        new Callable<com.google.spanner.v1.ResultSet>() {\n-          @Override\n-          public com.google.spanner.v1.ResultSet call() throws Exception {\n-            ByteString transactionId = initTransaction();\n-            final ExecuteSqlRequest.Builder builder =\n-                ExecuteSqlRequest.newBuilder()\n-                    .setSql(statement.getSql())\n-                    .setQueryMode(QueryMode.NORMAL)\n-                    .setSession(session.getName())\n-                    .setTransaction(TransactionSelector.newBuilder().setId(transactionId).build());\n-            Map<String, Value> stmtParameters = statement.getParameters();\n-            if (!stmtParameters.isEmpty()) {\n-              com.google.protobuf.Struct.Builder paramsBuilder = builder.getParamsBuilder();\n-              for (Map.Entry<String, Value> param : stmtParameters.entrySet()) {\n-                paramsBuilder.putFields(param.getKey(), param.getValue().toProto());\n-                builder.putParamTypes(param.getKey(), param.getValue().getType().toProto());\n+    log.log(Level.FINER, \"Starting PartitionedUpdate statement\");\n+    boolean foundStats = false;\n+    long updateCount = 0L;\n+    Duration remainingTimeout = timeout;\n+    Stopwatch stopWatch = Stopwatch.createStarted();\n+    try {\n+      // Loop to catch AbortedExceptions.\n+      while (true) {\n+        ByteString resumeToken = ByteString.EMPTY;\n+        try {\n+          ByteString transactionId = initTransaction();\n+          final ExecuteSqlRequest.Builder builder =\n+              ExecuteSqlRequest.newBuilder()\n+                  .setSql(statement.getSql())\n+                  .setQueryMode(QueryMode.NORMAL)\n+                  .setSession(session.getName())\n+                  .setTransaction(TransactionSelector.newBuilder().setId(transactionId).build());\n+          Map<String, Value> stmtParameters = statement.getParameters();\n+          if (!stmtParameters.isEmpty()) {\n+            com.google.protobuf.Struct.Builder paramsBuilder = builder.getParamsBuilder();\n+            for (Map.Entry<String, Value> param : stmtParameters.entrySet()) {\n+              paramsBuilder.putFields(param.getKey(), param.getValue().toProto());\n+              builder.putParamTypes(param.getKey(), param.getValue().getType().toProto());\n+            }\n+          }\n+          while (true) {\n+            remainingTimeout =\n+                remainingTimeout.minus(stopWatch.elapsed(TimeUnit.MILLISECONDS), ChronoUnit.MILLIS);\n+            try {\n+              builder.setResumeToken(resumeToken);\n+              ServerStream<PartialResultSet> stream =\n+                  rpc.executeStreamingPartitionedDml(\n+                      builder.build(), session.getOptions(), remainingTimeout);\n+              for (PartialResultSet rs : stream) {\n+                if (rs.getResumeToken() != null && !ByteString.EMPTY.equals(rs.getResumeToken())) {\n+                  resumeToken = rs.getResumeToken();\n+                }\n+                if (rs.hasStats()) {\n+                  foundStats = true;\n+                  updateCount += rs.getStats().getRowCountLowerBound();\n+                }\n+              }\n+              break;\n+            } catch (UnavailableException e) {\n+              // Retry the stream in the same transaction if the stream breaks with\n+              // UnavailableException and we have a resume token. Otherwise, we just retry the\n+              // entire transaction.\n+              if (resumeToken != null && !ByteString.EMPTY.equals(resumeToken)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxMTU3OQ=="}, "originalCommit": {"oid": "52f91e3af1c20030b0f416ce0789447866065cfb"}, "originalPosition": 110}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3194, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}