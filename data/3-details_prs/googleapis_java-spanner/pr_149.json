{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMTk0MTA3", "number": 149, "title": "tests: add test for session distribution", "bodyText": "Adds an additional test case for the SessionClient to verify the following behavior:\n\nCalling SessionClient#asyncBatchCreateSesions with distributeOverChannels=false should execute only one RPC using one channel.\nCalling SessionClient#asyncBatchCreateSesions with distributeOverChannels=false multiple times, should use a new channel hint for each consecutive call.\n\nThis ensures that increasing the number of sessions in the pool using consecutive calls to this method will eventually distribute the sessions over all available channels.", "createdAt": "2020-04-14T13:45:38Z", "url": "https://github.com/googleapis/java-spanner/pull/149", "merged": true, "mergeCommit": {"oid": "1c4af77cced471d3ad52a89602794c5219bff1c4"}, "closed": true, "closedAt": "2020-04-16T12:23:37Z", "author": {"login": "olavloite"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXjrtzAH2gAyNDAzMTk0MTA3OjMzMzFjYzQ1ZWQ1N2VkMGU4YmYxMWViN2Q5MmVjZGRhNWQxZDE5MTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcYHhHJAFqTM5NDM2MzMyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3331cc45ed57ed0e8bf11eb7d92ecdda5d1d1910", "author": {"user": {"login": "olavloite", "name": "Knut Olav L\u00f8ite"}}, "url": "https://github.com/googleapis/java-spanner/commit/3331cc45ed57ed0e8bf11eb7d92ecdda5d1d1910", "committedDate": "2020-04-14T13:40:46Z", "message": "tests: add test for session distribution"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MzYzMTgx", "url": "https://github.com/googleapis/java-spanner/pull/149#pullrequestreview-394363181", "createdAt": "2020-04-16T07:25:32Z", "commit": {"oid": "3331cc45ed57ed0e8bf11eb7d92ecdda5d1d1910"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNzoyNTozM1rOGGX-Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNzoyNTozM1rOGGX-Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMzNzM2Nw==", "bodyText": "Assume that spannerOptions.getNumChannels() returns 4. Does this means that we only have 4 available channels?\nBut why expectedChannels/usedChannelHintss can be [0,1,2,3,...,7]?\nI am just curious about the mocking here:\n                Long channelHint = (Long) options.get(SpannerRpc.Option.CHANNEL_HINT);\n                usedChannelHintss.add(channelHint);\nSpannerRpc.Option.CHANNEL_HINT is just a string. How do we construct the map options and channelHint will be become 0,1,2,3...7?", "url": "https://github.com/googleapis/java-spanner/pull/149#discussion_r409337367", "createdAt": "2020-04-16T07:25:33Z", "author": {"login": "hengfengli"}, "path": "google-cloud-spanner/src/test/java/com/google/cloud/spanner/SessionClientTest.java", "diffHunk": "@@ -193,6 +195,73 @@ public void onSessionCreateFailure(Throwable t, int createFailureForSessionCount\n     assertThat(usedChannels).containsExactlyElementsIn(expectedChannels);\n   }\n \n+  /**\n+   * Tests that multiple consequtive calls to {@link SessionClient#asyncBatchCreateSessions(int,\n+   * boolean, SessionConsumer)} with distributeOverChannels=false does not distribute one batch over\n+   * multiple channels, but it does assign each new call to a new channel. This means that multiple\n+   * calls to this method will still distribute the total set of sessions over all available\n+   * channels.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  @Test\n+  public void batchCreateSessionsDistributesMultipleRequestsOverChannels() {\n+    DatabaseId db = DatabaseId.of(dbName);\n+    final String sessionName = dbName + \"/sessions/s%d\";\n+    final Map<String, String> labels = Collections.<String, String>emptyMap();\n+    when(spannerOptions.getSessionLabels()).thenReturn(labels);\n+    final Set<Long> usedChannelHintss = Collections.synchronizedSet(new HashSet<Long>());\n+    when(rpc.batchCreateSessions(\n+            Mockito.eq(dbName), Mockito.anyInt(), Mockito.eq(labels), Mockito.anyMap()))\n+        .then(\n+            new Answer<List<com.google.spanner.v1.Session>>() {\n+              @Override\n+              public List<com.google.spanner.v1.Session> answer(InvocationOnMock invocation)\n+                  throws Throwable {\n+                Map<SpannerRpc.Option, Object> options = invocation.getArgumentAt(3, Map.class);\n+                Long channelHint = (Long) options.get(SpannerRpc.Option.CHANNEL_HINT);\n+                usedChannelHintss.add(channelHint);\n+                int sessionCount = invocation.getArgumentAt(1, Integer.class);\n+                List<com.google.spanner.v1.Session> res = new ArrayList<>();\n+                for (int i = 1; i <= sessionCount; i++) {\n+                  res.add(\n+                      com.google.spanner.v1.Session.newBuilder()\n+                          .setName(String.format(sessionName, i))\n+                          .putAllLabels(labels)\n+                          .build());\n+                }\n+                return res;\n+              }\n+            });\n+\n+    final AtomicInteger returnedSessionCount = new AtomicInteger();\n+    SessionConsumer consumer =\n+        new SessionConsumer() {\n+          @Override\n+          public void onSessionReady(SessionImpl session) {\n+            assertThat(session.getName()).startsWith(dbName + \"/sessions/s\");\n+            returnedSessionCount.incrementAndGet();\n+            session.close();\n+          }\n+\n+          @Override\n+          public void onSessionCreateFailure(Throwable t, int createFailureForSessionCount) {}\n+        };\n+    final int numSessions = 10;\n+    final int numBatches = spannerOptions.getNumChannels() * 2;\n+    try (SessionClient client = new SessionClient(spanner, db, new TestExecutorFactory())) {\n+      for (int batch = 0; batch < numBatches; batch++) {\n+        client.asyncBatchCreateSessions(numSessions, false, consumer);\n+      }\n+    }\n+    assertThat(returnedSessionCount.get()).isEqualTo(numSessions * numBatches);\n+    assertThat(usedChannelHintss.size()).isEqualTo(spannerOptions.getNumChannels() * 2);\n+    List<Long> expectedChannels = new ArrayList<>();\n+    for (long l = 0; l < spannerOptions.getNumChannels() * 2; l++) {\n+      expectedChannels.add(l);\n+    }\n+    assertThat(usedChannelHintss).containsExactlyElementsIn(expectedChannels);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3331cc45ed57ed0e8bf11eb7d92ecdda5d1d1910"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MzYzMzI3", "url": "https://github.com/googleapis/java-spanner/pull/149#pullrequestreview-394363327", "createdAt": "2020-04-16T07:25:46Z", "commit": {"oid": "3331cc45ed57ed0e8bf11eb7d92ecdda5d1d1910"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 890, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}