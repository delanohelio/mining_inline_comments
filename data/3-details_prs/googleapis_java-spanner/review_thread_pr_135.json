{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1NTE4NjA5", "number": 135, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTo0NTozMlrODx_vxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTo0NTozMlrODx_vxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzUxMjM4OnYy", "diffSide": "RIGHT", "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTo0NTozMlrOGFyCtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxNDoxMDoxMFrOGGnNkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxNTk1Ng==", "bodyText": "Doesn't this logic meant that over time we won't be maintaining the ratio of write prepared sessions to read sessions since we always favor keeping read sessions alive?", "url": "https://github.com/googleapis/java-spanner/pull/135#discussion_r408715956", "createdAt": "2020-04-15T09:45:32Z", "author": {"login": "skuruppu"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -1053,9 +1057,11 @@ private void keepAliveSessions(Instant currTime) {\n       while (numSessionsToKeepAlive > 0) {\n         PooledSession sessionToKeepAlive = null;\n         synchronized (lock) {\n-          sessionToKeepAlive = findSessionToKeepAlive(readSessions, keepAliveThreshold);\n+          sessionToKeepAlive = findSessionToKeepAlive(readSessions, keepAliveThreshold, 0);\n           if (sessionToKeepAlive == null) {\n-            sessionToKeepAlive = findSessionToKeepAlive(writePreparedSessions, keepAliveThreshold);\n+            sessionToKeepAlive =\n+                findSessionToKeepAlive(\n+                    writePreparedSessions, keepAliveThreshold, readSessions.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c95aed62d25e5f7444212493a7d953ee93a1b2ba"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU1NTI0MA==", "bodyText": "Yes, the session that is kept alive is taken from the pool, pinged and then released back into the pool (on line 1074). Releasing the session back into the pool will trigger a new prepareSession call if necessary.\nI've added an additional test case to verify this behavior.", "url": "https://github.com/googleapis/java-spanner/pull/135#discussion_r409555240", "createdAt": "2020-04-16T13:28:18Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -1053,9 +1057,11 @@ private void keepAliveSessions(Instant currTime) {\n       while (numSessionsToKeepAlive > 0) {\n         PooledSession sessionToKeepAlive = null;\n         synchronized (lock) {\n-          sessionToKeepAlive = findSessionToKeepAlive(readSessions, keepAliveThreshold);\n+          sessionToKeepAlive = findSessionToKeepAlive(readSessions, keepAliveThreshold, 0);\n           if (sessionToKeepAlive == null) {\n-            sessionToKeepAlive = findSessionToKeepAlive(writePreparedSessions, keepAliveThreshold);\n+            sessionToKeepAlive =\n+                findSessionToKeepAlive(\n+                    writePreparedSessions, keepAliveThreshold, readSessions.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxNTk1Ng=="}, "originalCommit": {"oid": "c95aed62d25e5f7444212493a7d953ee93a1b2ba"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU4NzA5MQ==", "bodyText": "And that test case now shows that my line of thought does not always work as expected :-)", "url": "https://github.com/googleapis/java-spanner/pull/135#discussion_r409587091", "createdAt": "2020-04-16T14:10:10Z", "author": {"login": "olavloite"}, "path": "google-cloud-spanner/src/main/java/com/google/cloud/spanner/SessionPool.java", "diffHunk": "@@ -1053,9 +1057,11 @@ private void keepAliveSessions(Instant currTime) {\n       while (numSessionsToKeepAlive > 0) {\n         PooledSession sessionToKeepAlive = null;\n         synchronized (lock) {\n-          sessionToKeepAlive = findSessionToKeepAlive(readSessions, keepAliveThreshold);\n+          sessionToKeepAlive = findSessionToKeepAlive(readSessions, keepAliveThreshold, 0);\n           if (sessionToKeepAlive == null) {\n-            sessionToKeepAlive = findSessionToKeepAlive(writePreparedSessions, keepAliveThreshold);\n+            sessionToKeepAlive =\n+                findSessionToKeepAlive(\n+                    writePreparedSessions, keepAliveThreshold, readSessions.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxNTk1Ng=="}, "originalCommit": {"oid": "c95aed62d25e5f7444212493a7d953ee93a1b2ba"}, "originalPosition": 159}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3230, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}