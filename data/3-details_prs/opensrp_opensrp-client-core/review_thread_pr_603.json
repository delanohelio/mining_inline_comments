{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0MjcyOTA2", "number": 603, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwNjo1NDo1N1rOESQiNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwNjo1NDo1N1rOESQiNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NTgwNzI0OnYy", "diffSide": "RIGHT", "path": "opensrp-app/src/test/java/org/smartregister/sync/intent/SyncIntentServiceTest.java", "isResolved": false, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwNjo1NDo1N1rOG3VySA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwOTozODoxMVrOG4E0yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY4MTgwMA==", "bodyText": "This is interesting, fetch really shouldn't happen if this is false.\nSo not sure why this test passes.", "url": "https://github.com/opensrp/opensrp-client-core/pull/603#discussion_r460681800", "createdAt": "2020-07-27T06:54:57Z", "author": {"login": "vincent-karuri"}, "path": "opensrp-app/src/test/java/org/smartregister/sync/intent/SyncIntentServiceTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package org.smartregister.sync.intent;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.pm.PackageManager;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.powermock.reflect.Whitebox;\n+import org.robolectric.RuntimeEnvironment;\n+import org.smartregister.BaseRobolectricUnitTest;\n+import org.smartregister.CoreLibrary;\n+import org.smartregister.SyncConfiguration;\n+import org.smartregister.domain.FetchStatus;\n+import org.smartregister.receiver.SyncStatusBroadcastReceiver;\n+import org.smartregister.util.SyncUtils;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Created by Richard Kareko on 7/21/20.\n+ */\n+\n+public class SyncIntentServiceTest extends BaseRobolectricUnitTest {\n+\n+    @Mock\n+    private SyncUtils syncUtils;\n+\n+    @Mock\n+    SyncConfiguration syncConfiguration;\n+\n+    @Captor\n+    private ArgumentCaptor<Intent>  intentArgumentCaptor;\n+\n+    private Context context = RuntimeEnvironment.application;\n+\n+    private SyncIntentService syncIntentService;\n+\n+    @Before\n+    public void setUp() {\n+        Whitebox.setInternalState(CoreLibrary.getInstance(), \"syncConfiguration\", syncConfiguration);\n+        MockitoAnnotations.initMocks(this);\n+        syncIntentService = new SyncIntentService();\n+        syncIntentService.init(context);\n+        Whitebox.setInternalState(syncIntentService, \"mBase\", RuntimeEnvironment.application);\n+    }\n+\n+    @Test\n+    public void testInit() {\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"httpAgent\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"syncUtils\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"context\"));\n+    }\n+\n+    @Test\n+    public void testHandleSyncSendFetchStartedBroadCast() throws PackageManager.NameNotFoundException {\n+        syncIntentService = spy(syncIntentService);\n+        Whitebox.setInternalState(syncIntentService, \"syncUtils\", syncUtils);\n+        when(syncUtils.verifyAuthorization()).thenReturn(true);\n+        when(syncUtils.isAppVersionAllowed()).thenReturn(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9611aa1ccb9308c3406b7fdaba8ab9bc9cc79cb9"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM0Njk4Mw==", "bodyText": "The check for isAppVersionAllowed id done later in the code after the broadcast has been sent as seen here", "url": "https://github.com/opensrp/opensrp-client-core/pull/603#discussion_r461346983", "createdAt": "2020-07-28T06:27:47Z", "author": {"login": "Rkareko"}, "path": "opensrp-app/src/test/java/org/smartregister/sync/intent/SyncIntentServiceTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package org.smartregister.sync.intent;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.pm.PackageManager;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.powermock.reflect.Whitebox;\n+import org.robolectric.RuntimeEnvironment;\n+import org.smartregister.BaseRobolectricUnitTest;\n+import org.smartregister.CoreLibrary;\n+import org.smartregister.SyncConfiguration;\n+import org.smartregister.domain.FetchStatus;\n+import org.smartregister.receiver.SyncStatusBroadcastReceiver;\n+import org.smartregister.util.SyncUtils;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Created by Richard Kareko on 7/21/20.\n+ */\n+\n+public class SyncIntentServiceTest extends BaseRobolectricUnitTest {\n+\n+    @Mock\n+    private SyncUtils syncUtils;\n+\n+    @Mock\n+    SyncConfiguration syncConfiguration;\n+\n+    @Captor\n+    private ArgumentCaptor<Intent>  intentArgumentCaptor;\n+\n+    private Context context = RuntimeEnvironment.application;\n+\n+    private SyncIntentService syncIntentService;\n+\n+    @Before\n+    public void setUp() {\n+        Whitebox.setInternalState(CoreLibrary.getInstance(), \"syncConfiguration\", syncConfiguration);\n+        MockitoAnnotations.initMocks(this);\n+        syncIntentService = new SyncIntentService();\n+        syncIntentService.init(context);\n+        Whitebox.setInternalState(syncIntentService, \"mBase\", RuntimeEnvironment.application);\n+    }\n+\n+    @Test\n+    public void testInit() {\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"httpAgent\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"syncUtils\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"context\"));\n+    }\n+\n+    @Test\n+    public void testHandleSyncSendFetchStartedBroadCast() throws PackageManager.NameNotFoundException {\n+        syncIntentService = spy(syncIntentService);\n+        Whitebox.setInternalState(syncIntentService, \"syncUtils\", syncUtils);\n+        when(syncUtils.verifyAuthorization()).thenReturn(true);\n+        when(syncUtils.isAppVersionAllowed()).thenReturn(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY4MTgwMA=="}, "originalCommit": {"oid": "9611aa1ccb9308c3406b7fdaba8ab9bc9cc79cb9"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4MDEyNQ==", "bodyText": "I guess the point was that the message should not be broadcast until we are sure fetch is actually happening.\nWhich atm only happens here.", "url": "https://github.com/opensrp/opensrp-client-core/pull/603#discussion_r461380125", "createdAt": "2020-07-28T07:39:04Z", "author": {"login": "vincent-karuri"}, "path": "opensrp-app/src/test/java/org/smartregister/sync/intent/SyncIntentServiceTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package org.smartregister.sync.intent;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.pm.PackageManager;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.powermock.reflect.Whitebox;\n+import org.robolectric.RuntimeEnvironment;\n+import org.smartregister.BaseRobolectricUnitTest;\n+import org.smartregister.CoreLibrary;\n+import org.smartregister.SyncConfiguration;\n+import org.smartregister.domain.FetchStatus;\n+import org.smartregister.receiver.SyncStatusBroadcastReceiver;\n+import org.smartregister.util.SyncUtils;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Created by Richard Kareko on 7/21/20.\n+ */\n+\n+public class SyncIntentServiceTest extends BaseRobolectricUnitTest {\n+\n+    @Mock\n+    private SyncUtils syncUtils;\n+\n+    @Mock\n+    SyncConfiguration syncConfiguration;\n+\n+    @Captor\n+    private ArgumentCaptor<Intent>  intentArgumentCaptor;\n+\n+    private Context context = RuntimeEnvironment.application;\n+\n+    private SyncIntentService syncIntentService;\n+\n+    @Before\n+    public void setUp() {\n+        Whitebox.setInternalState(CoreLibrary.getInstance(), \"syncConfiguration\", syncConfiguration);\n+        MockitoAnnotations.initMocks(this);\n+        syncIntentService = new SyncIntentService();\n+        syncIntentService.init(context);\n+        Whitebox.setInternalState(syncIntentService, \"mBase\", RuntimeEnvironment.application);\n+    }\n+\n+    @Test\n+    public void testInit() {\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"httpAgent\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"syncUtils\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"context\"));\n+    }\n+\n+    @Test\n+    public void testHandleSyncSendFetchStartedBroadCast() throws PackageManager.NameNotFoundException {\n+        syncIntentService = spy(syncIntentService);\n+        Whitebox.setInternalState(syncIntentService, \"syncUtils\", syncUtils);\n+        when(syncUtils.verifyAuthorization()).thenReturn(true);\n+        when(syncUtils.isAppVersionAllowed()).thenReturn(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY4MTgwMA=="}, "originalCommit": {"oid": "9611aa1ccb9308c3406b7fdaba8ab9bc9cc79cb9"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4MDc5NA==", "bodyText": "Fetch does not happen for the other if branches.", "url": "https://github.com/opensrp/opensrp-client-core/pull/603#discussion_r461380794", "createdAt": "2020-07-28T07:40:12Z", "author": {"login": "vincent-karuri"}, "path": "opensrp-app/src/test/java/org/smartregister/sync/intent/SyncIntentServiceTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package org.smartregister.sync.intent;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.pm.PackageManager;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.powermock.reflect.Whitebox;\n+import org.robolectric.RuntimeEnvironment;\n+import org.smartregister.BaseRobolectricUnitTest;\n+import org.smartregister.CoreLibrary;\n+import org.smartregister.SyncConfiguration;\n+import org.smartregister.domain.FetchStatus;\n+import org.smartregister.receiver.SyncStatusBroadcastReceiver;\n+import org.smartregister.util.SyncUtils;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Created by Richard Kareko on 7/21/20.\n+ */\n+\n+public class SyncIntentServiceTest extends BaseRobolectricUnitTest {\n+\n+    @Mock\n+    private SyncUtils syncUtils;\n+\n+    @Mock\n+    SyncConfiguration syncConfiguration;\n+\n+    @Captor\n+    private ArgumentCaptor<Intent>  intentArgumentCaptor;\n+\n+    private Context context = RuntimeEnvironment.application;\n+\n+    private SyncIntentService syncIntentService;\n+\n+    @Before\n+    public void setUp() {\n+        Whitebox.setInternalState(CoreLibrary.getInstance(), \"syncConfiguration\", syncConfiguration);\n+        MockitoAnnotations.initMocks(this);\n+        syncIntentService = new SyncIntentService();\n+        syncIntentService.init(context);\n+        Whitebox.setInternalState(syncIntentService, \"mBase\", RuntimeEnvironment.application);\n+    }\n+\n+    @Test\n+    public void testInit() {\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"httpAgent\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"syncUtils\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"context\"));\n+    }\n+\n+    @Test\n+    public void testHandleSyncSendFetchStartedBroadCast() throws PackageManager.NameNotFoundException {\n+        syncIntentService = spy(syncIntentService);\n+        Whitebox.setInternalState(syncIntentService, \"syncUtils\", syncUtils);\n+        when(syncUtils.verifyAuthorization()).thenReturn(true);\n+        when(syncUtils.isAppVersionAllowed()).thenReturn(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY4MTgwMA=="}, "originalCommit": {"oid": "9611aa1ccb9308c3406b7fdaba8ab9bc9cc79cb9"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM4OTAwMw==", "bodyText": "@ndegwamartin @githengi Would like to hear your thoughts on this. Should the broadcast message be moved from here to here", "url": "https://github.com/opensrp/opensrp-client-core/pull/603#discussion_r461389003", "createdAt": "2020-07-28T07:54:36Z", "author": {"login": "Rkareko"}, "path": "opensrp-app/src/test/java/org/smartregister/sync/intent/SyncIntentServiceTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package org.smartregister.sync.intent;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.pm.PackageManager;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.powermock.reflect.Whitebox;\n+import org.robolectric.RuntimeEnvironment;\n+import org.smartregister.BaseRobolectricUnitTest;\n+import org.smartregister.CoreLibrary;\n+import org.smartregister.SyncConfiguration;\n+import org.smartregister.domain.FetchStatus;\n+import org.smartregister.receiver.SyncStatusBroadcastReceiver;\n+import org.smartregister.util.SyncUtils;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Created by Richard Kareko on 7/21/20.\n+ */\n+\n+public class SyncIntentServiceTest extends BaseRobolectricUnitTest {\n+\n+    @Mock\n+    private SyncUtils syncUtils;\n+\n+    @Mock\n+    SyncConfiguration syncConfiguration;\n+\n+    @Captor\n+    private ArgumentCaptor<Intent>  intentArgumentCaptor;\n+\n+    private Context context = RuntimeEnvironment.application;\n+\n+    private SyncIntentService syncIntentService;\n+\n+    @Before\n+    public void setUp() {\n+        Whitebox.setInternalState(CoreLibrary.getInstance(), \"syncConfiguration\", syncConfiguration);\n+        MockitoAnnotations.initMocks(this);\n+        syncIntentService = new SyncIntentService();\n+        syncIntentService.init(context);\n+        Whitebox.setInternalState(syncIntentService, \"mBase\", RuntimeEnvironment.application);\n+    }\n+\n+    @Test\n+    public void testInit() {\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"httpAgent\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"syncUtils\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"context\"));\n+    }\n+\n+    @Test\n+    public void testHandleSyncSendFetchStartedBroadCast() throws PackageManager.NameNotFoundException {\n+        syncIntentService = spy(syncIntentService);\n+        Whitebox.setInternalState(syncIntentService, \"syncUtils\", syncUtils);\n+        when(syncUtils.verifyAuthorization()).thenReturn(true);\n+        when(syncUtils.isAppVersionAllowed()).thenReturn(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY4MTgwMA=="}, "originalCommit": {"oid": "9611aa1ccb9308c3406b7fdaba8ab9bc9cc79cb9"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQwODkwMQ==", "bodyText": "Hmm, maybe not unless you do some more refactoring. The sync process is comprised of two items, pushToServer and pullECFromServer. Push does not fall under the minAppVersionAllowed condition since it is triggered before then", "url": "https://github.com/opensrp/opensrp-client-core/pull/603#discussion_r461408901", "createdAt": "2020-07-28T08:29:03Z", "author": {"login": "ndegwamartin"}, "path": "opensrp-app/src/test/java/org/smartregister/sync/intent/SyncIntentServiceTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package org.smartregister.sync.intent;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.pm.PackageManager;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.powermock.reflect.Whitebox;\n+import org.robolectric.RuntimeEnvironment;\n+import org.smartregister.BaseRobolectricUnitTest;\n+import org.smartregister.CoreLibrary;\n+import org.smartregister.SyncConfiguration;\n+import org.smartregister.domain.FetchStatus;\n+import org.smartregister.receiver.SyncStatusBroadcastReceiver;\n+import org.smartregister.util.SyncUtils;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Created by Richard Kareko on 7/21/20.\n+ */\n+\n+public class SyncIntentServiceTest extends BaseRobolectricUnitTest {\n+\n+    @Mock\n+    private SyncUtils syncUtils;\n+\n+    @Mock\n+    SyncConfiguration syncConfiguration;\n+\n+    @Captor\n+    private ArgumentCaptor<Intent>  intentArgumentCaptor;\n+\n+    private Context context = RuntimeEnvironment.application;\n+\n+    private SyncIntentService syncIntentService;\n+\n+    @Before\n+    public void setUp() {\n+        Whitebox.setInternalState(CoreLibrary.getInstance(), \"syncConfiguration\", syncConfiguration);\n+        MockitoAnnotations.initMocks(this);\n+        syncIntentService = new SyncIntentService();\n+        syncIntentService.init(context);\n+        Whitebox.setInternalState(syncIntentService, \"mBase\", RuntimeEnvironment.application);\n+    }\n+\n+    @Test\n+    public void testInit() {\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"httpAgent\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"syncUtils\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"context\"));\n+    }\n+\n+    @Test\n+    public void testHandleSyncSendFetchStartedBroadCast() throws PackageManager.NameNotFoundException {\n+        syncIntentService = spy(syncIntentService);\n+        Whitebox.setInternalState(syncIntentService, \"syncUtils\", syncUtils);\n+        when(syncUtils.verifyAuthorization()).thenReturn(true);\n+        when(syncUtils.isAppVersionAllowed()).thenReturn(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY4MTgwMA=="}, "originalCommit": {"oid": "9611aa1ccb9308c3406b7fdaba8ab9bc9cc79cb9"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQxMjk1Nw==", "bodyText": "I think we should keep minAppVersionAllowed separate from pushToServer as currently is. Data on device should still be allowed to be uploaded even if app is older and deprecated.", "url": "https://github.com/opensrp/opensrp-client-core/pull/603#discussion_r461412957", "createdAt": "2020-07-28T08:35:38Z", "author": {"login": "githengi"}, "path": "opensrp-app/src/test/java/org/smartregister/sync/intent/SyncIntentServiceTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package org.smartregister.sync.intent;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.pm.PackageManager;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.powermock.reflect.Whitebox;\n+import org.robolectric.RuntimeEnvironment;\n+import org.smartregister.BaseRobolectricUnitTest;\n+import org.smartregister.CoreLibrary;\n+import org.smartregister.SyncConfiguration;\n+import org.smartregister.domain.FetchStatus;\n+import org.smartregister.receiver.SyncStatusBroadcastReceiver;\n+import org.smartregister.util.SyncUtils;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Created by Richard Kareko on 7/21/20.\n+ */\n+\n+public class SyncIntentServiceTest extends BaseRobolectricUnitTest {\n+\n+    @Mock\n+    private SyncUtils syncUtils;\n+\n+    @Mock\n+    SyncConfiguration syncConfiguration;\n+\n+    @Captor\n+    private ArgumentCaptor<Intent>  intentArgumentCaptor;\n+\n+    private Context context = RuntimeEnvironment.application;\n+\n+    private SyncIntentService syncIntentService;\n+\n+    @Before\n+    public void setUp() {\n+        Whitebox.setInternalState(CoreLibrary.getInstance(), \"syncConfiguration\", syncConfiguration);\n+        MockitoAnnotations.initMocks(this);\n+        syncIntentService = new SyncIntentService();\n+        syncIntentService.init(context);\n+        Whitebox.setInternalState(syncIntentService, \"mBase\", RuntimeEnvironment.application);\n+    }\n+\n+    @Test\n+    public void testInit() {\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"httpAgent\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"syncUtils\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"context\"));\n+    }\n+\n+    @Test\n+    public void testHandleSyncSendFetchStartedBroadCast() throws PackageManager.NameNotFoundException {\n+        syncIntentService = spy(syncIntentService);\n+        Whitebox.setInternalState(syncIntentService, \"syncUtils\", syncUtils);\n+        when(syncUtils.verifyAuthorization()).thenReturn(true);\n+        when(syncUtils.isAppVersionAllowed()).thenReturn(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY4MTgwMA=="}, "originalCommit": {"oid": "9611aa1ccb9308c3406b7fdaba8ab9bc9cc79cb9"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQyODg3Nw==", "bodyText": "The FetchStatus.fetchStarted is a bit of a misnomer since it signals the beginning of sync (both push and pull) though it should ideally apply to just pull (it's synonymous with fetch)?\nSo the question is whether to broadcast that only when an actual pull is happening, which doesn't happen for the first two branches.", "url": "https://github.com/opensrp/opensrp-client-core/pull/603#discussion_r461428877", "createdAt": "2020-07-28T09:01:39Z", "author": {"login": "vincent-karuri"}, "path": "opensrp-app/src/test/java/org/smartregister/sync/intent/SyncIntentServiceTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package org.smartregister.sync.intent;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.pm.PackageManager;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.powermock.reflect.Whitebox;\n+import org.robolectric.RuntimeEnvironment;\n+import org.smartregister.BaseRobolectricUnitTest;\n+import org.smartregister.CoreLibrary;\n+import org.smartregister.SyncConfiguration;\n+import org.smartregister.domain.FetchStatus;\n+import org.smartregister.receiver.SyncStatusBroadcastReceiver;\n+import org.smartregister.util.SyncUtils;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Created by Richard Kareko on 7/21/20.\n+ */\n+\n+public class SyncIntentServiceTest extends BaseRobolectricUnitTest {\n+\n+    @Mock\n+    private SyncUtils syncUtils;\n+\n+    @Mock\n+    SyncConfiguration syncConfiguration;\n+\n+    @Captor\n+    private ArgumentCaptor<Intent>  intentArgumentCaptor;\n+\n+    private Context context = RuntimeEnvironment.application;\n+\n+    private SyncIntentService syncIntentService;\n+\n+    @Before\n+    public void setUp() {\n+        Whitebox.setInternalState(CoreLibrary.getInstance(), \"syncConfiguration\", syncConfiguration);\n+        MockitoAnnotations.initMocks(this);\n+        syncIntentService = new SyncIntentService();\n+        syncIntentService.init(context);\n+        Whitebox.setInternalState(syncIntentService, \"mBase\", RuntimeEnvironment.application);\n+    }\n+\n+    @Test\n+    public void testInit() {\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"httpAgent\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"syncUtils\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"context\"));\n+    }\n+\n+    @Test\n+    public void testHandleSyncSendFetchStartedBroadCast() throws PackageManager.NameNotFoundException {\n+        syncIntentService = spy(syncIntentService);\n+        Whitebox.setInternalState(syncIntentService, \"syncUtils\", syncUtils);\n+        when(syncUtils.verifyAuthorization()).thenReturn(true);\n+        when(syncUtils.isAppVersionAllowed()).thenReturn(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY4MTgwMA=="}, "originalCommit": {"oid": "9611aa1ccb9308c3406b7fdaba8ab9bc9cc79cb9"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1MjQ5MA==", "bodyText": "I agree that FetchStatus.fetchStarted is a bit of a misnomer but it is used to signal that the sync process has started as such moving the broadcast to when the pull is happening would in essence mean that we are not considering the push to server bit as part of sync.", "url": "https://github.com/opensrp/opensrp-client-core/pull/603#discussion_r461452490", "createdAt": "2020-07-28T09:38:11Z", "author": {"login": "Rkareko"}, "path": "opensrp-app/src/test/java/org/smartregister/sync/intent/SyncIntentServiceTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package org.smartregister.sync.intent;\n+\n+import android.content.Context;\n+import android.content.Intent;\n+import android.content.pm.PackageManager;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.powermock.reflect.Whitebox;\n+import org.robolectric.RuntimeEnvironment;\n+import org.smartregister.BaseRobolectricUnitTest;\n+import org.smartregister.CoreLibrary;\n+import org.smartregister.SyncConfiguration;\n+import org.smartregister.domain.FetchStatus;\n+import org.smartregister.receiver.SyncStatusBroadcastReceiver;\n+import org.smartregister.util.SyncUtils;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Created by Richard Kareko on 7/21/20.\n+ */\n+\n+public class SyncIntentServiceTest extends BaseRobolectricUnitTest {\n+\n+    @Mock\n+    private SyncUtils syncUtils;\n+\n+    @Mock\n+    SyncConfiguration syncConfiguration;\n+\n+    @Captor\n+    private ArgumentCaptor<Intent>  intentArgumentCaptor;\n+\n+    private Context context = RuntimeEnvironment.application;\n+\n+    private SyncIntentService syncIntentService;\n+\n+    @Before\n+    public void setUp() {\n+        Whitebox.setInternalState(CoreLibrary.getInstance(), \"syncConfiguration\", syncConfiguration);\n+        MockitoAnnotations.initMocks(this);\n+        syncIntentService = new SyncIntentService();\n+        syncIntentService.init(context);\n+        Whitebox.setInternalState(syncIntentService, \"mBase\", RuntimeEnvironment.application);\n+    }\n+\n+    @Test\n+    public void testInit() {\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"httpAgent\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"syncUtils\"));\n+        assertNotNull(Whitebox.getInternalState(syncIntentService, \"context\"));\n+    }\n+\n+    @Test\n+    public void testHandleSyncSendFetchStartedBroadCast() throws PackageManager.NameNotFoundException {\n+        syncIntentService = spy(syncIntentService);\n+        Whitebox.setInternalState(syncIntentService, \"syncUtils\", syncUtils);\n+        when(syncUtils.verifyAuthorization()).thenReturn(true);\n+        when(syncUtils.isAppVersionAllowed()).thenReturn(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDY4MTgwMA=="}, "originalCommit": {"oid": "9611aa1ccb9308c3406b7fdaba8ab9bc9cc79cb9"}, "originalPosition": 68}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2093, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}