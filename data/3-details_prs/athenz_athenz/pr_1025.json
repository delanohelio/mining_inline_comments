{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzNDI3MjE5", "number": 1025, "title": "Authentication Documentation", "bodyText": "I confirm that this contribution is made under the terms of the license found in the root directory of this repository's source tree and that I have the authority necessary to make this contribution on behalf of its copyright owner.", "createdAt": "2020-07-02T10:31:52Z", "url": "https://github.com/AthenZ/athenz/pull/1025", "merged": true, "mergeCommit": {"oid": "841f3c6c884e059fd300c291d3836d70d37bc00c"}, "closed": true, "closedAt": "2020-07-20T16:11:33Z", "author": {"login": "OferLevi85"}, "timelineItems": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcw8XpngFqTQ0MTU1NDk4Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc2z-VNAFqTQ1MTc1NTE2Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNTU0OTgy", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441554982", "createdAt": "2020-07-02T10:34:34Z", "commit": {"oid": "42957dbe7e2821901c87e6b350ffecc19f5e78b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDozNDozNVrOGsHMnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDozNDozNVrOGsHMnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkwODQ0NA==", "bodyText": "Removed reference to Verizon Media's OKTA", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r448908444", "createdAt": "2020-07-02T10:34:35Z", "author": {"login": "OferLevi85"}, "path": "docs/aws_sso.md", "diffHunk": "@@ -0,0 +1,56 @@\n+If you are working with AWS, there are two things you should avoid at all costs:\n+\n+* Use account\u2019s root credentials for day-to-day work\n+* Provision individual users in your account and generate credentials for them\n+\n+AWS Single Sign On (SSO) with Athenz allows you to avoid both. Because an Athenz\n+domain is directly related to an AWS account, the same authorization mechanism\n+can be leveraged for SSO to the AWS console, via SAML-based integration. The\n+Identity Provider service validates the user and then uses Athenz", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42957dbe7e2821901c87e6b350ffecc19f5e78b5"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNTU1ODg3", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441555887", "createdAt": "2020-07-02T10:35:55Z", "commit": {"oid": "42957dbe7e2821901c87e6b350ffecc19f5e78b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDozNTo1NVrOGsHPWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDozNTo1NVrOGsHPWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkwOTE0Nw==", "bodyText": "Replaced Onboarding to AWS text mentioning Verizon Media internal systems.", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r448909147", "createdAt": "2020-07-02T10:35:55Z", "author": {"login": "OferLevi85"}, "path": "docs/aws_sso.md", "diffHunk": "@@ -0,0 +1,56 @@\n+If you are working with AWS, there are two things you should avoid at all costs:\n+\n+* Use account\u2019s root credentials for day-to-day work\n+* Provision individual users in your account and generate credentials for them\n+\n+AWS Single Sign On (SSO) with Athenz allows you to avoid both. Because an Athenz\n+domain is directly related to an AWS account, the same authorization mechanism\n+can be leveraged for SSO to the AWS console, via SAML-based integration. The\n+Identity Provider service validates the user and then uses Athenz\n+to determine the AWS role(s) the user can assume. This set of roles also indirectly\n+identifies all the accounts the user can access from the console. In its simplest\n+form, the single (potentially large) list can be presented to AWS in a SAML\n+document, and AWS allows selection of the account/role to use.\n+\n+## Onboard to AWS\n+\n+To register an AWS Account with a domain, run the following command:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42957dbe7e2821901c87e6b350ffecc19f5e78b5"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNTU4MzQ1", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441558345", "createdAt": "2020-07-02T10:39:43Z", "commit": {"oid": "42957dbe7e2821901c87e6b350ffecc19f5e78b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDozOTo0NFrOGsHWxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDozOTo0NFrOGsHWxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkxMTA0NA==", "bodyText": "Removed explanation on registering AWS accounts using Verizon Media internal systems.", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r448911044", "createdAt": "2020-07-02T10:39:44Z", "author": {"login": "OferLevi85"}, "path": "docs/aws_sso.md", "diffHunk": "@@ -0,0 +1,56 @@\n+If you are working with AWS, there are two things you should avoid at all costs:\n+\n+* Use account\u2019s root credentials for day-to-day work\n+* Provision individual users in your account and generate credentials for them\n+\n+AWS Single Sign On (SSO) with Athenz allows you to avoid both. Because an Athenz\n+domain is directly related to an AWS account, the same authorization mechanism\n+can be leveraged for SSO to the AWS console, via SAML-based integration. The\n+Identity Provider service validates the user and then uses Athenz\n+to determine the AWS role(s) the user can assume. This set of roles also indirectly\n+identifies all the accounts the user can access from the console. In its simplest\n+form, the single (potentially large) list can be presented to AWS in a SAML\n+document, and AWS allows selection of the account/role to use.\n+\n+## Onboard to AWS\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+In the Athenz UI, when you select your domain,\n+you should see your onboarded AWS account number.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42957dbe7e2821901c87e6b350ffecc19f5e78b5"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNTU5NTM2", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441559536", "createdAt": "2020-07-02T10:41:33Z", "commit": {"oid": "42957dbe7e2821901c87e6b350ffecc19f5e78b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDo0MTozM1rOGsHadQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDo0MTozM1rOGsHadQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkxMTk4OQ==", "bodyText": "Removed reference to OKTA", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r448911989", "createdAt": "2020-07-02T10:41:33Z", "author": {"login": "OferLevi85"}, "path": "docs/aws_sso.md", "diffHunk": "@@ -0,0 +1,56 @@\n+If you are working with AWS, there are two things you should avoid at all costs:\n+\n+* Use account\u2019s root credentials for day-to-day work\n+* Provision individual users in your account and generate credentials for them\n+\n+AWS Single Sign On (SSO) with Athenz allows you to avoid both. Because an Athenz\n+domain is directly related to an AWS account, the same authorization mechanism\n+can be leveraged for SSO to the AWS console, via SAML-based integration. The\n+Identity Provider service validates the user and then uses Athenz\n+to determine the AWS role(s) the user can assume. This set of roles also indirectly\n+identifies all the accounts the user can access from the console. In its simplest\n+form, the single (potentially large) list can be presented to AWS in a SAML\n+document, and AWS allows selection of the account/role to use.\n+\n+## Onboard to AWS\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+In the Athenz UI, when you select your domain,\n+you should see your onboarded AWS account number.\n+\n+Once your AWS account creation has successfully completed, it should create the\n+following 3 required roles for AWS Console SSO with their corresponding policies:\n+\n+* aws.fed.admin.user - Members of this role get admin privileges for your AWS\n+account. This is ROOT for AWS accounts. No one should be assigned this role,\n+unless they are performing ROOT functions\n+* aws.fed.power.user - This role restricts access to IAM functions, VPC core\n+functions, etc.  Your day to day tasks should use this role.\n+* aws.fed.read.only - ReadOnly Access to the AWS account.\n+\n+![AWS Federated roles in Athenz](images/aws_fed_roles.png)\n+\n+## Add members to AWS SSO roles\n+\n+In the Athenz UI,\n+\n+Follow these steps to add any users in one of those 3 aws sso roles. Since\n+SAML integration does not carry out standard Athenz Authorization checks\n+but rather reads the contents of the role to find out what IAM roles the\n+user has access, the users must be explicitly added to one of these roles\n+to get login access to the configured AWS account.\n+\n+View a particular role\u2019s details by clicking on the Members icon\n+in the role name line. The server shows all the members plus the audit history\n+of when and who added or deleted any of the members in that role.\n+Once the role members view is displayed, you can add any new members to\n+the role by entering their identity name. To add new members enter their ids and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42957dbe7e2821901c87e6b350ffecc19f5e78b5"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNTY2NzUx", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441566751", "createdAt": "2020-07-02T10:52:26Z", "commit": {"oid": "42957dbe7e2821901c87e6b350ffecc19f5e78b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDo1MjoyNlrOGsHwFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMDo1MjoyNlrOGsHwFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkxNzUyNw==", "bodyText": "Removed entire section on \"Access AWS Console\" which uses Verizon Media internal systems.", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r448917527", "createdAt": "2020-07-02T10:52:26Z", "author": {"login": "OferLevi85"}, "path": "docs/aws_sso.md", "diffHunk": "@@ -0,0 +1,56 @@\n+If you are working with AWS, there are two things you should avoid at all costs:\n+\n+* Use account\u2019s root credentials for day-to-day work\n+* Provision individual users in your account and generate credentials for them\n+\n+AWS Single Sign On (SSO) with Athenz allows you to avoid both. Because an Athenz\n+domain is directly related to an AWS account, the same authorization mechanism\n+can be leveraged for SSO to the AWS console, via SAML-based integration. The\n+Identity Provider service validates the user and then uses Athenz\n+to determine the AWS role(s) the user can assume. This set of roles also indirectly\n+identifies all the accounts the user can access from the console. In its simplest\n+form, the single (potentially large) list can be presented to AWS in a SAML\n+document, and AWS allows selection of the account/role to use.\n+\n+## Onboard to AWS\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+In the Athenz UI, when you select your domain,\n+you should see your onboarded AWS account number.\n+\n+Once your AWS account creation has successfully completed, it should create the\n+following 3 required roles for AWS Console SSO with their corresponding policies:\n+\n+* aws.fed.admin.user - Members of this role get admin privileges for your AWS\n+account. This is ROOT for AWS accounts. No one should be assigned this role,\n+unless they are performing ROOT functions\n+* aws.fed.power.user - This role restricts access to IAM functions, VPC core\n+functions, etc.  Your day to day tasks should use this role.\n+* aws.fed.read.only - ReadOnly Access to the AWS account.\n+\n+![AWS Federated roles in Athenz](images/aws_fed_roles.png)\n+\n+## Add members to AWS SSO roles", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42957dbe7e2821901c87e6b350ffecc19f5e78b5"}, "originalPosition": 37}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "42957dbe7e2821901c87e6b350ffecc19f5e78b5", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/42957dbe7e2821901c87e6b350ffecc19f5e78b5", "committedDate": "2020-07-02T09:58:07Z", "message": "Authentication Documentation"}, "afterCommit": {"oid": "848caf95b00f20949a6c860888b7cecedf203cef", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/848caf95b00f20949a6c860888b7cecedf203cef", "committedDate": "2020-07-02T11:45:10Z", "message": "Authentication Documentation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "848caf95b00f20949a6c860888b7cecedf203cef", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/848caf95b00f20949a6c860888b7cecedf203cef", "committedDate": "2020-07-02T11:45:10Z", "message": "Authentication Documentation"}, "afterCommit": {"oid": "bf69d68f9c2d76fdac7167f2252c8b0921931671", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/bf69d68f9c2d76fdac7167f2252c8b0921931671", "committedDate": "2020-07-02T12:10:52Z", "message": "Authentication Documentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzA2MjM4", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441706238", "createdAt": "2020-07-02T13:59:38Z", "commit": {"oid": "bf69d68f9c2d76fdac7167f2252c8b0921931671"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzo1OTozOVrOGsOLiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMzo1OTozOVrOGsOLiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyMjg1OQ==", "bodyText": "Replaced the content of this doc with the content from our internal documentation (using UI to generate keys instead of zms-cli)", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r449022859", "createdAt": "2020-07-02T13:59:39Z", "author": {"login": "OferLevi85"}, "path": "docs/reg_service_guide.md", "diffHunk": "@@ -1,82 +1,94 @@\n-# Registering ZMS Service Identity\n-----------------------------------", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf69d68f9c2d76fdac7167f2252c8b0921931671"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzE0NTg0", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441714584", "createdAt": "2020-07-02T14:08:38Z", "commit": {"oid": "bf69d68f9c2d76fdac7167f2252c8b0921931671"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDowODozOVrOGsOjlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDowODozOVrOGsOjlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyOTAxNQ==", "bodyText": "Removed use cases 2 and 4 from internal documentation which involved internal systems", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r449029015", "createdAt": "2020-07-02T14:08:39Z", "author": {"login": "OferLevi85"}, "path": "docs/service_x509_credentials.md", "diffHunk": "@@ -0,0 +1,101 @@\n+Once a domain has been registered in Athenz, the administrator will\n+register service identities that are specified in domain roles and\n+policy assertions. The latter can reference those roles having access to\n+specified resources. Athenz supports service authentication with\n+two types of credentials:\n+\n+- X.509 Certificates (preferred approach)\n+- Public/Private Key Pairs [Instructions](reg_service_guide.md)\n+\n+To contact Athenz Services (ZMS/ZTS) or other Athenz Enabled services,\n+the client service must first obtain an Athenz CA issued X.509 certificate.\n+In this section we'll cover how to register the service identity and\n+obtain X.509 certificates based on what environment your service will be running in.\n+\n+## Use Case 1: Service Running in AWS EC2\n+\n+If the service is running in AWS, Service Identity Agent (SIA) running on the\n+instance is responsible for generating a private key for the service and\n+obtaining a x.509 certificate from ZTS Service. The files are located in\n+the following locations:\n+\n+```\n+    private-key: /var/lib/sia/keys/<domain>.<service>.key.pem\n+    certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem\n+```\n+\n+The certificate is valid for 30 days and SIA agent automatically\n+will refresh the certificate daily. Follow [these steps](service_x509_credentials_aws.md) for\n+full details how to configure SIA agent running in AWS as part\n+of the foundation image.\n+\n+## Use Case 2: Service running on-prem within an Athenz Enabled Framework (K8S Omega/Ensemble, SD v3/v4)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf69d68f9c2d76fdac7167f2252c8b0921931671"}, "originalPosition": 32}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bf69d68f9c2d76fdac7167f2252c8b0921931671", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/bf69d68f9c2d76fdac7167f2252c8b0921931671", "committedDate": "2020-07-02T12:10:52Z", "message": "Authentication Documentation"}, "afterCommit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/43cd0972c45b29a3cb62b47817c45f2ebee5dee2", "committedDate": "2020-07-02T14:25:19Z", "message": "Authentication Documentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzMzODk2", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441733896", "createdAt": "2020-07-02T14:29:11Z", "commit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDoyOToxMVrOGsPcSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDoyOToxMVrOGsPcSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA0MzUzMA==", "bodyText": "Replaced internal top level creation which involves internal systems.", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r449043530", "createdAt": "2020-07-02T14:29:11Z", "author": {"login": "OferLevi85"}, "path": "docs/service_x509_credentials_aws.md", "diffHunk": "@@ -0,0 +1,346 @@\n+![AWS EC2 Setup](images/aws-ec2-setup.png)\n+\n+**Bootstrapping AWS EC2 instances with Athenz Service x.509 Identities\n+requires the instances to have network connectivity to both Athenz ZTS\n+and AWS STS Services.**\n+\n+## Domain Registration\n+\n+Identify your Athenz domain before you can proceed by using Athenz UI.\n+\n+You may create a top-level domain or a sub domain using Athenz UI or zms-cli.\n+Only Athenz System Administrators can create top level domains (members of the sys.auth role).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzM2MjA1", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441736205", "createdAt": "2020-07-02T14:31:24Z", "commit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDozMToyNFrOGsPi4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDozMToyNFrOGsPi4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA0NTIxOA==", "bodyText": "Removed the reference to bootstrapping", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r449045218", "createdAt": "2020-07-02T14:31:24Z", "author": {"login": "OferLevi85"}, "path": "docs/service_x509_credentials_aws.md", "diffHunk": "@@ -0,0 +1,346 @@\n+![AWS EC2 Setup](images/aws-ec2-setup.png)\n+\n+**Bootstrapping AWS EC2 instances with Athenz Service x.509 Identities\n+requires the instances to have network connectivity to both Athenz ZTS\n+and AWS STS Services.**\n+\n+## Domain Registration\n+\n+Identify your Athenz domain before you can proceed by using Athenz UI.\n+\n+You may create a top-level domain or a sub domain using Athenz UI or zms-cli.\n+Only Athenz System Administrators can create top level domains (members of the sys.auth role).\n+To create a top-level domain using zms-cli run the following:\n+\n+```\n+zms-cli add-domakn <domain-name> <unique-product-id> <domain-admins separated by space>\n+```\n+\n+If you already have top-level domain and need to create a sub domain using Athenz UI:\n+click the \"Create\u201d link next to \"My Domains\" label in the top right corner\n+and then click on \u201cSub Domain\u201d tab and follow the on screen instruction.\n+\n+![Create Sub Domain](images/create_sub_domain.png)\n+\n+Or using zms-cli:\n+```\n+zms-cli add-doman <top-doman.sub-domain-name> <domain-admins separated by space>\n+```\n+\n+## AWS Account ID Registration\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+## Athenz Service Identity Registration\n+\n+Create a service identity for your AWS EC2 instances in your Athenz domain. This full service identity name `<domain>.<service>` will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your EC2 Instance Role.\n+\n+In the Athenz UI, select your domain, select the `Services` tab and then choose `Add a Service` link in the top left corner. You must provide a service name and an optional description for your service. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzM4OTkz", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441738993", "createdAt": "2020-07-02T14:34:23Z", "commit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDozNDoyNFrOGsPqzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDozNDoyNFrOGsPqzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA0NzI0Nw==", "bodyText": "This area should be expanded as I'm not sure on the instructions for installing sia.\nAlso, not sure how it works with OpenStack as hca  code isn't part of open-source.", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r449047247", "createdAt": "2020-07-02T14:34:24Z", "author": {"login": "OferLevi85"}, "path": "docs/service_x509_credentials_aws.md", "diffHunk": "@@ -0,0 +1,346 @@\n+![AWS EC2 Setup](images/aws-ec2-setup.png)\n+\n+**Bootstrapping AWS EC2 instances with Athenz Service x.509 Identities\n+requires the instances to have network connectivity to both Athenz ZTS\n+and AWS STS Services.**\n+\n+## Domain Registration\n+\n+Identify your Athenz domain before you can proceed by using Athenz UI.\n+\n+You may create a top-level domain or a sub domain using Athenz UI or zms-cli.\n+Only Athenz System Administrators can create top level domains (members of the sys.auth role).\n+To create a top-level domain using zms-cli run the following:\n+\n+```\n+zms-cli add-domakn <domain-name> <unique-product-id> <domain-admins separated by space>\n+```\n+\n+If you already have top-level domain and need to create a sub domain using Athenz UI:\n+click the \"Create\u201d link next to \"My Domains\" label in the top right corner\n+and then click on \u201cSub Domain\u201d tab and follow the on screen instruction.\n+\n+![Create Sub Domain](images/create_sub_domain.png)\n+\n+Or using zms-cli:\n+```\n+zms-cli add-doman <top-doman.sub-domain-name> <domain-admins separated by space>\n+```\n+\n+## AWS Account ID Registration\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+## Athenz Service Identity Registration\n+\n+Create a service identity for your AWS EC2 instances in your Athenz domain. This full service identity name `<domain>.<service>` will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your EC2 Instance Role.\n+\n+In the Athenz UI, select your domain, select the `Services` tab and then choose `Add a Service` link in the top left corner. You must provide a service name and an optional description for your service. \n+\n+![Service Identity Registration](images/aws-service-register.png)\n+\n+## Athenz Service Identity Authorization\n+\n+Before ZTS can validate and issue X.509 TLS Certificates to the\n+AWS EC2 instance, it must validate that the service owner has\n+authorized its service to be launched by AWS EC2 Provider. In the\n+Athenz UI select your service that was created in the previous\n+step and click on the icon in the `Providers` column:\n+\n+![Service Identity Authorization_1](images/aws-service-authorize.png)\n+\n+Then, click on the `Allow` button to authorize your service to\n+be launched by AWS EC2 provider.\n+\n+![Service Identity Authorization_2](images/aws-service-authorize-2.png)\n+\n+\n+## IAM Role Setup\n+\n+There are two IAM roles required for instances to obtain Athenz X.509 certificates:\n+\n+- EC2 Instance Profile Role\n+- Athenz Service Identity Assume Role\n+\n+It is assumed that at this point you have already configured the first\n+EC2 Instance Profile IAM Role that your EC2 instance will be launched\n+with. In order to access your EC2 instances through the Bastion daemon,\n+your EC2 instance profile role must be named as `<domain>.<service>-service`.\n+The bastion service uses the profile arn to determine the EC2 instance\n+service name so it can carry out an authorization check to see if the user\n+is authorized to ssh login to the specified instance or not. If the property\n+is unable to name their instance profile name as `<domain>.<service>-service`\n+then check out the [Non Standard Instance Profile Name](#non-standard-instance-profile-name)\n+section for additional requirements.\n+\n+The second Athenz Service Identity IAM Assume Role must be created and\n+must have the `<domain>.<service>` name. This role will not have any\n+permissions but instead will have a trust relationship with your EC2\n+instance role such that your EC2 instance role can assume this role.\n+\n+In the AWS Console, select `IAM` from the Services drop down and then\n+click on the `Roles` link in the left sidebar. Choose the `Create Role`\n+button. Under the `AWS Service` type, select `EC2`, then `EC2` again\n+for the use case and finally choose `Next: Permissions` button in the\n+bottom right corner.\n+\n+![IAM Role Setup_1](images/iam-role-setup-1.png)\n+\n+In the `Attach permissions policy` screen do not choose any permissions\n+and just click on the `Next: Review` button in the bottom right corner\n+to continue. Specify the `Role name` in the `<domain>.<service>` format\n+and choose `Create Role` to complete the process.\n+\n+In the Roles list view, choose the role just created and choose the\n+`Trust Relationships` tab.\n+\n+![IAM Role Setup_2](images/iam-role-setup-2.png)\n+\n+Click on `Edit trust relationship` button and append a block containing\n+the following policy to the `Statement` block (Replace the `<account-id>`\n+and `<ec2-instance-role>` values with their corresponding values for\n+your environment:\n+\n+```\n+ {\n+   \"Effect\": \"Allow\",\n+   \"Principal\": {\n+     \"AWS\": \"arn:aws:iam::<account-id>:role/<ec2-instance-role>\"\n+   },\n+   \"Action\": \"sts:AssumeRole\"\n+ }\n+```\n+\n+Once correctly updated, your EC2 instance role must appear in the `Trusted entities` table:\n+\n+![IAM Role Setup_3](images/iam-role-setup-3.png)\n+\n+### Setup for Services with Region Specific Instance Profile Roles\n+\n+The IAM Role setup is identical when you have the same service\n+being deployed in multiple regions with role names that\n+are specific to each region. Since IAM roles are global, you only need\n+to create a single Athenz IAM Role in the `<domain>.<service>` format.\n+Then, when you're setting up your trust relationship, you'll authorize\n+all your region specific profile roles to have the capability to\n+assume the Athenz `<domain>.<service>` role.\n+\n+## Installing SIA\n+\n+The AWS SIA source is part of the Athenz project and can be found in:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzQxMTYw", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441741160", "createdAt": "2020-07-02T14:36:42Z", "commit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDozNjo0MlrOGsPw_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDozNjo0MlrOGsPw_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA0ODgyOA==", "bodyText": "Removed reference to ZTokens.", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r449048828", "createdAt": "2020-07-02T14:36:42Z", "author": {"login": "OferLevi85"}, "path": "docs/service_x509_credentials_aws.md", "diffHunk": "@@ -0,0 +1,346 @@\n+![AWS EC2 Setup](images/aws-ec2-setup.png)\n+\n+**Bootstrapping AWS EC2 instances with Athenz Service x.509 Identities\n+requires the instances to have network connectivity to both Athenz ZTS\n+and AWS STS Services.**\n+\n+## Domain Registration\n+\n+Identify your Athenz domain before you can proceed by using Athenz UI.\n+\n+You may create a top-level domain or a sub domain using Athenz UI or zms-cli.\n+Only Athenz System Administrators can create top level domains (members of the sys.auth role).\n+To create a top-level domain using zms-cli run the following:\n+\n+```\n+zms-cli add-domakn <domain-name> <unique-product-id> <domain-admins separated by space>\n+```\n+\n+If you already have top-level domain and need to create a sub domain using Athenz UI:\n+click the \"Create\u201d link next to \"My Domains\" label in the top right corner\n+and then click on \u201cSub Domain\u201d tab and follow the on screen instruction.\n+\n+![Create Sub Domain](images/create_sub_domain.png)\n+\n+Or using zms-cli:\n+```\n+zms-cli add-doman <top-doman.sub-domain-name> <domain-admins separated by space>\n+```\n+\n+## AWS Account ID Registration\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+## Athenz Service Identity Registration\n+\n+Create a service identity for your AWS EC2 instances in your Athenz domain. This full service identity name `<domain>.<service>` will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your EC2 Instance Role.\n+\n+In the Athenz UI, select your domain, select the `Services` tab and then choose `Add a Service` link in the top left corner. You must provide a service name and an optional description for your service. \n+\n+![Service Identity Registration](images/aws-service-register.png)\n+\n+## Athenz Service Identity Authorization\n+\n+Before ZTS can validate and issue X.509 TLS Certificates to the\n+AWS EC2 instance, it must validate that the service owner has\n+authorized its service to be launched by AWS EC2 Provider. In the\n+Athenz UI select your service that was created in the previous\n+step and click on the icon in the `Providers` column:\n+\n+![Service Identity Authorization_1](images/aws-service-authorize.png)\n+\n+Then, click on the `Allow` button to authorize your service to\n+be launched by AWS EC2 provider.\n+\n+![Service Identity Authorization_2](images/aws-service-authorize-2.png)\n+\n+\n+## IAM Role Setup\n+\n+There are two IAM roles required for instances to obtain Athenz X.509 certificates:\n+\n+- EC2 Instance Profile Role\n+- Athenz Service Identity Assume Role\n+\n+It is assumed that at this point you have already configured the first\n+EC2 Instance Profile IAM Role that your EC2 instance will be launched\n+with. In order to access your EC2 instances through the Bastion daemon,\n+your EC2 instance profile role must be named as `<domain>.<service>-service`.\n+The bastion service uses the profile arn to determine the EC2 instance\n+service name so it can carry out an authorization check to see if the user\n+is authorized to ssh login to the specified instance or not. If the property\n+is unable to name their instance profile name as `<domain>.<service>-service`\n+then check out the [Non Standard Instance Profile Name](#non-standard-instance-profile-name)\n+section for additional requirements.\n+\n+The second Athenz Service Identity IAM Assume Role must be created and\n+must have the `<domain>.<service>` name. This role will not have any\n+permissions but instead will have a trust relationship with your EC2\n+instance role such that your EC2 instance role can assume this role.\n+\n+In the AWS Console, select `IAM` from the Services drop down and then\n+click on the `Roles` link in the left sidebar. Choose the `Create Role`\n+button. Under the `AWS Service` type, select `EC2`, then `EC2` again\n+for the use case and finally choose `Next: Permissions` button in the\n+bottom right corner.\n+\n+![IAM Role Setup_1](images/iam-role-setup-1.png)\n+\n+In the `Attach permissions policy` screen do not choose any permissions\n+and just click on the `Next: Review` button in the bottom right corner\n+to continue. Specify the `Role name` in the `<domain>.<service>` format\n+and choose `Create Role` to complete the process.\n+\n+In the Roles list view, choose the role just created and choose the\n+`Trust Relationships` tab.\n+\n+![IAM Role Setup_2](images/iam-role-setup-2.png)\n+\n+Click on `Edit trust relationship` button and append a block containing\n+the following policy to the `Statement` block (Replace the `<account-id>`\n+and `<ec2-instance-role>` values with their corresponding values for\n+your environment:\n+\n+```\n+ {\n+   \"Effect\": \"Allow\",\n+   \"Principal\": {\n+     \"AWS\": \"arn:aws:iam::<account-id>:role/<ec2-instance-role>\"\n+   },\n+   \"Action\": \"sts:AssumeRole\"\n+ }\n+```\n+\n+Once correctly updated, your EC2 instance role must appear in the `Trusted entities` table:\n+\n+![IAM Role Setup_3](images/iam-role-setup-3.png)\n+\n+### Setup for Services with Region Specific Instance Profile Roles\n+\n+The IAM Role setup is identical when you have the same service\n+being deployed in multiple regions with role names that\n+are specific to each region. Since IAM roles are global, you only need\n+to create a single Athenz IAM Role in the `<domain>.<service>` format.\n+Then, when you're setting up your trust relationship, you'll authorize\n+all your region specific profile roles to have the capability to\n+assume the Athenz `<domain>.<service>` role.\n+\n+## Installing SIA\n+\n+The AWS SIA source is part of the Athenz project and can be found in:\n+```\n+provider/aws/sia-ec2\n+``` \n+Follow the readme for instructions on how to install it.\n+\n+## SIA Configuration Setup\n+\n+When building your image, you can include the following configuration\n+file called `sia_config` in the `/etc/sia` directory. It must include\n+the following required fields:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"<service name>\",\n+  \"accounts\": [\n+    {\n+      \"domain\": \"<domain name>\",\n+      \"account\": \"<aws account id associated with domain name>\"\n+    }\n+  ]\n+}\n+```\n+\n+The domain/account/service values here must match to the IAM Role\n+created earlier. For example, if the service identity name is `api`\n+in domain `sports` whose corresponding aws account id is `123456789`,\n+then the `sia_config` file will be as follows:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"api\",\n+  \"accounts\": [\n+    {\n+      \"domain\": \"sports\",\n+      \"account\": \"123456789\"\n+    }\n+  ]\n+}\n+```\n+\n+If you require bastion ssh access to your instances, then the profile\n+role must be called `<domain>.<service>-service` and you don't need to\n+specify this configuration file unless you want to change the ownership\n+of the generated private key and certificate files - see\n+[Private Key File Ownership](#private-key-file-ownership) section for more details.\n+\n+### Private Key File Ownership\n+\n+By default SIA agent runs as root and the private key is only readable\n+by root. If your service is running as another user, you can configure\n+SIA agent to automatically change the ownership of the private key file\n+to the configured user.\n+For example, if you want the private key to be owned by `ec2-user`, then\n+your `sia_config` configuration file would be as follows:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"api\",\n+  \"accounts\": [\n+    {\n+      \"domain\": \"sports\",\n+      \"account\": \"123456789\",\n+      \"user\": \"ec2-user\"\n+    }\n+  ]\n+}\n+```\n+\n+### SSH Certificate Support\n+\n+As part of the bootstrap process, SIA also retrieves a host ssh certificate\n+to be used by the bastion daemon that provides ssh access to instances.\n+However, if the administrator wants to disable this functionality, they\n+can do so by specifying `ssh` entry in their `sia_config` file with `false`\n+value as follows:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"api\",\n+  \"ssh\": false,\n+  \"accounts\": [\n+    {\n+      \"domain\": \"sports\",\n+      \"account\": \"123456789\"\n+    }\n+  ]\n+}\n+```\n+\n+## Private Key and Certificate Setup\n+\n+By default, the private key for the service identity is available in\n+the `/var/lib/sia/keys` directory and has the name `<domain>.<service>.key.pem`.\n+The private key is in PKCS#1 format. The corresponding X.509 certificate\n+is in the `/var/lib/sia/certs` directory and has the name\n+`<domain>.<service>.cert.pem`. The certificate is valid for 30 days and will\n+be refreshed automatically by SIA every day. It is the responsibility of the\n+application owner to update their container/application to refresh and use\n+the latest certificate before it expires. In the same `/var/lib/sia/certs`\n+directory SIA will also generate the Athenz CA certificate file called `ca.cert.pem`.\n+\n+### Role Certificate Support\n+\n+In addition to requesting Athenz service identity certificate, SIA provides\n+the capability to request Athenz Role Certificates as well. If you want to change the default behavior or request\n+SIA to automatically retrieve role certificates for your service, as part", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "originalPosition": 243}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzQ1NzI0", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441745724", "createdAt": "2020-07-02T14:41:39Z", "commit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDo0MTozOVrOGsP-dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDo0MTozOVrOGsP-dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1MjI3Nw==", "bodyText": "I decided to leave this in but I'm not sure about how bastion gets the ssh key from the host as the bootstrapping process isn't open source.", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r449052277", "createdAt": "2020-07-02T14:41:39Z", "author": {"login": "OferLevi85"}, "path": "docs/service_x509_credentials_aws.md", "diffHunk": "@@ -0,0 +1,346 @@\n+![AWS EC2 Setup](images/aws-ec2-setup.png)\n+\n+**Bootstrapping AWS EC2 instances with Athenz Service x.509 Identities\n+requires the instances to have network connectivity to both Athenz ZTS\n+and AWS STS Services.**\n+\n+## Domain Registration\n+\n+Identify your Athenz domain before you can proceed by using Athenz UI.\n+\n+You may create a top-level domain or a sub domain using Athenz UI or zms-cli.\n+Only Athenz System Administrators can create top level domains (members of the sys.auth role).\n+To create a top-level domain using zms-cli run the following:\n+\n+```\n+zms-cli add-domakn <domain-name> <unique-product-id> <domain-admins separated by space>\n+```\n+\n+If you already have top-level domain and need to create a sub domain using Athenz UI:\n+click the \"Create\u201d link next to \"My Domains\" label in the top right corner\n+and then click on \u201cSub Domain\u201d tab and follow the on screen instruction.\n+\n+![Create Sub Domain](images/create_sub_domain.png)\n+\n+Or using zms-cli:\n+```\n+zms-cli add-doman <top-doman.sub-domain-name> <domain-admins separated by space>\n+```\n+\n+## AWS Account ID Registration\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+## Athenz Service Identity Registration\n+\n+Create a service identity for your AWS EC2 instances in your Athenz domain. This full service identity name `<domain>.<service>` will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your EC2 Instance Role.\n+\n+In the Athenz UI, select your domain, select the `Services` tab and then choose `Add a Service` link in the top left corner. You must provide a service name and an optional description for your service. \n+\n+![Service Identity Registration](images/aws-service-register.png)\n+\n+## Athenz Service Identity Authorization\n+\n+Before ZTS can validate and issue X.509 TLS Certificates to the\n+AWS EC2 instance, it must validate that the service owner has\n+authorized its service to be launched by AWS EC2 Provider. In the\n+Athenz UI select your service that was created in the previous\n+step and click on the icon in the `Providers` column:\n+\n+![Service Identity Authorization_1](images/aws-service-authorize.png)\n+\n+Then, click on the `Allow` button to authorize your service to\n+be launched by AWS EC2 provider.\n+\n+![Service Identity Authorization_2](images/aws-service-authorize-2.png)\n+\n+\n+## IAM Role Setup\n+\n+There are two IAM roles required for instances to obtain Athenz X.509 certificates:\n+\n+- EC2 Instance Profile Role\n+- Athenz Service Identity Assume Role\n+\n+It is assumed that at this point you have already configured the first\n+EC2 Instance Profile IAM Role that your EC2 instance will be launched\n+with. In order to access your EC2 instances through the Bastion daemon,\n+your EC2 instance profile role must be named as `<domain>.<service>-service`.\n+The bastion service uses the profile arn to determine the EC2 instance\n+service name so it can carry out an authorization check to see if the user\n+is authorized to ssh login to the specified instance or not. If the property\n+is unable to name their instance profile name as `<domain>.<service>-service`\n+then check out the [Non Standard Instance Profile Name](#non-standard-instance-profile-name)\n+section for additional requirements.\n+\n+The second Athenz Service Identity IAM Assume Role must be created and\n+must have the `<domain>.<service>` name. This role will not have any\n+permissions but instead will have a trust relationship with your EC2\n+instance role such that your EC2 instance role can assume this role.\n+\n+In the AWS Console, select `IAM` from the Services drop down and then\n+click on the `Roles` link in the left sidebar. Choose the `Create Role`\n+button. Under the `AWS Service` type, select `EC2`, then `EC2` again\n+for the use case and finally choose `Next: Permissions` button in the\n+bottom right corner.\n+\n+![IAM Role Setup_1](images/iam-role-setup-1.png)\n+\n+In the `Attach permissions policy` screen do not choose any permissions\n+and just click on the `Next: Review` button in the bottom right corner\n+to continue. Specify the `Role name` in the `<domain>.<service>` format\n+and choose `Create Role` to complete the process.\n+\n+In the Roles list view, choose the role just created and choose the\n+`Trust Relationships` tab.\n+\n+![IAM Role Setup_2](images/iam-role-setup-2.png)\n+\n+Click on `Edit trust relationship` button and append a block containing\n+the following policy to the `Statement` block (Replace the `<account-id>`\n+and `<ec2-instance-role>` values with their corresponding values for\n+your environment:\n+\n+```\n+ {\n+   \"Effect\": \"Allow\",\n+   \"Principal\": {\n+     \"AWS\": \"arn:aws:iam::<account-id>:role/<ec2-instance-role>\"\n+   },\n+   \"Action\": \"sts:AssumeRole\"\n+ }\n+```\n+\n+Once correctly updated, your EC2 instance role must appear in the `Trusted entities` table:\n+\n+![IAM Role Setup_3](images/iam-role-setup-3.png)\n+\n+### Setup for Services with Region Specific Instance Profile Roles\n+\n+The IAM Role setup is identical when you have the same service\n+being deployed in multiple regions with role names that\n+are specific to each region. Since IAM roles are global, you only need\n+to create a single Athenz IAM Role in the `<domain>.<service>` format.\n+Then, when you're setting up your trust relationship, you'll authorize\n+all your region specific profile roles to have the capability to\n+assume the Athenz `<domain>.<service>` role.\n+\n+## Installing SIA\n+\n+The AWS SIA source is part of the Athenz project and can be found in:\n+```\n+provider/aws/sia-ec2\n+``` \n+Follow the readme for instructions on how to install it.\n+\n+## SIA Configuration Setup\n+\n+When building your image, you can include the following configuration\n+file called `sia_config` in the `/etc/sia` directory. It must include\n+the following required fields:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"<service name>\",\n+  \"accounts\": [\n+    {\n+      \"domain\": \"<domain name>\",\n+      \"account\": \"<aws account id associated with domain name>\"\n+    }\n+  ]\n+}\n+```\n+\n+The domain/account/service values here must match to the IAM Role\n+created earlier. For example, if the service identity name is `api`\n+in domain `sports` whose corresponding aws account id is `123456789`,\n+then the `sia_config` file will be as follows:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"api\",\n+  \"accounts\": [\n+    {\n+      \"domain\": \"sports\",\n+      \"account\": \"123456789\"\n+    }\n+  ]\n+}\n+```\n+\n+If you require bastion ssh access to your instances, then the profile\n+role must be called `<domain>.<service>-service` and you don't need to\n+specify this configuration file unless you want to change the ownership\n+of the generated private key and certificate files - see\n+[Private Key File Ownership](#private-key-file-ownership) section for more details.\n+\n+### Private Key File Ownership\n+\n+By default SIA agent runs as root and the private key is only readable\n+by root. If your service is running as another user, you can configure\n+SIA agent to automatically change the ownership of the private key file\n+to the configured user.\n+For example, if you want the private key to be owned by `ec2-user`, then\n+your `sia_config` configuration file would be as follows:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"api\",\n+  \"accounts\": [\n+    {\n+      \"domain\": \"sports\",\n+      \"account\": \"123456789\",\n+      \"user\": \"ec2-user\"\n+    }\n+  ]\n+}\n+```\n+\n+### SSH Certificate Support\n+\n+As part of the bootstrap process, SIA also retrieves a host ssh certificate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "originalPosition": 207}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzUyMjMz", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441752233", "createdAt": "2020-07-02T14:48:40Z", "commit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDo0ODo0MFrOGsQQ2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDo0ODo0MFrOGsQQ2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA1Njk4Ng==", "bodyText": "I left the assumption that the default location is /var/lib/sia/keys and /var/lib/sia/certs.", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r449056986", "createdAt": "2020-07-02T14:48:40Z", "author": {"login": "OferLevi85"}, "path": "docs/service_x509_credentials_aws.md", "diffHunk": "@@ -0,0 +1,346 @@\n+![AWS EC2 Setup](images/aws-ec2-setup.png)\n+\n+**Bootstrapping AWS EC2 instances with Athenz Service x.509 Identities\n+requires the instances to have network connectivity to both Athenz ZTS\n+and AWS STS Services.**\n+\n+## Domain Registration\n+\n+Identify your Athenz domain before you can proceed by using Athenz UI.\n+\n+You may create a top-level domain or a sub domain using Athenz UI or zms-cli.\n+Only Athenz System Administrators can create top level domains (members of the sys.auth role).\n+To create a top-level domain using zms-cli run the following:\n+\n+```\n+zms-cli add-domakn <domain-name> <unique-product-id> <domain-admins separated by space>\n+```\n+\n+If you already have top-level domain and need to create a sub domain using Athenz UI:\n+click the \"Create\u201d link next to \"My Domains\" label in the top right corner\n+and then click on \u201cSub Domain\u201d tab and follow the on screen instruction.\n+\n+![Create Sub Domain](images/create_sub_domain.png)\n+\n+Or using zms-cli:\n+```\n+zms-cli add-doman <top-doman.sub-domain-name> <domain-admins separated by space>\n+```\n+\n+## AWS Account ID Registration\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+## Athenz Service Identity Registration\n+\n+Create a service identity for your AWS EC2 instances in your Athenz domain. This full service identity name `<domain>.<service>` will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your EC2 Instance Role.\n+\n+In the Athenz UI, select your domain, select the `Services` tab and then choose `Add a Service` link in the top left corner. You must provide a service name and an optional description for your service. \n+\n+![Service Identity Registration](images/aws-service-register.png)\n+\n+## Athenz Service Identity Authorization\n+\n+Before ZTS can validate and issue X.509 TLS Certificates to the\n+AWS EC2 instance, it must validate that the service owner has\n+authorized its service to be launched by AWS EC2 Provider. In the\n+Athenz UI select your service that was created in the previous\n+step and click on the icon in the `Providers` column:\n+\n+![Service Identity Authorization_1](images/aws-service-authorize.png)\n+\n+Then, click on the `Allow` button to authorize your service to\n+be launched by AWS EC2 provider.\n+\n+![Service Identity Authorization_2](images/aws-service-authorize-2.png)\n+\n+\n+## IAM Role Setup\n+\n+There are two IAM roles required for instances to obtain Athenz X.509 certificates:\n+\n+- EC2 Instance Profile Role\n+- Athenz Service Identity Assume Role\n+\n+It is assumed that at this point you have already configured the first\n+EC2 Instance Profile IAM Role that your EC2 instance will be launched\n+with. In order to access your EC2 instances through the Bastion daemon,\n+your EC2 instance profile role must be named as `<domain>.<service>-service`.\n+The bastion service uses the profile arn to determine the EC2 instance\n+service name so it can carry out an authorization check to see if the user\n+is authorized to ssh login to the specified instance or not. If the property\n+is unable to name their instance profile name as `<domain>.<service>-service`\n+then check out the [Non Standard Instance Profile Name](#non-standard-instance-profile-name)\n+section for additional requirements.\n+\n+The second Athenz Service Identity IAM Assume Role must be created and\n+must have the `<domain>.<service>` name. This role will not have any\n+permissions but instead will have a trust relationship with your EC2\n+instance role such that your EC2 instance role can assume this role.\n+\n+In the AWS Console, select `IAM` from the Services drop down and then\n+click on the `Roles` link in the left sidebar. Choose the `Create Role`\n+button. Under the `AWS Service` type, select `EC2`, then `EC2` again\n+for the use case and finally choose `Next: Permissions` button in the\n+bottom right corner.\n+\n+![IAM Role Setup_1](images/iam-role-setup-1.png)\n+\n+In the `Attach permissions policy` screen do not choose any permissions\n+and just click on the `Next: Review` button in the bottom right corner\n+to continue. Specify the `Role name` in the `<domain>.<service>` format\n+and choose `Create Role` to complete the process.\n+\n+In the Roles list view, choose the role just created and choose the\n+`Trust Relationships` tab.\n+\n+![IAM Role Setup_2](images/iam-role-setup-2.png)\n+\n+Click on `Edit trust relationship` button and append a block containing\n+the following policy to the `Statement` block (Replace the `<account-id>`\n+and `<ec2-instance-role>` values with their corresponding values for\n+your environment:\n+\n+```\n+ {\n+   \"Effect\": \"Allow\",\n+   \"Principal\": {\n+     \"AWS\": \"arn:aws:iam::<account-id>:role/<ec2-instance-role>\"\n+   },\n+   \"Action\": \"sts:AssumeRole\"\n+ }\n+```\n+\n+Once correctly updated, your EC2 instance role must appear in the `Trusted entities` table:\n+\n+![IAM Role Setup_3](images/iam-role-setup-3.png)\n+\n+### Setup for Services with Region Specific Instance Profile Roles\n+\n+The IAM Role setup is identical when you have the same service\n+being deployed in multiple regions with role names that\n+are specific to each region. Since IAM roles are global, you only need\n+to create a single Athenz IAM Role in the `<domain>.<service>` format.\n+Then, when you're setting up your trust relationship, you'll authorize\n+all your region specific profile roles to have the capability to\n+assume the Athenz `<domain>.<service>` role.\n+\n+## Installing SIA\n+\n+The AWS SIA source is part of the Athenz project and can be found in:\n+```\n+provider/aws/sia-ec2\n+``` \n+Follow the readme for instructions on how to install it.\n+\n+## SIA Configuration Setup\n+\n+When building your image, you can include the following configuration\n+file called `sia_config` in the `/etc/sia` directory. It must include\n+the following required fields:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"<service name>\",\n+  \"accounts\": [\n+    {\n+      \"domain\": \"<domain name>\",\n+      \"account\": \"<aws account id associated with domain name>\"\n+    }\n+  ]\n+}\n+```\n+\n+The domain/account/service values here must match to the IAM Role\n+created earlier. For example, if the service identity name is `api`\n+in domain `sports` whose corresponding aws account id is `123456789`,\n+then the `sia_config` file will be as follows:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"api\",\n+  \"accounts\": [\n+    {\n+      \"domain\": \"sports\",\n+      \"account\": \"123456789\"\n+    }\n+  ]\n+}\n+```\n+\n+If you require bastion ssh access to your instances, then the profile\n+role must be called `<domain>.<service>-service` and you don't need to\n+specify this configuration file unless you want to change the ownership\n+of the generated private key and certificate files - see\n+[Private Key File Ownership](#private-key-file-ownership) section for more details.\n+\n+### Private Key File Ownership\n+\n+By default SIA agent runs as root and the private key is only readable\n+by root. If your service is running as another user, you can configure\n+SIA agent to automatically change the ownership of the private key file\n+to the configured user.\n+For example, if you want the private key to be owned by `ec2-user`, then\n+your `sia_config` configuration file would be as follows:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"api\",\n+  \"accounts\": [\n+    {\n+      \"domain\": \"sports\",\n+      \"account\": \"123456789\",\n+      \"user\": \"ec2-user\"\n+    }\n+  ]\n+}\n+```\n+\n+### SSH Certificate Support\n+\n+As part of the bootstrap process, SIA also retrieves a host ssh certificate\n+to be used by the bastion daemon that provides ssh access to instances.\n+However, if the administrator wants to disable this functionality, they\n+can do so by specifying `ssh` entry in their `sia_config` file with `false`\n+value as follows:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"api\",\n+  \"ssh\": false,\n+  \"accounts\": [\n+    {\n+      \"domain\": \"sports\",\n+      \"account\": \"123456789\"\n+    }\n+  ]\n+}\n+```\n+\n+## Private Key and Certificate Setup\n+\n+By default, the private key for the service identity is available in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "originalPosition": 229}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzYyOTEw", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441762910", "createdAt": "2020-07-02T15:00:09Z", "commit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTowMDoxMFrOGsQwGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTowMDoxMFrOGsQwGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2NDk4NQ==", "bodyText": "Removed the explanation on how to install the private keys using Ykeykey or chef as ykeykey isn't open source and so is the logic done by chef.", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r449064985", "createdAt": "2020-07-02T15:00:10Z", "author": {"login": "OferLevi85"}, "path": "docs/sia_server_guide.md", "diffHunk": "@@ -0,0 +1,75 @@\n+SIA Server is required for authenticating existing unmanaged services. For\n+managed service inception (e.g., Manhattan), other more convenient\n+automated mechanisms get the credentials safely to the service. The SIA\n+server provides on-box support for securely getting an identity token\n+for a running service that was previously registered in ZMS.\n+\n+The SIA server requires access to that service's [private key](reg_service_guide.md)\n+to sign the token. The server runs as a protected local agent, and the services use Unix domain\n+socket interface to request tokens. SIA communicates with ZTS to validate service details.\n+\n+## Installing SIA\n+\n+The AWS SIA source is part of the Athenz project and can be found in:\n+```\n+provider/aws/sia-ec2\n+``` \n+Follow the readme for instructions on how to install it.\n+\n+## Private Key Installation\n+\n+The SIA Server needs to have access the service's private key so it can\n+generate and sign a ServiceToken for the service. Then the service can\n+use that ServiceToken to authenticate itself in Athenz and, if\n+necessary, obtain a RoleToken to process requests against other Athenz\n+protected services.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzY3ODY5", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441767869", "createdAt": "2020-07-02T15:05:35Z", "commit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTowNTozNlrOGsQ-Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTowNTozNlrOGsQ-Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2ODU3NA==", "bodyText": "Removed the verification tool \"sia_ntoken\" which is part of \"athens_tools\" which isn't open source.", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r449068574", "createdAt": "2020-07-02T15:05:36Z", "author": {"login": "OferLevi85"}, "path": "docs/sia_server_guide.md", "diffHunk": "@@ -0,0 +1,75 @@\n+SIA Server is required for authenticating existing unmanaged services. For\n+managed service inception (e.g., Manhattan), other more convenient\n+automated mechanisms get the credentials safely to the service. The SIA\n+server provides on-box support for securely getting an identity token\n+for a running service that was previously registered in ZMS.\n+\n+The SIA server requires access to that service's [private key](reg_service_guide.md)\n+to sign the token. The server runs as a protected local agent, and the services use Unix domain\n+socket interface to request tokens. SIA communicates with ZTS to validate service details.\n+\n+## Installing SIA\n+\n+The AWS SIA source is part of the Athenz project and can be found in:\n+```\n+provider/aws/sia-ec2\n+``` \n+Follow the readme for instructions on how to install it.\n+\n+## Private Key Installation\n+\n+The SIA Server needs to have access the service's private key so it can\n+generate and sign a ServiceToken for the service. Then the service can\n+use that ServiceToken to authenticate itself in Athenz and, if\n+necessary, obtain a RoleToken to process requests against other Athenz\n+protected services.\n+\n+## Key Update/New Service\n+\n+If a new service is updated on the host or the key has been updated on\n+disk, the SIA service must be restarted for the changes to take effect\n+because it caches the private key details during server startup.\n+\n+## Service Identity Setup Verification\n+\n+Once the private key has been installed on the SIA Server and the\n+Service has been registered in ZMS with its public key, the\n+administrator can verify that the setup is done correctly by executing\n+the following command:\n+\n+```\n+sudo /home/y/bin64/sia_setup_verify -d <domain-name> -s <service-name>\n+```\n+\n+The command will verify that the private key is installed in the correct\n+directory location and a service token will be generated successfully.\n+Then it will verify that it can authenticate against ZTS server with\n+that service token and retrieve the Service Identity details. It will\n+also verify that the public key with the correct key identifier is\n+registered in Athenz. Any issues will be reported with suggestions how\n+to fix them.\n+\n+This utility only verifies your service configuration without connecting\n+to SIA Server over its protocol. Once the configuration details have been\n+verified, the administrator needs to make sure that the SIA Server is\n+restarted and running.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzcyNTMz", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441772533", "createdAt": "2020-07-02T15:09:42Z", "commit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTowOTo0MlrOGsRI5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTowOTo0MlrOGsRI5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3MTMzNQ==", "bodyText": "Removed explanation on increasing log level using yinst", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r449071335", "createdAt": "2020-07-02T15:09:42Z", "author": {"login": "OferLevi85"}, "path": "docs/sia_server_guide.md", "diffHunk": "@@ -0,0 +1,75 @@\n+SIA Server is required for authenticating existing unmanaged services. For\n+managed service inception (e.g., Manhattan), other more convenient\n+automated mechanisms get the credentials safely to the service. The SIA\n+server provides on-box support for securely getting an identity token\n+for a running service that was previously registered in ZMS.\n+\n+The SIA server requires access to that service's [private key](reg_service_guide.md)\n+to sign the token. The server runs as a protected local agent, and the services use Unix domain\n+socket interface to request tokens. SIA communicates with ZTS to validate service details.\n+\n+## Installing SIA\n+\n+The AWS SIA source is part of the Athenz project and can be found in:\n+```\n+provider/aws/sia-ec2\n+``` \n+Follow the readme for instructions on how to install it.\n+\n+## Private Key Installation\n+\n+The SIA Server needs to have access the service's private key so it can\n+generate and sign a ServiceToken for the service. Then the service can\n+use that ServiceToken to authenticate itself in Athenz and, if\n+necessary, obtain a RoleToken to process requests against other Athenz\n+protected services.\n+\n+## Key Update/New Service\n+\n+If a new service is updated on the host or the key has been updated on\n+disk, the SIA service must be restarted for the changes to take effect\n+because it caches the private key details during server startup.\n+\n+## Service Identity Setup Verification\n+\n+Once the private key has been installed on the SIA Server and the\n+Service has been registered in ZMS with its public key, the\n+administrator can verify that the setup is done correctly by executing\n+the following command:\n+\n+```\n+sudo /home/y/bin64/sia_setup_verify -d <domain-name> -s <service-name>\n+```\n+\n+The command will verify that the private key is installed in the correct\n+directory location and a service token will be generated successfully.\n+Then it will verify that it can authenticate against ZTS server with\n+that service token and retrieve the Service Identity details. It will\n+also verify that the public key with the correct key identifier is\n+registered in Athenz. Any issues will be reported with suggestions how\n+to fix them.\n+\n+This utility only verifies your service configuration without connecting\n+to SIA Server over its protocol. Once the configuration details have been\n+verified, the administrator needs to make sure that the SIA Server is\n+restarted and running.\n+\n+## Logging/Troubleshooting\n+\n+If there are any issues with receiving `PrincipalTokens` for any\n+service, the administrator can check the log file for any error\n+messages.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODAyNDY0", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-441802464", "createdAt": "2020-07-02T15:29:53Z", "commit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNToyOTo1NFrOGsSFvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTozMDoxMFrOGsSHFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4NjkwOA==", "bodyText": "@OferLevi85", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r449086908", "createdAt": "2020-07-02T15:29:54Z", "author": {"login": "abvaidya"}, "path": "docs/aws_temp_creds.md", "diffHunk": "@@ -0,0 +1,492 @@\n+This feature allows any service to obtain temporary session credentials\n+for a role defined in AWS IAM to carry out operations against AWS Services.\n+For example, your service might need to access its own S3 bucket to\n+push some data to AWS. Instead of using an IAM user's credentials to\n+access that S3 bucket, the administrator will define a role providing\n+access to that S3 bucket and then configure their service to retrieve\n+temporary session credentials for that role through ZTS Server.\n+\n+## Connection Details\n+\n+To obtain temporary credentials, the client must contact ZTS Server\n+running in AWS.\n+\n+## Client X.509 Certificate Requirements\n+\n+To contact ZTS running in AWS to obtain temporary credentials, the client\n+service must authenticate itself using Athenz issued client X.509 certificates.\n+The steps are different depending on where your client service is running.\n+\n+Follow [these steps](service_x509_credentials.md) to obtain a service x.509\n+certificate for your client service.\n+\n+## AWS Account ID Registration\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+## AWS Configuration Setup\n+\n+To obtain temporary credentials for a given role through ZTS Server, the\n+administrator must follow through these steps:\n+\n+1\\. You must already have a role created in AWS IAM that you would like\n+to obtain temporary credentials for.\n+\n+2\\. In AWS, setup a trust relationship for your role such that ZTS can\n+assume that role. On the IAM Roles page, choose the role that you want\n+to modify and click on the Trust Relationships tab. Click on the Edit\n+Trust Relationship button and append the following section to the\n+current document's Statement element (don't forget to make sure to\n+convert the Statement element into an array and add necessary commas):\n+\n+```\n+    {\n+        \"Effect\": \"Allow\",\n+        \"Principal\": {\n+            \"AWS\": \"arn:aws:iam::799404451347:role/athenz-zts-service\"\n+        },\n+        \"Action\": \"sts:AssumeRole\"\n+    }\n+```\n+\n+If configured correctly, the Trust Relationships tab should show\n+athenz-zts-service as one of entries in the Trusted Entities table.\n+\n+![AWS IAM Role Trust Relationship Setup](images/aws_trust_setup.png)\n+\n+### Expiration Period\n+\n+AWS announced that they have extended the federated api access to AWS resources\n+from the default 1 hour to up to [12 hours](https://aws.amazon.com/blogs/security/enable-federated-api-access-to-your-aws-resources-for-up-to-12-hours-using-iam-roles/). To change the expiration\n+period for a role, click on the `Edit` link in the role configuration\n+screen in IAM and choose either one of the predefined duration or specify\n+a custom one.\n+\n+![AWS IAM Role Duration](images/aws_trust_setup_duration.png)\n+\n+Once the role is configured with a longer duration period.\n+use the ZTS client api as described in the [Obtaining AWS Temporary Credentials](#obtaining-aws-temporary-credentials)\n+section to specify the requested duration for the temporary credentials.\n+\n+### External ID Condition\n+\n+By including an external id condition in the AssumeRole policy,\n+the account administrator secures its roles to be accessed by\n+unauthorized principals in case ZTS has been compromised since\n+AWS STS will reject any assume role requests unless the external\n+id is specified as part of the request.\n+\n+Once an external id has been chosen, the AssumeRole policy configured\n+for the role can be updated to include the external id condition. For\n+example, to configure an external id `hockey` for our role we'll\n+have the following policy:\n+\n+```\n+    {\n+        \"Effect\": \"Allow\",\n+        \"Principal\": {\n+            \"AWS\": \"arn:aws:iam::799404451347:role/athenz-zts-service\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA4NzI1Mw==", "bodyText": "@OferLevi85", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r449087253", "createdAt": "2020-07-02T15:30:10Z", "author": {"login": "abvaidya"}, "path": "docs/aws_temp_creds.md", "diffHunk": "@@ -0,0 +1,492 @@\n+This feature allows any service to obtain temporary session credentials\n+for a role defined in AWS IAM to carry out operations against AWS Services.\n+For example, your service might need to access its own S3 bucket to\n+push some data to AWS. Instead of using an IAM user's credentials to\n+access that S3 bucket, the administrator will define a role providing\n+access to that S3 bucket and then configure their service to retrieve\n+temporary session credentials for that role through ZTS Server.\n+\n+## Connection Details\n+\n+To obtain temporary credentials, the client must contact ZTS Server\n+running in AWS.\n+\n+## Client X.509 Certificate Requirements\n+\n+To contact ZTS running in AWS to obtain temporary credentials, the client\n+service must authenticate itself using Athenz issued client X.509 certificates.\n+The steps are different depending on where your client service is running.\n+\n+Follow [these steps](service_x509_credentials.md) to obtain a service x.509\n+certificate for your client service.\n+\n+## AWS Account ID Registration\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+## AWS Configuration Setup\n+\n+To obtain temporary credentials for a given role through ZTS Server, the\n+administrator must follow through these steps:\n+\n+1\\. You must already have a role created in AWS IAM that you would like\n+to obtain temporary credentials for.\n+\n+2\\. In AWS, setup a trust relationship for your role such that ZTS can\n+assume that role. On the IAM Roles page, choose the role that you want\n+to modify and click on the Trust Relationships tab. Click on the Edit\n+Trust Relationship button and append the following section to the\n+current document's Statement element (don't forget to make sure to\n+convert the Statement element into an array and add necessary commas):\n+\n+```\n+    {\n+        \"Effect\": \"Allow\",\n+        \"Principal\": {\n+            \"AWS\": \"arn:aws:iam::799404451347:role/athenz-zts-service\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "originalPosition": 49}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/43cd0972c45b29a3cb62b47817c45f2ebee5dee2", "committedDate": "2020-07-02T14:25:19Z", "message": "Authentication Documentation"}, "afterCommit": {"oid": "6ea1609a3d77a066f3a774768763af9ade5a7132", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/6ea1609a3d77a066f3a774768763af9ade5a7132", "committedDate": "2020-07-02T15:36:35Z", "message": "Authentication Documentation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "93d14d0c4e6f95d13019784db159f5a395121723", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/93d14d0c4e6f95d13019784db159f5a395121723", "committedDate": "2020-07-02T17:44:51Z", "message": "Fix"}, "afterCommit": {"oid": "92e0e5dc54c39e1fcc3c4ac3e670f982a217a137", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/92e0e5dc54c39e1fcc3c4ac3e670f982a217a137", "committedDate": "2020-07-02T17:45:28Z", "message": "Authentication Documentation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "92e0e5dc54c39e1fcc3c4ac3e670f982a217a137", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/92e0e5dc54c39e1fcc3c4ac3e670f982a217a137", "committedDate": "2020-07-02T17:45:28Z", "message": "Authentication Documentation"}, "afterCommit": {"oid": "6500c7d9f3f10a08e3b5787a25c1b796c3226df3", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/6500c7d9f3f10a08e3b5787a25c1b796c3226df3", "committedDate": "2020-07-02T17:53:14Z", "message": "Authentication Documentation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6500c7d9f3f10a08e3b5787a25c1b796c3226df3", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/6500c7d9f3f10a08e3b5787a25c1b796c3226df3", "committedDate": "2020-07-02T17:53:14Z", "message": "Authentication Documentation"}, "afterCommit": {"oid": "ec4e0a39228ec33169784b94c998da27d8744ec6", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/ec4e0a39228ec33169784b94c998da27d8744ec6", "committedDate": "2020-07-02T19:27:35Z", "message": "Authentication Documentation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ec4e0a39228ec33169784b94c998da27d8744ec6", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/ec4e0a39228ec33169784b94c998da27d8744ec6", "committedDate": "2020-07-02T19:27:35Z", "message": "Authentication Documentation"}, "afterCommit": {"oid": "b073fc036bca2bc40da1a2d1d69ab8708d80cd6c", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/b073fc036bca2bc40da1a2d1d69ab8708d80cd6c", "committedDate": "2020-07-02T19:42:36Z", "message": "Authentication Documentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NTEwNjA5", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-447510609", "createdAt": "2020-07-13T18:47:36Z", "commit": {"oid": "b073fc036bca2bc40da1a2d1d69ab8708d80cd6c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxODo0NzozNlrOGw1UEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMDozNjoyNVrOGw45Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1ODMyMg==", "bodyText": "dist is internal reference", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r453858322", "createdAt": "2020-07-13T18:47:36Z", "author": {"login": "abvaidya"}, "path": "docs/reg_service_guide.md", "diffHunk": "@@ -1,82 +1,94 @@\n-# Registering ZMS Service Identity\n-----------------------------------\n-\n-* [Key Generation](#key-generation)\n-    * [Private Keys](#private-keys)\n-    * [Key Rotation](#key-rotation)\n-* [Service Identity Registration](#service-identity-registration)\n-\n Once a domain has been registered in Athenz, the administrator will\n register service identities that are specified in domain roles and\n policy assertions. The latter can reference those roles having access to\n-specified resources.\n+specified resources. Athenz supports service authentication with\n+two types of credentials:\n+\n+- X.509 Certificates (preferred approach) [Instructions](service_x509_credentials.md)\n+- Public/Private Key Pairs\n \n Before you can register the service identity, you'll need to generate\n-keys. We'll cover how to create the keys and register the service\n-identity next.\n+keys. In this section we'll cover how to create the keys and register the service\n+identity.\n \n ## Key Generation\n-----------------\n \n The registration process requires the domain administrator to generate a\n-private/public RSA key pair (recommended to be at least 2048 bit)\n-for the service. Athenz also supports EC keys.\n+private/public RSA key pair (must be at least 2048 bit) for the service.\n \n The following are the keys and the services that use those keys:\n \n--   **private key** - The service agent uses the private key to generate a\n+-   **private key** - The SIA server/utility uses the private key to generate a\n     `ServiceToken` identifying the service.\n -   **public key** - ZMS/ZTS then use the public key to validate the\n-    `ServiceToken` generated by service agent.\n+    `ServiceToken` generated by SIA.\n \n The `openssl` command-line utility is used to generate the key pair:\n \n-    $ openssl genrsa -out service_private.pem 2048\n-    $ openssl rsa -in service_private.pem -pubout > service_public.pem\n-\n+```\n+    $ umask 077\n+    $ openssl genrsa -out service_private.key 2048\n+    $ openssl rsa -in service_private.key -pubout > service_public.key\n+```\n \n-The zms-cli client utility requires that the public key have an extension\n-of .pem.\n+If using the [zms-cli](zms_client.md) client utility to register the service identity,\n+the public key file must have an extension of .pem or .key.\n \n ### Private Keys\n-----------------\n \n-The private key file must be installed on all hosts where the client\n-service will be running.\n+The private key file must be installed on all hosts where the service\n+will be running. The reason the use of X.509 Certificates is the\n+preferred approach is because to securely install the private key\n+on all hosts presents a challenge. It can be made available through\n+installing the private key as part of a passphrase-protected `dist` package,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b073fc036bca2bc40da1a2d1d69ab8708d80cd6c"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1ODQ5OA==", "bodyText": "Ykeykey / YCA are internal", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r453858498", "createdAt": "2020-07-13T18:47:53Z", "author": {"login": "abvaidya"}, "path": "docs/reg_service_guide.md", "diffHunk": "@@ -1,82 +1,94 @@\n-# Registering ZMS Service Identity\n-----------------------------------\n-\n-* [Key Generation](#key-generation)\n-    * [Private Keys](#private-keys)\n-    * [Key Rotation](#key-rotation)\n-* [Service Identity Registration](#service-identity-registration)\n-\n Once a domain has been registered in Athenz, the administrator will\n register service identities that are specified in domain roles and\n policy assertions. The latter can reference those roles having access to\n-specified resources.\n+specified resources. Athenz supports service authentication with\n+two types of credentials:\n+\n+- X.509 Certificates (preferred approach) [Instructions](service_x509_credentials.md)\n+- Public/Private Key Pairs\n \n Before you can register the service identity, you'll need to generate\n-keys. We'll cover how to create the keys and register the service\n-identity next.\n+keys. In this section we'll cover how to create the keys and register the service\n+identity.\n \n ## Key Generation\n-----------------\n \n The registration process requires the domain administrator to generate a\n-private/public RSA key pair (recommended to be at least 2048 bit)\n-for the service. Athenz also supports EC keys.\n+private/public RSA key pair (must be at least 2048 bit) for the service.\n \n The following are the keys and the services that use those keys:\n \n--   **private key** - The service agent uses the private key to generate a\n+-   **private key** - The SIA server/utility uses the private key to generate a\n     `ServiceToken` identifying the service.\n -   **public key** - ZMS/ZTS then use the public key to validate the\n-    `ServiceToken` generated by service agent.\n+    `ServiceToken` generated by SIA.\n \n The `openssl` command-line utility is used to generate the key pair:\n \n-    $ openssl genrsa -out service_private.pem 2048\n-    $ openssl rsa -in service_private.pem -pubout > service_public.pem\n-\n+```\n+    $ umask 077\n+    $ openssl genrsa -out service_private.key 2048\n+    $ openssl rsa -in service_private.key -pubout > service_public.key\n+```\n \n-The zms-cli client utility requires that the public key have an extension\n-of .pem.\n+If using the [zms-cli](zms_client.md) client utility to register the service identity,\n+the public key file must have an extension of .pem or .key.\n \n ### Private Keys\n-----------------\n \n-The private key file must be installed on all hosts where the client\n-service will be running.\n+The private key file must be installed on all hosts where the service\n+will be running. The reason the use of X.509 Certificates is the\n+preferred approach is because to securely install the private key\n+on all hosts presents a challenge. It can be made available through\n+installing the private key as part of a passphrase-protected `dist` package,\n+however, the use of those packages is no longer recommended by Paranoids.\n+That leaves the option to either install through Chef or Ykeykey (using YCA).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b073fc036bca2bc40da1a2d1d69ab8708d80cd6c"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1ODU4OQ==", "bodyText": "internal references", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r453858589", "createdAt": "2020-07-13T18:48:04Z", "author": {"login": "abvaidya"}, "path": "docs/reg_service_guide.md", "diffHunk": "@@ -1,82 +1,94 @@\n-# Registering ZMS Service Identity\n-----------------------------------\n-\n-* [Key Generation](#key-generation)\n-    * [Private Keys](#private-keys)\n-    * [Key Rotation](#key-rotation)\n-* [Service Identity Registration](#service-identity-registration)\n-\n Once a domain has been registered in Athenz, the administrator will\n register service identities that are specified in domain roles and\n policy assertions. The latter can reference those roles having access to\n-specified resources.\n+specified resources. Athenz supports service authentication with\n+two types of credentials:\n+\n+- X.509 Certificates (preferred approach) [Instructions](service_x509_credentials.md)\n+- Public/Private Key Pairs\n \n Before you can register the service identity, you'll need to generate\n-keys. We'll cover how to create the keys and register the service\n-identity next.\n+keys. In this section we'll cover how to create the keys and register the service\n+identity.\n \n ## Key Generation\n-----------------\n \n The registration process requires the domain administrator to generate a\n-private/public RSA key pair (recommended to be at least 2048 bit)\n-for the service. Athenz also supports EC keys.\n+private/public RSA key pair (must be at least 2048 bit) for the service.\n \n The following are the keys and the services that use those keys:\n \n--   **private key** - The service agent uses the private key to generate a\n+-   **private key** - The SIA server/utility uses the private key to generate a\n     `ServiceToken` identifying the service.\n -   **public key** - ZMS/ZTS then use the public key to validate the\n-    `ServiceToken` generated by service agent.\n+    `ServiceToken` generated by SIA.\n \n The `openssl` command-line utility is used to generate the key pair:\n \n-    $ openssl genrsa -out service_private.pem 2048\n-    $ openssl rsa -in service_private.pem -pubout > service_public.pem\n-\n+```\n+    $ umask 077\n+    $ openssl genrsa -out service_private.key 2048\n+    $ openssl rsa -in service_private.key -pubout > service_public.key\n+```\n \n-The zms-cli client utility requires that the public key have an extension\n-of .pem.\n+If using the [zms-cli](zms_client.md) client utility to register the service identity,\n+the public key file must have an extension of .pem or .key.\n \n ### Private Keys\n-----------------\n \n-The private key file must be installed on all hosts where the client\n-service will be running.\n+The private key file must be installed on all hosts where the service\n+will be running. The reason the use of X.509 Certificates is the\n+preferred approach is because to securely install the private key\n+on all hosts presents a challenge. It can be made available through\n+installing the private key as part of a passphrase-protected `dist` package,\n+however, the use of those packages is no longer recommended by Paranoids.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b073fc036bca2bc40da1a2d1d69ab8708d80cd6c"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1OTM3OQ==", "bodyText": "Omega / Ensemble , SD are internal references", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r453859379", "createdAt": "2020-07-13T18:49:28Z", "author": {"login": "abvaidya"}, "path": "docs/service_x509_credentials.md", "diffHunk": "@@ -0,0 +1,101 @@\n+Once a domain has been registered in Athenz, the administrator will\n+register service identities that are specified in domain roles and\n+policy assertions. The latter can reference those roles having access to\n+specified resources. Athenz supports service authentication with\n+two types of credentials:\n+\n+- X.509 Certificates (preferred approach)\n+- Public/Private Key Pairs [Instructions](reg_service_guide.md)\n+\n+To contact Athenz Services (ZMS/ZTS) or other Athenz Enabled services,\n+the client service must first obtain an Athenz CA issued X.509 certificate.\n+In this section we'll cover how to register the service identity and\n+obtain X.509 certificates based on what environment your service will be running in.\n+\n+## Use Case 1: Service Running in AWS EC2\n+\n+If the service is running in AWS, Service Identity Agent (SIA) running on the\n+instance is responsible for generating a private key for the service and\n+obtaining a x.509 certificate from ZTS Service. The files are located in\n+the following locations:\n+\n+```\n+    private-key: /var/lib/sia/keys/<domain>.<service>.key.pem\n+    certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem\n+```\n+\n+The certificate is valid for 30 days and SIA agent automatically\n+will refresh the certificate daily. Follow [these steps](service_x509_credentials_aws.md) for\n+full details how to configure SIA agent running in AWS as part\n+of the foundation image.\n+\n+## Use Case 2: Service running on-prem within an Athenz Enabled Framework (K8S Omega/Ensemble, SD v3/v4)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b073fc036bca2bc40da1a2d1d69ab8708d80cd6c"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg1OTkyOA==", "bodyText": "need to generalize the assumption of members of sys.auth admin role", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r453859928", "createdAt": "2020-07-13T18:50:28Z", "author": {"login": "abvaidya"}, "path": "docs/service_x509_credentials_aws.md", "diffHunk": "@@ -0,0 +1,346 @@\n+![AWS EC2 Setup](images/aws-ec2-setup.png)\n+\n+**Bootstrapping AWS EC2 instances with Athenz Service x.509 Identities\n+requires the instances to have network connectivity to both Athenz ZTS\n+and AWS STS Services.**\n+\n+## Domain Registration\n+\n+Identify your Athenz domain before you can proceed by using Athenz UI.\n+\n+You may create a top-level domain or a sub domain using Athenz UI or zms-cli.\n+Only Athenz System Administrators can create top level domains (members of the sys.auth role).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA0MzUzMA=="}, "originalCommit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkxMzQ2Mg==", "bodyText": "internal", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r453913462", "createdAt": "2020-07-13T20:30:03Z", "author": {"login": "abvaidya"}, "path": "docs/service_x509_credentials_aws_lambda.md", "diffHunk": "@@ -0,0 +1,254 @@\n+\n+> **Important:** Certificate Signing is an expensive operation (both on the client and\n+>  the server side) so if your application is going to launch large number of instances\n+>  of your lambda function, then you must not fetch Athenz x.509 certificates directly\n+>  within your lambda function. The recommended approach for that scenario is have one\n+>  lambda function to fetch the Athenz X.509 Certificate Identity private key and the\n+>  public certificate, store them in AWS Parameter Store and update those daily. Then\n+>  have all other lambda functions authorized based on their IAM credentials to fetch\n+>  and use that x.509 certificate.\n+\n+## Domain Registration\n+\n+Identify your Athenz domain before you can proceed by visiting Athenz UI.\n+\n+Follow the [instructions documented for EC2 instances](service_x509_credentials_aws.md#domain-registration) to register your domain if one doesn't exist already.\n+\n+## AWS Account ID Registration\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+## Athenz Service Identity Registration\n+\n+Create a service identity for your AWS Lambda function in your Athenz domain. This full service identity name `<domain>.<service>` will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your Lambda Function Execution Role.\n+\n+In the Athenz UI, select your domain, select the `Services` tab and then choose `Add a Service`  link in the top left corner. You must provide a service name and an optional description for your service.\n+\n+![Service Identity Registration](images/aws-service-register.png)\n+\n+## Athenz Service Identity Authorization Role and Policy\n+\n+Before ZTS can validate and issue X.509 TLS Certificates to the AWS Lambda, it must validate that the service owner has authorized its service to be launched by AWS Lambda Provider. The following role and policy must be created in your Athenz domain for this authorization:\n+\n+When viewing your domain details, choose the `Roles` tab and select\n+`Add Role` link on the left side of the screen underneath the tab names.\n+Role details are as follows (don't forget to press the `Add` button after\n+specifying the role member before pressing the `Submit` button):\n+\n+```\n+Role Category: Regular\n+Role Name: aws_lambda_launch_provider\n+Add Member(s): athens.aws-lambda.*\n+```\n+\n+Then choose the `Policies` tab and select `Add Policy` link on the left side\n+of the screen underneath the tab names. Policy details are as follows\n+(make sure to replace `<your-service-name>` in the Rule Resource\n+with your actual service name):\n+\n+```\n+Policy Name: aws_lambda_launch_provider\n+Rule Effect: Allow\n+Rule Action: launch\n+Rule Role: aws_lambda_launch_provider\n+Rule Resource: service.<your-service-name>\n+```\n+\n+## IAM Role Setup\n+\n+There are two IAM roles required for instances to obtain Athenz X.509 certificates:\n+\n+- Lambda Function Execution Role\n+- Athenz Service Identity Assume Role\n+\n+It is assumed that at this point you have already configured the first Lambda Function Execution Role that your code will be launched with (roles created through the AWS console are created with /service-role/ path). The second Athenz Service Identity IAM Assume Role must be created and must have the `<domain>.<service>` name. This role will not have any permissions but instead will have a trust relationship with your Lambda execution role such that your Lambda execution role can assume this role.\n+\n+In the AWS Console, select `IAM` from the Services drop down and then click on the `Roles` link in the left sidebar. Choose the `Create Role` button. Under the `AWS Service` type, select `Lambda` and choose `Next: Permissions` button in the bottom right corner.\n+\n+![IAM Lambda Role Setup_1](images/iam-lambda-role-setup-1.png)\n+\n+In the `Attach permissions policy` screen do not choose any permissions and just click on the `Next: Review` button in the bottom right corner to continue. Specify the `Role name` in the `<domain>.<service>` format and choose `Create Role` to complete the process.\n+\n+In the Roles list view, choose the role just created and choose the `Trust Relationships` tab.\n+\n+![IAM Lambda Role Setup_2](images/iam-lambda-role-setup-2.png)\n+\n+Click on `Edit trust relationship` button and append a block containing the following policy to the `Statement` block Replace the `<account-id>` and `<lambda-execution-role>` values with their corresponding values for your environment. For the `<lambda-execution-role>` make sure to include the full path since roles created through the AWS console are created with `/service-role/` path:\n+\n+```\n+ {\n+   \"Effect\": \"Allow\",\n+   \"Principal\": {\n+     \"AWS\": \"arn:aws:iam::<account-id>:role/<lambda-execution-role>\"\n+   },\n+   \"Action\": \"sts:AssumeRole\"\n+ }\n+```\n+\n+Once correctly updated, your Lambda role must appear in the `Trusted entities` table:\n+\n+![IAM Lambda Role Setup_3](images/iam-lambda-role-setup-3.png)\n+\n+## Private Key and Certificate Setup\n+\n+Since we're dealing with functions in this use case, we cannot have a SIA agent daemon running to generate a private key for the service and then retrieve a corresponding x.509 certificate from the ZTS Server. Instead, the function being invoked will be responsible for generating a private key and then a csr for its request. Finally, it will submit that request to the ZTS Server to retrieve its X.509 certificate which then it can use  along with its generated private key to establish TLS connections to other Verizon Media Athenz enabled services. Athenz Team provides functions/methods in Go and Java programming languages to quickly generate a private key and request its corresponding X.509 certificate from ZTS Server.\n+\n+Important consideration when dealing with Lambda functions:\n+\n+* The code to do this needs to prefetch and cache the certificate in a way that does not block every invocation, as minting a new certificate is somewhat expensive.\n+* The short lifetime and stateless nature of the function means it cannot rotate its certificates. It just gets new ones when needed.\n+\n+### Java\n+\n+The following function is available in the Athenz ZTS Java Client:\n+\n+```\n+/**\n+ * For AWS Lambda functions generate a new private key, request a\n+ * x.509 certificate based on the requested CSR and return both to\n+ * the client in order to establish tls connections with other\n+ * Athenz enabled services.\n+ * @param domainName name of the athenz domain\n+ * @param serviceName name of the athenz service\n+ * @param account AWS account name that the function runs in\n+ * @param provider name of the provider service for AWS Lambda\n+ * @return AWSLambdaIdentity with private key and certificate\n+ */\n+public AWSLambdaIdentity getAWSLambdaServiceCertificate(String domainName,\n+        String serviceName, String account, String provider);\n+```\n+\n+For example, here is a quick program that can be compiled and packaged into lambda.jar and deployed as a Lambda function in AWS. It retrieves a private key and the corresponding x.509 certificate and returns as output.\n+\n+First you need to update your Java project `pom.xml` file to indicate\n+the dependency on the Athenz zts java client libraries. Checkout the\n+[Bintray ZTS Java Client Package](https://bintray.com/yahoo/maven/athenz-zts-java-client/)\n+pages to make sure you're using the latest release version:\n+\n+```xml\n+  <dependencies>\n+    <dependency>\n+      <groupId>com.yahoo.athenz</groupId>\n+      <artifactId>athenz-zts-java-client</artifactId>\n+      <version>1.8.37</version>\n+    </dependency>\n+  </dependencies>\n+```\n+\n+Next, is the Lambda function handler implementation:\n+\n+```\n+package com.amazonaws.lambda.demo;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestHandler;\n+import com.yahoo.athenz.zts.AWSLambdaIdentity;\n+import com.yahoo.athenz.zts.ZTSClient;\n+\n+public class LambdaFunctionHandler implements RequestHandler<Object, String> {\n+\n+    @Override\n+    public String handleRequest(Object input, Context context) {\n+\n+        final String athenzDomain = \"athens\"; // replace this with your domain name\n+        final String athenzService = \"lambda\"; // replace this with your service name\n+        final String awsAccount = \"149134300625\"; // replace this with your account number\n+        final String athenzProvider = \"<lambada-name>.<lambada region>\"; // replace with labada name and region. for example: \"athens.aws-labmda.us-west-2\"\n+        final String ztsUrl = \"https://zts-addres/zts/v1\"; // replace this with your zts Url (ending with /zts/v1)\n+        final String certDn = \"ou=Athenz,o=Oath\"; // the dn you want included in cert\n+        final String certDomain = \"aws.oath.cloud\"; // cert domain\n+\n+        // our key and cert to display for test purposes\n+\n+        String certificate;\n+        String privateKey;\n+\n+        // generate a private key and retrieve the corresponding\n+        // certificate from Athenz ZTS Service\n+\n+        try (ZTSClient client = new ZTSClient(ztsUrl)) {\n+            ZTSClient.setX509CsrDetails(certDn, certDomain);\n+            AWSLambdaIdentity lambdaIdentity = client.getAWSLambdaServiceCertificate(athenzDomain,\n+                    athenzService, awsAccount, athenzProvider);\n+\n+            certificate = lambdaIdentity.getX509Certificate().toString();\n+            privateKey = lambdaIdentity.getPrivateKey().toString();\n+        }\n+\n+        // just return our data so we can see it in our aws console\n+\n+        return \"Lambda - Private Key: \" + privateKey + \" Certificate: \" + certificate;\n+    }\n+}\n+```\n+\n+### Go\n+\n+The following function is available in the `/sia-ec2/util` package:\n+\n+```\n+func GetAWSLambdaServiceCertificate(ztsUrl, domain, service, account, region string) (tls.Certificate, error)\n+```\n+\n+Change the `ztsUrl` field with your zts (ending with `/zts/v1`). The `domain` is your Athenz domain name while `service` is the service name that your Lambda function will run as. The `account` field is the AWS account id while `region` is where this function will be running.\n+\n+For example, here is a quick program that can be compiled and packaged into main.zip and deployed as a Lambda function in AWS. It retrieves a private key and the corresponding x.509 certificate and returns as output.\n+\n+```\n+package main\n+\n+import (\n+    \"crypto/rsa\"\n+    \"encoding/pem\"\n+    \"fmt\"\n+\n+    \"github.com/aws/aws-lambda-go/lambda\"\n+    \"git.ouroath.com/athens/sia-aws/util\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b073fc036bca2bc40da1a2d1d69ab8708d80cd6c"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkxMzkxMA==", "bodyText": "lets replace with 123456789 for consistency", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r453913910", "createdAt": "2020-07-13T20:30:52Z", "author": {"login": "abvaidya"}, "path": "docs/service_x509_credentials_aws_lambda.md", "diffHunk": "@@ -0,0 +1,254 @@\n+\n+> **Important:** Certificate Signing is an expensive operation (both on the client and\n+>  the server side) so if your application is going to launch large number of instances\n+>  of your lambda function, then you must not fetch Athenz x.509 certificates directly\n+>  within your lambda function. The recommended approach for that scenario is have one\n+>  lambda function to fetch the Athenz X.509 Certificate Identity private key and the\n+>  public certificate, store them in AWS Parameter Store and update those daily. Then\n+>  have all other lambda functions authorized based on their IAM credentials to fetch\n+>  and use that x.509 certificate.\n+\n+## Domain Registration\n+\n+Identify your Athenz domain before you can proceed by visiting Athenz UI.\n+\n+Follow the [instructions documented for EC2 instances](service_x509_credentials_aws.md#domain-registration) to register your domain if one doesn't exist already.\n+\n+## AWS Account ID Registration\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+## Athenz Service Identity Registration\n+\n+Create a service identity for your AWS Lambda function in your Athenz domain. This full service identity name `<domain>.<service>` will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your Lambda Function Execution Role.\n+\n+In the Athenz UI, select your domain, select the `Services` tab and then choose `Add a Service`  link in the top left corner. You must provide a service name and an optional description for your service.\n+\n+![Service Identity Registration](images/aws-service-register.png)\n+\n+## Athenz Service Identity Authorization Role and Policy\n+\n+Before ZTS can validate and issue X.509 TLS Certificates to the AWS Lambda, it must validate that the service owner has authorized its service to be launched by AWS Lambda Provider. The following role and policy must be created in your Athenz domain for this authorization:\n+\n+When viewing your domain details, choose the `Roles` tab and select\n+`Add Role` link on the left side of the screen underneath the tab names.\n+Role details are as follows (don't forget to press the `Add` button after\n+specifying the role member before pressing the `Submit` button):\n+\n+```\n+Role Category: Regular\n+Role Name: aws_lambda_launch_provider\n+Add Member(s): athens.aws-lambda.*\n+```\n+\n+Then choose the `Policies` tab and select `Add Policy` link on the left side\n+of the screen underneath the tab names. Policy details are as follows\n+(make sure to replace `<your-service-name>` in the Rule Resource\n+with your actual service name):\n+\n+```\n+Policy Name: aws_lambda_launch_provider\n+Rule Effect: Allow\n+Rule Action: launch\n+Rule Role: aws_lambda_launch_provider\n+Rule Resource: service.<your-service-name>\n+```\n+\n+## IAM Role Setup\n+\n+There are two IAM roles required for instances to obtain Athenz X.509 certificates:\n+\n+- Lambda Function Execution Role\n+- Athenz Service Identity Assume Role\n+\n+It is assumed that at this point you have already configured the first Lambda Function Execution Role that your code will be launched with (roles created through the AWS console are created with /service-role/ path). The second Athenz Service Identity IAM Assume Role must be created and must have the `<domain>.<service>` name. This role will not have any permissions but instead will have a trust relationship with your Lambda execution role such that your Lambda execution role can assume this role.\n+\n+In the AWS Console, select `IAM` from the Services drop down and then click on the `Roles` link in the left sidebar. Choose the `Create Role` button. Under the `AWS Service` type, select `Lambda` and choose `Next: Permissions` button in the bottom right corner.\n+\n+![IAM Lambda Role Setup_1](images/iam-lambda-role-setup-1.png)\n+\n+In the `Attach permissions policy` screen do not choose any permissions and just click on the `Next: Review` button in the bottom right corner to continue. Specify the `Role name` in the `<domain>.<service>` format and choose `Create Role` to complete the process.\n+\n+In the Roles list view, choose the role just created and choose the `Trust Relationships` tab.\n+\n+![IAM Lambda Role Setup_2](images/iam-lambda-role-setup-2.png)\n+\n+Click on `Edit trust relationship` button and append a block containing the following policy to the `Statement` block Replace the `<account-id>` and `<lambda-execution-role>` values with their corresponding values for your environment. For the `<lambda-execution-role>` make sure to include the full path since roles created through the AWS console are created with `/service-role/` path:\n+\n+```\n+ {\n+   \"Effect\": \"Allow\",\n+   \"Principal\": {\n+     \"AWS\": \"arn:aws:iam::<account-id>:role/<lambda-execution-role>\"\n+   },\n+   \"Action\": \"sts:AssumeRole\"\n+ }\n+```\n+\n+Once correctly updated, your Lambda role must appear in the `Trusted entities` table:\n+\n+![IAM Lambda Role Setup_3](images/iam-lambda-role-setup-3.png)\n+\n+## Private Key and Certificate Setup\n+\n+Since we're dealing with functions in this use case, we cannot have a SIA agent daemon running to generate a private key for the service and then retrieve a corresponding x.509 certificate from the ZTS Server. Instead, the function being invoked will be responsible for generating a private key and then a csr for its request. Finally, it will submit that request to the ZTS Server to retrieve its X.509 certificate which then it can use  along with its generated private key to establish TLS connections to other Verizon Media Athenz enabled services. Athenz Team provides functions/methods in Go and Java programming languages to quickly generate a private key and request its corresponding X.509 certificate from ZTS Server.\n+\n+Important consideration when dealing with Lambda functions:\n+\n+* The code to do this needs to prefetch and cache the certificate in a way that does not block every invocation, as minting a new certificate is somewhat expensive.\n+* The short lifetime and stateless nature of the function means it cannot rotate its certificates. It just gets new ones when needed.\n+\n+### Java\n+\n+The following function is available in the Athenz ZTS Java Client:\n+\n+```\n+/**\n+ * For AWS Lambda functions generate a new private key, request a\n+ * x.509 certificate based on the requested CSR and return both to\n+ * the client in order to establish tls connections with other\n+ * Athenz enabled services.\n+ * @param domainName name of the athenz domain\n+ * @param serviceName name of the athenz service\n+ * @param account AWS account name that the function runs in\n+ * @param provider name of the provider service for AWS Lambda\n+ * @return AWSLambdaIdentity with private key and certificate\n+ */\n+public AWSLambdaIdentity getAWSLambdaServiceCertificate(String domainName,\n+        String serviceName, String account, String provider);\n+```\n+\n+For example, here is a quick program that can be compiled and packaged into lambda.jar and deployed as a Lambda function in AWS. It retrieves a private key and the corresponding x.509 certificate and returns as output.\n+\n+First you need to update your Java project `pom.xml` file to indicate\n+the dependency on the Athenz zts java client libraries. Checkout the\n+[Bintray ZTS Java Client Package](https://bintray.com/yahoo/maven/athenz-zts-java-client/)\n+pages to make sure you're using the latest release version:\n+\n+```xml\n+  <dependencies>\n+    <dependency>\n+      <groupId>com.yahoo.athenz</groupId>\n+      <artifactId>athenz-zts-java-client</artifactId>\n+      <version>1.8.37</version>\n+    </dependency>\n+  </dependencies>\n+```\n+\n+Next, is the Lambda function handler implementation:\n+\n+```\n+package com.amazonaws.lambda.demo;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestHandler;\n+import com.yahoo.athenz.zts.AWSLambdaIdentity;\n+import com.yahoo.athenz.zts.ZTSClient;\n+\n+public class LambdaFunctionHandler implements RequestHandler<Object, String> {\n+\n+    @Override\n+    public String handleRequest(Object input, Context context) {\n+\n+        final String athenzDomain = \"athens\"; // replace this with your domain name\n+        final String athenzService = \"lambda\"; // replace this with your service name\n+        final String awsAccount = \"149134300625\"; // replace this with your account number", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b073fc036bca2bc40da1a2d1d69ab8708d80cd6c"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkxNDM1OQ==", "bodyText": "lets use 123465789 for consistency", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r453914359", "createdAt": "2020-07-13T20:31:40Z", "author": {"login": "abvaidya"}, "path": "docs/service_x509_credentials_aws_lambda.md", "diffHunk": "@@ -0,0 +1,254 @@\n+\n+> **Important:** Certificate Signing is an expensive operation (both on the client and\n+>  the server side) so if your application is going to launch large number of instances\n+>  of your lambda function, then you must not fetch Athenz x.509 certificates directly\n+>  within your lambda function. The recommended approach for that scenario is have one\n+>  lambda function to fetch the Athenz X.509 Certificate Identity private key and the\n+>  public certificate, store them in AWS Parameter Store and update those daily. Then\n+>  have all other lambda functions authorized based on their IAM credentials to fetch\n+>  and use that x.509 certificate.\n+\n+## Domain Registration\n+\n+Identify your Athenz domain before you can proceed by visiting Athenz UI.\n+\n+Follow the [instructions documented for EC2 instances](service_x509_credentials_aws.md#domain-registration) to register your domain if one doesn't exist already.\n+\n+## AWS Account ID Registration\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+## Athenz Service Identity Registration\n+\n+Create a service identity for your AWS Lambda function in your Athenz domain. This full service identity name `<domain>.<service>` will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your Lambda Function Execution Role.\n+\n+In the Athenz UI, select your domain, select the `Services` tab and then choose `Add a Service`  link in the top left corner. You must provide a service name and an optional description for your service.\n+\n+![Service Identity Registration](images/aws-service-register.png)\n+\n+## Athenz Service Identity Authorization Role and Policy\n+\n+Before ZTS can validate and issue X.509 TLS Certificates to the AWS Lambda, it must validate that the service owner has authorized its service to be launched by AWS Lambda Provider. The following role and policy must be created in your Athenz domain for this authorization:\n+\n+When viewing your domain details, choose the `Roles` tab and select\n+`Add Role` link on the left side of the screen underneath the tab names.\n+Role details are as follows (don't forget to press the `Add` button after\n+specifying the role member before pressing the `Submit` button):\n+\n+```\n+Role Category: Regular\n+Role Name: aws_lambda_launch_provider\n+Add Member(s): athens.aws-lambda.*\n+```\n+\n+Then choose the `Policies` tab and select `Add Policy` link on the left side\n+of the screen underneath the tab names. Policy details are as follows\n+(make sure to replace `<your-service-name>` in the Rule Resource\n+with your actual service name):\n+\n+```\n+Policy Name: aws_lambda_launch_provider\n+Rule Effect: Allow\n+Rule Action: launch\n+Rule Role: aws_lambda_launch_provider\n+Rule Resource: service.<your-service-name>\n+```\n+\n+## IAM Role Setup\n+\n+There are two IAM roles required for instances to obtain Athenz X.509 certificates:\n+\n+- Lambda Function Execution Role\n+- Athenz Service Identity Assume Role\n+\n+It is assumed that at this point you have already configured the first Lambda Function Execution Role that your code will be launched with (roles created through the AWS console are created with /service-role/ path). The second Athenz Service Identity IAM Assume Role must be created and must have the `<domain>.<service>` name. This role will not have any permissions but instead will have a trust relationship with your Lambda execution role such that your Lambda execution role can assume this role.\n+\n+In the AWS Console, select `IAM` from the Services drop down and then click on the `Roles` link in the left sidebar. Choose the `Create Role` button. Under the `AWS Service` type, select `Lambda` and choose `Next: Permissions` button in the bottom right corner.\n+\n+![IAM Lambda Role Setup_1](images/iam-lambda-role-setup-1.png)\n+\n+In the `Attach permissions policy` screen do not choose any permissions and just click on the `Next: Review` button in the bottom right corner to continue. Specify the `Role name` in the `<domain>.<service>` format and choose `Create Role` to complete the process.\n+\n+In the Roles list view, choose the role just created and choose the `Trust Relationships` tab.\n+\n+![IAM Lambda Role Setup_2](images/iam-lambda-role-setup-2.png)\n+\n+Click on `Edit trust relationship` button and append a block containing the following policy to the `Statement` block Replace the `<account-id>` and `<lambda-execution-role>` values with their corresponding values for your environment. For the `<lambda-execution-role>` make sure to include the full path since roles created through the AWS console are created with `/service-role/` path:\n+\n+```\n+ {\n+   \"Effect\": \"Allow\",\n+   \"Principal\": {\n+     \"AWS\": \"arn:aws:iam::<account-id>:role/<lambda-execution-role>\"\n+   },\n+   \"Action\": \"sts:AssumeRole\"\n+ }\n+```\n+\n+Once correctly updated, your Lambda role must appear in the `Trusted entities` table:\n+\n+![IAM Lambda Role Setup_3](images/iam-lambda-role-setup-3.png)\n+\n+## Private Key and Certificate Setup\n+\n+Since we're dealing with functions in this use case, we cannot have a SIA agent daemon running to generate a private key for the service and then retrieve a corresponding x.509 certificate from the ZTS Server. Instead, the function being invoked will be responsible for generating a private key and then a csr for its request. Finally, it will submit that request to the ZTS Server to retrieve its X.509 certificate which then it can use  along with its generated private key to establish TLS connections to other Verizon Media Athenz enabled services. Athenz Team provides functions/methods in Go and Java programming languages to quickly generate a private key and request its corresponding X.509 certificate from ZTS Server.\n+\n+Important consideration when dealing with Lambda functions:\n+\n+* The code to do this needs to prefetch and cache the certificate in a way that does not block every invocation, as minting a new certificate is somewhat expensive.\n+* The short lifetime and stateless nature of the function means it cannot rotate its certificates. It just gets new ones when needed.\n+\n+### Java\n+\n+The following function is available in the Athenz ZTS Java Client:\n+\n+```\n+/**\n+ * For AWS Lambda functions generate a new private key, request a\n+ * x.509 certificate based on the requested CSR and return both to\n+ * the client in order to establish tls connections with other\n+ * Athenz enabled services.\n+ * @param domainName name of the athenz domain\n+ * @param serviceName name of the athenz service\n+ * @param account AWS account name that the function runs in\n+ * @param provider name of the provider service for AWS Lambda\n+ * @return AWSLambdaIdentity with private key and certificate\n+ */\n+public AWSLambdaIdentity getAWSLambdaServiceCertificate(String domainName,\n+        String serviceName, String account, String provider);\n+```\n+\n+For example, here is a quick program that can be compiled and packaged into lambda.jar and deployed as a Lambda function in AWS. It retrieves a private key and the corresponding x.509 certificate and returns as output.\n+\n+First you need to update your Java project `pom.xml` file to indicate\n+the dependency on the Athenz zts java client libraries. Checkout the\n+[Bintray ZTS Java Client Package](https://bintray.com/yahoo/maven/athenz-zts-java-client/)\n+pages to make sure you're using the latest release version:\n+\n+```xml\n+  <dependencies>\n+    <dependency>\n+      <groupId>com.yahoo.athenz</groupId>\n+      <artifactId>athenz-zts-java-client</artifactId>\n+      <version>1.8.37</version>\n+    </dependency>\n+  </dependencies>\n+```\n+\n+Next, is the Lambda function handler implementation:\n+\n+```\n+package com.amazonaws.lambda.demo;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestHandler;\n+import com.yahoo.athenz.zts.AWSLambdaIdentity;\n+import com.yahoo.athenz.zts.ZTSClient;\n+\n+public class LambdaFunctionHandler implements RequestHandler<Object, String> {\n+\n+    @Override\n+    public String handleRequest(Object input, Context context) {\n+\n+        final String athenzDomain = \"athens\"; // replace this with your domain name\n+        final String athenzService = \"lambda\"; // replace this with your service name\n+        final String awsAccount = \"149134300625\"; // replace this with your account number\n+        final String athenzProvider = \"<lambada-name>.<lambada region>\"; // replace with labada name and region. for example: \"athens.aws-labmda.us-west-2\"\n+        final String ztsUrl = \"https://zts-addres/zts/v1\"; // replace this with your zts Url (ending with /zts/v1)\n+        final String certDn = \"ou=Athenz,o=Oath\"; // the dn you want included in cert\n+        final String certDomain = \"aws.oath.cloud\"; // cert domain\n+\n+        // our key and cert to display for test purposes\n+\n+        String certificate;\n+        String privateKey;\n+\n+        // generate a private key and retrieve the corresponding\n+        // certificate from Athenz ZTS Service\n+\n+        try (ZTSClient client = new ZTSClient(ztsUrl)) {\n+            ZTSClient.setX509CsrDetails(certDn, certDomain);\n+            AWSLambdaIdentity lambdaIdentity = client.getAWSLambdaServiceCertificate(athenzDomain,\n+                    athenzService, awsAccount, athenzProvider);\n+\n+            certificate = lambdaIdentity.getX509Certificate().toString();\n+            privateKey = lambdaIdentity.getPrivateKey().toString();\n+        }\n+\n+        // just return our data so we can see it in our aws console\n+\n+        return \"Lambda - Private Key: \" + privateKey + \" Certificate: \" + certificate;\n+    }\n+}\n+```\n+\n+### Go\n+\n+The following function is available in the `/sia-ec2/util` package:\n+\n+```\n+func GetAWSLambdaServiceCertificate(ztsUrl, domain, service, account, region string) (tls.Certificate, error)\n+```\n+\n+Change the `ztsUrl` field with your zts (ending with `/zts/v1`). The `domain` is your Athenz domain name while `service` is the service name that your Lambda function will run as. The `account` field is the AWS account id while `region` is where this function will be running.\n+\n+For example, here is a quick program that can be compiled and packaged into main.zip and deployed as a Lambda function in AWS. It retrieves a private key and the corresponding x.509 certificate and returns as output.\n+\n+```\n+package main\n+\n+import (\n+    \"crypto/rsa\"\n+    \"encoding/pem\"\n+    \"fmt\"\n+\n+    \"github.com/aws/aws-lambda-go/lambda\"\n+    \"git.ouroath.com/athens/sia-aws/util\"\n+)\n+\n+type Request struct {\n+    Zts     string `json:\"zts\"`\n+    Region  string `json:\"region\"`\n+    Domain  string `json:\"domain\"`\n+    Account string `json:\"account\"`\n+    Service string `json:\"service\"`\n+}\n+\n+type Response struct {\n+    PrivateKey      string `json:\"privatekey\"`\n+    X509Certificate string `json:\"certificate\"`\n+    Message         string `json:\"message\"`\n+}\n+\n+func Handler(req Request) (Response, error) {\n+    x509Cert, err := util.GetAWSLambdaServiceCertificate(req.Zts, req.Domain, req.Service, req.Account, req.Region)\n+    var resp Response\n+    if err != nil {\n+        resp.Message = fmt.Sprintf(\"Unable to get certificate: %v\", err)\n+    } else {\n+        resp.PrivateKey = util.PrivatePem(x509Cert.PrivateKey.(*rsa.PrivateKey))\n+        resp.X509Certificate = string(pem.EncodeToMemory(&pem.Block{Type: \"CERTIFICATE\", Bytes: x509Cert.Certificate[0]}))\n+        resp.Message = \"Success\"\n+    }\n+    return resp, err\n+}\n+\n+func main() {\n+    lambda.Start(Handler)\n+}\n+```\n+\n+Here is a sample input for this function. Our domain is called athens and the service is called lambda-function-test.\n+\n+```\n+{\n+  \"zts\": \"https://zts.com:4443/zts/v1\",\n+  \"region\": \"us-west-2\",\n+  \"domain\": \"athens\",\n+  \"service\": \"lambda-function-test\",\n+  \"account\": \"149134300625\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b073fc036bca2bc40da1a2d1d69ab8708d80cd6c"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkxNjk5NA==", "bodyText": "@havetisyan should we remove sia server completely?", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r453916994", "createdAt": "2020-07-13T20:36:25Z", "author": {"login": "abvaidya"}, "path": "docs/sia_server_guide.md", "diffHunk": "@@ -0,0 +1,75 @@\n+SIA Server is required for authenticating existing unmanaged services. For\n+managed service inception (e.g., Manhattan), other more convenient\n+automated mechanisms get the credentials safely to the service. The SIA\n+server provides on-box support for securely getting an identity token\n+for a running service that was previously registered in ZMS.\n+\n+The SIA server requires access to that service's [private key](reg_service_guide.md)\n+to sign the token. The server runs as a protected local agent, and the services use Unix domain\n+socket interface to request tokens. SIA communicates with ZTS to validate service details.\n+\n+## Installing SIA\n+\n+The AWS SIA source is part of the Athenz project and can be found in:\n+```\n+provider/aws/sia-ec2\n+``` \n+Follow the readme for instructions on how to install it.\n+\n+## Private Key Installation\n+\n+The SIA Server needs to have access the service's private key so it can\n+generate and sign a ServiceToken for the service. Then the service can\n+use that ServiceToken to authenticate itself in Athenz and, if\n+necessary, obtain a RoleToken to process requests against other Athenz\n+protected services.\n+\n+## Key Update/New Service\n+\n+If a new service is updated on the host or the key has been updated on\n+disk, the SIA service must be restarted for the changes to take effect\n+because it caches the private key details during server startup.\n+\n+## Service Identity Setup Verification\n+\n+Once the private key has been installed on the SIA Server and the\n+Service has been registered in ZMS with its public key, the\n+administrator can verify that the setup is done correctly by executing\n+the following command:\n+\n+```\n+sudo /home/y/bin64/sia_setup_verify -d <domain-name> -s <service-name>\n+```\n+\n+The command will verify that the private key is installed in the correct\n+directory location and a service token will be generated successfully.\n+Then it will verify that it can authenticate against ZTS server with\n+that service token and retrieve the Service Identity details. It will\n+also verify that the public key with the correct key identifier is\n+registered in Athenz. Any issues will be reported with suggestions how\n+to fix them.\n+\n+This utility only verifies your service configuration without connecting\n+to SIA Server over its protocol. Once the configuration details have been\n+verified, the administrator needs to make sure that the SIA Server is\n+restarted and running.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA2ODU3NA=="}, "originalCommit": {"oid": "43cd0972c45b29a3cb62b47817c45f2ebee5dee2"}, "originalPosition": 55}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b073fc036bca2bc40da1a2d1d69ab8708d80cd6c", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/b073fc036bca2bc40da1a2d1d69ab8708d80cd6c", "committedDate": "2020-07-02T19:42:36Z", "message": "Authentication Documentation"}, "afterCommit": {"oid": "51b5382b709f8f88256bd0d6c2357ab11f5b16b0", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/51b5382b709f8f88256bd0d6c2357ab11f5b16b0", "committedDate": "2020-07-14T17:13:55Z", "message": "Authentication Documentation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "51b5382b709f8f88256bd0d6c2357ab11f5b16b0", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/51b5382b709f8f88256bd0d6c2357ab11f5b16b0", "committedDate": "2020-07-14T17:13:55Z", "message": "Authentication Documentation"}, "afterCommit": {"oid": "c5d9a245eb06347829bf5891be43326d504d3c52", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/c5d9a245eb06347829bf5891be43326d504d3c52", "committedDate": "2020-07-14T17:22:49Z", "message": "Authentication Documentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMjgyODIz", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-450282823", "createdAt": "2020-07-16T23:31:30Z", "commit": {"oid": "c5d9a245eb06347829bf5891be43326d504d3c52"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMzozMTozMFrOGzAPKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMzo0MDowM1rOGzAZmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEzNDQ0MA==", "bodyText": "remove the reference to Verizon Media", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r456134440", "createdAt": "2020-07-16T23:31:30Z", "author": {"login": "havetisyan"}, "path": "docs/service_x509_credentials.md", "diffHunk": "@@ -0,0 +1,101 @@\n+Once a domain has been registered in Athenz, the administrator will\n+register service identities that are specified in domain roles and\n+policy assertions. The latter can reference those roles having access to\n+specified resources. Athenz supports service authentication with\n+two types of credentials:\n+\n+- X.509 Certificates (preferred approach)\n+- Public/Private Key Pairs [Instructions](reg_service_guide.md)\n+\n+To contact Athenz Services (ZMS/ZTS) or other Athenz Enabled services,\n+the client service must first obtain an Athenz CA issued X.509 certificate.\n+In this section we'll cover how to register the service identity and\n+obtain X.509 certificates based on what environment your service will be running in.\n+\n+## Use Case 1: Service Running in AWS EC2\n+\n+If the service is running in AWS, Service Identity Agent (SIA) running on the\n+instance is responsible for generating a private key for the service and\n+obtaining a x.509 certificate from ZTS Service. The files are located in\n+the following locations:\n+\n+```\n+    private-key: /var/lib/sia/keys/<domain>.<service>.key.pem\n+    certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem\n+```\n+\n+The certificate is valid for 30 days and SIA agent automatically\n+will refresh the certificate daily. Follow [these steps](service_x509_credentials_aws.md) for\n+full details how to configure SIA agent running in AWS as part\n+of the foundation image.\n+\n+## Use Case 2: Service running on-prem within an Athenz Enabled Framework (K8S)\n+\n+If the service is running within an Athenz enabled framework then it\n+must already have access to service identity x.509 certificate that\n+was generated for the service. Refer to the documentation provided\n+by the framework to see where the files are located.\n+\n+## Use Case 3: Service Running in AWS ECS (Elastic Container Service)\n+\n+If the service is running in AWS ECS, Service Identity Agent (SIA) included\n+in your image is responsible for generating a private key for the service and\n+obtaining a x.509 certificate from ZTS Service. The files are located in\n+the following locations:\n+\n+```\n+    private-key: /var/lib/sia/keys/<domain>.<service>.key.pem\n+    certificate: /var/lib/sia/certs/<domain>.<service>.cert.pem\n+```\n+\n+The certificate is valid for 30 days and SIA agent automatically\n+will refresh the certificate daily. Follow [these steps](service_x509_credentials_aws_ecs.md) for\n+full details how to configure SIA agent running in AWS as part of your image.\n+\n+## Use Case 4: Service Running in AWS Lambda Function\n+\n+If the service is running in AWS Lambda function, the function being invoked will be\n+responsible for generating a private key and then a csr for its request. It will submit\n+that request to the ZTS Server to retrieve its X.509 certificate which then it\n+can use  along with its generated private key to establish TLS connections to\n+other Verizon Media Athenz enabled services. Athenz Team provides functions/methods in Go", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d9a245eb06347829bf5891be43326d504d3c52"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEzNTQ1Nw==", "bodyText": "let's remove any references to ssh certificates", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r456135457", "createdAt": "2020-07-16T23:34:33Z", "author": {"login": "havetisyan"}, "path": "docs/service_x509_credentials_aws.md", "diffHunk": "@@ -0,0 +1,346 @@\n+![AWS EC2 Setup](images/aws-ec2-setup.png)\n+\n+**Bootstrapping AWS EC2 instances with Athenz Service x.509 Identities\n+requires the instances to have network connectivity to both Athenz ZTS\n+and AWS STS Services.**\n+\n+## Domain Registration\n+\n+Identify your Athenz domain before you can proceed by using Athenz UI.\n+\n+You may create a top-level domain or a sub domain using Athenz UI or zms-cli.\n+Only Athenz System Administrators can create top level domains (members of the sys.auth domain's admin role).\n+To create a top-level domain using zms-cli run the following:\n+\n+```\n+zms-cli add-domakn <domain-name> <unique-product-id> <domain-admins separated by space>\n+```\n+\n+If you already have top-level domain and need to create a sub domain using Athenz UI:\n+click the \"Create\u201d link next to \"My Domains\" label in the top right corner\n+and then click on \u201cSub Domain\u201d tab and follow the on screen instruction.\n+\n+![Create Sub Domain](images/create_sub_domain.png)\n+\n+Or using zms-cli:\n+```\n+zms-cli add-doman <top-doman.sub-domain-name> <domain-admins separated by space>\n+```\n+\n+## AWS Account ID Registration\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+## Athenz Service Identity Registration\n+\n+Create a service identity for your AWS EC2 instances in your Athenz domain. This full service identity name `<domain>.<service>` will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your EC2 Instance Role.\n+\n+In the Athenz UI, select your domain, select the `Services` tab and then choose `Add a Service` link in the top left corner. You must provide a service name and an optional description for your service. \n+\n+![Service Identity Registration](images/aws-service-register.png)\n+\n+## Athenz Service Identity Authorization\n+\n+Before ZTS can validate and issue X.509 TLS Certificates to the\n+AWS EC2 instance, it must validate that the service owner has\n+authorized its service to be launched by AWS EC2 Provider. In the\n+Athenz UI select your service that was created in the previous\n+step and click on the icon in the `Providers` column:\n+\n+![Service Identity Authorization_1](images/aws-service-authorize.png)\n+\n+Then, click on the `Allow` button to authorize your service to\n+be launched by AWS EC2 provider.\n+\n+![Service Identity Authorization_2](images/aws-service-authorize-2.png)\n+\n+\n+## IAM Role Setup\n+\n+There are two IAM roles required for instances to obtain Athenz X.509 certificates:\n+\n+- EC2 Instance Profile Role\n+- Athenz Service Identity Assume Role\n+\n+It is assumed that at this point you have already configured the first\n+EC2 Instance Profile IAM Role that your EC2 instance will be launched\n+with. In order to access your EC2 instances through the Bastion daemon,\n+your EC2 instance profile role must be named as `<domain>.<service>-service`.\n+The bastion service uses the profile arn to determine the EC2 instance\n+service name so it can carry out an authorization check to see if the user\n+is authorized to ssh login to the specified instance or not. If the property\n+is unable to name their instance profile name as `<domain>.<service>-service`\n+then check out the [Non Standard Instance Profile Name](#non-standard-instance-profile-name)\n+section for additional requirements.\n+\n+The second Athenz Service Identity IAM Assume Role must be created and\n+must have the `<domain>.<service>` name. This role will not have any\n+permissions but instead will have a trust relationship with your EC2\n+instance role such that your EC2 instance role can assume this role.\n+\n+In the AWS Console, select `IAM` from the Services drop down and then\n+click on the `Roles` link in the left sidebar. Choose the `Create Role`\n+button. Under the `AWS Service` type, select `EC2`, then `EC2` again\n+for the use case and finally choose `Next: Permissions` button in the\n+bottom right corner.\n+\n+![IAM Role Setup_1](images/iam-role-setup-1.png)\n+\n+In the `Attach permissions policy` screen do not choose any permissions\n+and just click on the `Next: Review` button in the bottom right corner\n+to continue. Specify the `Role name` in the `<domain>.<service>` format\n+and choose `Create Role` to complete the process.\n+\n+In the Roles list view, choose the role just created and choose the\n+`Trust Relationships` tab.\n+\n+![IAM Role Setup_2](images/iam-role-setup-2.png)\n+\n+Click on `Edit trust relationship` button and append a block containing\n+the following policy to the `Statement` block (Replace the `<account-id>`\n+and `<ec2-instance-role>` values with their corresponding values for\n+your environment:\n+\n+```\n+ {\n+   \"Effect\": \"Allow\",\n+   \"Principal\": {\n+     \"AWS\": \"arn:aws:iam::<account-id>:role/<ec2-instance-role>\"\n+   },\n+   \"Action\": \"sts:AssumeRole\"\n+ }\n+```\n+\n+Once correctly updated, your EC2 instance role must appear in the `Trusted entities` table:\n+\n+![IAM Role Setup_3](images/iam-role-setup-3.png)\n+\n+### Setup for Services with Region Specific Instance Profile Roles\n+\n+The IAM Role setup is identical when you have the same service\n+being deployed in multiple regions with role names that\n+are specific to each region. Since IAM roles are global, you only need\n+to create a single Athenz IAM Role in the `<domain>.<service>` format.\n+Then, when you're setting up your trust relationship, you'll authorize\n+all your region specific profile roles to have the capability to\n+assume the Athenz `<domain>.<service>` role.\n+\n+## Installing SIA\n+\n+The AWS SIA source is part of the Athenz project and can be found in:\n+```\n+provider/aws/sia-ec2\n+``` \n+Follow the readme for instructions on how to install it.\n+\n+## SIA Configuration Setup\n+\n+When building your image, you can include the following configuration\n+file called `sia_config` in the `/etc/sia` directory. It must include\n+the following required fields:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"<service name>\",\n+  \"accounts\": [\n+    {\n+      \"domain\": \"<domain name>\",\n+      \"account\": \"<aws account id associated with domain name>\"\n+    }\n+  ]\n+}\n+```\n+\n+The domain/account/service values here must match to the IAM Role\n+created earlier. For example, if the service identity name is `api`\n+in domain `sports` whose corresponding aws account id is `123456789`,\n+then the `sia_config` file will be as follows:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"api\",\n+  \"accounts\": [\n+    {\n+      \"domain\": \"sports\",\n+      \"account\": \"123456789\"\n+    }\n+  ]\n+}\n+```\n+\n+If you require bastion ssh access to your instances, then the profile\n+role must be called `<domain>.<service>-service` and you don't need to\n+specify this configuration file unless you want to change the ownership\n+of the generated private key and certificate files - see\n+[Private Key File Ownership](#private-key-file-ownership) section for more details.\n+\n+### Private Key File Ownership\n+\n+By default SIA agent runs as root and the private key is only readable\n+by root. If your service is running as another user, you can configure\n+SIA agent to automatically change the ownership of the private key file\n+to the configured user.\n+For example, if you want the private key to be owned by `ec2-user`, then\n+your `sia_config` configuration file would be as follows:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"api\",\n+  \"accounts\": [\n+    {\n+      \"domain\": \"sports\",\n+      \"account\": \"123456789\",\n+      \"user\": \"ec2-user\"\n+    }\n+  ]\n+}\n+```\n+\n+### SSH Certificate Support", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d9a245eb06347829bf5891be43326d504d3c52"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEzNTgxOQ==", "bodyText": "remove this bullet point regarding the bastion", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r456135819", "createdAt": "2020-07-16T23:35:38Z", "author": {"login": "havetisyan"}, "path": "docs/service_x509_credentials_aws.md", "diffHunk": "@@ -0,0 +1,346 @@\n+![AWS EC2 Setup](images/aws-ec2-setup.png)\n+\n+**Bootstrapping AWS EC2 instances with Athenz Service x.509 Identities\n+requires the instances to have network connectivity to both Athenz ZTS\n+and AWS STS Services.**\n+\n+## Domain Registration\n+\n+Identify your Athenz domain before you can proceed by using Athenz UI.\n+\n+You may create a top-level domain or a sub domain using Athenz UI or zms-cli.\n+Only Athenz System Administrators can create top level domains (members of the sys.auth domain's admin role).\n+To create a top-level domain using zms-cli run the following:\n+\n+```\n+zms-cli add-domakn <domain-name> <unique-product-id> <domain-admins separated by space>\n+```\n+\n+If you already have top-level domain and need to create a sub domain using Athenz UI:\n+click the \"Create\u201d link next to \"My Domains\" label in the top right corner\n+and then click on \u201cSub Domain\u201d tab and follow the on screen instruction.\n+\n+![Create Sub Domain](images/create_sub_domain.png)\n+\n+Or using zms-cli:\n+```\n+zms-cli add-doman <top-doman.sub-domain-name> <domain-admins separated by space>\n+```\n+\n+## AWS Account ID Registration\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+## Athenz Service Identity Registration\n+\n+Create a service identity for your AWS EC2 instances in your Athenz domain. This full service identity name `<domain>.<service>` will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your EC2 Instance Role.\n+\n+In the Athenz UI, select your domain, select the `Services` tab and then choose `Add a Service` link in the top left corner. You must provide a service name and an optional description for your service. \n+\n+![Service Identity Registration](images/aws-service-register.png)\n+\n+## Athenz Service Identity Authorization\n+\n+Before ZTS can validate and issue X.509 TLS Certificates to the\n+AWS EC2 instance, it must validate that the service owner has\n+authorized its service to be launched by AWS EC2 Provider. In the\n+Athenz UI select your service that was created in the previous\n+step and click on the icon in the `Providers` column:\n+\n+![Service Identity Authorization_1](images/aws-service-authorize.png)\n+\n+Then, click on the `Allow` button to authorize your service to\n+be launched by AWS EC2 provider.\n+\n+![Service Identity Authorization_2](images/aws-service-authorize-2.png)\n+\n+\n+## IAM Role Setup\n+\n+There are two IAM roles required for instances to obtain Athenz X.509 certificates:\n+\n+- EC2 Instance Profile Role\n+- Athenz Service Identity Assume Role\n+\n+It is assumed that at this point you have already configured the first\n+EC2 Instance Profile IAM Role that your EC2 instance will be launched\n+with. In order to access your EC2 instances through the Bastion daemon,\n+your EC2 instance profile role must be named as `<domain>.<service>-service`.\n+The bastion service uses the profile arn to determine the EC2 instance\n+service name so it can carry out an authorization check to see if the user\n+is authorized to ssh login to the specified instance or not. If the property\n+is unable to name their instance profile name as `<domain>.<service>-service`\n+then check out the [Non Standard Instance Profile Name](#non-standard-instance-profile-name)\n+section for additional requirements.\n+\n+The second Athenz Service Identity IAM Assume Role must be created and\n+must have the `<domain>.<service>` name. This role will not have any\n+permissions but instead will have a trust relationship with your EC2\n+instance role such that your EC2 instance role can assume this role.\n+\n+In the AWS Console, select `IAM` from the Services drop down and then\n+click on the `Roles` link in the left sidebar. Choose the `Create Role`\n+button. Under the `AWS Service` type, select `EC2`, then `EC2` again\n+for the use case and finally choose `Next: Permissions` button in the\n+bottom right corner.\n+\n+![IAM Role Setup_1](images/iam-role-setup-1.png)\n+\n+In the `Attach permissions policy` screen do not choose any permissions\n+and just click on the `Next: Review` button in the bottom right corner\n+to continue. Specify the `Role name` in the `<domain>.<service>` format\n+and choose `Create Role` to complete the process.\n+\n+In the Roles list view, choose the role just created and choose the\n+`Trust Relationships` tab.\n+\n+![IAM Role Setup_2](images/iam-role-setup-2.png)\n+\n+Click on `Edit trust relationship` button and append a block containing\n+the following policy to the `Statement` block (Replace the `<account-id>`\n+and `<ec2-instance-role>` values with their corresponding values for\n+your environment:\n+\n+```\n+ {\n+   \"Effect\": \"Allow\",\n+   \"Principal\": {\n+     \"AWS\": \"arn:aws:iam::<account-id>:role/<ec2-instance-role>\"\n+   },\n+   \"Action\": \"sts:AssumeRole\"\n+ }\n+```\n+\n+Once correctly updated, your EC2 instance role must appear in the `Trusted entities` table:\n+\n+![IAM Role Setup_3](images/iam-role-setup-3.png)\n+\n+### Setup for Services with Region Specific Instance Profile Roles\n+\n+The IAM Role setup is identical when you have the same service\n+being deployed in multiple regions with role names that\n+are specific to each region. Since IAM roles are global, you only need\n+to create a single Athenz IAM Role in the `<domain>.<service>` format.\n+Then, when you're setting up your trust relationship, you'll authorize\n+all your region specific profile roles to have the capability to\n+assume the Athenz `<domain>.<service>` role.\n+\n+## Installing SIA\n+\n+The AWS SIA source is part of the Athenz project and can be found in:\n+```\n+provider/aws/sia-ec2\n+``` \n+Follow the readme for instructions on how to install it.\n+\n+## SIA Configuration Setup\n+\n+When building your image, you can include the following configuration\n+file called `sia_config` in the `/etc/sia` directory. It must include\n+the following required fields:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"<service name>\",\n+  \"accounts\": [\n+    {\n+      \"domain\": \"<domain name>\",\n+      \"account\": \"<aws account id associated with domain name>\"\n+    }\n+  ]\n+}\n+```\n+\n+The domain/account/service values here must match to the IAM Role\n+created earlier. For example, if the service identity name is `api`\n+in domain `sports` whose corresponding aws account id is `123456789`,\n+then the `sia_config` file will be as follows:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"api\",\n+  \"accounts\": [\n+    {\n+      \"domain\": \"sports\",\n+      \"account\": \"123456789\"\n+    }\n+  ]\n+}\n+```\n+\n+If you require bastion ssh access to your instances, then the profile\n+role must be called `<domain>.<service>-service` and you don't need to\n+specify this configuration file unless you want to change the ownership\n+of the generated private key and certificate files - see\n+[Private Key File Ownership](#private-key-file-ownership) section for more details.\n+\n+### Private Key File Ownership\n+\n+By default SIA agent runs as root and the private key is only readable\n+by root. If your service is running as another user, you can configure\n+SIA agent to automatically change the ownership of the private key file\n+to the configured user.\n+For example, if you want the private key to be owned by `ec2-user`, then\n+your `sia_config` configuration file would be as follows:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"api\",\n+  \"accounts\": [\n+    {\n+      \"domain\": \"sports\",\n+      \"account\": \"123456789\",\n+      \"user\": \"ec2-user\"\n+    }\n+  ]\n+}\n+```\n+\n+### SSH Certificate Support\n+\n+As part of the bootstrap process, SIA also retrieves a host ssh certificate\n+to be used by the bastion daemon that provides ssh access to instances.\n+However, if the administrator wants to disable this functionality, they\n+can do so by specifying `ssh` entry in their `sia_config` file with `false`\n+value as follows:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"api\",\n+  \"ssh\": false,\n+  \"accounts\": [\n+    {\n+      \"domain\": \"sports\",\n+      \"account\": \"123456789\"\n+    }\n+  ]\n+}\n+```\n+\n+## Private Key and Certificate Setup\n+\n+By default, the private key for the service identity is available in\n+the `/var/lib/sia/keys` directory and has the name `<domain>.<service>.key.pem`.\n+The private key is in PKCS#1 format. The corresponding X.509 certificate\n+is in the `/var/lib/sia/certs` directory and has the name\n+`<domain>.<service>.cert.pem`. The certificate is valid for 30 days and will\n+be refreshed automatically by SIA every day. It is the responsibility of the\n+application owner to update their container/application to refresh and use\n+the latest certificate before it expires. In the same `/var/lib/sia/certs`\n+directory SIA will also generate the Athenz CA certificate file called `ca.cert.pem`.\n+\n+### Role Certificate Support\n+\n+In addition to requesting Athenz service identity certificate, SIA provides\n+the capability to request Athenz Role Certificates as well. If you want to change the default behavior or request\n+SIA to automatically retrieve role certificates for your service, as part\n+of building your ami image, you can include the following additional fields\n+in the configuration file:\n+\n+```\n+{\n+  \"version\": \"1.0.0\",\n+  \"service\": \"<service name>\",\n+  \"accounts\": [\n+    {\n+      \"domain\": \"<domain name>\",\n+      \"account\": \"<aws account id associated with domain name>\",\n+      \"roles\": {\n+        \"<role-domain1>:role.<role-name1>\": {\n+        },\n+        \"<role-domain2>:role.<role-name2>\": {\n+        }\n+      }\n+    }\n+  ]\n+}\n+```\n+\n+The role certificates will also be stored in the `/var/lib/sia/certs` directory\n+and have the name of `<role-domain1>:role.<role-name1>.cert.pem`. They are also\n+valid for 30 days and SIA will automatically refresh them once a day.\n+\n+## Setup Without SIA Configuration File\n+\n+If a property deploying their service in AWS meets the following 2 requirements:\n+\n+- does not need any role certificates to be retrieved by SIA automatically\n+- has the option to name their EC2 instance role\n+\n+then they have the option for a simpler setup without including a sia configuration\n+file in their image.\n+\n+In this model, the property would name their EC2 instance role as\n+`<domain>.<service>-service`. The property must still follow the full steps as\n+described in the [IAM Role Setup](#iam-role-setup) section to setup the\n+`<domain>.<service>` role, but the requirement to have a sia_config file is\n+no longer present. When SIA is running and is not able to find the sia_config\n+file, it will check if the instance profile arn has the `<domain>.<service>-service`\n+format. If it does, then it would drop `-service` part to parse the rest of the\n+string to extract the Athenz domain and service values and determine the assume\n+role name that it needs to fetch temporary credentials for before contacting ZTS Server.\n+\n+## Non Standard Instance Profile Name\n+\n+If a property deploying their service in AWS does not have the\n+capability to name their instance profile role name as\n+`<domain>.<service>-service` due to legacy requirements, the following\n+steps can be followed to configure SIA to use the non-standard\n+instance profile name.\n+\n+- The property must still follow the full steps as\n+described in the [IAM Role Setup](#iam-role-setup) section to setup the\n+`<domain>.<service>` role and the trust relationship.\n+- The property must install a SIA config file `/etc/sia/sia_config`\n+specifying the service name that will be deployed on this instance\n+- The instance must be deployed with the `athenzservice` tag and the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d9a245eb06347829bf5891be43326d504d3c52"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEzNzA0Mg==", "bodyText": "let's user temporary domain name here", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r456137042", "createdAt": "2020-07-16T23:39:51Z", "author": {"login": "havetisyan"}, "path": "docs/service_x509_credentials_aws_lambda.md", "diffHunk": "@@ -0,0 +1,254 @@\n+\n+> **Important:** Certificate Signing is an expensive operation (both on the client and\n+>  the server side) so if your application is going to launch large number of instances\n+>  of your lambda function, then you must not fetch Athenz x.509 certificates directly\n+>  within your lambda function. The recommended approach for that scenario is have one\n+>  lambda function to fetch the Athenz X.509 Certificate Identity private key and the\n+>  public certificate, store them in AWS Parameter Store and update those daily. Then\n+>  have all other lambda functions authorized based on their IAM credentials to fetch\n+>  and use that x.509 certificate.\n+\n+## Domain Registration\n+\n+Identify your Athenz domain before you can proceed by visiting Athenz UI.\n+\n+Follow the [instructions documented for EC2 instances](service_x509_credentials_aws.md#domain-registration) to register your domain if one doesn't exist already.\n+\n+## AWS Account ID Registration\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+## Athenz Service Identity Registration\n+\n+Create a service identity for your AWS Lambda function in your Athenz domain. This full service identity name `<domain>.<service>` will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your Lambda Function Execution Role.\n+\n+In the Athenz UI, select your domain, select the `Services` tab and then choose `Add a Service`  link in the top left corner. You must provide a service name and an optional description for your service.\n+\n+![Service Identity Registration](images/aws-service-register.png)\n+\n+## Athenz Service Identity Authorization Role and Policy\n+\n+Before ZTS can validate and issue X.509 TLS Certificates to the AWS Lambda, it must validate that the service owner has authorized its service to be launched by AWS Lambda Provider. The following role and policy must be created in your Athenz domain for this authorization:\n+\n+When viewing your domain details, choose the `Roles` tab and select\n+`Add Role` link on the left side of the screen underneath the tab names.\n+Role details are as follows (don't forget to press the `Add` button after\n+specifying the role member before pressing the `Submit` button):\n+\n+```\n+Role Category: Regular\n+Role Name: aws_lambda_launch_provider\n+Add Member(s): athens.aws-lambda.*\n+```\n+\n+Then choose the `Policies` tab and select `Add Policy` link on the left side\n+of the screen underneath the tab names. Policy details are as follows\n+(make sure to replace `<your-service-name>` in the Rule Resource\n+with your actual service name):\n+\n+```\n+Policy Name: aws_lambda_launch_provider\n+Rule Effect: Allow\n+Rule Action: launch\n+Rule Role: aws_lambda_launch_provider\n+Rule Resource: service.<your-service-name>\n+```\n+\n+## IAM Role Setup\n+\n+There are two IAM roles required for instances to obtain Athenz X.509 certificates:\n+\n+- Lambda Function Execution Role\n+- Athenz Service Identity Assume Role\n+\n+It is assumed that at this point you have already configured the first Lambda Function Execution Role that your code will be launched with (roles created through the AWS console are created with /service-role/ path). The second Athenz Service Identity IAM Assume Role must be created and must have the `<domain>.<service>` name. This role will not have any permissions but instead will have a trust relationship with your Lambda execution role such that your Lambda execution role can assume this role.\n+\n+In the AWS Console, select `IAM` from the Services drop down and then click on the `Roles` link in the left sidebar. Choose the `Create Role` button. Under the `AWS Service` type, select `Lambda` and choose `Next: Permissions` button in the bottom right corner.\n+\n+![IAM Lambda Role Setup_1](images/iam-lambda-role-setup-1.png)\n+\n+In the `Attach permissions policy` screen do not choose any permissions and just click on the `Next: Review` button in the bottom right corner to continue. Specify the `Role name` in the `<domain>.<service>` format and choose `Create Role` to complete the process.\n+\n+In the Roles list view, choose the role just created and choose the `Trust Relationships` tab.\n+\n+![IAM Lambda Role Setup_2](images/iam-lambda-role-setup-2.png)\n+\n+Click on `Edit trust relationship` button and append a block containing the following policy to the `Statement` block Replace the `<account-id>` and `<lambda-execution-role>` values with their corresponding values for your environment. For the `<lambda-execution-role>` make sure to include the full path since roles created through the AWS console are created with `/service-role/` path:\n+\n+```\n+ {\n+   \"Effect\": \"Allow\",\n+   \"Principal\": {\n+     \"AWS\": \"arn:aws:iam::<account-id>:role/<lambda-execution-role>\"\n+   },\n+   \"Action\": \"sts:AssumeRole\"\n+ }\n+```\n+\n+Once correctly updated, your Lambda role must appear in the `Trusted entities` table:\n+\n+![IAM Lambda Role Setup_3](images/iam-lambda-role-setup-3.png)\n+\n+## Private Key and Certificate Setup\n+\n+Since we're dealing with functions in this use case, we cannot have a SIA agent daemon running to generate a private key for the service and then retrieve a corresponding x.509 certificate from the ZTS Server. Instead, the function being invoked will be responsible for generating a private key and then a csr for its request. Finally, it will submit that request to the ZTS Server to retrieve its X.509 certificate which then it can use  along with its generated private key to establish TLS connections to other Verizon Media Athenz enabled services. Athenz Team provides functions/methods in Go and Java programming languages to quickly generate a private key and request its corresponding X.509 certificate from ZTS Server.\n+\n+Important consideration when dealing with Lambda functions:\n+\n+* The code to do this needs to prefetch and cache the certificate in a way that does not block every invocation, as minting a new certificate is somewhat expensive.\n+* The short lifetime and stateless nature of the function means it cannot rotate its certificates. It just gets new ones when needed.\n+\n+### Java\n+\n+The following function is available in the Athenz ZTS Java Client:\n+\n+```\n+/**\n+ * For AWS Lambda functions generate a new private key, request a\n+ * x.509 certificate based on the requested CSR and return both to\n+ * the client in order to establish tls connections with other\n+ * Athenz enabled services.\n+ * @param domainName name of the athenz domain\n+ * @param serviceName name of the athenz service\n+ * @param account AWS account name that the function runs in\n+ * @param provider name of the provider service for AWS Lambda\n+ * @return AWSLambdaIdentity with private key and certificate\n+ */\n+public AWSLambdaIdentity getAWSLambdaServiceCertificate(String domainName,\n+        String serviceName, String account, String provider);\n+```\n+\n+For example, here is a quick program that can be compiled and packaged into lambda.jar and deployed as a Lambda function in AWS. It retrieves a private key and the corresponding x.509 certificate and returns as output.\n+\n+First you need to update your Java project `pom.xml` file to indicate\n+the dependency on the Athenz zts java client libraries. Checkout the\n+[Bintray ZTS Java Client Package](https://bintray.com/yahoo/maven/athenz-zts-java-client/)\n+pages to make sure you're using the latest release version:\n+\n+```xml\n+  <dependencies>\n+    <dependency>\n+      <groupId>com.yahoo.athenz</groupId>\n+      <artifactId>athenz-zts-java-client</artifactId>\n+      <version>1.8.37</version>\n+    </dependency>\n+  </dependencies>\n+```\n+\n+Next, is the Lambda function handler implementation:\n+\n+```\n+package com.amazonaws.lambda.demo;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestHandler;\n+import com.yahoo.athenz.zts.AWSLambdaIdentity;\n+import com.yahoo.athenz.zts.ZTSClient;\n+\n+public class LambdaFunctionHandler implements RequestHandler<Object, String> {\n+\n+    @Override\n+    public String handleRequest(Object input, Context context) {\n+\n+        final String athenzDomain = \"athens\"; // replace this with your domain name\n+        final String athenzService = \"lambda\"; // replace this with your service name\n+        final String awsAccount = \"123456789\"; // replace this with your account number\n+        final String athenzProvider = \"<lambada-name>.<lambada region>\"; // replace with labada name and region. for example: \"athens.aws-labmda.us-west-2\"\n+        final String ztsUrl = \"https://zts-addres/zts/v1\"; // replace this with your zts Url (ending with /zts/v1)\n+        final String certDn = \"ou=Athenz,o=Oath\"; // the dn you want included in cert\n+        final String certDomain = \"aws.oath.cloud\"; // cert domain", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d9a245eb06347829bf5891be43326d504d3c52"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEzNzExMw==", "bodyText": "zts-address", "url": "https://github.com/AthenZ/athenz/pull/1025#discussion_r456137113", "createdAt": "2020-07-16T23:40:03Z", "author": {"login": "havetisyan"}, "path": "docs/service_x509_credentials_aws_lambda.md", "diffHunk": "@@ -0,0 +1,254 @@\n+\n+> **Important:** Certificate Signing is an expensive operation (both on the client and\n+>  the server side) so if your application is going to launch large number of instances\n+>  of your lambda function, then you must not fetch Athenz x.509 certificates directly\n+>  within your lambda function. The recommended approach for that scenario is have one\n+>  lambda function to fetch the Athenz X.509 Certificate Identity private key and the\n+>  public certificate, store them in AWS Parameter Store and update those daily. Then\n+>  have all other lambda functions authorized based on their IAM credentials to fetch\n+>  and use that x.509 certificate.\n+\n+## Domain Registration\n+\n+Identify your Athenz domain before you can proceed by visiting Athenz UI.\n+\n+Follow the [instructions documented for EC2 instances](service_x509_credentials_aws.md#domain-registration) to register your domain if one doesn't exist already.\n+\n+## AWS Account ID Registration\n+\n+To register an AWS Account with a domain, run the following command:\n+```\n+zms-cli -d <domain-name> set-aws-account <aws-account-id>\n+```\n+\n+## Athenz Service Identity Registration\n+\n+Create a service identity for your AWS Lambda function in your Athenz domain. This full service identity name `<domain>.<service>` will be the IAM role name that you will need to create in AWS IAM and set up a trust relationship with your Lambda Function Execution Role.\n+\n+In the Athenz UI, select your domain, select the `Services` tab and then choose `Add a Service`  link in the top left corner. You must provide a service name and an optional description for your service.\n+\n+![Service Identity Registration](images/aws-service-register.png)\n+\n+## Athenz Service Identity Authorization Role and Policy\n+\n+Before ZTS can validate and issue X.509 TLS Certificates to the AWS Lambda, it must validate that the service owner has authorized its service to be launched by AWS Lambda Provider. The following role and policy must be created in your Athenz domain for this authorization:\n+\n+When viewing your domain details, choose the `Roles` tab and select\n+`Add Role` link on the left side of the screen underneath the tab names.\n+Role details are as follows (don't forget to press the `Add` button after\n+specifying the role member before pressing the `Submit` button):\n+\n+```\n+Role Category: Regular\n+Role Name: aws_lambda_launch_provider\n+Add Member(s): athens.aws-lambda.*\n+```\n+\n+Then choose the `Policies` tab and select `Add Policy` link on the left side\n+of the screen underneath the tab names. Policy details are as follows\n+(make sure to replace `<your-service-name>` in the Rule Resource\n+with your actual service name):\n+\n+```\n+Policy Name: aws_lambda_launch_provider\n+Rule Effect: Allow\n+Rule Action: launch\n+Rule Role: aws_lambda_launch_provider\n+Rule Resource: service.<your-service-name>\n+```\n+\n+## IAM Role Setup\n+\n+There are two IAM roles required for instances to obtain Athenz X.509 certificates:\n+\n+- Lambda Function Execution Role\n+- Athenz Service Identity Assume Role\n+\n+It is assumed that at this point you have already configured the first Lambda Function Execution Role that your code will be launched with (roles created through the AWS console are created with /service-role/ path). The second Athenz Service Identity IAM Assume Role must be created and must have the `<domain>.<service>` name. This role will not have any permissions but instead will have a trust relationship with your Lambda execution role such that your Lambda execution role can assume this role.\n+\n+In the AWS Console, select `IAM` from the Services drop down and then click on the `Roles` link in the left sidebar. Choose the `Create Role` button. Under the `AWS Service` type, select `Lambda` and choose `Next: Permissions` button in the bottom right corner.\n+\n+![IAM Lambda Role Setup_1](images/iam-lambda-role-setup-1.png)\n+\n+In the `Attach permissions policy` screen do not choose any permissions and just click on the `Next: Review` button in the bottom right corner to continue. Specify the `Role name` in the `<domain>.<service>` format and choose `Create Role` to complete the process.\n+\n+In the Roles list view, choose the role just created and choose the `Trust Relationships` tab.\n+\n+![IAM Lambda Role Setup_2](images/iam-lambda-role-setup-2.png)\n+\n+Click on `Edit trust relationship` button and append a block containing the following policy to the `Statement` block Replace the `<account-id>` and `<lambda-execution-role>` values with their corresponding values for your environment. For the `<lambda-execution-role>` make sure to include the full path since roles created through the AWS console are created with `/service-role/` path:\n+\n+```\n+ {\n+   \"Effect\": \"Allow\",\n+   \"Principal\": {\n+     \"AWS\": \"arn:aws:iam::<account-id>:role/<lambda-execution-role>\"\n+   },\n+   \"Action\": \"sts:AssumeRole\"\n+ }\n+```\n+\n+Once correctly updated, your Lambda role must appear in the `Trusted entities` table:\n+\n+![IAM Lambda Role Setup_3](images/iam-lambda-role-setup-3.png)\n+\n+## Private Key and Certificate Setup\n+\n+Since we're dealing with functions in this use case, we cannot have a SIA agent daemon running to generate a private key for the service and then retrieve a corresponding x.509 certificate from the ZTS Server. Instead, the function being invoked will be responsible for generating a private key and then a csr for its request. Finally, it will submit that request to the ZTS Server to retrieve its X.509 certificate which then it can use  along with its generated private key to establish TLS connections to other Verizon Media Athenz enabled services. Athenz Team provides functions/methods in Go and Java programming languages to quickly generate a private key and request its corresponding X.509 certificate from ZTS Server.\n+\n+Important consideration when dealing with Lambda functions:\n+\n+* The code to do this needs to prefetch and cache the certificate in a way that does not block every invocation, as minting a new certificate is somewhat expensive.\n+* The short lifetime and stateless nature of the function means it cannot rotate its certificates. It just gets new ones when needed.\n+\n+### Java\n+\n+The following function is available in the Athenz ZTS Java Client:\n+\n+```\n+/**\n+ * For AWS Lambda functions generate a new private key, request a\n+ * x.509 certificate based on the requested CSR and return both to\n+ * the client in order to establish tls connections with other\n+ * Athenz enabled services.\n+ * @param domainName name of the athenz domain\n+ * @param serviceName name of the athenz service\n+ * @param account AWS account name that the function runs in\n+ * @param provider name of the provider service for AWS Lambda\n+ * @return AWSLambdaIdentity with private key and certificate\n+ */\n+public AWSLambdaIdentity getAWSLambdaServiceCertificate(String domainName,\n+        String serviceName, String account, String provider);\n+```\n+\n+For example, here is a quick program that can be compiled and packaged into lambda.jar and deployed as a Lambda function in AWS. It retrieves a private key and the corresponding x.509 certificate and returns as output.\n+\n+First you need to update your Java project `pom.xml` file to indicate\n+the dependency on the Athenz zts java client libraries. Checkout the\n+[Bintray ZTS Java Client Package](https://bintray.com/yahoo/maven/athenz-zts-java-client/)\n+pages to make sure you're using the latest release version:\n+\n+```xml\n+  <dependencies>\n+    <dependency>\n+      <groupId>com.yahoo.athenz</groupId>\n+      <artifactId>athenz-zts-java-client</artifactId>\n+      <version>1.8.37</version>\n+    </dependency>\n+  </dependencies>\n+```\n+\n+Next, is the Lambda function handler implementation:\n+\n+```\n+package com.amazonaws.lambda.demo;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestHandler;\n+import com.yahoo.athenz.zts.AWSLambdaIdentity;\n+import com.yahoo.athenz.zts.ZTSClient;\n+\n+public class LambdaFunctionHandler implements RequestHandler<Object, String> {\n+\n+    @Override\n+    public String handleRequest(Object input, Context context) {\n+\n+        final String athenzDomain = \"athens\"; // replace this with your domain name\n+        final String athenzService = \"lambda\"; // replace this with your service name\n+        final String awsAccount = \"123456789\"; // replace this with your account number\n+        final String athenzProvider = \"<lambada-name>.<lambada region>\"; // replace with labada name and region. for example: \"athens.aws-labmda.us-west-2\"\n+        final String ztsUrl = \"https://zts-addres/zts/v1\"; // replace this with your zts Url (ending with /zts/v1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c5d9a245eb06347829bf5891be43326d504d3c52"}, "originalPosition": 160}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c5d9a245eb06347829bf5891be43326d504d3c52", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/c5d9a245eb06347829bf5891be43326d504d3c52", "committedDate": "2020-07-14T17:22:49Z", "message": "Authentication Documentation"}, "afterCommit": {"oid": "edfdc042288c6db21fe029a413f97e593ea0a4b5", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/edfdc042288c6db21fe029a413f97e593ea0a4b5", "committedDate": "2020-07-19T12:23:38Z", "message": "Authentication Documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3f2fdd525fc26abfb227e99b7a170f0d07043f9", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/f3f2fdd525fc26abfb227e99b7a170f0d07043f9", "committedDate": "2020-07-19T12:41:20Z", "message": "Authentication Documentation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "edfdc042288c6db21fe029a413f97e593ea0a4b5", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/edfdc042288c6db21fe029a413f97e593ea0a4b5", "committedDate": "2020-07-19T12:23:38Z", "message": "Authentication Documentation"}, "afterCommit": {"oid": "f3f2fdd525fc26abfb227e99b7a170f0d07043f9", "author": {"user": {"login": "OferLevi85", "name": "Ofer Levi"}}, "url": "https://github.com/AthenZ/athenz/commit/f3f2fdd525fc26abfb227e99b7a170f0d07043f9", "committedDate": "2020-07-19T12:41:20Z", "message": "Authentication Documentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNzU1MTY3", "url": "https://github.com/AthenZ/athenz/pull/1025#pullrequestreview-451755167", "createdAt": "2020-07-20T16:11:14Z", "commit": {"oid": "f3f2fdd525fc26abfb227e99b7a170f0d07043f9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2985, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}