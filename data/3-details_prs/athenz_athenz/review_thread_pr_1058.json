{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3MTQ0MDEw", "number": 1058, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNTo0MjowMVrOEScgaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTowMjozMVrOEVoOzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3Nzc2ODc1OnYy", "diffSide": "RIGHT", "path": "docs/zts_access_token_guide.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNTo0MjowMVrOG3oS6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNTo0MjowMVrOG3oS6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk4NTA2Nw==", "bodyText": "Let's use a placeholder for the version", "url": "https://github.com/AthenZ/athenz/pull/1058#discussion_r460985067", "createdAt": "2020-07-27T15:42:01Z", "author": {"login": "abvaidya"}, "path": "docs/zts_access_token_guide.md", "diffHunk": "@@ -0,0 +1,380 @@\n+Access Tokens are used to authorize access to service provider resources.\n+The Access Token contains the set of roles (identified in the token as\n+scopes) a client belongs to for a specified domain. So, when a client wants\n+to access a resource, this client\n+must obtain the appropriate Access Token from ZTS and use the token in the\n+header of the subsequent HTTP client request. If enabled, the service will\n+also return an ID Token if requested. ID Token identifies the authenticated\n+principal for a given Athenz Service Identity.\n+\n+Support for accessing OAuth2 access/id tokens is based on Client Credentials\n+authentication workflow as defined in [RFC6749: The OAuth 2.0 Authorization Framework](https://tools.ietf.org/html/rfc6749#section-4.4).\n+\n+## Access/ID Token Request\n+\n+### Request\n+\n+To request an access token from ZTS Server, the client will send a POST\n+request with `application/x-www-form-urlencoded` content-type to `/oauth2/token`\n+endpoint. The request body must contain the following parameters:\n+\n+```\n+grant_type : Value MUST be set to \"client_credentials\"\n+scope : list of scopes/roles requested in the access token. The caller\n+        can either specify to include all roles the principal has access\n+        to in a specific domain (e.g. <domain-name>:domain) or ask for\n+        specific roles only (e.g. <domain-name>:role.<role1>). Scopes\n+        are separated by spaces.\n+        To request an ID token, the scope must include 'openid' and audience\n+        service name (e.g. <domain-name>:service.<service-name>). The domain\n+        name in id token request match the domain name in the access token\n+        scope.\n+expires_in : requested expiry time for access token in seconds\n+```\n+\n+For example, when a principal requests an access token only for accessing\n+`demo` domain and wants to include all roles it has access to in that\n+domain, the request would be:\n+\n+```\n+POST /zts/v1/oauth2/token HTTP/1.1\n+Host: <zts-address>\n+Content-Type: application/x-www-form-urlencoded\n+\n+grant_type=client_credentials&scope=demo%3Adomain\n+```\n+\n+If the principal requests an access token only for accessing\n+`demo` domain and wants to include `readers` and `writers` roles it has access\n+to in that domain, the request would be:\n+\n+```\n+POST /zts/v1/oauth2/token HTTP/1.1\n+Host: <zts-address>\n+Content-Type: application/x-www-form-urlencoded\n+\n+grant_type=client_credentials&scope=demo%3Arole.readers+sherpa%3Arole.writers\n+```\n+\n+If the principal requests an access token along with an id token for accessing\n+`demo` domain for `backend` service and wants to include `readers` and `writers`\n+roles it has access to in that domain, the request would be:\n+\n+```\n+POST /zts/v1/oauth2/token HTTP/1.1\n+Host: <zts-address>\n+Content-Type: application/x-www-form-urlencoded\n+\n+grant_type=client_credentials&scope=openid+demo%3Aservice.backend+demo%3Arole.readers+demo%3Arole.writers\n+```\n+\n+### Response\n+\n+If the access token request is valid and authorized, the ZTS server issues\n+an access token (and id token if requested). The response contains the following\n+json document:\n+\n+```\n+{\n+  \"access_token\":\"<generated-token>\",\n+  \"id_token\":\"<generated-token>\",\n+  \"token_type\":\"Bearer\",\n+  \"expires_in\":3600\n+}\n+```\n+\n+## Access Token format\n+\n+An access token is a [JSON web token (JWT)](https://tools.ietf.org/html/rfc7519)\n+encoded in Base64 URL-encoded format that contains a header, payload, and signature.\n+An application server can authorize the principal to access specific resources based\n+on the scopes (roles) defined in the access token.\n+\n+### Access Token Header\n+\n+The Access token header contains the Athenz ZTS Server Private key id and the\n+algorithm used to sign the payload.\n+\n+```\n+{\n+  \"alg\": \"ES256\",\n+  \"kid\": \"<zts server private key id>\"\n+}\n+```\n+\n+### Access Token Payload\n+\n+The Access Token Payload contains the following claims:\n+\n+```\n+ver : version of the access token\n+iss : token issuer\n+aud : the audience (the Athenz Domain name) that the access token is intended for\n+uid : unique identifier for the principal (same as client Id)\n+sub : subject of the access token (same as client Id)\n+iat : token issue time in seconds (Unix time)\n+exp : token expiry time in seconds (Unix time)\n+scp : array of scopes are granted to this access token. This is the list of roles that principal can assume in the audience domain\n+client_id : client ID (Athenz Principal) of the client that requested the access token\n+```\n+\n+Here is an example of an access token that `alpha.api` retrieved to access\n+some resource in `beta` domain. The principal `alpha.api` is authorized\n+to assume `readers` and `writers` roles in the `beta` domain.\n+\n+```\n+{\n+  \"ver\": 1,\n+  \"iss\": \"athenz\",\n+  \"aud\": \"beta\",\n+  \"client_id\": \"alpha.api\",\n+  \"uid\": \"alpha.api\",\n+  \"sub\": \"alpha.api\",\n+  \"iat\": 1554491974,\n+  \"exp\": 1554495574,\n+  \"scp\": [\n+    \"readers\",\n+    \"writers\"\n+  ]\n+}\n+```\n+\n+### Access Token Validation\n+\n+You can use any standards based JWT library to validate the access token\n+generated by ZTS Server. You can also implement your own verifier by\n+following the [RFC7519: Section 7.2:  Validating a JWT](https://tools.ietf.org/html/rfc7519).\n+\n+## ID Token format\n+\n+An ID token is a [JSON web token (JWT)](https://tools.ietf.org/html/rfc7519)\n+encoded in Base64 URL-encoded format that contains a header, payload, and\n+signature. The ID token, if enabled, can be issued for clients to authenticate\n+themselves along with their access token to the requested Athenz service.\n+ZTS Server never issues ID Tokens on its own. They're always returned along\n+with access tokens.\n+\n+### ID Token Header\n+\n+The ID token header contains the Athenz ZTS Server Private key id and the\n+algorithm used to sign the payload.\n+\n+```\n+{\n+  \"alg\": \"ES256\",\n+  \"kid\": \"<zts server private key id>\"\n+}\n+```\n+\n+### ID Token Payload\n+\n+The ID Token Payload contains the following claims:\n+\n+```\n+ver : version of the id token\n+iss : token issuer\n+aud : the audience (the Athenz Service name) that the id token is intended for\n+sub : subject of the id token - athenz pricnipal name requesting the token\n+iat : token issue time in seconds (Unix time)\n+exp : token expiry time in seconds (Unix time)\n+auth_time: authentication time in seconds (Unix time)\n+```\n+\n+Here is an example of an id token that `alpha.api` retrieved for its\n+authorization request to `beta.backend` service.\n+\n+```\n+{\n+  \"ver\": 1,\n+  \"iss\": \"athenz\",\n+  \"aud\": \"beta.backend\",\n+  \"sub\": \"alpha.api\",\n+  \"iat\": 1554491974,\n+  \"auth_time\": 1554491974,\n+  \"exp\": 1554495574\n+}\n+```\n+\n+### ID Token Validation\n+\n+You can use any standards based JWT library to validate the id token\n+generated by ZTS Server. You can also implement your own verifier by\n+following the [RFC7519: Section 7.2:  Validating a JWT](https://tools.ietf.org/html/rfc7519).\n+\n+## Fetching Access Tokens with Java Client Library\n+\n+First you need to update your Java project `pom.xml` file to indicate\n+the dependency on the Athenz zts java client library. Checkout the\n+[Bintray ZTS Java Client Package](https://bintray.com/yahoo/maven/athenz-zts-java-client/)\n+page to make sure you're using the latest release version (You must use\n+1.8.37 or newer version of the client library). \n+\n+### ZTS Client Object\n+\n+ZTS Client Library provides several constructors. The recommended\n+approach is to use the an SSL context that includes service's Athenz\n+issued CA certificate.\n+\n+ZTSClient object must be closed to release any allocated resources.\n+ZTSClient class implements Closeable interface. However, to correctly\n+handle auto-refresh of access tokens, the client used to fetch\n+the token cannot be closed since the background tasks need to use\n+the same client to refresh the access token. Our general recommendation\n+is that you create a single ZTSClient object and use that for all\n+requests (it is thread safe) and then close the client when your\n+application is shutting down.\n+\n+** Important **\n+\n+During the shutdown of the application, `ZTSClient.cancelPrefetch()`\n+must be called to stop the timer thread that automatically fetches\n+and refreshes any cached tokens in the ZTS Client.\n+\n+#### Athenz Issued CA certificate\n+\n+If your service is running on AWS/Openstack bootstrapped\n+hosts or within an Athenz enabled container environment like K8S,\n+then it already has an Athenz issued X.509 certificate that it can\n+use for authentication.\n+\n+```java\n+/**\n+ * Constructs a new ZTSClient object with the given SSLContext object\n+ * and ZTS Server Url. Default read and connect timeout values are\n+ * 30000ms (30sec). The application can change these values by using the\n+ * athenz.zts.client.read_timeout and athenz.zts.client.connect_timeout\n+ * system properties. The values specified for timeouts must be in milliseconds.\n+ * @param ztsUrl ZTS Server's URL\n+ * @param sslContext SSLContext that includes service's private key and x.509 certificate\n+ * for authenticating requests\n+ */\n+public ZTSClient(String ztsUrl, SSLContext sslContext);\n+```\n+\n+First update your `pom.xml` to include dependency on `athenz-cert-refresher` package\n+which provides support to create a SSLContext object based on our private key\n+and certificate:\n+\n+```java\n+<dependency>\n+  <groupId>com.yahoo.athenz</groupId>\n+  <artifactId>athenz-cert-refresher</artifactId>\n+  <version>1.8.37</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed6420360e26256f5e3a9c16f964dca8e40336f6"}, "originalPosition": 262}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3Nzc3NzY0OnYy", "diffSide": "RIGHT", "path": "docs/zts_access_token_guide.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNTo0NDoxN1rOG3oYrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxNTo0NDoxN1rOG3oYrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk4NjU0Mw==", "bodyText": "Let's reword this section to remove the internal assumption of identity being available out-of-the-box.", "url": "https://github.com/AthenZ/athenz/pull/1058#discussion_r460986543", "createdAt": "2020-07-27T15:44:17Z", "author": {"login": "abvaidya"}, "path": "docs/zts_access_token_guide.md", "diffHunk": "@@ -0,0 +1,380 @@\n+Access Tokens are used to authorize access to service provider resources.\n+The Access Token contains the set of roles (identified in the token as\n+scopes) a client belongs to for a specified domain. So, when a client wants\n+to access a resource, this client\n+must obtain the appropriate Access Token from ZTS and use the token in the\n+header of the subsequent HTTP client request. If enabled, the service will\n+also return an ID Token if requested. ID Token identifies the authenticated\n+principal for a given Athenz Service Identity.\n+\n+Support for accessing OAuth2 access/id tokens is based on Client Credentials\n+authentication workflow as defined in [RFC6749: The OAuth 2.0 Authorization Framework](https://tools.ietf.org/html/rfc6749#section-4.4).\n+\n+## Access/ID Token Request\n+\n+### Request\n+\n+To request an access token from ZTS Server, the client will send a POST\n+request with `application/x-www-form-urlencoded` content-type to `/oauth2/token`\n+endpoint. The request body must contain the following parameters:\n+\n+```\n+grant_type : Value MUST be set to \"client_credentials\"\n+scope : list of scopes/roles requested in the access token. The caller\n+        can either specify to include all roles the principal has access\n+        to in a specific domain (e.g. <domain-name>:domain) or ask for\n+        specific roles only (e.g. <domain-name>:role.<role1>). Scopes\n+        are separated by spaces.\n+        To request an ID token, the scope must include 'openid' and audience\n+        service name (e.g. <domain-name>:service.<service-name>). The domain\n+        name in id token request match the domain name in the access token\n+        scope.\n+expires_in : requested expiry time for access token in seconds\n+```\n+\n+For example, when a principal requests an access token only for accessing\n+`demo` domain and wants to include all roles it has access to in that\n+domain, the request would be:\n+\n+```\n+POST /zts/v1/oauth2/token HTTP/1.1\n+Host: <zts-address>\n+Content-Type: application/x-www-form-urlencoded\n+\n+grant_type=client_credentials&scope=demo%3Adomain\n+```\n+\n+If the principal requests an access token only for accessing\n+`demo` domain and wants to include `readers` and `writers` roles it has access\n+to in that domain, the request would be:\n+\n+```\n+POST /zts/v1/oauth2/token HTTP/1.1\n+Host: <zts-address>\n+Content-Type: application/x-www-form-urlencoded\n+\n+grant_type=client_credentials&scope=demo%3Arole.readers+sherpa%3Arole.writers\n+```\n+\n+If the principal requests an access token along with an id token for accessing\n+`demo` domain for `backend` service and wants to include `readers` and `writers`\n+roles it has access to in that domain, the request would be:\n+\n+```\n+POST /zts/v1/oauth2/token HTTP/1.1\n+Host: <zts-address>\n+Content-Type: application/x-www-form-urlencoded\n+\n+grant_type=client_credentials&scope=openid+demo%3Aservice.backend+demo%3Arole.readers+demo%3Arole.writers\n+```\n+\n+### Response\n+\n+If the access token request is valid and authorized, the ZTS server issues\n+an access token (and id token if requested). The response contains the following\n+json document:\n+\n+```\n+{\n+  \"access_token\":\"<generated-token>\",\n+  \"id_token\":\"<generated-token>\",\n+  \"token_type\":\"Bearer\",\n+  \"expires_in\":3600\n+}\n+```\n+\n+## Access Token format\n+\n+An access token is a [JSON web token (JWT)](https://tools.ietf.org/html/rfc7519)\n+encoded in Base64 URL-encoded format that contains a header, payload, and signature.\n+An application server can authorize the principal to access specific resources based\n+on the scopes (roles) defined in the access token.\n+\n+### Access Token Header\n+\n+The Access token header contains the Athenz ZTS Server Private key id and the\n+algorithm used to sign the payload.\n+\n+```\n+{\n+  \"alg\": \"ES256\",\n+  \"kid\": \"<zts server private key id>\"\n+}\n+```\n+\n+### Access Token Payload\n+\n+The Access Token Payload contains the following claims:\n+\n+```\n+ver : version of the access token\n+iss : token issuer\n+aud : the audience (the Athenz Domain name) that the access token is intended for\n+uid : unique identifier for the principal (same as client Id)\n+sub : subject of the access token (same as client Id)\n+iat : token issue time in seconds (Unix time)\n+exp : token expiry time in seconds (Unix time)\n+scp : array of scopes are granted to this access token. This is the list of roles that principal can assume in the audience domain\n+client_id : client ID (Athenz Principal) of the client that requested the access token\n+```\n+\n+Here is an example of an access token that `alpha.api` retrieved to access\n+some resource in `beta` domain. The principal `alpha.api` is authorized\n+to assume `readers` and `writers` roles in the `beta` domain.\n+\n+```\n+{\n+  \"ver\": 1,\n+  \"iss\": \"athenz\",\n+  \"aud\": \"beta\",\n+  \"client_id\": \"alpha.api\",\n+  \"uid\": \"alpha.api\",\n+  \"sub\": \"alpha.api\",\n+  \"iat\": 1554491974,\n+  \"exp\": 1554495574,\n+  \"scp\": [\n+    \"readers\",\n+    \"writers\"\n+  ]\n+}\n+```\n+\n+### Access Token Validation\n+\n+You can use any standards based JWT library to validate the access token\n+generated by ZTS Server. You can also implement your own verifier by\n+following the [RFC7519: Section 7.2:  Validating a JWT](https://tools.ietf.org/html/rfc7519).\n+\n+## ID Token format\n+\n+An ID token is a [JSON web token (JWT)](https://tools.ietf.org/html/rfc7519)\n+encoded in Base64 URL-encoded format that contains a header, payload, and\n+signature. The ID token, if enabled, can be issued for clients to authenticate\n+themselves along with their access token to the requested Athenz service.\n+ZTS Server never issues ID Tokens on its own. They're always returned along\n+with access tokens.\n+\n+### ID Token Header\n+\n+The ID token header contains the Athenz ZTS Server Private key id and the\n+algorithm used to sign the payload.\n+\n+```\n+{\n+  \"alg\": \"ES256\",\n+  \"kid\": \"<zts server private key id>\"\n+}\n+```\n+\n+### ID Token Payload\n+\n+The ID Token Payload contains the following claims:\n+\n+```\n+ver : version of the id token\n+iss : token issuer\n+aud : the audience (the Athenz Service name) that the id token is intended for\n+sub : subject of the id token - athenz pricnipal name requesting the token\n+iat : token issue time in seconds (Unix time)\n+exp : token expiry time in seconds (Unix time)\n+auth_time: authentication time in seconds (Unix time)\n+```\n+\n+Here is an example of an id token that `alpha.api` retrieved for its\n+authorization request to `beta.backend` service.\n+\n+```\n+{\n+  \"ver\": 1,\n+  \"iss\": \"athenz\",\n+  \"aud\": \"beta.backend\",\n+  \"sub\": \"alpha.api\",\n+  \"iat\": 1554491974,\n+  \"auth_time\": 1554491974,\n+  \"exp\": 1554495574\n+}\n+```\n+\n+### ID Token Validation\n+\n+You can use any standards based JWT library to validate the id token\n+generated by ZTS Server. You can also implement your own verifier by\n+following the [RFC7519: Section 7.2:  Validating a JWT](https://tools.ietf.org/html/rfc7519).\n+\n+## Fetching Access Tokens with Java Client Library\n+\n+First you need to update your Java project `pom.xml` file to indicate\n+the dependency on the Athenz zts java client library. Checkout the\n+[Bintray ZTS Java Client Package](https://bintray.com/yahoo/maven/athenz-zts-java-client/)\n+page to make sure you're using the latest release version (You must use\n+1.8.37 or newer version of the client library). \n+\n+### ZTS Client Object\n+\n+ZTS Client Library provides several constructors. The recommended\n+approach is to use the an SSL context that includes service's Athenz\n+issued CA certificate.\n+\n+ZTSClient object must be closed to release any allocated resources.\n+ZTSClient class implements Closeable interface. However, to correctly\n+handle auto-refresh of access tokens, the client used to fetch\n+the token cannot be closed since the background tasks need to use\n+the same client to refresh the access token. Our general recommendation\n+is that you create a single ZTSClient object and use that for all\n+requests (it is thread safe) and then close the client when your\n+application is shutting down.\n+\n+** Important **\n+\n+During the shutdown of the application, `ZTSClient.cancelPrefetch()`\n+must be called to stop the timer thread that automatically fetches\n+and refreshes any cached tokens in the ZTS Client.\n+\n+#### Athenz Issued CA certificate", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed6420360e26256f5e3a9c16f964dca8e40336f6"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDE3Mzg1OnYy", "diffSide": "RIGHT", "path": "docs/athenz_templates.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODo1MjoxMlrOG8WXug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODo1MjoxMlrOG8WXug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDI2Ng==", "bodyText": "Remove the reference to git repo. We should say that the system admin will manage all the templates in a file their data repository.", "url": "https://github.com/AthenZ/athenz/pull/1058#discussion_r465934266", "createdAt": "2020-08-05T18:52:12Z", "author": {"login": "havetisyan"}, "path": "docs/athenz_templates.md", "diffHunk": "@@ -0,0 +1,235 @@\n+# Introducing Athenz Templates\n+Templates are a collection of predefined roles, \n+policies and services that can be applied on a domain. \n+Imagine in a real world scenario if you are creating a solution\n+for any organization(Openstack, Kubernetes) \n+and subsequently want to set up provisioning rules(a static set of \n+roles and policies) for the solution, rather than requiring each domain \n+admin to create each of these roles and policies manually, \n+you can pre-bundle the roles and policies as a template and Athenz \n+will automatically apply them for you while creating or updating a domain.\n+    \n+## Templates\n+\n+### Creating and updating templates\n+Templates today exists in json format in git repo under a file called ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b9c3c4e72612e2cb580d030c2097215cfc8600a"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMTE0NzAzOnYy", "diffSide": "RIGHT", "path": "docs/athenz_templates.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTowMjozMVrOG8fmtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwMTowMjozMVrOG8fmtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA4NTU1Nw==", "bodyText": "Typo:\nenc=ecli -> env=ecli", "url": "https://github.com/AthenZ/athenz/pull/1058#discussion_r466085557", "createdAt": "2020-08-06T01:02:31Z", "author": {"login": "jothi-prasad"}, "path": "docs/athenz_templates.md", "diffHunk": "@@ -0,0 +1,235 @@\n+# Introducing Athenz Templates\n+Templates are a collection of predefined roles, \n+policies and services that can be applied on a domain. \n+Imagine in a real world scenario if you are creating a solution\n+for any organization(Openstack, Kubernetes) \n+and subsequently want to set up provisioning rules(a static set of \n+roles and policies) for the solution, rather than requiring each domain \n+admin to create each of these roles and policies manually, \n+you can pre-bundle the roles and policies as a template and Athenz \n+will automatically apply them for you while creating or updating a domain.\n+    \n+## Templates\n+\n+### Creating and updating templates\n+Templates today exists in json format in git repo under a file called \n+solutions_templates.json and will follow the format below\n+```\n+{\n+\t\"<template_name>\": {\n+\t\t\"metadata\": {},\n+\t\t\"roles\": [<athenz-roles>],\n+\t        \"policies\": [<athenz-policies>],\n+\t\t\"services\": [<athenz-services>]\n+      }\n+}\n+```\n+All templates will be managed by the Athenz System Administrators. To create / update templates, edit the solution_templates.json configuration file.\n+\n+## Template Entities\n+A Template consists of metadata, services, roles and role metadata, \n+policies with assertions. Please find the explanation for every entity below\n+\n+### MetaData\n+Metadata contains critical fields to represent vital characteristics of a template. \n+Look at the sample structure below for one of the templates in use.\n+\n+```         \n+ \"metadata\":\n+                {\n+                    \"latestVersion\": 1,\n+                    \"timestamp\": \"2020-06-16T00:00:00.000Z\",\n+                    \"description\": \"Description of template\",\n+                    \"keywordsToReplace\": \"_env_,_track_\",\n+                    \"autoUpdate\": false\n+                }\n+```\n+\n+A - Description - description of the template (restrict it to 140 characters if possible)\n+\n+B - latestVersion - to manage versioning. Everytime there is a change in the template including a template metadata change, Make sure to bump up the latestVersion field by 1.\n+\n+C - Timestamp - recorded timestamp when you update(including \n+metadata change) a template. This is purely to help you time track template changes.\n+\n+D - keywordsToReplace - this field is a comma separated placeholder you can add to your role/policy name which will be auto replaced on the fly. for ex: keywordsToReplace will be set to \n+\u201c_env_, _track_\u201d for a role name \u201c_domain_:role.some-role._env_.track._track_.emitters\". You should leave keywordsToReplace field empty if you do not have any placeholders in your role or policy name. (for ex: \"keywordsToReplace\": \"\",)\n+\n+Note: _domain_ is the only exception here. When applying a template to a domain, the server will automatically include the correct domain name in role/policy names by replacing the _domain_ placeholder with the appropriate value so do not worry about adding it.\n+\n+Example structure of roles/policies which uses multiple placeholders:\n+\n+```\n+\"roles\": [\n+                {\n+                    \"name\": \"_domain_:role.some-role._env_.track._track_.emitters\",\n+                    \"modified\": \"1970-01-01T00:00:00.000Z\"\n+                }\n+            ],\n+            \"policies\": [\n+                {\n+                    \"name\": \"_domain_:policy.some-policy._env_.track._track_.emitters\",\n+                    \"modified\": \"1970-01-01T00:00:00.000Z\",\n+                    \"assertions\": [\n+                        {\n+                            \"resource\": \"some-resource._env_:role.track._track_.emitters\",\n+                            \"role\": \"_domain_:role.some-role._env_.track._track_.emitters\",\n+                            \"action\": \"assume_role\"\n+                        }\n+                    ]\n+                }\n+            ]\n+```\n+\n+### Roles\n+Roles can have attributes like name, modified timestamp, Role Meta attributes\n+ (check the complete role meta attributes list below) and roleMembers. \n+ By default roles that are created by the template will not have any members \n+ unless the role members are hard-coded in the template \n+ (check the example structure below). The domain administrator will \n+ need to add members to those roles after the domain is created or the \n+ template has been applied to a domain. Now if you notice role members array \n+ in the image below, members can also have placeholders which have to be added \n+ to keywordsToReplace.\n+\n+Sample structure for Roles with role members:\n+```\n+           \"roles\": [\n+                {\n+                    \"name\": \"_domain_:role.aws_instance_launch_provider\",\n+                    \"modified\": \"1970-01-01T00:00:00.000Z\",\n+                    \"roleMembers\": [\n+                        {\n+                            \"memberName\": \"athens.aws.*\"\n+                        }\n+                    ]\n+                },\n+                {\n+                    \"name\": \"_domain_:role.aws.ssh_login\",\n+                    \"modified\": \"1970-01-01T00:00:00.000Z\"\n+                },\n+                {\n+                    \"name\": \"_domain_:role.aws_ssh_cert_request\",\n+                    \"modified\": \"1970-01-01T00:00:00.000Z\",\n+                    \"roleMembers\": [\n+                        {\n+                            \"memberName\": \"_domain_._service_\"\n+                        }\n+                    ]\n+                }\n+            ]\n+```\n+Allowed Role Meta Attributes:\n+```\n+\"selfServe\": \"false\",\n+\"memberExpiryDays\": 90,\n+\"tokenExpiryMins\": 30,\n+\"certExpiryMins\": 10,\n+\"serviceExpiryDays\": 50,\n+\"memberReviewDays\": 65,\n+\"serviceReviewDays\": 15,\n+\"reviewEnabled\": true\n+```\n+\n+### Policies\n+Array of policies with name, modified timestamp and array of assertions. \n+Check the sample Json below.\n+\n+           \"policies\": [\n+                {\n+                    \"name\": \"_domain_:policy.aws_instance_launch_provider\",\n+                    \"modified\": \"1970-01-01T00:00:00.000Z\",\n+                    \"assertions\": [\n+                        {\n+                            \"resource\": \"_domain_:service._service_\",\n+                            \"role\": \"_domain_:role.aws_instance_launch_provider\",\n+                            \"action\": \"launch\"\n+                        }\n+                    ]\n+                },\n+                {\n+                    \"name\": \"_domain_:policy.aws.ssh_login\",\n+                    \"modified\": \"1970-01-01T00:00:00.000Z\",\n+                    \"assertions\": [\n+                        {\n+                            \"resource\": \"_domain_:aws._service_.*\",\n+                            \"role\": \"_domain_:role.aws.ssh_login\",\n+                            \"action\": \"ssh_login\",\n+                            \"effect\": \"DENY\"\n+                        }\n+                    ]\n+                }\n+\n+## Applying Templates\n+Templates can be applied via [ZMS CLI](zms_client.md)\n+and via Athenz UI. let's take a look at a few examples on how to apply \n+different types of templates.\n+\n+### Example 1\n+Templates with placeholders in role and policy names \n+(aka comma separated values in keywordsToReplace under template metadata field)\n+will have to pass the key value pair for all placeholders via CLI.\n+However, Athenz UI will automatically detect the placeholders and prompt \n+the user to enter those placeholder values without which you cannot apply a template\n+\n+##### CLI\n+```\n+zms-cli -d some-domain set-domain-template some-template-name enc=ecli track=clit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b9c3c4e72612e2cb580d030c2097215cfc8600a"}, "originalPosition": 177}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1711, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}