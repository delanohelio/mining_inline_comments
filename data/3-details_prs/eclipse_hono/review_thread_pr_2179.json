{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3NDk5ODQ2", "number": 2179, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNjo1NTo0NlrOEj6f5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzowMDowMVrOEj6koA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MDk0MDU1OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNjo1NTo0NlrOHSitsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxMzoxMjoyMVrOHSwJWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwNTE3MQ==", "bodyText": "under which circumstances would you want to set this to false?", "url": "https://github.com/eclipse/hono/pull/2179#discussion_r489205171", "createdAt": "2020-09-16T06:55:46Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java", "diffHunk": "@@ -56,6 +56,29 @@ static ApplicationClientFactory create(final HonoConnection connection, final Se\n      *\n      * @param tenantId The tenant to consume data for.\n      * @param telemetryConsumer The handler to invoke with every message received.\n+     * @param autoAccept {@code true} if received deliveries should be automatically accepted (and settled)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c08d0695daca42fec9a1ccbc6474c0655087a0fa"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NTM5OQ==", "bodyText": "In case accepting/rejecting the delivery should be done asynchronously.\nIn the case of the added test case here, a scenario should be simulated where the consumer takes a long time to accept the delivery - longer than the sendMessageTimeout. Without the autoAccept=false flag, this would mean having to block the event loop thread in the message handler, requiring the use of an extra HonoConnection/ApplicationClientFactory instance in the test.", "url": "https://github.com/eclipse/hono/pull/2179#discussion_r489245399", "createdAt": "2020-09-16T08:08:24Z", "author": {"login": "calohmn"}, "path": "client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java", "diffHunk": "@@ -56,6 +56,29 @@ static ApplicationClientFactory create(final HonoConnection connection, final Se\n      *\n      * @param tenantId The tenant to consume data for.\n      * @param telemetryConsumer The handler to invoke with every message received.\n+     * @param autoAccept {@code true} if received deliveries should be automatically accepted (and settled)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwNTE3MQ=="}, "originalCommit": {"oid": "c08d0695daca42fec9a1ccbc6474c0655087a0fa"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI5MDMxOA==", "bodyText": "What you describe as the use is actually an anti pattern, isn't it? It means that the messages sent downstream will remain in flight for an indeterminate amount of time :-(\nIMHO we should be very explicit in the JavaDoc that a consumer should not perform any time consuming work in the handler but should spawn a new thread or something like that in such a case, but otherwise quickly settle the incoming transfer.", "url": "https://github.com/eclipse/hono/pull/2179#discussion_r489290318", "createdAt": "2020-09-16T09:17:57Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java", "diffHunk": "@@ -56,6 +56,29 @@ static ApplicationClientFactory create(final HonoConnection connection, final Se\n      *\n      * @param tenantId The tenant to consume data for.\n      * @param telemetryConsumer The handler to invoke with every message received.\n+     * @param autoAccept {@code true} if received deliveries should be automatically accepted (and settled)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwNTE3MQ=="}, "originalCommit": {"oid": "c08d0695daca42fec9a1ccbc6474c0655087a0fa"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQyNTI0MA==", "bodyText": "I've added a corresponding note in the javadocs.", "url": "https://github.com/eclipse/hono/pull/2179#discussion_r489425240", "createdAt": "2020-09-16T13:12:21Z", "author": {"login": "calohmn"}, "path": "client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java", "diffHunk": "@@ -56,6 +56,29 @@ static ApplicationClientFactory create(final HonoConnection connection, final Se\n      *\n      * @param tenantId The tenant to consume data for.\n      * @param telemetryConsumer The handler to invoke with every message received.\n+     * @param autoAccept {@code true} if received deliveries should be automatically accepted (and settled)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwNTE3MQ=="}, "originalCommit": {"oid": "c08d0695daca42fec9a1ccbc6474c0655087a0fa"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MDk0NDIzOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNjo1NzowOVrOHSiv-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODowOToxMlrOHSlM4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwNTc1Mg==", "bodyText": "why would you want to set this to false?", "url": "https://github.com/eclipse/hono/pull/2179#discussion_r489205752", "createdAt": "2020-09-16T06:57:09Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java", "diffHunk": "@@ -67,11 +90,32 @@ static ApplicationClientFactory create(final HonoConnection connection, final Se\n             Consumer<Message> telemetryConsumer,\n             Handler<Void> closeHandler);\n \n+    /**\n+     * Creates a client for consuming events from Hono's north bound <em>Event API</em>.\n+     *\n+     * @param tenantId The tenant to consume events for.\n+     * @param eventConsumer The handler to invoke with every event received.\n+     * @param closeHandler The handler invoked when the peer detaches the link.\n+     * @param autoAccept {@code true} if received deliveries should be automatically accepted (and settled)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c08d0695daca42fec9a1ccbc6474c0655087a0fa"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NTkyMw==", "bodyText": "See above.", "url": "https://github.com/eclipse/hono/pull/2179#discussion_r489245923", "createdAt": "2020-09-16T08:09:12Z", "author": {"login": "calohmn"}, "path": "client/src/main/java/org/eclipse/hono/client/ApplicationClientFactory.java", "diffHunk": "@@ -67,11 +90,32 @@ static ApplicationClientFactory create(final HonoConnection connection, final Se\n             Consumer<Message> telemetryConsumer,\n             Handler<Void> closeHandler);\n \n+    /**\n+     * Creates a client for consuming events from Hono's north bound <em>Event API</em>.\n+     *\n+     * @param tenantId The tenant to consume events for.\n+     * @param eventConsumer The handler to invoke with every event received.\n+     * @param closeHandler The handler invoked when the peer detaches the link.\n+     * @param autoAccept {@code true} if received deliveries should be automatically accepted (and settled)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwNTc1Mg=="}, "originalCommit": {"oid": "c08d0695daca42fec9a1ccbc6474c0655087a0fa"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MDk1MTYwOnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/http/TelemetryHttpIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNjo1OTozOVrOHSi0oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoyMToyNFrOHSlpeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwNjk0NA==", "bodyText": "IMHO tests checking for literal string values produced elsewhere in the code base will be very flaky.\nFMPOV we can either check for a constant that is used in both places or remove this check.", "url": "https://github.com/eclipse/hono/pull/2179#discussion_r489206944", "createdAt": "2020-09-16T06:59:39Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/http/TelemetryHttpIT.java", "diffHunk": "@@ -125,4 +127,102 @@ public void testUploadMessageFailsForLargePayload(final VertxTestContext ctx) {\n             // THEN the message gets rejected by the HTTP adapter with a 413\n             .onComplete(ctx.completing());\n     }\n+\n+    /**\n+     * Verifies that the upload of a telemetry message fails with a 503 status code\n+     * when there is no consumer.\n+     *\n+     * @param ctx The test context\n+     */\n+    @Test\n+    public void testUploadMessageFailsForNoConsumer(final VertxTestContext ctx) {\n+\n+        // GIVEN a device\n+        final Tenant tenant = new Tenant();\n+\n+        helper.registry\n+                .addDeviceForTenant(tenantId, tenant, deviceId, PWD)\n+                .compose(ok -> {\n+\n+                    // WHEN the device tries to upload a telemetry message while there is no consumer for it\n+                    final MultiMap requestHeaders = MultiMap.caseInsensitiveMultiMap()\n+                            .add(HttpHeaders.CONTENT_TYPE, \"text/plain\")\n+                            .add(HttpHeaders.AUTHORIZATION, authorization);\n+\n+                    return httpClient.create(\n+                            getEndpointUri(),\n+                            Buffer.buffer(\"hello\"),\n+                            requestHeaders,\n+                            ResponsePredicate.status(HttpURLConnection.HTTP_UNAVAILABLE));\n+\n+                })\n+                // THEN the message gets rejected by the HTTP adapter with a 503\n+                .onComplete(ctx.succeeding(response -> {\n+                    ctx.verify(() -> {\n+                        assertThat(response.bodyAsString()).isEqualTo(\"temporarily unavailable\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c08d0695daca42fec9a1ccbc6474c0655087a0fa"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MzI0Mg==", "bodyText": "I mainly added this here so that with the fix for #2166, the more specific error message can be checked upon here.\nI have removed the check now and will add it again with the fix for #2166 (using a constant then).", "url": "https://github.com/eclipse/hono/pull/2179#discussion_r489253242", "createdAt": "2020-09-16T08:21:24Z", "author": {"login": "calohmn"}, "path": "tests/src/test/java/org/eclipse/hono/tests/http/TelemetryHttpIT.java", "diffHunk": "@@ -125,4 +127,102 @@ public void testUploadMessageFailsForLargePayload(final VertxTestContext ctx) {\n             // THEN the message gets rejected by the HTTP adapter with a 413\n             .onComplete(ctx.completing());\n     }\n+\n+    /**\n+     * Verifies that the upload of a telemetry message fails with a 503 status code\n+     * when there is no consumer.\n+     *\n+     * @param ctx The test context\n+     */\n+    @Test\n+    public void testUploadMessageFailsForNoConsumer(final VertxTestContext ctx) {\n+\n+        // GIVEN a device\n+        final Tenant tenant = new Tenant();\n+\n+        helper.registry\n+                .addDeviceForTenant(tenantId, tenant, deviceId, PWD)\n+                .compose(ok -> {\n+\n+                    // WHEN the device tries to upload a telemetry message while there is no consumer for it\n+                    final MultiMap requestHeaders = MultiMap.caseInsensitiveMultiMap()\n+                            .add(HttpHeaders.CONTENT_TYPE, \"text/plain\")\n+                            .add(HttpHeaders.AUTHORIZATION, authorization);\n+\n+                    return httpClient.create(\n+                            getEndpointUri(),\n+                            Buffer.buffer(\"hello\"),\n+                            requestHeaders,\n+                            ResponsePredicate.status(HttpURLConnection.HTTP_UNAVAILABLE));\n+\n+                })\n+                // THEN the message gets rejected by the HTTP adapter with a 503\n+                .onComplete(ctx.succeeding(response -> {\n+                    ctx.verify(() -> {\n+                        assertThat(response.bodyAsString()).isEqualTo(\"temporarily unavailable\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwNjk0NA=="}, "originalCommit": {"oid": "c08d0695daca42fec9a1ccbc6474c0655087a0fa"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MDk1MjY0OnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/http/TelemetryHttpIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzowMDowMVrOHSi1RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzowMDowMVrOHSi1RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwNzEwOQ==", "bodyText": "same here", "url": "https://github.com/eclipse/hono/pull/2179#discussion_r489207109", "createdAt": "2020-09-16T07:00:01Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/http/TelemetryHttpIT.java", "diffHunk": "@@ -125,4 +127,102 @@ public void testUploadMessageFailsForLargePayload(final VertxTestContext ctx) {\n             // THEN the message gets rejected by the HTTP adapter with a 413\n             .onComplete(ctx.completing());\n     }\n+\n+    /**\n+     * Verifies that the upload of a telemetry message fails with a 503 status code\n+     * when there is no consumer.\n+     *\n+     * @param ctx The test context\n+     */\n+    @Test\n+    public void testUploadMessageFailsForNoConsumer(final VertxTestContext ctx) {\n+\n+        // GIVEN a device\n+        final Tenant tenant = new Tenant();\n+\n+        helper.registry\n+                .addDeviceForTenant(tenantId, tenant, deviceId, PWD)\n+                .compose(ok -> {\n+\n+                    // WHEN the device tries to upload a telemetry message while there is no consumer for it\n+                    final MultiMap requestHeaders = MultiMap.caseInsensitiveMultiMap()\n+                            .add(HttpHeaders.CONTENT_TYPE, \"text/plain\")\n+                            .add(HttpHeaders.AUTHORIZATION, authorization);\n+\n+                    return httpClient.create(\n+                            getEndpointUri(),\n+                            Buffer.buffer(\"hello\"),\n+                            requestHeaders,\n+                            ResponsePredicate.status(HttpURLConnection.HTTP_UNAVAILABLE));\n+\n+                })\n+                // THEN the message gets rejected by the HTTP adapter with a 503\n+                .onComplete(ctx.succeeding(response -> {\n+                    ctx.verify(() -> {\n+                        assertThat(response.bodyAsString()).isEqualTo(\"temporarily unavailable\");\n+                    });\n+                    ctx.completeNow();\n+                }));\n+    }\n+\n+    /**\n+     * Verifies that the upload of a QoS 1 telemetry message fails with a 503 status code\n+     * when the consumer doesn't update the message delivery state and the\n+     * <em>sendMessageTimeout</em> has elapsed.\n+     *\n+     * @param ctx The test context\n+     * @throws InterruptedException if test is interrupted while running.\n+     */\n+    @Test\n+    public void testUploadQos1MessageFailsIfDeliveryStateNotUpdated(final VertxTestContext ctx)\n+            throws InterruptedException {\n+\n+        // GIVEN a device and a northbound message consumer that doesn't update the message delivery state\n+        final Tenant tenant = new Tenant();\n+        final Checkpoint messageReceived = ctx.checkpoint();\n+        final Checkpoint httpResponseReceived = ctx.checkpoint();\n+\n+        final VertxTestContext setup = new VertxTestContext();\n+        final Checkpoint setupDone = setup.checkpoint();\n+        helper.registry\n+                .addDeviceForTenant(tenantId, tenant, deviceId, PWD)\n+                .compose(ok -> helper.applicationClientFactory.createTelemetryConsumer(\n+                        tenantId, \n+                        (delivery, msg) -> {\n+                            logger.debug(\"received {}\", msg);\n+                            messageReceived.flag();\n+                            // don't update the delivery state here\n+                        },\n+                        false, \n+                        remoteClose -> {}))\n+                .onComplete(setup.succeeding(v -> setupDone.flag()));\n+\n+        assertThat(setup.awaitCompletion(helper.getTestSetupTimeout(), TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN the device tries to upload a telemetry message\n+        final MultiMap requestHeaders = MultiMap.caseInsensitiveMultiMap()\n+                .add(HttpHeaders.CONTENT_TYPE, \"binary/octet-stream\")\n+                .add(HttpHeaders.AUTHORIZATION, authorization)\n+                .add(HttpHeaders.ORIGIN, ORIGIN_URI)\n+                .add(Constants.HEADER_QOS_LEVEL, \"1\");\n+\n+        // THEN the message gets rejected by the HTTP adapter with a 503\n+        final Future<HttpResponse<Buffer>> httpResponseFuture = httpClient.create(\n+                getEndpointUri(),\n+                Buffer.buffer(\"hello\"),\n+                requestHeaders,\n+                ResponsePredicate.status(HttpURLConnection.HTTP_UNAVAILABLE));\n+\n+        httpResponseFuture\n+                .onComplete(ctx.succeeding(response -> {\n+                    ctx.verify(() -> {\n+                        assertThat(response.bodyAsString()).isEqualTo(\"temporarily unavailable\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c08d0695daca42fec9a1ccbc6474c0655087a0fa"}, "originalPosition": 107}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3056, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}