{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0ODEyNzY3", "number": 2138, "title": "[#2112] Add integration tests for search devices operation", "bodyText": "This should be merged after #2136", "createdAt": "2020-08-27T16:23:31Z", "url": "https://github.com/eclipse/hono/pull/2138", "merged": true, "mergeCommit": {"oid": "3748f18e864767291235e9c32fa80a5d3be928c4"}, "closed": true, "closedAt": "2020-09-03T15:43:31Z", "author": {"login": "kaniyan"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdDQv9AABqjM3MDI5MzAzNzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdFSis1gFqTQ4MTk2OTg4MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5c92aae09db41a72b23c1db9071f797752be7da2", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/5c92aae09db41a72b23c1db9071f797752be7da2", "committedDate": "2020-08-27T16:20:12Z", "message": "[#2112] Add integration tests for search devices operation\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}, "afterCommit": {"oid": "845fc62c799551ebb4e7e83b308ac0c800c840a3", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/845fc62c799551ebb4e7e83b308ac0c800c840a3", "committedDate": "2020-08-28T08:29:26Z", "message": "[#2112] Add integration tests for search devices operation\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5NDcxMjM5", "url": "https://github.com/eclipse/hono/pull/2138#pullrequestreview-479471239", "createdAt": "2020-09-01T07:32:01Z", "commit": {"oid": "845fc62c799551ebb4e7e83b308ac0c800c840a3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzozMjowMVrOHKpE2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzozMjowMVrOHKpE2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkyMDc5NQ==", "bodyText": "can we use the simple parameter types? I do not see why we need to use Optionals here. There is certainly no problem with providing a page size and an offset and empty lists, if no filters nor sort options are used, right?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r480920795", "createdAt": "2020-09-01T07:32:01Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/DeviceRegistryHttpClient.java", "diffHunk": "@@ -532,6 +542,45 @@ private static String registrationWithoutIdUri(final String tenant) {\n         return httpClient.delete(requestUri, status -> status == HttpURLConnection.HTTP_NO_CONTENT);\n     }\n \n+    /**\n+     * Finds devices belonging to the given tenant with optional filters, paging and sorting options.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param pageSize The maximum number of results to include in a response.\n+     * @param pageOffset The offset into the result set from which to include objects in the response.\n+     * @param filters The filters are predicates that objects in the result set must match.\n+     * @param sortOptions A list of sort options.\n+     * @param expectedStatus The status code indicating a successful outcome.\n+     * @return A future indicating the outcome of the operation. The future will contain the response payload\n+     *         if the request succeeded. Otherwise the future will fail with a \n+     *         {@link org.eclipse.hono.client.ServiceInvocationException}.\n+     * @throws NullPointerException if the tenant is {@code null}.\n+     */\n+    public Future<Buffer> searchDevices(\n+            final String tenantId,\n+            final Optional<Integer> pageSize,\n+            final Optional<Integer> pageOffset,\n+            final Optional<List<String>> filters,\n+            final Optional<List<String>> sortOptions,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845fc62c799551ebb4e7e83b308ac0c800c840a3"}, "originalPosition": 47}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "845fc62c799551ebb4e7e83b308ac0c800c840a3", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/845fc62c799551ebb4e7e83b308ac0c800c840a3", "committedDate": "2020-08-28T08:29:26Z", "message": "[#2112] Add integration tests for search devices operation\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}, "afterCommit": {"oid": "dec1f16371bf4fcad58cee306475f1a3c2a96f93", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/dec1f16371bf4fcad58cee306475f1a3c2a96f93", "committedDate": "2020-09-01T14:16:21Z", "message": "Changes related to review comments\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dec1f16371bf4fcad58cee306475f1a3c2a96f93", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/dec1f16371bf4fcad58cee306475f1a3c2a96f93", "committedDate": "2020-09-01T14:16:21Z", "message": "Changes related to review comments\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}, "afterCommit": {"oid": "f951a077e1fbc1806a332c0c23d0a4fdc1fed7c7", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/f951a077e1fbc1806a332c0c23d0a4fdc1fed7c7", "committedDate": "2020-09-01T15:19:29Z", "message": "Changes related to review comments and rebase due to PR#2142\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f951a077e1fbc1806a332c0c23d0a4fdc1fed7c7", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/f951a077e1fbc1806a332c0c23d0a4fdc1fed7c7", "committedDate": "2020-09-01T15:19:29Z", "message": "Changes related to review comments and rebase due to PR#2142\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}, "afterCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/f92c3f68cd920bda3d26282f942c46300e984c0b", "committedDate": "2020-09-01T15:35:53Z", "message": "[#2112] Add integration tests for search devices operation\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwNTUzMTE5", "url": "https://github.com/eclipse/hono/pull/2138#pullrequestreview-480553119", "createdAt": "2020-09-02T07:29:15Z", "commit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzoyOToxNVrOHLgozw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzo0MTo0MFrOHLhSAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzMTExOQ==", "bodyText": "maybe we can keep the name of this feature flag in line with the other two flags that we already use?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481831119", "createdAt": "2020-09-02T07:29:15Z", "author": {"login": "sophokles73"}, "path": "tests/pom.xml", "diffHunk": "@@ -43,6 +43,8 @@ Test cases are run against Docker images of Hono server + (Apache Qpid Dispatch\n     <!-- should be set to false if testing against a registry that doesn't support GW mode -->\n     <deviceregistry.supportsGatewayMode>true</deviceregistry.supportsGatewayMode>\n     <deviceregistry.credentials.supportsClientContext>true</deviceregistry.credentials.supportsClientContext>\n+    <!-- should be set to true if testing against a registry that supports search devices operation -->\n+    <hono.deviceregistry.supportsSearchDevices>false</hono.deviceregistry.supportsSearchDevices>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNDExMQ==", "bodyText": "well, the idea here is to make all parameters mandatory, right?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481834111", "createdAt": "2020-09-02T07:32:42Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/DeviceRegistryHttpClient.java", "diffHunk": "@@ -577,6 +587,49 @@ private static String registrationWithoutIdUri(final String tenant) {\n                 ResponsePredicate.status(expectedStatus));\n     }\n \n+    /**\n+     * Finds devices belonging to the given tenant with optional filters, paging and sorting options.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param pageSize The maximum number of results to include in a response.\n+     * @param pageOffset The offset into the result set from which to include objects in the response.\n+     * @param filters The filters are predicates that objects in the result set must match.\n+     * @param sortOptions A list of sort options.\n+     * @param expectedStatusCode The status code indicating a successful outcome.\n+     * @return A future indicating the outcome of the operation. The future will contain the response if the\n+     *         response contained the expected status code. Otherwise the future will fail.\n+     * @throws NullPointerException if the tenant is {@code null}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNDQ0NA==", "bodyText": "missing null checks", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481834444", "createdAt": "2020-09-02T07:33:05Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/DeviceRegistryHttpClient.java", "diffHunk": "@@ -577,6 +587,49 @@ private static String registrationWithoutIdUri(final String tenant) {\n                 ResponsePredicate.status(expectedStatus));\n     }\n \n+    /**\n+     * Finds devices belonging to the given tenant with optional filters, paging and sorting options.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param pageSize The maximum number of results to include in a response.\n+     * @param pageOffset The offset into the result set from which to include objects in the response.\n+     * @param filters The filters are predicates that objects in the result set must match.\n+     * @param sortOptions A list of sort options.\n+     * @param expectedStatusCode The status code indicating a successful outcome.\n+     * @return A future indicating the outcome of the operation. The future will contain the response if the\n+     *         response contained the expected status code. Otherwise the future will fail.\n+     * @throws NullPointerException if the tenant is {@code null}.\n+     */\n+    public Future<HttpResponse<Buffer>> searchDevices(\n+            final String tenantId,\n+            final Optional<Integer> pageSize,\n+            final Optional<Integer> pageOffset,\n+            final List<String> filters,\n+            final List<String> sortOptions,\n+            final int expectedStatusCode) {\n+\n+        Objects.requireNonNull(tenantId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNjQyNQ==", "bodyText": "does what?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481836425", "createdAt": "2020-09-02T07:35:28Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNjgwNA==", "bodyText": "...WithValidPageSizeSucceeds?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481836804", "createdAt": "2020-09-02T07:35:52Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzYyNw==", "bodyText": "how about also asserting the overall result set size?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481837627", "createdAt": "2020-09-02T07:36:50Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzkwOQ==", "bodyText": "does what?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481837909", "createdAt": "2020-09-02T07:37:12Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageOffset(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page offset.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzOTA4Ng==", "bodyText": "Multiple", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481839086", "createdAt": "2020-09-02T07:38:40Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageOffset(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageOffset(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            null, List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+\n+                            final JsonObject deviceObject = response.getJsonObject(0);\n+                            assertThat(deviceObject.getString(\"id\")).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when filterJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidFilterJson(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(\"Invalid filterJson\"), null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with multiple filters succeeds and matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithMutlipleFilters(final VertxTestContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg0MDAwNw==", "bodyText": "how about adding a step verifying that a combination of other filters actually yields a result?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481840007", "createdAt": "2020-09-02T07:39:49Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageOffset(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageOffset(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            null, List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+\n+                            final JsonObject deviceObject = response.getJsonObject(0);\n+                            assertThat(deviceObject.getString(\"id\")).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when filterJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidFilterJson(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(\"Invalid filterJson\"), null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with multiple filters succeeds and matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithMutlipleFilters(final VertxTestContext ctx) {\n+            final Device device1 = new Device().setEnabled(false).setExtensions(Map.of(\"id\", \"1\"));\n+            final Device device2 = new Device().setEnabled(true).setExtensions(Map.of(\"id\", \"2\"));\n+            final String filterJson1 = getFilterJson(\"/ext/id\", \"1\", \"eq\");\n+            final String filterJson2 = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, device1), registry.registerDevice(tenantId, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson2), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg0MTY2Ng==", "bodyText": "how about also checking position 1?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481841666", "createdAt": "2020-09-02T07:41:40Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageOffset(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageOffset(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            null, List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+\n+                            final JsonObject deviceObject = response.getJsonObject(0);\n+                            assertThat(deviceObject.getString(\"id\")).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when filterJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidFilterJson(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(\"Invalid filterJson\"), null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with multiple filters succeeds and matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithMutlipleFilters(final VertxTestContext ctx) {\n+            final Device device1 = new Device().setEnabled(false).setExtensions(Map.of(\"id\", \"1\"));\n+            final Device device2 = new Device().setEnabled(true).setExtensions(Map.of(\"id\", \"2\"));\n+            final String filterJson1 = getFilterJson(\"/ext/id\", \"1\", \"eq\");\n+            final String filterJson2 = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, device1), registry.registerDevice(tenantId, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson2), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when sortJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidSortJson(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(), null,\n+                            List.of(\"Invalid sortJson\"), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid sort option succeeds and the result is sorted accordingly.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithSortOption(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(), null,\n+                            List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(2);\n+\n+                            final JsonObject deviceObject = response.getJsonObject(0);\n+                            assertThat(deviceObject.getString(\"id\")).isEqualTo(deviceId2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 212}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/f92c3f68cd920bda3d26282f942c46300e984c0b", "committedDate": "2020-09-01T15:35:53Z", "message": "[#2112] Add integration tests for search devices operation\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}, "afterCommit": {"oid": "8d0862922fcbf8f51380f7b4c6fa0ed4453942f6", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/8d0862922fcbf8f51380f7b4c6fa0ed4453942f6", "committedDate": "2020-09-02T08:43:13Z", "message": "Changes based on review comments\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwNzI3NDE2", "url": "https://github.com/eclipse/hono/pull/2138#pullrequestreview-480727416", "createdAt": "2020-09-02T11:29:29Z", "commit": {"oid": "8d0862922fcbf8f51380f7b4c6fa0ed4453942f6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMToyOToyOVrOHLq0RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxMToyOToyOVrOHLq0RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk5Nzg5Mg==", "bodyText": "well, you have registered two devices and the first page of the search result contains the first match (page size = 1). However, the overall result set size should be 2 because you haven't specified any search criteria, right? So we could also check the total property in the response body. But wait a second, it looks like the response body currently doesn't contain the total and result properties but instead only contains the result set as a JSON array. IMHO this is currently not compliant with the spec ...", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481997892", "createdAt": "2020-09-02T11:29:29Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzYyNw=="}, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 91}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "275e8d9b2066e0e2d4ed28db5267e3b7c61441d2", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/275e8d9b2066e0e2d4ed28db5267e3b7c61441d2", "committedDate": "2020-09-03T13:39:48Z", "message": "[#2112] Add integration tests for search devices operation\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f48fe68ec5aade35775992b7cf089c6b0402c9f7", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/f48fe68ec5aade35775992b7cf089c6b0402c9f7", "committedDate": "2020-09-03T13:39:48Z", "message": "Changes based on review comments\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00692ee0f93fbfc8ba22625f80914de1f6229f5a", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/00692ee0f93fbfc8ba22625f80914de1f6229f5a", "committedDate": "2020-09-03T13:39:48Z", "message": "Changes with respect to PR #2150 (fix search devices result)\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8d0862922fcbf8f51380f7b4c6fa0ed4453942f6", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/8d0862922fcbf8f51380f7b4c6fa0ed4453942f6", "committedDate": "2020-09-02T08:43:13Z", "message": "Changes based on review comments\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}, "afterCommit": {"oid": "00692ee0f93fbfc8ba22625f80914de1f6229f5a", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/00692ee0f93fbfc8ba22625f80914de1f6229f5a", "committedDate": "2020-09-03T13:39:48Z", "message": "Changes with respect to PR #2150 (fix search devices result)\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxODcyNzI2", "url": "https://github.com/eclipse/hono/pull/2138#pullrequestreview-481872726", "createdAt": "2020-09-03T14:04:24Z", "commit": {"oid": "00692ee0f93fbfc8ba22625f80914de1f6229f5a"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDowNDoyNFrOHMoMOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDowNTozOVrOHMoQJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwMzQ1MA==", "bodyText": "httpResponse.bodyAsJson(SearchDeviceResult.class)?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r483003450", "createdAt": "2020-09-03T14:04:24Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -420,6 +427,243 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageSizeFails(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with pageSize succeeds and the result is in accordance\n+         * with the specified page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageSizeSucceeds(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), List.of(),\n+                            List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00692ee0f93fbfc8ba22625f80914de1f6229f5a"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwNDEwMA==", "bodyText": "httpResponse.bodyAsJson(SearchDeviceResult.class)?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r483004100", "createdAt": "2020-09-03T14:05:13Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -420,6 +427,243 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageSizeFails(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with pageSize succeeds and the result is in accordance\n+         * with the specified page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageSizeSucceeds(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), List.of(),\n+                            List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(2);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageOffsetFails(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with page offset succeeds and the result is in accordance with\n+         * the specified page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageOffsetSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            List.of(), List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00692ee0f93fbfc8ba22625f80914de1f6229f5a"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwNDI4OQ==", "bodyText": "httpResponse.bodyAsJson(SearchDeviceResult.class)?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r483004289", "createdAt": "2020-09-03T14:05:27Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -420,6 +427,243 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageSizeFails(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with pageSize succeeds and the result is in accordance\n+         * with the specified page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageSizeSucceeds(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), List.of(),\n+                            List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(2);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageOffsetFails(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with page offset succeeds and the result is in accordance with\n+         * the specified page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageOffsetSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            List.of(), List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(2);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                            assertThat(searchDevicesResult.getResult().get(0).getId()).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when filterJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidFilterJsonFails(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(\"Invalid filterJson\"), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with multiple filters succeeds and matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidMultipleFiltersSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setEnabled(false).setExtensions(Map.of(\"id\", \"1\"));\n+            final Device device2 = new Device().setEnabled(true).setExtensions(Map.of(\"id\", \"2\"));\n+            final String filterJson1 = getFilterJson(\"/ext/id\", \"1\", \"eq\");\n+            final String filterJson2 = getFilterJson(\"/enabled\", true, \"eq\");\n+            final String filterJson3 = getFilterJson(\"/enabled\", false, \"eq\");\n+\n+            CompositeFuture\n+                    .all(registry.registerDevice(tenantId, deviceId1, device1),\n+                            registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson2), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson3), List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00692ee0f93fbfc8ba22625f80914de1f6229f5a"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwNDQ1NQ==", "bodyText": "httpResponse.bodyAsJson(SearchDeviceResult.class)?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r483004455", "createdAt": "2020-09-03T14:05:39Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -420,6 +427,243 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageSizeFails(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with pageSize succeeds and the result is in accordance\n+         * with the specified page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageSizeSucceeds(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), List.of(),\n+                            List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(2);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageOffsetFails(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with page offset succeeds and the result is in accordance with\n+         * the specified page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageOffsetSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            List.of(), List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(2);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                            assertThat(searchDevicesResult.getResult().get(0).getId()).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when filterJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidFilterJsonFails(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(\"Invalid filterJson\"), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with multiple filters succeeds and matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidMultipleFiltersSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setEnabled(false).setExtensions(Map.of(\"id\", \"1\"));\n+            final Device device2 = new Device().setEnabled(true).setExtensions(Map.of(\"id\", \"2\"));\n+            final String filterJson1 = getFilterJson(\"/ext/id\", \"1\", \"eq\");\n+            final String filterJson2 = getFilterJson(\"/enabled\", true, \"eq\");\n+            final String filterJson3 = getFilterJson(\"/enabled\", false, \"eq\");\n+\n+            CompositeFuture\n+                    .all(registry.registerDevice(tenantId, deviceId1, device1),\n+                            registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson2), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson3), List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(1);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                            assertThat(searchDevicesResult.getResult().get(0).getId()).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when sortJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidSortJsonFails(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(), List.of(),\n+                            List.of(\"Invalid sortJson\"), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid sort option succeeds and the result is sorted\n+         * accordingly.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidSortOptionSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(), List.of(),\n+                            List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00692ee0f93fbfc8ba22625f80914de1f6229f5a"}, "originalPosition": 241}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a2504733c6d43b3bd5bb9e70928bb25d4ca5399", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/3a2504733c6d43b3bd5bb9e70928bb25d4ca5399", "committedDate": "2020-09-03T14:25:00Z", "message": "Use httpResponse.bodyAsJson(...) to map the body from http response.\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxOTY5ODgw", "url": "https://github.com/eclipse/hono/pull/2138#pullrequestreview-481969880", "createdAt": "2020-09-03T15:43:03Z", "commit": {"oid": "3a2504733c6d43b3bd5bb9e70928bb25d4ca5399"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 534, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}