{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwMDk1MTI4", "number": 2094, "reviewThreads": {"totalCount": 62, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMzo1MDowMVrOEUnPuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwODo1NDozMFrOFFeKHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMDQ5OTc2OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMzo1MDowMVrOG66TBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMzo1MDowMVrOG66TBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQyNTczNA==", "bodyText": "FMPOV this should be a set ... and can we rename the field to authorities? Permissions are usually granted on a particular subject like you have permission READ on field address ...", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r464425734", "createdAt": "2020-08-03T13:50:01Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -68,6 +68,11 @@\n     @JsonProperty(RegistryManagementConstants.FIELD_MAPPER)\n     private String mapper;\n \n+    @JsonProperty(RegistryManagementConstants.PERMISSIONS)\n+    @JsonInclude(value = Include.NON_EMPTY)\n+    @JsonFormat(with = JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)\n+    private List<String> permissions = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49c1080d0b757b5f6992eec8aad7c564a83d1c73"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMDUwOTgzOnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMzo1MjoyOVrOG66ZCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMzo1MjoyOVrOG66ZCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQyNzI3Mw==", "bodyText": "I'd rather not allow for this variability. We define this as a JSON array of strings and that's it. No ambiguity there, right?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r464427273", "createdAt": "2020-08-03T13:52:29Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -68,6 +68,11 @@\n     @JsonProperty(RegistryManagementConstants.FIELD_MAPPER)\n     private String mapper;\n \n+    @JsonProperty(RegistryManagementConstants.PERMISSIONS)\n+    @JsonInclude(value = Include.NON_EMPTY)\n+    @JsonFormat(with = JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49c1080d0b757b5f6992eec8aad7c564a83d1c73"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMDUyOTg5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxMzo1NzoyOVrOG66lRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwODozMjoxOFrOG7WkbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQzMDQwNw==", "bodyText": "how about adding an addEdgeDevice() method to AbstractRegistrationService instead? Subclasses can then either directly implement the logic to add the record to the persistent store or delegate to an existing collaborator.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r464430407", "createdAt": "2020-08-03T13:57:29Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -194,7 +213,36 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasPermissionForAutoRegistration(gatewayResult)) {\n+\n+                                    if (deviceBackend == null) {\n+                                        LOG.warn(\"cannot auto-provision device - no backend set\");\n+                                        return Future.succeededFuture(RegistrationResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                                    }\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistrationConstants.FIELD_MEMBER_OF);\n+                                    if (memberOf != null && !memberOf.isEmpty()) {\n+                                        device.setViaGroups(memberOf.getList());\n+                                    }\n+\n+                                    LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);\n+                                    return deviceBackend.createDevice(tenantId, Optional.ofNullable(deviceId), device, span)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49c1080d0b757b5f6992eec8aad7c564a83d1c73"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg4ODk0MA==", "bodyText": "Yes that makes sense, especially since MongoDbBasedRegistrationService actually takes the direct implementation route...", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r464888940", "createdAt": "2020-08-04T08:32:18Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -194,7 +213,36 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasPermissionForAutoRegistration(gatewayResult)) {\n+\n+                                    if (deviceBackend == null) {\n+                                        LOG.warn(\"cannot auto-provision device - no backend set\");\n+                                        return Future.succeededFuture(RegistrationResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                                    }\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistrationConstants.FIELD_MEMBER_OF);\n+                                    if (memberOf != null && !memberOf.isEmpty()) {\n+                                        device.setViaGroups(memberOf.getList());\n+                                    }\n+\n+                                    LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);\n+                                    return deviceBackend.createDevice(tenantId, Optional.ofNullable(deviceId), device, span)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQzMDQwNw=="}, "originalCommit": {"oid": "49c1080d0b757b5f6992eec8aad7c564a83d1c73"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMzEyMjg1OnYy", "diffSide": "RIGHT", "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractProtocolAdapterBase.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwNjozMDo1NFrOG7S3KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwNjozMDo1NFrOG7S3KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgyODIwMA==", "bodyText": "we should add the value from the context, shouldn't we?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r464828200", "createdAt": "2020-08-04T06:30:54Z", "author": {"login": "sophokles73"}, "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractProtocolAdapterBase.java", "diffHunk": "@@ -1651,4 +1700,34 @@ public final ConnectionLimitManager getConnectionLimitManager() {\n     public final void setConnectionLimitManager(final ConnectionLimitManager connectionLimitManager) {\n         this.connectionLimitManager = connectionLimitManager;\n     }\n+\n+    private boolean wasAutoProvisioned(final JsonObject registrationInfo) {\n+        if (registrationInfo != null) {\n+            final JsonObject deviceDefaults = registrationInfo.getJsonObject(RequestResponseApiConstants.FIELD_PAYLOAD_DEFAULTS);\n+            if (deviceDefaults != null) {\n+                final String registrationStatus = deviceDefaults.getString(RegistrationConstants.REGISTRATION_STATUS.KEY);\n+                if (RegistrationConstants.REGISTRATION_STATUS.NEW.name().equalsIgnoreCase(registrationStatus)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Adds auto-provisioning application properties to the given message, if present in the given context.\n+     *\n+     * @param msg The message for which the application properties shall be set.\n+     * @param context The context containing the properties set in the processing of the auto-provisionoing.\n+     */\n+    protected void addAutoProvisioningProperties(final Message msg, final ExecutionContext context) {\n+        if (context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID, null) != null) {\n+            MessageHelper.addProperty(msg, MessageHelper.APP_PROPERTY_GATEWAY_ID, context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID));\n+        }\n+\n+        if (context.get(RegistrationConstants.REGISTRATION_STATUS.KEY, null) != null) {\n+            MessageHelper.addProperty(msg, RegistrationConstants.REGISTRATION_STATUS.KEY, RegistrationConstants.REGISTRATION_STATUS.NEW.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49c1080d0b757b5f6992eec8aad7c564a83d1c73"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODY2OTQ5OnYy", "diffSide": "RIGHT", "path": "adapters/mqtt-vertx-base/src/main/java/org/eclipse/hono/adapter/mqtt/impl/VertxBasedMqttProtocolAdapter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMjozMjowN1rOG8HjmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDoxMToxM1rOICMtBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MTU0NA==", "bodyText": "at this point we verify the registration status of the gateway itself. There is no need to handle auto provisioning as the device ID is the same as the authenticated (gateway) ID. In fact, the device ID is unknown at this point in time and will be (finally) established after the mapper has been invoked.\nThe auto provisioning will be handled in the uploadMessage method ...", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r465691544", "createdAt": "2020-08-05T12:32:07Z", "author": {"login": "sophokles73"}, "path": "adapters/mqtt-vertx-base/src/main/java/org/eclipse/hono/adapter/mqtt/impl/VertxBasedMqttProtocolAdapter.java", "diffHunk": "@@ -102,10 +102,16 @@ public void setMessageMapping(final MessageMapping<MqttContext> messageMappingSe\n             final ResourceIdentifier targetAddress) {\n \n         return getRegistrationAssertion(\n-                targetAddress.getTenantId(),\n-                targetAddress.getResourceId(),\n-                ctx.authenticatedDevice(),\n-                ctx.getTracingContext())\n+                    targetAddress.getTenantId(),\n+                    targetAddress.getResourceId(),\n+                    ctx.authenticatedDevice(),\n+                    ctx.getTracingContext())\n+                .compose(handleAutoProvisioning(ctx,\n+                    ctx.endpoint(),\n+                    targetAddress.getTenantId(),\n+                    targetAddress.getResourceId(),\n+                    ctx.authenticatedDevice()\n+                ))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3046fb518d979acc553f6536f8651425947157"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3NjE5OQ==", "bodyText": "As auto-provisioning has been moved to the registration service completely, I guess this can be resolved?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539176199", "createdAt": "2020-12-09T10:11:13Z", "author": {"login": "fkaltner"}, "path": "adapters/mqtt-vertx-base/src/main/java/org/eclipse/hono/adapter/mqtt/impl/VertxBasedMqttProtocolAdapter.java", "diffHunk": "@@ -102,10 +102,16 @@ public void setMessageMapping(final MessageMapping<MqttContext> messageMappingSe\n             final ResourceIdentifier targetAddress) {\n \n         return getRegistrationAssertion(\n-                targetAddress.getTenantId(),\n-                targetAddress.getResourceId(),\n-                ctx.authenticatedDevice(),\n-                ctx.getTracingContext())\n+                    targetAddress.getTenantId(),\n+                    targetAddress.getResourceId(),\n+                    ctx.authenticatedDevice(),\n+                    ctx.getTracingContext())\n+                .compose(handleAutoProvisioning(ctx,\n+                    ctx.endpoint(),\n+                    targetAddress.getTenantId(),\n+                    targetAddress.getResourceId(),\n+                    ctx.authenticatedDevice()\n+                ))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MTU0NA=="}, "originalCommit": {"oid": "5a3046fb518d979acc553f6536f8651425947157"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwODY3Nzk5OnYy", "diffSide": "RIGHT", "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractProtocolAdapterBase.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMjozNDozNlrOG8Ho3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDowOToyMVrOICMoPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Mjg5Mg==", "bodyText": "so, in case of a telemetry message being used for auto-provisioning a device, the downstream application will receive two messages containing this property: the empty notification event and the telemetry message, right?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r465692892", "createdAt": "2020-08-05T12:34:36Z", "author": {"login": "sophokles73"}, "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractProtocolAdapterBase.java", "diffHunk": "@@ -1651,4 +1700,34 @@ public final ConnectionLimitManager getConnectionLimitManager() {\n     public final void setConnectionLimitManager(final ConnectionLimitManager connectionLimitManager) {\n         this.connectionLimitManager = connectionLimitManager;\n     }\n+\n+    private boolean wasAutoProvisioned(final JsonObject registrationInfo) {\n+        if (registrationInfo != null) {\n+            final JsonObject deviceDefaults = registrationInfo.getJsonObject(RequestResponseApiConstants.FIELD_PAYLOAD_DEFAULTS);\n+            if (deviceDefaults != null) {\n+                final String registrationStatus = deviceDefaults.getString(RegistrationConstants.REGISTRATION_STATUS.KEY);\n+                if (RegistrationConstants.REGISTRATION_STATUS.NEW.name().equalsIgnoreCase(registrationStatus)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Adds auto-provisioning application properties to the given message, if present in the given context.\n+     *\n+     * @param msg The message for which the application properties shall be set.\n+     * @param context The context containing the properties set in the processing of the auto-provisionoing.\n+     */\n+    protected void addAutoProvisioningProperties(final Message msg, final ExecutionContext context) {\n+        if (context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID, null) != null) {\n+            MessageHelper.addProperty(msg, MessageHelper.APP_PROPERTY_GATEWAY_ID, context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID));\n+        }\n+\n+        if (context.get(RegistrationConstants.REGISTRATION_STATUS.KEY, null) != null) {\n+            MessageHelper.addProperty(msg, RegistrationConstants.REGISTRATION_STATUS.KEY, context.get(RegistrationConstants.REGISTRATION_STATUS.KEY));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3046fb518d979acc553f6536f8651425947157"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5NjI2NQ==", "bodyText": "Yes, that is correct.\nAfter a second thought: I guess setting the property in the telemetry message might be redundant since an application should always act upon an event with that property, since the event will be delivered at least once.\nSo I tend to not set the property for the telemetry message. WDYT?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r465696265", "createdAt": "2020-08-05T12:40:19Z", "author": {"login": "fkaltner"}, "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractProtocolAdapterBase.java", "diffHunk": "@@ -1651,4 +1700,34 @@ public final ConnectionLimitManager getConnectionLimitManager() {\n     public final void setConnectionLimitManager(final ConnectionLimitManager connectionLimitManager) {\n         this.connectionLimitManager = connectionLimitManager;\n     }\n+\n+    private boolean wasAutoProvisioned(final JsonObject registrationInfo) {\n+        if (registrationInfo != null) {\n+            final JsonObject deviceDefaults = registrationInfo.getJsonObject(RequestResponseApiConstants.FIELD_PAYLOAD_DEFAULTS);\n+            if (deviceDefaults != null) {\n+                final String registrationStatus = deviceDefaults.getString(RegistrationConstants.REGISTRATION_STATUS.KEY);\n+                if (RegistrationConstants.REGISTRATION_STATUS.NEW.name().equalsIgnoreCase(registrationStatus)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Adds auto-provisioning application properties to the given message, if present in the given context.\n+     *\n+     * @param msg The message for which the application properties shall be set.\n+     * @param context The context containing the properties set in the processing of the auto-provisionoing.\n+     */\n+    protected void addAutoProvisioningProperties(final Message msg, final ExecutionContext context) {\n+        if (context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID, null) != null) {\n+            MessageHelper.addProperty(msg, MessageHelper.APP_PROPERTY_GATEWAY_ID, context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID));\n+        }\n+\n+        if (context.get(RegistrationConstants.REGISTRATION_STATUS.KEY, null) != null) {\n+            MessageHelper.addProperty(msg, RegistrationConstants.REGISTRATION_STATUS.KEY, context.get(RegistrationConstants.REGISTRATION_STATUS.KEY));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Mjg5Mg=="}, "originalCommit": {"oid": "5a3046fb518d979acc553f6536f8651425947157"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcyODMwMA==", "bodyText": "I am afraid that the whole mechanism as currently devised is not very robust. For example, if the connection between the adapter and the registry fails after the device has been provisioned but before the response message containing the registration info has reached the adapter, then the downstream application (Ditto) will not be notified about the newly provisioned device. However, subsequent requests from the gateway on behalf of the device will not trigger auto-provisioning again because the device now exists in the registry. Thus, Ditto will effectively never be notified about the new device.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r465728300", "createdAt": "2020-08-05T13:31:41Z", "author": {"login": "sophokles73"}, "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractProtocolAdapterBase.java", "diffHunk": "@@ -1651,4 +1700,34 @@ public final ConnectionLimitManager getConnectionLimitManager() {\n     public final void setConnectionLimitManager(final ConnectionLimitManager connectionLimitManager) {\n         this.connectionLimitManager = connectionLimitManager;\n     }\n+\n+    private boolean wasAutoProvisioned(final JsonObject registrationInfo) {\n+        if (registrationInfo != null) {\n+            final JsonObject deviceDefaults = registrationInfo.getJsonObject(RequestResponseApiConstants.FIELD_PAYLOAD_DEFAULTS);\n+            if (deviceDefaults != null) {\n+                final String registrationStatus = deviceDefaults.getString(RegistrationConstants.REGISTRATION_STATUS.KEY);\n+                if (RegistrationConstants.REGISTRATION_STATUS.NEW.name().equalsIgnoreCase(registrationStatus)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Adds auto-provisioning application properties to the given message, if present in the given context.\n+     *\n+     * @param msg The message for which the application properties shall be set.\n+     * @param context The context containing the properties set in the processing of the auto-provisionoing.\n+     */\n+    protected void addAutoProvisioningProperties(final Message msg, final ExecutionContext context) {\n+        if (context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID, null) != null) {\n+            MessageHelper.addProperty(msg, MessageHelper.APP_PROPERTY_GATEWAY_ID, context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID));\n+        }\n+\n+        if (context.get(RegistrationConstants.REGISTRATION_STATUS.KEY, null) != null) {\n+            MessageHelper.addProperty(msg, RegistrationConstants.REGISTRATION_STATUS.KEY, context.get(RegistrationConstants.REGISTRATION_STATUS.KEY));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Mjg5Mg=="}, "originalCommit": {"oid": "5a3046fb518d979acc553f6536f8651425947157"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc2OTYwMQ==", "bodyText": "Yes, that is a potential edge case.\nAn implementation without such edge cases would involve keeping persistent state as far as I can see. We could keep a flag in the Device Registry Service implementation which indicates if the registration event was already sent downstream.\nThe protocol adapters then would need to check that flag as well and send an event as long as it is set to \"pending delivery\". When the event was successfully delivered to the AMQP network, the protocol adapters may set that flag to \"delivered\" with another call to the Device Registry Service.\nHowever there may be still edge cases I guess, since the AMQP network \"ack\" is not an application-level \"ack\" - yet I think this should be sufficient.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r465769601", "createdAt": "2020-08-05T14:29:49Z", "author": {"login": "fkaltner"}, "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractProtocolAdapterBase.java", "diffHunk": "@@ -1651,4 +1700,34 @@ public final ConnectionLimitManager getConnectionLimitManager() {\n     public final void setConnectionLimitManager(final ConnectionLimitManager connectionLimitManager) {\n         this.connectionLimitManager = connectionLimitManager;\n     }\n+\n+    private boolean wasAutoProvisioned(final JsonObject registrationInfo) {\n+        if (registrationInfo != null) {\n+            final JsonObject deviceDefaults = registrationInfo.getJsonObject(RequestResponseApiConstants.FIELD_PAYLOAD_DEFAULTS);\n+            if (deviceDefaults != null) {\n+                final String registrationStatus = deviceDefaults.getString(RegistrationConstants.REGISTRATION_STATUS.KEY);\n+                if (RegistrationConstants.REGISTRATION_STATUS.NEW.name().equalsIgnoreCase(registrationStatus)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Adds auto-provisioning application properties to the given message, if present in the given context.\n+     *\n+     * @param msg The message for which the application properties shall be set.\n+     * @param context The context containing the properties set in the processing of the auto-provisionoing.\n+     */\n+    protected void addAutoProvisioningProperties(final Message msg, final ExecutionContext context) {\n+        if (context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID, null) != null) {\n+            MessageHelper.addProperty(msg, MessageHelper.APP_PROPERTY_GATEWAY_ID, context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID));\n+        }\n+\n+        if (context.get(RegistrationConstants.REGISTRATION_STATUS.KEY, null) != null) {\n+            MessageHelper.addProperty(msg, RegistrationConstants.REGISTRATION_STATUS.KEY, context.get(RegistrationConstants.REGISTRATION_STATUS.KEY));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Mjg5Mg=="}, "originalCommit": {"oid": "5a3046fb518d979acc553f6536f8651425947157"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc3NDU4NA==", "bodyText": "FMPOV all of this actually makes it more reasonable to let the registry emit the event that a device has been provisioned on-the-fly. We already follow that approach for auto-provisioning devices based on client certs, so this would actually be the more consistent approach anyway ...", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r465774584", "createdAt": "2020-08-05T14:36:52Z", "author": {"login": "sophokles73"}, "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractProtocolAdapterBase.java", "diffHunk": "@@ -1651,4 +1700,34 @@ public final ConnectionLimitManager getConnectionLimitManager() {\n     public final void setConnectionLimitManager(final ConnectionLimitManager connectionLimitManager) {\n         this.connectionLimitManager = connectionLimitManager;\n     }\n+\n+    private boolean wasAutoProvisioned(final JsonObject registrationInfo) {\n+        if (registrationInfo != null) {\n+            final JsonObject deviceDefaults = registrationInfo.getJsonObject(RequestResponseApiConstants.FIELD_PAYLOAD_DEFAULTS);\n+            if (deviceDefaults != null) {\n+                final String registrationStatus = deviceDefaults.getString(RegistrationConstants.REGISTRATION_STATUS.KEY);\n+                if (RegistrationConstants.REGISTRATION_STATUS.NEW.name().equalsIgnoreCase(registrationStatus)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Adds auto-provisioning application properties to the given message, if present in the given context.\n+     *\n+     * @param msg The message for which the application properties shall be set.\n+     * @param context The context containing the properties set in the processing of the auto-provisionoing.\n+     */\n+    protected void addAutoProvisioningProperties(final Message msg, final ExecutionContext context) {\n+        if (context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID, null) != null) {\n+            MessageHelper.addProperty(msg, MessageHelper.APP_PROPERTY_GATEWAY_ID, context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID));\n+        }\n+\n+        if (context.get(RegistrationConstants.REGISTRATION_STATUS.KEY, null) != null) {\n+            MessageHelper.addProperty(msg, RegistrationConstants.REGISTRATION_STATUS.KEY, context.get(RegistrationConstants.REGISTRATION_STATUS.KEY));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Mjg5Mg=="}, "originalCommit": {"oid": "5a3046fb518d979acc553f6536f8651425947157"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwMTI1NA==", "bodyText": "Maybe I missed something but I do not think that the device registry sends an event for auto-provisioning based on client certificates. It creates the device as well which is consistent with the implementation for gateway-based auto-provisioning.\nFrom the perspective of the device registries' responsibilities it makes sense to put it there - however there is one thing which the device registry does not know: was it an event or a telemetry message? (i.e. do I need to send an event or not)\nI found that rather odd to add a flag or the endpoint to the device registry's api since it doesn't have anything in common with device registration as far as I can see.\nOr did you have a different approach in mind?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r465801254", "createdAt": "2020-08-05T15:13:13Z", "author": {"login": "fkaltner"}, "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractProtocolAdapterBase.java", "diffHunk": "@@ -1651,4 +1700,34 @@ public final ConnectionLimitManager getConnectionLimitManager() {\n     public final void setConnectionLimitManager(final ConnectionLimitManager connectionLimitManager) {\n         this.connectionLimitManager = connectionLimitManager;\n     }\n+\n+    private boolean wasAutoProvisioned(final JsonObject registrationInfo) {\n+        if (registrationInfo != null) {\n+            final JsonObject deviceDefaults = registrationInfo.getJsonObject(RequestResponseApiConstants.FIELD_PAYLOAD_DEFAULTS);\n+            if (deviceDefaults != null) {\n+                final String registrationStatus = deviceDefaults.getString(RegistrationConstants.REGISTRATION_STATUS.KEY);\n+                if (RegistrationConstants.REGISTRATION_STATUS.NEW.name().equalsIgnoreCase(registrationStatus)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Adds auto-provisioning application properties to the given message, if present in the given context.\n+     *\n+     * @param msg The message for which the application properties shall be set.\n+     * @param context The context containing the properties set in the processing of the auto-provisionoing.\n+     */\n+    protected void addAutoProvisioningProperties(final Message msg, final ExecutionContext context) {\n+        if (context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID, null) != null) {\n+            MessageHelper.addProperty(msg, MessageHelper.APP_PROPERTY_GATEWAY_ID, context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID));\n+        }\n+\n+        if (context.get(RegistrationConstants.REGISTRATION_STATUS.KEY, null) != null) {\n+            MessageHelper.addProperty(msg, RegistrationConstants.REGISTRATION_STATUS.KEY, context.get(RegistrationConstants.REGISTRATION_STATUS.KEY));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Mjg5Mg=="}, "originalCommit": {"oid": "5a3046fb518d979acc553f6536f8651425947157"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg0MzkyNg==", "bodyText": "Maybe I missed something but I do not think that the device registry sends an event for auto-provisioning based on client certificates. It creates the device as well which is consistent with the implementation for gateway-based auto-provisioning.\n\nOur example implementation (currently) doesn't, that's right. However, when we talked about how we wanted the client cert auto-provisioning to work, we agreed that it would be the responsibility of the registry implementation to notify other applications about the newly provisioned device. We left open how that should be done, but you can easily imagine that publishing an event would be a feasible option.\n\nFrom the perspective of the device registries' responsibilities it makes sense to put it there - however there is one thing which the device registry does not know: was it an event or a telemetry message? (i.e. do I need to send an event or not)\n\nIt doesn't need to because the registry would always publish an event indicating that the device has been provisioned while the protocol adapters would simply forward the telemetry message it received from the device as is.\n\nI found that rather odd to add a flag or the endpoint to the device registry's api since it doesn't have anything in common with device registration as far as I can see.\n\nIf the registry is responsible for emitting the event, there is no need to expose such a flag via its API.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r465843926", "createdAt": "2020-08-05T16:16:11Z", "author": {"login": "sophokles73"}, "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractProtocolAdapterBase.java", "diffHunk": "@@ -1651,4 +1700,34 @@ public final ConnectionLimitManager getConnectionLimitManager() {\n     public final void setConnectionLimitManager(final ConnectionLimitManager connectionLimitManager) {\n         this.connectionLimitManager = connectionLimitManager;\n     }\n+\n+    private boolean wasAutoProvisioned(final JsonObject registrationInfo) {\n+        if (registrationInfo != null) {\n+            final JsonObject deviceDefaults = registrationInfo.getJsonObject(RequestResponseApiConstants.FIELD_PAYLOAD_DEFAULTS);\n+            if (deviceDefaults != null) {\n+                final String registrationStatus = deviceDefaults.getString(RegistrationConstants.REGISTRATION_STATUS.KEY);\n+                if (RegistrationConstants.REGISTRATION_STATUS.NEW.name().equalsIgnoreCase(registrationStatus)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Adds auto-provisioning application properties to the given message, if present in the given context.\n+     *\n+     * @param msg The message for which the application properties shall be set.\n+     * @param context The context containing the properties set in the processing of the auto-provisionoing.\n+     */\n+    protected void addAutoProvisioningProperties(final Message msg, final ExecutionContext context) {\n+        if (context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID, null) != null) {\n+            MessageHelper.addProperty(msg, MessageHelper.APP_PROPERTY_GATEWAY_ID, context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID));\n+        }\n+\n+        if (context.get(RegistrationConstants.REGISTRATION_STATUS.KEY, null) != null) {\n+            MessageHelper.addProperty(msg, RegistrationConstants.REGISTRATION_STATUS.KEY, context.get(RegistrationConstants.REGISTRATION_STATUS.KEY));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Mjg5Mg=="}, "originalCommit": {"oid": "5a3046fb518d979acc553f6536f8651425947157"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3NDk3NQ==", "bodyText": "The implementation is now adapted so that it emits an empty event, so I guess this can be resolved?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539174975", "createdAt": "2020-12-09T10:09:21Z", "author": {"login": "fkaltner"}, "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractProtocolAdapterBase.java", "diffHunk": "@@ -1651,4 +1700,34 @@ public final ConnectionLimitManager getConnectionLimitManager() {\n     public final void setConnectionLimitManager(final ConnectionLimitManager connectionLimitManager) {\n         this.connectionLimitManager = connectionLimitManager;\n     }\n+\n+    private boolean wasAutoProvisioned(final JsonObject registrationInfo) {\n+        if (registrationInfo != null) {\n+            final JsonObject deviceDefaults = registrationInfo.getJsonObject(RequestResponseApiConstants.FIELD_PAYLOAD_DEFAULTS);\n+            if (deviceDefaults != null) {\n+                final String registrationStatus = deviceDefaults.getString(RegistrationConstants.REGISTRATION_STATUS.KEY);\n+                if (RegistrationConstants.REGISTRATION_STATUS.NEW.name().equalsIgnoreCase(registrationStatus)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Adds auto-provisioning application properties to the given message, if present in the given context.\n+     *\n+     * @param msg The message for which the application properties shall be set.\n+     * @param context The context containing the properties set in the processing of the auto-provisionoing.\n+     */\n+    protected void addAutoProvisioningProperties(final Message msg, final ExecutionContext context) {\n+        if (context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID, null) != null) {\n+            MessageHelper.addProperty(msg, MessageHelper.APP_PROPERTY_GATEWAY_ID, context.get(MessageHelper.APP_PROPERTY_GATEWAY_ID));\n+        }\n+\n+        if (context.get(RegistrationConstants.REGISTRATION_STATUS.KEY, null) != null) {\n+            MessageHelper.addProperty(msg, RegistrationConstants.REGISTRATION_STATUS.KEY, context.get(RegistrationConstants.REGISTRATION_STATUS.KEY));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5Mjg5Mg=="}, "originalCommit": {"oid": "5a3046fb518d979acc553f6536f8651425947157"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzMDg0NDIyOnYy", "diffSide": "RIGHT", "path": "tests/pom.xml", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwNzozMzo1NFrOG_VUXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMlQwOTowNTozMFrOG_Yg_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2Mjc1MQ==", "bodyText": "why do you think that we need these?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r469062751", "createdAt": "2020-08-12T07:33:54Z", "author": {"login": "sophokles73"}, "path": "tests/pom.xml", "diffHunk": "@@ -612,6 +615,9 @@ Test cases are run against Docker images of Hono server + (Apache Qpid Dispatch\n                     </assembly>\n                   </build>\n                   <run>\n+                    <dependsOn>\n+                      <container>artemis</container>\n+                    </dependsOn>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c3428022dd51f442b9304cbef37bec8d3a4d540"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA5MjgxMw==", "bodyText": "I ran into the problem that the device registry is started before the qdrouter which leads to the device registry startup failing (as it requires now a connection to the AMQP network) and consequently the integration tests fail.\nSince we use custom networks I thought this is the only option to define startup order:\n\nTo express start order dependencies using custom networks refer to the dependsOn configuration.\n\n(see http://dmp.fabric8.io/#start-depends-on)\nDid I miss something?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r469092813", "createdAt": "2020-08-12T08:27:19Z", "author": {"login": "fkaltner"}, "path": "tests/pom.xml", "diffHunk": "@@ -612,6 +615,9 @@ Test cases are run against Docker images of Hono server + (Apache Qpid Dispatch\n                     </assembly>\n                   </build>\n                   <run>\n+                    <dependsOn>\n+                      <container>artemis</container>\n+                    </dependsOn>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2Mjc1MQ=="}, "originalCommit": {"oid": "7c3428022dd51f442b9304cbef37bec8d3a4d540"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTEwMDgzNg==", "bodyText": "Also I think if we properly set all dependencies we could set <startParallel> to true which would make the integration tests run faster.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r469100836", "createdAt": "2020-08-12T08:41:20Z", "author": {"login": "fkaltner"}, "path": "tests/pom.xml", "diffHunk": "@@ -612,6 +615,9 @@ Test cases are run against Docker images of Hono server + (Apache Qpid Dispatch\n                     </assembly>\n                   </build>\n                   <run>\n+                    <dependsOn>\n+                      <container>artemis</container>\n+                    </dependsOn>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2Mjc1MQ=="}, "originalCommit": {"oid": "7c3428022dd51f442b9304cbef37bec8d3a4d540"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExMjk1MQ==", "bodyText": "The containers are started in the order that they are defined in the pom.xml. In order to start the registry after the router, simply move the router container definition before the registry's.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r469112951", "createdAt": "2020-08-12T09:01:25Z", "author": {"login": "sophokles73"}, "path": "tests/pom.xml", "diffHunk": "@@ -612,6 +615,9 @@ Test cases are run against Docker images of Hono server + (Apache Qpid Dispatch\n                     </assembly>\n                   </build>\n                   <run>\n+                    <dependsOn>\n+                      <container>artemis</container>\n+                    </dependsOn>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2Mjc1MQ=="}, "originalCommit": {"oid": "7c3428022dd51f442b9304cbef37bec8d3a4d540"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExNDI1Nw==", "bodyText": "Also I think if we properly set all dependencies we could set  to true which would make the integration tests run faster.\n\nWe did that at the beginning of our journey but quickly realized that it is close to impossible to understand the logs in case something goes wrong during startup. It also does not speed up the startup (on Travis) because the containers then compete for the (scarce) CPU resources and some containers may even fail to start up because they run into the configured timeout ...", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r469114257", "createdAt": "2020-08-12T09:03:52Z", "author": {"login": "sophokles73"}, "path": "tests/pom.xml", "diffHunk": "@@ -612,6 +615,9 @@ Test cases are run against Docker images of Hono server + (Apache Qpid Dispatch\n                     </assembly>\n                   </build>\n                   <run>\n+                    <dependsOn>\n+                      <container>artemis</container>\n+                    </dependsOn>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2Mjc1MQ=="}, "originalCommit": {"oid": "7c3428022dd51f442b9304cbef37bec8d3a4d540"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTExNTEzMw==", "bodyText": "Okay, thanks for clarification. I will change the order the POM then.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r469115133", "createdAt": "2020-08-12T09:05:30Z", "author": {"login": "fkaltner"}, "path": "tests/pom.xml", "diffHunk": "@@ -612,6 +615,9 @@ Test cases are run against Docker images of Hono server + (Apache Qpid Dispatch\n                     </assembly>\n                   </build>\n                   <run>\n+                    <dependsOn>\n+                      <container>artemis</container>\n+                    </dependsOn>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA2Mjc1MQ=="}, "originalCommit": {"oid": "7c3428022dd51f442b9304cbef37bec8d3a4d540"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjg0OTcxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/eclipse/hono/util/MessageHelper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDoyODo0OVrOHAOLvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNTowNDo0MVrOHBspmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NDQzMA==", "bodyText": "why don't we simply provide DeviceRegistry as the adapter type name and keep the null check?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r469994430", "createdAt": "2020-08-13T14:28:49Z", "author": {"login": "sophokles73"}, "path": "core/src/main/java/org/eclipse/hono/util/MessageHelper.java", "diffHunk": "@@ -1123,7 +1120,9 @@ public static Message addProperties(\n         setCreationTime(msg);\n         msg.setAddress(ri.getBasePath());\n         addDeviceId(msg, ri.getResourceId());\n-        addProperty(msg, MessageHelper.APP_PROPERTY_ORIG_ADAPTER, adapterTypeName);\n+        if (adapterTypeName != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61e3955b9389002312011209fb46a90db8bd1161"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU0MjE2OQ==", "bodyText": "It's not really an adapter then but I guess it is worth the trade-off to keep the null check.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r471542169", "createdAt": "2020-08-17T15:04:41Z", "author": {"login": "fkaltner"}, "path": "core/src/main/java/org/eclipse/hono/util/MessageHelper.java", "diffHunk": "@@ -1123,7 +1120,9 @@ public static Message addProperties(\n         setCreationTime(msg);\n         msg.setAddress(ri.getBasePath());\n         addDeviceId(msg, ri.getResourceId());\n-        addProperty(msg, MessageHelper.APP_PROPERTY_ORIG_ADAPTER, adapterTypeName);\n+        if (adapterTypeName != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NDQzMA=="}, "originalCommit": {"oid": "61e3955b9389002312011209fb46a90db8bd1161"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNjg2Mzc3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/eclipse/hono/util/RegistrationConstants.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNDozMTozMFrOHAOT7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNTowNDowOVrOHBsoGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NjUyNA==", "bodyText": "none of these are used in the Device Registration API, are they? If not, then they should be moved to RegistryManagementConstants or some other appropriate location...", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r469996524", "createdAt": "2020-08-13T14:31:30Z", "author": {"login": "sophokles73"}, "path": "core/src/main/java/org/eclipse/hono/util/RegistrationConstants.java", "diffHunk": "@@ -56,6 +56,32 @@\n      */\n     public static final String FIELD_MAPPER = \"mapper\";\n \n+    /**\n+     * The name of the field in a response to the <em>assert Device Registration</em> operation\n+     * that contains the authorities of a gateway.\n+     */\n+    public static final String FIELD_AUTHORITIES = \"authorities\";\n+\n+    /**\n+     * The name of the field in a response to the <em>assert Device Registration</em> operation\n+     * that contains the name of the gateway groups.\n+     */\n+    public static final String FIELD_MEMBER_OF = \"memberOf\";\n+\n+    /**\n+     * The name of the authority which authorizes a gateway to perform auto-provisioning.\n+     */\n+    public static final String AUTHORITY_AUTO_PROVISIONING_ENABLED = \"auto-provisioning-enabled\";\n+\n+    /**\n+     * The registration status of a device.\n+     */\n+    public enum REGISTRATION_STATUS {\n+        NEW;\n+\n+        public static final String KEY = \"hono_registration_status\";\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61e3955b9389002312011209fb46a90db8bd1161"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU0MTc4NA==", "bodyText": "That's true. I used the constants defined in RegistryManagementConstants instead, moved one to EventConstants and one to MessageHelper instead.\nHope this fits better.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r471541784", "createdAt": "2020-08-17T15:04:09Z", "author": {"login": "fkaltner"}, "path": "core/src/main/java/org/eclipse/hono/util/RegistrationConstants.java", "diffHunk": "@@ -56,6 +56,32 @@\n      */\n     public static final String FIELD_MAPPER = \"mapper\";\n \n+    /**\n+     * The name of the field in a response to the <em>assert Device Registration</em> operation\n+     * that contains the authorities of a gateway.\n+     */\n+    public static final String FIELD_AUTHORITIES = \"authorities\";\n+\n+    /**\n+     * The name of the field in a response to the <em>assert Device Registration</em> operation\n+     * that contains the name of the gateway groups.\n+     */\n+    public static final String FIELD_MEMBER_OF = \"memberOf\";\n+\n+    /**\n+     * The name of the authority which authorizes a gateway to perform auto-provisioning.\n+     */\n+    public static final String AUTHORITY_AUTO_PROVISIONING_ENABLED = \"auto-provisioning-enabled\";\n+\n+    /**\n+     * The registration status of a device.\n+     */\n+    public enum REGISTRATION_STATUS {\n+        NEW;\n+\n+        public static final String KEY = \"hono_registration_status\";\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk5NjUyNA=="}, "originalCommit": {"oid": "61e3955b9389002312011209fb46a90db8bd1161"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzIzMjQxOnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTo1Mzo1OVrOHAR22Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxMzowNjoyNlrOHBn8Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1NDYxNw==", "bodyText": "why do we need this?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r470054617", "createdAt": "2020-08-13T15:53:59Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -55,8 +75,108 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(AbstractRegistrationService.class);\n \n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61e3955b9389002312011209fb46a90db8bd1161"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ2NTA0Ng==", "bodyText": "We don't. I didn't know about the mapTo() method in JsonObject which I learnt just today.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r471465046", "createdAt": "2020-08-17T13:06:26Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -55,8 +75,108 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(AbstractRegistrationService.class);\n \n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1NDYxNw=="}, "originalCommit": {"oid": "61e3955b9389002312011209fb46a90db8bd1161"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzIzMzg3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTo1NDoxOFrOHAR3tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxMzowNjozN1rOHBn8mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1NDgzOA==", "bodyText": "why do we need this?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r470054838", "createdAt": "2020-08-13T15:54:18Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -32,6 +37,7 @@\n public class AutowiredTenantInformationService implements TenantInformationService {\n \n     private static final Logger LOG = LoggerFactory.getLogger(AutowiredTenantInformationService.class);\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61e3955b9389002312011209fb46a90db8bd1161"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ2NTExMg==", "bodyText": "See: #2094 (comment)", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r471465112", "createdAt": "2020-08-17T13:06:37Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -32,6 +37,7 @@\n public class AutowiredTenantInformationService implements TenantInformationService {\n \n     private static final Logger LOG = LoggerFactory.getLogger(AutowiredTenantInformationService.class);\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1NDgzOA=="}, "originalCommit": {"oid": "61e3955b9389002312011209fb46a90db8bd1161"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNzIzNTgxOnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/TenantInformationService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTo1NDo0OFrOHAR47Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNTowNTowMlrOHBsqlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1NTE0OQ==", "bodyText": "what if there is no such tenant?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r470055149", "createdAt": "2020-08-13T15:54:48Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/TenantInformationService.java", "diffHunk": "@@ -42,4 +44,16 @@\n      */\n      Future<Result<TenantKey>> tenantExists(String tenantId, Span span);\n \n+    /**\n+     * Gets the tenant identified by the given id.\n+     *\n+     * @param tenantId The id identifying the tenant to obtain.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     *\n+     * @return A future whose outcome contains the requested tenant.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61e3955b9389002312011209fb46a90db8bd1161"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTU0MjQyMQ==", "bodyText": "Adapted the documentation accordingly.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r471542421", "createdAt": "2020-08-17T15:05:02Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/TenantInformationService.java", "diffHunk": "@@ -42,4 +44,16 @@\n      */\n      Future<Result<TenantKey>> tenantExists(String tenantId, Span span);\n \n+    /**\n+     * Gets the tenant identified by the given id.\n+     *\n+     * @param tenantId The id identifying the tenant to obtain.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     *\n+     * @return A future whose outcome contains the requested tenant.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1NTE0OQ=="}, "originalCommit": {"oid": "61e3955b9389002312011209fb46a90db8bd1161"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MTYxODUyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/eclipse/hono/util/EventConstants.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMzozOToxMVrOHCVDzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMzozOToxMVrOHCVDzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwNDIzOA==", "bodyText": "We use standard camel case names for enums ...", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r472204238", "createdAt": "2020-08-18T13:39:11Z", "author": {"login": "sophokles73"}, "path": "core/src/main/java/org/eclipse/hono/util/EventConstants.java", "diffHunk": "@@ -37,6 +37,13 @@\n      */\n     public static final String CONTENT_TYPE_EMPTY_NOTIFICATION = \"application/vnd.eclipse-hono-empty-notification\";\n \n+    /**\n+     * The registration status of a device.\n+     */\n+    public enum REGISTRATION_STATUS {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6b467294d9babc281973504c66a24513396041e"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MTYzNTk3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMzo0MzoxMlrOHCVPAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNTo0ODowOFrOHODmaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwNzEwNg==", "bodyText": "We always use active form present tense for JavaDocs.\n\nAdds a new edge ...", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r472207106", "createdAt": "2020-08-18T13:43:12Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -159,6 +276,38 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Add a new edge device in the process of auto-provisioning of not yet registered edge devices sending data", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6b467294d9babc281973504c66a24513396041e"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwMTA5Nw==", "bodyText": "I know but missed that one. Thanks for spotting.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r484501097", "createdAt": "2020-09-07T15:48:08Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -159,6 +276,38 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Add a new edge device in the process of auto-provisioning of not yet registered edge devices sending data", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwNzEwNg=="}, "originalCommit": {"oid": "a6b467294d9babc281973504c66a24513396041e"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MTY0MjgyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMzo0NDo0NlrOHCVTTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNTo0ODo0MFrOHODnMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwODIwNQ==", "bodyText": "What will be contained in the future if the operation fails? Why should it fail?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r472208205", "createdAt": "2020-08-18T13:44:46Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -159,6 +276,38 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Add a new edge device in the process of auto-provisioning of not yet registered edge devices sending data\n+     * via a gateway.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param deviceId The ID the device should be registered under.\n+     * @param device Device information, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    protected abstract Future<OperationResult<Id>> addEdgeDevice(String tenantId, Optional<String> deviceId, Device device, Span span);\n+\n+    private Future<OperationResult<Id>> setAutoProvisioningNotificationSent(final String tenantId, final String deviceId, final JsonObject deviceJson, final Span span) {\n+        final Device device = deviceJson.mapTo(Device.class);\n+        device.setAutoProvisioningNotificationSent(true);\n+        return updateDevice(tenantId, deviceId, device, Optional.empty(), span);\n+    }\n+\n+    /**\n+     * Updates device registration data.\n+     *\n+     * @param tenantId The tenant the device belongs to.\n+     * @param deviceId The ID of the device to update the registration for.\n+     * @param device Device information, must not be {@code null}.\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6b467294d9babc281973504c66a24513396041e"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwMTI5OQ==", "bodyText": "Fixed.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r484501299", "createdAt": "2020-09-07T15:48:40Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -159,6 +276,38 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Add a new edge device in the process of auto-provisioning of not yet registered edge devices sending data\n+     * via a gateway.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param deviceId The ID the device should be registered under.\n+     * @param device Device information, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    protected abstract Future<OperationResult<Id>> addEdgeDevice(String tenantId, Optional<String> deviceId, Device device, Span span);\n+\n+    private Future<OperationResult<Id>> setAutoProvisioningNotificationSent(final String tenantId, final String deviceId, final JsonObject deviceJson, final Span span) {\n+        final Device device = deviceJson.mapTo(Device.class);\n+        device.setAutoProvisioningNotificationSent(true);\n+        return updateDevice(tenantId, deviceId, device, Optional.empty(), span);\n+    }\n+\n+    /**\n+     * Updates device registration data.\n+     *\n+     * @param tenantId The tenant the device belongs to.\n+     * @param deviceId The ID of the device to update the registration for.\n+     * @param device Device information, must not be {@code null}.\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwODIwNQ=="}, "originalCommit": {"oid": "a6b467294d9babc281973504c66a24513396041e"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MTY1MzY1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMzo0NzoxM1rOHCVZ3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxNTo0OTozNlrOHODomQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwOTg4Nw==", "bodyText": "this will only work if the result has status 200 and thus the payload contains JSON .... see implementation of tenantExists ...", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r472209887", "createdAt": "2020-08-18T13:47:13Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -53,6 +55,12 @@\n                 });\n     }\n \n+    @Override\n+    public Future<TenantResult<TenantObject>> getTenant(final String tenantId, final Span span) {\n+        return service.get(tenantId, span)\n+                .map(tenantJson -> TenantResult.from(HttpURLConnection.HTTP_OK, tenantJson.getPayload().mapTo(TenantObject.class)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6b467294d9babc281973504c66a24513396041e"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEwNDA0MQ==", "bodyText": "True.\nFMPOV a failed Future would make more sense (in contrast to the implementation of tenantExists). Otherwise every caller of the getTenant method would need to start with an if examining the result.\nIn general I find this pattern (returning a result which is possibly an error) cumbersome - isn't that what the onFailure methods in a Future are meant for?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r473104041", "createdAt": "2020-08-19T15:10:18Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -53,6 +55,12 @@\n                 });\n     }\n \n+    @Override\n+    public Future<TenantResult<TenantObject>> getTenant(final String tenantId, final Span span) {\n+        return service.get(tenantId, span)\n+                .map(tenantJson -> TenantResult.from(HttpURLConnection.HTTP_OK, tenantJson.getPayload().mapTo(TenantObject.class)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwOTg4Nw=="}, "originalCommit": {"oid": "a6b467294d9babc281973504c66a24513396041e"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzExMzk3Mw==", "bodyText": "yes, and we all agree that we need to change the service interfaces accordingly (some time). But we will definitely not have some methods in some interfaces follow one approach while others follow another one. At least we want to be consistent ...", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r473113973", "createdAt": "2020-08-19T15:23:44Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -53,6 +55,12 @@\n                 });\n     }\n \n+    @Override\n+    public Future<TenantResult<TenantObject>> getTenant(final String tenantId, final Span span) {\n+        return service.get(tenantId, span)\n+                .map(tenantJson -> TenantResult.from(HttpURLConnection.HTTP_OK, tenantJson.getPayload().mapTo(TenantObject.class)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwOTg4Nw=="}, "originalCommit": {"oid": "a6b467294d9babc281973504c66a24513396041e"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwMTY1Nw==", "bodyText": "Fixed (in a consistent way ;-) )", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r484501657", "createdAt": "2020-09-07T15:49:36Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -53,6 +55,12 @@\n                 });\n     }\n \n+    @Override\n+    public Future<TenantResult<TenantObject>> getTenant(final String tenantId, final Span span) {\n+        return service.get(tenantId, span)\n+                .map(tenantJson -> TenantResult.from(HttpURLConnection.HTTP_OK, tenantJson.getPayload().mapTo(TenantObject.class)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIwOTg4Nw=="}, "originalCommit": {"oid": "a6b467294d9babc281973504c66a24513396041e"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MTY2OTAxOnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxMzo1MDozN1rOHCVjYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwOToxMjowOFrOHc9Low==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIxMjMyMA==", "bodyText": "IMHO these should better be moved to the device's status property because we do not want clients to be able to update these, right?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r472212320", "createdAt": "2020-08-18T13:50:37Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -38,6 +40,12 @@\n     @JsonProperty(RegistryManagementConstants.FIELD_ENABLED)\n     private Boolean enabled;\n \n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONED)\n+    private Boolean autoProvisioned;\n+\n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONING_NOTIFICATION_SENT)\n+    private Boolean autoProvisioningNotificationSent;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6b467294d9babc281973504c66a24513396041e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA3NzI1OQ==", "bodyText": "Yes that it is right. I looked at the implementation of the status property and it seems like it is not complete yet. Consequently on my local deployment (with file based registry) there is only the current time returned as created and updated timestamp.\nThere is also an open issue regarding this: #1960\nSo I guess it makes sense to implement the status property first and then come back to this PR?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r473077259", "createdAt": "2020-08-19T14:34:09Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -38,6 +40,12 @@\n     @JsonProperty(RegistryManagementConstants.FIELD_ENABLED)\n     private Boolean enabled;\n \n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONED)\n+    private Boolean autoProvisioned;\n+\n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONING_NOTIFICATION_SENT)\n+    private Boolean autoProvisioningNotificationSent;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIxMjMyMA=="}, "originalCommit": {"oid": "a6b467294d9babc281973504c66a24513396041e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY2NTYwMA==", "bodyText": "Either that or do not include the fields in the device object being transferred between the client and the registry", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r473665600", "createdAt": "2020-08-20T06:54:54Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -38,6 +40,12 @@\n     @JsonProperty(RegistryManagementConstants.FIELD_ENABLED)\n     private Boolean enabled;\n \n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONED)\n+    private Boolean autoProvisioned;\n+\n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONING_NOTIFICATION_SENT)\n+    private Boolean autoProvisioningNotificationSent;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIxMjMyMA=="}, "originalCommit": {"oid": "a6b467294d9babc281973504c66a24513396041e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc4OTUwOA==", "bodyText": "I am struggling with what you mean with\n\ndo not include the fields in the device object being transferred between the client and the registry\n\nI was looking for some kind of \"internal model\" initially already but went to re-investigate if there is such a thing after you remark. As far as I can see the org.eclipse.hono.service.management.device.Device class is used as the sole model class - internally as well as for the API. So the only option I see to have those two fields persistent is to include them in that class.\nDid I miss something?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r473789508", "createdAt": "2020-08-20T09:02:07Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -38,6 +40,12 @@\n     @JsonProperty(RegistryManagementConstants.FIELD_ENABLED)\n     private Boolean enabled;\n \n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONED)\n+    private Boolean autoProvisioned;\n+\n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONING_NOTIFICATION_SENT)\n+    private Boolean autoProvisioningNotificationSent;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIxMjMyMA=="}, "originalCommit": {"oid": "a6b467294d9babc281973504c66a24513396041e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkxMDA0OQ==", "bodyText": "No, you didn't. However, that doesn't mean that you need to transfer their values hence and forth between the registry and the client, does it?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r473910049", "createdAt": "2020-08-20T11:48:09Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -38,6 +40,12 @@\n     @JsonProperty(RegistryManagementConstants.FIELD_ENABLED)\n     private Boolean enabled;\n \n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONED)\n+    private Boolean autoProvisioned;\n+\n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONING_NOTIFICATION_SENT)\n+    private Boolean autoProvisioningNotificationSent;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIxMjMyMA=="}, "originalCommit": {"oid": "a6b467294d9babc281973504c66a24513396041e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDUwMzc3Nw==", "bodyText": "Okay, so I guess you mean FileBasedDeviceBackend and MongoDbBasedDeviceBackend with client.\nThe problem is that we do a replace of the device when persisting for the file-based registry (there we just replace the entry in the HashMap) as well as for the MongoDb-based registry (there we replace the document of the device).\nIf I do not transfer the values (i.e. setting them to null) the present flags will be overwritten (with null). In order to put this to work I would need to implement some kind of \"merge\" as far as I can see.\nBut I do think that the status property is a better alternative than implementing merge-logic (which is just a workaround for the missing status property in my opinion).\nHence I do actually only see the implementation of the status property as a solution. So I would continue there and come back to this PR.\nWDYT?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r484503777", "createdAt": "2020-09-07T15:55:02Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -38,6 +40,12 @@\n     @JsonProperty(RegistryManagementConstants.FIELD_ENABLED)\n     private Boolean enabled;\n \n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONED)\n+    private Boolean autoProvisioned;\n+\n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONING_NOTIFICATION_SENT)\n+    private Boolean autoProvisioningNotificationSent;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIxMjMyMA=="}, "originalCommit": {"oid": "a6b467294d9babc281973504c66a24513396041e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDEyNDU3OQ==", "bodyText": "Finally #2189 is near being merged. After it was merged I am able to continue on this one.\nI guess it makes sense to squash my commits to the present one and then continue with moving the auto-provisioning properties to the device status in a separate commit. WDYT?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r500124579", "createdAt": "2020-10-06T09:12:08Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -38,6 +40,12 @@\n     @JsonProperty(RegistryManagementConstants.FIELD_ENABLED)\n     private Boolean enabled;\n \n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONED)\n+    private Boolean autoProvisioned;\n+\n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONING_NOTIFICATION_SENT)\n+    private Boolean autoProvisioningNotificationSent;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIxMjMyMA=="}, "originalCommit": {"oid": "a6b467294d9babc281973504c66a24513396041e"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMjY4MjE4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMjoyNToxN1rOHOabJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxMjoyNToxN1rOHOabJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg3NTA0NQ==", "bodyText": "StatusCodeMapper.from(final int statusCode, final String detailMessage) should take care of this mapping.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r484875045", "createdAt": "2020-09-08T12:25:17Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -359,16 +367,24 @@ public final void setTenantInformationService(final TenantInformationService ten\n \n                                     LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);\n                                     return addEdgeDevice(tenantId, Optional.ofNullable(deviceId), device, span)\n-                                            .compose(addDeviceOk -> sendEmptyEvent(tenantId, deviceId, gatewayId, span)\n-                                                .compose(sendEmptyEventOk -> processAssertRegistration(DeviceKey.from(tenantKey, deviceId), span)\n-                                                    .compose(deviceRegistrationData -> {\n-                                                        final JsonObject deviceData = deviceRegistrationData.getPayload()\n-                                                                .getJsonObject(RegistrationConstants.FIELD_DATA, new JsonObject());\n-                                                        return setAutoProvisioningNotificationSent(tenantId, deviceId, deviceData, span)\n-                                                            .compose(idOperationResult -> createSuccessfulRegistrationResult(tenantId, deviceId, deviceData, span));\n-                                                    })\n-                                                )\n-                                            );\n+                                            .compose(registrationResult -> {\n+                                                if (registrationResult.isError()) {\n+                                                    if (registrationResult.getStatus() < 400 || registrationResult.getStatus() >= 500) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4cfe0a6a35da900833b7016044b94aa216921fe1"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTEyNDQ4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwNjoyMzozMlrOHRFXvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwNjoyMzozMlrOHRFXvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY3NTgzNw==", "bodyText": "Concerning Optional.ofNullable(deviceId): deviceId can't be null here.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r487675837", "createdAt": "2020-09-14T06:23:32Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -194,7 +351,42 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setAutoProvisioned(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);\n+                                    if (memberOf != null && !memberOf.isEmpty()) {\n+                                        device.setViaGroups(memberOf.getList());\n+                                    }\n+\n+                                    LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);\n+                                    return addEdgeDevice(tenantId, Optional.ofNullable(deviceId), device, span)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4cfe0a6a35da900833b7016044b94aa216921fe1"}, "originalPosition": 227}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MTE2NzYwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQwNjozOTo1MVrOHRFw4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNzoxOToxNFrOHR0FqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY4MjI3Mg==", "bodyText": "I would be good to create a new child span here, and use it in this block (for everything except createSuccessfulRegistrationResult, I guess). That would allow filtering for that operation in the Tracing UI.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r487682272", "createdAt": "2020-09-14T06:39:51Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -194,7 +351,42 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setAutoProvisioned(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);\n+                                    if (memberOf != null && !memberOf.isEmpty()) {\n+                                        device.setViaGroups(memberOf.getList());\n+                                    }\n+\n+                                    LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4cfe0a6a35da900833b7016044b94aa216921fe1"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQxOTkyNQ==", "bodyText": "That makes sense. But I would also use the child span for createSuccessfulRegistrationResult since it is also done in the context of auto provisioning.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r488419925", "createdAt": "2020-09-15T06:36:04Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -194,7 +351,42 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setAutoProvisioned(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);\n+                                    if (memberOf != null && !memberOf.isEmpty()) {\n+                                        device.setViaGroups(memberOf.getList());\n+                                    }\n+\n+                                    LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY4MjI3Mg=="}, "originalCommit": {"oid": "4cfe0a6a35da900833b7016044b94aa216921fe1"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQ0MTI1Ng==", "bodyText": "I just think the auto provisioning is finished at that point, and a possible error like \"failed to resolve group members\", returned in createSuccessfulRegistrationResult, would be better of getting logged in the assert Device Registration span.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r488441256", "createdAt": "2020-09-15T07:19:14Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -194,7 +351,42 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setAutoProvisioned(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);\n+                                    if (memberOf != null && !memberOf.isEmpty()) {\n+                                        device.setViaGroups(memberOf.getList());\n+                                    }\n+\n+                                    LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY4MjI3Mg=="}, "originalCommit": {"oid": "4cfe0a6a35da900833b7016044b94aa216921fe1"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxMTI4MDE0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwOToxNzozMVrOHoyMkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo1MDo0M1rOH-jfiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUyNzUwNg==", "bodyText": "This span isn't getting finished below. And naming it \"perform auto-provisioning\" would fit the usual naming style better FMPOV.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r512527506", "createdAt": "2020-10-27T09:17:31Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -227,7 +405,41 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setAutoProvisioned(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);\n+                                    if (memberOf != null && !memberOf.isEmpty()) {\n+                                        device.setViaGroups(memberOf.getList());\n+                                    }\n+\n+                                    LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);\n+                                    final Span childSpan = TracingHelper.buildChildSpan(tracer, span.context(), \"auto-provisioning\", Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0e8393655a7c6309fcc88671317efa3f9d0853a"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1NTI3Mg==", "bodyText": "I think this should be fixed now by the most recent refactoring.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r535355272", "createdAt": "2020-12-03T15:50:43Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -227,7 +405,41 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setAutoProvisioned(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);\n+                                    if (memberOf != null && !memberOf.isEmpty()) {\n+                                        device.setViaGroups(memberOf.getList());\n+                                    }\n+\n+                                    LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);\n+                                    final Span childSpan = TracingHelper.buildChildSpan(tracer, span.context(), \"auto-provisioning\", Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjUyNzUwNg=="}, "originalCommit": {"oid": "f0e8393655a7c6309fcc88671317efa3f9d0853a"}, "originalPosition": 254}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzU3NzUyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOToxNzoxOFrOHxEvsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwOTowNTowNlrOH9Q0_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMDAxNg==", "bodyText": "Missing info about the null check of the opentracingTracer in the JavaDoc.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r521220016", "createdAt": "2020-11-11T09:17:18Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -56,8 +77,127 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(AbstractRegistrationService.class);\n \n+    /**\n+     * The OpenTracing {@code Tracer} for tracking processing of requests.\n+     */\n+    protected Tracer tracer = NoopTracerFactory.create();\n+\n     protected TenantInformationService tenantInformationService = new NoopTenantInformationService();\n \n+    protected DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(c -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    return c;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return startInternal()\n+            .compose(ok -> connectionAttempt)\n+            .mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        return stopInternal();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom startup logic, see {@link Lifecycle#start()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> startInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom shutdown logic, see {@link Lifecycle#stop()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> stopInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.#\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3467601a96b1383ffda871cfdcade7a3bf1b761"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAwMDg5Mg==", "bodyText": "Added.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r534000892", "createdAt": "2020-12-02T09:05:06Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -56,8 +77,127 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(AbstractRegistrationService.class);\n \n+    /**\n+     * The OpenTracing {@code Tracer} for tracking processing of requests.\n+     */\n+    protected Tracer tracer = NoopTracerFactory.create();\n+\n     protected TenantInformationService tenantInformationService = new NoopTenantInformationService();\n \n+    protected DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(c -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    return c;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return startInternal()\n+            .compose(ok -> connectionAttempt)\n+            .mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        return stopInternal();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom startup logic, see {@link Lifecycle#start()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> startInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom shutdown logic, see {@link Lifecycle#stop()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> stopInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.#\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMDAxNg=="}, "originalCommit": {"oid": "a3467601a96b1383ffda871cfdcade7a3bf1b761"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzU3Nzg2OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOToxNzoyM1rOHxEv4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwOTowNToxN1rOH9Q1eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMDA2Ng==", "bodyText": "Null check of opentracingTracer should precede the log statement. If opentracingTracer is null then  opentracingTracer.getClass() will throw NullPointerException.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r521220066", "createdAt": "2020-11-11T09:17:23Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -56,8 +77,127 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(AbstractRegistrationService.class);\n \n+    /**\n+     * The OpenTracing {@code Tracer} for tracking processing of requests.\n+     */\n+    protected Tracer tracer = NoopTracerFactory.create();\n+\n     protected TenantInformationService tenantInformationService = new NoopTenantInformationService();\n \n+    protected DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(c -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    return c;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return startInternal()\n+            .compose(ok -> connectionAttempt)\n+            .mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        return stopInternal();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom startup logic, see {@link Lifecycle#start()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> startInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom shutdown logic, see {@link Lifecycle#stop()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> stopInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.#\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3467601a96b1383ffda871cfdcade7a3bf1b761"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAwMTAxOA==", "bodyText": "Good catch. Changed order.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r534001018", "createdAt": "2020-12-02T09:05:17Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -56,8 +77,127 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(AbstractRegistrationService.class);\n \n+    /**\n+     * The OpenTracing {@code Tracer} for tracking processing of requests.\n+     */\n+    protected Tracer tracer = NoopTracerFactory.create();\n+\n     protected TenantInformationService tenantInformationService = new NoopTenantInformationService();\n \n+    protected DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(c -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    return c;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return startInternal()\n+            .compose(ok -> connectionAttempt)\n+            .mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        return stopInternal();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom startup logic, see {@link Lifecycle#start()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> startInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom shutdown logic, see {@link Lifecycle#stop()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> stopInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.#\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMDA2Ng=="}, "originalCommit": {"oid": "a3467601a96b1383ffda871cfdcade7a3bf1b761"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzU3ODA1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOToxNzoyOFrOHxEwCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwOTowNjowNlrOH9Q3WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMDEwNA==", "bodyText": "This method is deprecated.  How about using newMessage(ResourceIdentifier, String, Buffer, TenantObject, Map, Map, boolean, boolean) instead.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r521220104", "createdAt": "2020-11-11T09:17:28Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -56,8 +77,127 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(AbstractRegistrationService.class);\n \n+    /**\n+     * The OpenTracing {@code Tracer} for tracking processing of requests.\n+     */\n+    protected Tracer tracer = NoopTracerFactory.create();\n+\n     protected TenantInformationService tenantInformationService = new NoopTenantInformationService();\n \n+    protected DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(c -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    return c;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return startInternal()\n+            .compose(ok -> connectionAttempt)\n+            .mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        return stopInternal();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom startup logic, see {@link Lifecycle#start()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> startInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom shutdown logic, see {@link Lifecycle#stop()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> stopInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.#\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);\n+    }\n+\n+    private Future<ProtonDelivery> sendEmptyEvent(\n+            final String tenant,\n+            final String deviceId,\n+            final String gatewayId,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenant);\n+        Objects.requireNonNull(deviceId);\n+\n+        LOG.debug(\"sending auto-provisioning event for device {} via gateway {}\", deviceId, gatewayId);\n+\n+        final Future<TenantResult<TenantObject>> tenantTracker = tenantInformationService.getTenant(tenant, span);\n+        final Future<DownstreamSender> senderTracker = downstreamSenderFactory.getOrCreateEventSender(tenant);\n+\n+        return CompositeFuture.all(tenantTracker, senderTracker).compose(ok -> {\n+            final Message msg = MessageHelper.newMessage(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3467601a96b1383ffda871cfdcade7a3bf1b761"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAwMTQ5Ng==", "bodyText": "Right, the method has become deprecated in the meantime. Switched to the advised one.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r534001496", "createdAt": "2020-12-02T09:06:06Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -56,8 +77,127 @@\n \n     private static final Logger LOG = LoggerFactory.getLogger(AbstractRegistrationService.class);\n \n+    /**\n+     * The OpenTracing {@code Tracer} for tracking processing of requests.\n+     */\n+    protected Tracer tracer = NoopTracerFactory.create();\n+\n     protected TenantInformationService tenantInformationService = new NoopTenantInformationService();\n \n+    protected DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(c -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    return c;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return startInternal()\n+            .compose(ok -> connectionAttempt)\n+            .mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        return stopInternal();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom startup logic, see {@link Lifecycle#start()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> startInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom shutdown logic, see {@link Lifecycle#stop()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> stopInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.#\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);\n+    }\n+\n+    private Future<ProtonDelivery> sendEmptyEvent(\n+            final String tenant,\n+            final String deviceId,\n+            final String gatewayId,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenant);\n+        Objects.requireNonNull(deviceId);\n+\n+        LOG.debug(\"sending auto-provisioning event for device {} via gateway {}\", deviceId, gatewayId);\n+\n+        final Future<TenantResult<TenantObject>> tenantTracker = tenantInformationService.getTenant(tenant, span);\n+        final Future<DownstreamSender> senderTracker = downstreamSenderFactory.getOrCreateEventSender(tenant);\n+\n+        return CompositeFuture.all(tenantTracker, senderTracker).compose(ok -> {\n+            final Message msg = MessageHelper.newMessage(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIyMDEwNA=="}, "originalCommit": {"oid": "a3467601a96b1383ffda871cfdcade7a3bf1b761"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzczMjMyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOTo1ODo1NlrOHxGPRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNzowODo0MlrOIBqVag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NDQ4Nw==", "bodyText": "How about adding information about null check of parameters using @throws in the JavaDoc?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r521244487", "createdAt": "2020-11-11T09:58:56Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -192,6 +332,44 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Adds a new edge device in the process of auto-provisioning of not yet registered edge devices sending data\n+     * via a gateway.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param deviceId The ID the device should be registered under.\n+     * @param device Device information, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/createDeviceRegistration\">\n+     *         Device Registry Management API - Create Device Registration </a>\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3467601a96b1383ffda871cfdcade7a3bf1b761"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAxOTA2Nw==", "bodyText": "As this is a abstract method and the implementations differ regarding their null checks I am not sure if it will be of any help for the reader.\nAlso usually I have rarely seen a NullpointerException being catched.\nI think we should rather add documentation to the @param tags stating that the parameter must not be null making it part of the method's contract.\nWDYT?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r534019067", "createdAt": "2020-12-02T09:31:24Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -192,6 +332,44 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Adds a new edge device in the process of auto-provisioning of not yet registered edge devices sending data\n+     * via a gateway.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param deviceId The ID the device should be registered under.\n+     * @param device Device information, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/createDeviceRegistration\">\n+     *         Device Registry Management API - Create Device Registration </a>\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NDQ4Nw=="}, "originalCommit": {"oid": "a3467601a96b1383ffda871cfdcade7a3bf1b761"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYxMzA5OA==", "bodyText": "This became obsolete in the refactored version.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r538613098", "createdAt": "2020-12-08T17:08:42Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -192,6 +332,44 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Adds a new edge device in the process of auto-provisioning of not yet registered edge devices sending data\n+     * via a gateway.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param deviceId The ID the device should be registered under.\n+     * @param device Device information, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/createDeviceRegistration\">\n+     *         Device Registry Management API - Create Device Registration </a>\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NDQ4Nw=="}, "originalCommit": {"oid": "a3467601a96b1383ffda871cfdcade7a3bf1b761"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzczNTczOnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOTo1OTo1MVrOHxGRZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNzowODo1NVrOIBqWaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NTAyOQ==", "bodyText": "How about adding information about null check of parameters using @throws in the JavaDoc?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r521245029", "createdAt": "2020-11-11T09:59:51Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -192,6 +332,44 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Adds a new edge device in the process of auto-provisioning of not yet registered edge devices sending data\n+     * via a gateway.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param deviceId The ID the device should be registered under.\n+     * @param device Device information, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/createDeviceRegistration\">\n+     *         Device Registry Management API - Create Device Registration </a>\n+     */\n+    protected abstract Future<OperationResult<Id>> addEdgeDevice(String tenantId, Optional<String> deviceId, Device device, Span span);\n+\n+    private Future<OperationResult<Id>> setAutoProvisioningNotificationSent(final String tenantId, final String deviceId, final JsonObject deviceJson, final Span span) {\n+        final Device device = deviceJson.mapTo(Device.class);\n+        device.setAutoProvisioningNotificationSent(true);\n+        return updateDevice(tenantId, deviceId, device, Optional.empty(), span);\n+    }\n+\n+    /**\n+     * Updates device registration data.\n+     *\n+     * @param tenantId The tenant the device belongs to.\n+     * @param deviceId The ID of the device to update the registration for.\n+     * @param device Device information, must not be {@code null}.\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/updateRegistration\">\n+     *         Device Registry Management API - Update Device Registration </a>\n+     */\n+    public abstract Future<OperationResult<Id>> updateDevice(String tenantId, String deviceId, Device device, Optional<String> resourceVersion, Span span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3467601a96b1383ffda871cfdcade7a3bf1b761"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAyMjYzMA==", "bodyText": "See above.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r534022630", "createdAt": "2020-12-02T09:36:42Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -192,6 +332,44 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Adds a new edge device in the process of auto-provisioning of not yet registered edge devices sending data\n+     * via a gateway.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param deviceId The ID the device should be registered under.\n+     * @param device Device information, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/createDeviceRegistration\">\n+     *         Device Registry Management API - Create Device Registration </a>\n+     */\n+    protected abstract Future<OperationResult<Id>> addEdgeDevice(String tenantId, Optional<String> deviceId, Device device, Span span);\n+\n+    private Future<OperationResult<Id>> setAutoProvisioningNotificationSent(final String tenantId, final String deviceId, final JsonObject deviceJson, final Span span) {\n+        final Device device = deviceJson.mapTo(Device.class);\n+        device.setAutoProvisioningNotificationSent(true);\n+        return updateDevice(tenantId, deviceId, device, Optional.empty(), span);\n+    }\n+\n+    /**\n+     * Updates device registration data.\n+     *\n+     * @param tenantId The tenant the device belongs to.\n+     * @param deviceId The ID of the device to update the registration for.\n+     * @param device Device information, must not be {@code null}.\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/updateRegistration\">\n+     *         Device Registry Management API - Update Device Registration </a>\n+     */\n+    public abstract Future<OperationResult<Id>> updateDevice(String tenantId, String deviceId, Device device, Optional<String> resourceVersion, Span span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NTAyOQ=="}, "originalCommit": {"oid": "a3467601a96b1383ffda871cfdcade7a3bf1b761"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODYxMzM1Mg==", "bodyText": "This became obsolete in the refactored version.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r538613352", "createdAt": "2020-12-08T17:08:55Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -192,6 +332,44 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Adds a new edge device in the process of auto-provisioning of not yet registered edge devices sending data\n+     * via a gateway.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param deviceId The ID the device should be registered under.\n+     * @param device Device information, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/createDeviceRegistration\">\n+     *         Device Registry Management API - Create Device Registration </a>\n+     */\n+    protected abstract Future<OperationResult<Id>> addEdgeDevice(String tenantId, Optional<String> deviceId, Device device, Span span);\n+\n+    private Future<OperationResult<Id>> setAutoProvisioningNotificationSent(final String tenantId, final String deviceId, final JsonObject deviceJson, final Span span) {\n+        final Device device = deviceJson.mapTo(Device.class);\n+        device.setAutoProvisioningNotificationSent(true);\n+        return updateDevice(tenantId, deviceId, device, Optional.empty(), span);\n+    }\n+\n+    /**\n+     * Updates device registration data.\n+     *\n+     * @param tenantId The tenant the device belongs to.\n+     * @param deviceId The ID of the device to update the registration for.\n+     * @param device Device information, must not be {@code null}.\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/updateRegistration\">\n+     *         Device Registry Management API - Update Device Registration </a>\n+     */\n+    public abstract Future<OperationResult<Id>> updateDevice(String tenantId, String deviceId, Device device, Optional<String> resourceVersion, Span span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NTAyOQ=="}, "originalCommit": {"oid": "a3467601a96b1383ffda871cfdcade7a3bf1b761"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzgzNzE2OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxMDoyNzo0NlrOHxHQLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMDoyODozNFrOH9UWXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2MTEwMg==", "bodyText": "How about updating the JavaDoc of this method about auto provisioning of devices for gateways?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r521261102", "createdAt": "2020-11-11T10:27:46Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -227,7 +405,41 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setAutoProvisioned(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);\n+                                    if (memberOf != null && !memberOf.isEmpty()) {\n+                                        device.setViaGroups(memberOf.getList());\n+                                    }\n+\n+                                    LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);\n+                                    final Span childSpan = TracingHelper.buildChildSpan(tracer, span.context(), \"auto-provisioning\", Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY)\n+                                            .start();\n+                                    return addEdgeDevice(tenantId, Optional.of(deviceId), device, childSpan)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3467601a96b1383ffda871cfdcade7a3bf1b761"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA1ODU4OQ==", "bodyText": "Added to the doc of RegistrationService.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r534058589", "createdAt": "2020-12-02T10:28:34Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -227,7 +405,41 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setAutoProvisioned(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);\n+                                    if (memberOf != null && !memberOf.isEmpty()) {\n+                                        device.setViaGroups(memberOf.getList());\n+                                    }\n+\n+                                    LOG.debug(\"auto-provisioning device {} for gateway {}\", deviceId, gatewayId);\n+                                    final Span childSpan = TracingHelper.buildChildSpan(tracer, span.context(), \"auto-provisioning\", Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY)\n+                                            .start();\n+                                    return addEdgeDevice(tenantId, Optional.of(deviceId), device, childSpan)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2MTEwMg=="}, "originalCommit": {"oid": "a3467601a96b1383ffda871cfdcade7a3bf1b761"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMDkzNTIyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMjo1NTo0MVrOH4_kLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDozNDowNFrOICNrYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyMzc1Nw==", "bodyText": "How about adding information about null check of parameters in this public method?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r529523757", "createdAt": "2020-11-24T12:55:41Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -192,6 +332,45 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Adds a new edge device in the process of auto-provisioning of not yet registered edge devices sending data\n+     * via a gateway.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param deviceId The ID the device should be registered under.\n+     * @param device Device information, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/createDeviceRegistration\">\n+     *         Device Registry Management API - Create Device Registration </a>\n+     */\n+    protected abstract Future<OperationResult<Id>> addEdgeDevice(String tenantId, Optional<String> deviceId, Device device, Span span);\n+\n+    private Future<OperationResult<Id>> setAutoProvisioningNotificationSent(final String tenantId, final String deviceId, final JsonObject deviceJson, final Span span) {\n+        final Device device = deviceJson.mapTo(Device.class);\n+        return updateDevice(tenantId, deviceId, Optional.of(true), device, Optional.empty(), span);\n+    }\n+\n+    /**\n+     * Updates device registration data.\n+     *\n+     * @param tenantId The tenant the device belongs to.\n+     * @param deviceId The ID of the device to update the registration for.\n+     * @param autoProvisioningNotificationSent Marks the auto-provisioning notification for this device as sent.\n+     *                                         If set to {@link Optional#empty()} the value will not be updated.\n+     * @param device Device information, must not be {@code null}.\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/updateRegistration\">\n+     *         Device Registry Management API - Update Device Registration </a>\n+     */\n+    public abstract Future<OperationResult<Id>> updateDevice(String tenantId, String deviceId, Optional<Boolean> autoProvisioningNotificationSent, Device device,  Optional<String> resourceVersion, Span span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE4OTg5NA==", "bodyText": "This method doesn't exist any more after refactoring", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539189894", "createdAt": "2020-12-09T10:30:57Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -192,6 +332,45 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Adds a new edge device in the process of auto-provisioning of not yet registered edge devices sending data\n+     * via a gateway.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param deviceId The ID the device should be registered under.\n+     * @param device Device information, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/createDeviceRegistration\">\n+     *         Device Registry Management API - Create Device Registration </a>\n+     */\n+    protected abstract Future<OperationResult<Id>> addEdgeDevice(String tenantId, Optional<String> deviceId, Device device, Span span);\n+\n+    private Future<OperationResult<Id>> setAutoProvisioningNotificationSent(final String tenantId, final String deviceId, final JsonObject deviceJson, final Span span) {\n+        final Device device = deviceJson.mapTo(Device.class);\n+        return updateDevice(tenantId, deviceId, Optional.of(true), device, Optional.empty(), span);\n+    }\n+\n+    /**\n+     * Updates device registration data.\n+     *\n+     * @param tenantId The tenant the device belongs to.\n+     * @param deviceId The ID of the device to update the registration for.\n+     * @param autoProvisioningNotificationSent Marks the auto-provisioning notification for this device as sent.\n+     *                                         If set to {@link Optional#empty()} the value will not be updated.\n+     * @param device Device information, must not be {@code null}.\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/updateRegistration\">\n+     *         Device Registry Management API - Update Device Registration </a>\n+     */\n+    public abstract Future<OperationResult<Id>> updateDevice(String tenantId, String deviceId, Optional<Boolean> autoProvisioningNotificationSent, Device device,  Optional<String> resourceVersion, Span span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyMzc1Nw=="}, "originalCommit": {"oid": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE5MjE2Mg==", "bodyText": "Yes, now it is reusing the methods as defined in DeviceManagementService.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539192162", "createdAt": "2020-12-09T10:34:04Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -192,6 +332,45 @@ public final void setTenantInformationService(final TenantInformationService ten\n         return assertRegistration(tenantId, deviceId, gatewayId, NoopSpan.INSTANCE);\n     }\n \n+    /**\n+     * Adds a new edge device in the process of auto-provisioning of not yet registered edge devices sending data\n+     * via a gateway.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param deviceId The ID the device should be registered under.\n+     * @param device Device information, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/createDeviceRegistration\">\n+     *         Device Registry Management API - Create Device Registration </a>\n+     */\n+    protected abstract Future<OperationResult<Id>> addEdgeDevice(String tenantId, Optional<String> deviceId, Device device, Span span);\n+\n+    private Future<OperationResult<Id>> setAutoProvisioningNotificationSent(final String tenantId, final String deviceId, final JsonObject deviceJson, final Span span) {\n+        final Device device = deviceJson.mapTo(Device.class);\n+        return updateDevice(tenantId, deviceId, Optional.of(true), device, Optional.empty(), span);\n+    }\n+\n+    /**\n+     * Updates device registration data.\n+     *\n+     * @param tenantId The tenant the device belongs to.\n+     * @param deviceId The ID of the device to update the registration for.\n+     * @param autoProvisioningNotificationSent Marks the auto-provisioning notification for this device as sent.\n+     *                                         If set to {@link Optional#empty()} the value will not be updated.\n+     * @param device Device information, must not be {@code null}.\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status code</em> is set as specified in the\n+     *         <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/updateRegistration\">\n+     *         Device Registry Management API - Update Device Registration </a>\n+     */\n+    public abstract Future<OperationResult<Id>> updateDevice(String tenantId, String deviceId, Optional<Boolean> autoProvisioningNotificationSent, Device device,  Optional<String> resourceVersion, Span span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUyMzc1Nw=="}, "originalCommit": {"oid": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTIyMDc2OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/TenantInformationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNDowMzo1OFrOH5CSxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODozMjowM1rOIDXkWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2ODQ1Mw==", "bodyText": "How about adding info about null checks in the JavaDoc  * @throws NullPointerException if any of the parameters are {@code null}.?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r529568453", "createdAt": "2020-11-24T14:03:58Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/TenantInformationService.java", "diffHunk": "@@ -42,4 +44,22 @@\n      */\n      Future<Result<TenantKey>> tenantExists(String tenantId, Span span);\n \n+    /**\n+     * Gets the tenant identified by the given id.\n+     *\n+     * @param tenantId The id identifying the tenant to obtain.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *             The <em>status</em> will be\n+     *             <ul>\n+     *             <li><em>200 OK</em> if a tenant with the given ID is registered.\n+     *             The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *             <li><em>404 Not Found</em> if no tenant with the given identifier exists.</li>\n+     *             </ul>\n+     */\n+     Future<TenantResult<TenantObject>> getTenant(String tenantId, Span span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMjc3OQ==", "bodyText": "How about adding info about null checks in the JavaDoc * @throws NullPointerException if any of the parameters are {@code null}.?\n\nAny update on this?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540402779", "createdAt": "2020-12-10T18:32:03Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/TenantInformationService.java", "diffHunk": "@@ -42,4 +44,22 @@\n      */\n      Future<Result<TenantKey>> tenantExists(String tenantId, Span span);\n \n+    /**\n+     * Gets the tenant identified by the given id.\n+     *\n+     * @param tenantId The id identifying the tenant to obtain.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *             The <em>status</em> will be\n+     *             <ul>\n+     *             <li><em>200 OK</em> if a tenant with the given ID is registered.\n+     *             The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *             <li><em>404 Not Found</em> if no tenant with the given identifier exists.</li>\n+     *             </ul>\n+     */\n+     Future<TenantResult<TenantObject>> getTenant(String tenantId, Span span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2ODQ1Mw=="}, "originalCommit": {"oid": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTI3Njg5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNDoxNjoxMFrOH5C05g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNTo0Nzo0NFrOID-ltQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU3NzE5MA==", "bodyText": "There are many longer lines as the one above and could be formatted to fit the Hono code style provided in\nhono/eclipse/hono-code-style.xml. I have my IDE's code formatter configured to use the hono-code-style.xml.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r529577190", "createdAt": "2020-11-24T14:16:10Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -227,7 +406,40 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA0Njc5Mg==", "bodyText": "Indeed. Since the code style is not enforced by the maven build I assumed it to be not \"binding\" especially since there is a lot of code which does not fully adhere to it.\nI did the reformat but personally I did not find the result more readable than before \ud83d\ude12. Hence I would rather not apply it...", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r534046792", "createdAt": "2020-12-02T10:11:24Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -227,7 +406,40 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU3NzE5MA=="}, "originalCommit": {"oid": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDkyNDk0NQ==", "bodyText": "The project code style guide aims to create a consistent code style irrespective of personal preferences which makes easier understanding of a large code base.  IMHO it is good to adhere to it.  As you said there are places where some code doesn't confirm to the code style and FMPOV those should also be updated whenever possible. @calohmn @sophokles73 WDYT?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540924945", "createdAt": "2020-12-11T12:51:10Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -227,7 +406,40 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU3NzE5MA=="}, "originalCommit": {"oid": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk5MzQ1Ng==", "bodyText": "I think it would be good to adhere to the Hono code formatting style when possible, with the freedom to keep some lines with custom formatting. While I think some added linebreaks in the code in this PR for overly long lines wouldn't hurt, I don't see a direct need to change things.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540993456", "createdAt": "2020-12-11T14:38:59Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -227,7 +406,40 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU3NzE5MA=="}, "originalCommit": {"oid": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk5NTQ0Nw==", "bodyText": "I applied the formatter in the latest commit. As I said, in my opinion it makes things worse... :-(", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540995447", "createdAt": "2020-12-11T14:42:05Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -227,7 +406,40 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU3NzE5MA=="}, "originalCommit": {"oid": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA0MjEwMQ==", "bodyText": "I managed to find a middle ground between the formatter and readability together with @kaniyan.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r541042101", "createdAt": "2020-12-11T15:47:44Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -227,7 +406,40 @@ public final void setTenantInformationService(final TenantInformationService ten\n                                 final RegistrationResult deviceResult = deviceInfoTracker.result();\n                                 final RegistrationResult gatewayResult = gatewayInfoTracker.result();\n \n-                                if (!isDeviceEnabled(deviceResult)) {\n+                                if (deviceResult.isNotFound() && !gatewayResult.isNotFound()\n+                                        && isDeviceEnabled(gatewayResult) && hasAuthorityForAutoRegistration(gatewayResult)) {\n+\n+                                    final Device device = new Device()\n+                                        .setEnabled(true)\n+                                        .setVia(Collections.singletonList(gatewayId));\n+\n+                                    final JsonArray memberOf = gatewayResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)\n+                                            .getJsonArray(RegistryManagementConstants.FIELD_MEMBER_OF);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU3NzE5MA=="}, "originalCommit": {"oid": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTMwODYyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNDoyMzowNlrOH5DInQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQwOTo0NTo0MFrOH9SiQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU4MjIzNw==", "bodyText": "I think it has been accidentally misspelt as authorties instead of authorities.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r529582237", "createdAt": "2020-11-24T14:23:06Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -433,10 +653,27 @@ private boolean isDeviceEnabled(final RegistrationResult registrationResult) {\n                 isDeviceEnabled(registrationResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA));\n     }\n \n+    private boolean wasDeviceAutoProvisioned(final JsonObject registrationData) {\n+        return registrationData.getJsonObject(RegistryManagementConstants.FIELD_STATUS, new JsonObject())\n+                .getBoolean(RegistrationConstants.FIELD_AUTO_PROVISIONED, Boolean.FALSE);\n+    }\n+\n+    private boolean wasAutoProvisioningNotificationSent(final JsonObject registrationData) {\n+        return registrationData.getJsonObject(RegistryManagementConstants.FIELD_STATUS, new JsonObject())\n+                .getBoolean(RegistrationConstants.FIELD_AUTO_PROVISIONING_NOTIFICATION_SENT, Boolean.FALSE);\n+    }\n+\n     private boolean isDeviceEnabled(final JsonObject registrationData) {\n         return registrationData.getBoolean(RegistrationConstants.FIELD_ENABLED, Boolean.TRUE);\n     }\n \n+    private boolean hasAuthorityForAutoRegistration(final RegistrationResult registrationResult) {\n+        final JsonArray authorties = registrationResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3"}, "originalPosition": 322}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDAyODg2Ng==", "bodyText": "Yes, thanks for spotting.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r534028866", "createdAt": "2020-12-02T09:45:40Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -433,10 +653,27 @@ private boolean isDeviceEnabled(final RegistrationResult registrationResult) {\n                 isDeviceEnabled(registrationResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA));\n     }\n \n+    private boolean wasDeviceAutoProvisioned(final JsonObject registrationData) {\n+        return registrationData.getJsonObject(RegistryManagementConstants.FIELD_STATUS, new JsonObject())\n+                .getBoolean(RegistrationConstants.FIELD_AUTO_PROVISIONED, Boolean.FALSE);\n+    }\n+\n+    private boolean wasAutoProvisioningNotificationSent(final JsonObject registrationData) {\n+        return registrationData.getJsonObject(RegistryManagementConstants.FIELD_STATUS, new JsonObject())\n+                .getBoolean(RegistrationConstants.FIELD_AUTO_PROVISIONING_NOTIFICATION_SENT, Boolean.FALSE);\n+    }\n+\n     private boolean isDeviceEnabled(final JsonObject registrationData) {\n         return registrationData.getBoolean(RegistrationConstants.FIELD_ENABLED, Boolean.TRUE);\n     }\n \n+    private boolean hasAuthorityForAutoRegistration(final RegistrationResult registrationResult) {\n+        final JsonArray authorties = registrationResult.getPayload().getJsonObject(RegistrationConstants.FIELD_DATA)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU4MjIzNw=="}, "originalCommit": {"oid": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3"}, "originalPosition": 322}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTMxMDA4OnYy", "diffSide": "RIGHT", "path": "site/documentation/content/api/management/device-registry-v1.yaml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNDoyMzoyN1rOH5DJmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNDoyMzoyN1rOH5DJmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU4MjQ5MQ==", "bodyText": "I think it has been accidentally misspelt as authorties instead of authorities.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r529582491", "createdAt": "2020-11-24T14:23:27Z", "author": {"login": "kaniyan"}, "path": "site/documentation/content/api/management/device-registry-v1.yaml", "diffHunk": "@@ -988,6 +988,14 @@ components:\n                description: |\n                   The IDs of the gateway groups that this device is a member of.\n                   Note that neither \"via\" nor \"viaGroups\" must be set if \"memberOf\" is set.\n+            \"authorities\":\n+               type: array\n+               items:\n+                  type: string\n+               description: |\n+                  The authorties granted to a device. Applies to gateways only currently: the authority", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cc4fbbd9f67104e089bd2bb3e2d1be222bff8a3"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDMzNTg0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNjoyOTo1OFrOICEmCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOTo0MToyM1rOICLZxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MzMzOQ==", "bodyText": "Missing Javadoc.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539043339", "createdAt": "2020-12-09T06:29:58Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -73,27 +111,24 @@ public final void setTenantInformationService(final TenantInformationService ten\n         this.tenantInformationService = tenantInformationService;\n     }\n \n+    public TenantInformationService getTenantInformationService() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE1NDg4Nw==", "bodyText": "Removed method, was obsolete anyway.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539154887", "createdAt": "2020-12-09T09:41:23Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -73,27 +111,24 @@ public final void setTenantInformationService(final TenantInformationService ten\n         this.tenantInformationService = tenantInformationService;\n     }\n \n+    public TenantInformationService getTenantInformationService() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MzMzOQ=="}, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDMzODA3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNjozMDo1MFrOICEnOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOTo0MTozMlrOICLaQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MzY0Mw==", "bodyText": "Add comma: \"If set,\"", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539043643", "createdAt": "2020-12-09T06:30:50Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -73,27 +111,24 @@ public final void setTenantInformationService(final TenantInformationService ten\n         this.tenantInformationService = tenantInformationService;\n     }\n \n+    public TenantInformationService getTenantInformationService() {\n+        return tenantInformationService;\n+    }\n+\n     /**\n-     * Gets device registration data by device ID.\n+     * Sets the AutoProvisioner to use.\n+     * <p>\n+     * If set gateway based auto-provisioning will be performed. Defaults to {@code null} meaning auto-provisioning", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE1NTAwOQ==", "bodyText": "Done.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539155009", "createdAt": "2020-12-09T09:41:32Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -73,27 +111,24 @@ public final void setTenantInformationService(final TenantInformationService ten\n         this.tenantInformationService = tenantInformationService;\n     }\n \n+    public TenantInformationService getTenantInformationService() {\n+        return tenantInformationService;\n+    }\n+\n     /**\n-     * Gets device registration data by device ID.\n+     * Sets the AutoProvisioner to use.\n+     * <p>\n+     * If set gateway based auto-provisioning will be performed. Defaults to {@code null} meaning auto-provisioning", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0MzY0Mw=="}, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDM0MDk0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNjozMTo1NVrOICEo3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOTo0MTozN1rOICLaeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NDA2MA==", "bodyText": "deviceManagementService and deviceRegistrationInformationService can be final.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539044060", "createdAt": "2020-12-09T06:31:55Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private DeviceManagementService deviceManagementService;\n+\n+    private DeviceRegistrationInformationService deviceRegistrationInformationService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE1NTA2Ng==", "bodyText": "Done.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539155066", "createdAt": "2020-12-09T09:41:37Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private DeviceManagementService deviceManagementService;\n+\n+    private DeviceRegistrationInformationService deviceRegistrationInformationService;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0NDA2MA=="}, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDM2OTU0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNjo0MTozOVrOICE4hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOTo0MTo0MVrOICLanA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0ODA3MA==", "bodyText": "In almost all of Hono (except for the JDBC packages), Future.compose instead of Future.flatMap is used (flatMap is an alias for compose here). Therefore I would prefer that here for better readability.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539048070", "createdAt": "2020-12-09T06:41:39Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -53,6 +55,18 @@\n                 });\n     }\n \n+    @Override\n+    public Future<TenantResult<TenantObject>> getTenant(final String tenantId, final Span span) {\n+        return service.get(tenantId, span)\n+                .flatMap(result -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE1NTEwMA==", "bodyText": "Done.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539155100", "createdAt": "2020-12-09T09:41:41Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -53,6 +55,18 @@\n                 });\n     }\n \n+    @Override\n+    public Future<TenantResult<TenantObject>> getTenant(final String tenantId, final Span span) {\n+        return service.get(tenantId, span)\n+                .flatMap(result -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA0ODA3MA=="}, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDM5MjM4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNjo0OToyOVrOICFFPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMTozMToyM1rOID02xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MTMyNQ==", "bodyText": "According to the Javadoc in the interface, this method returns a succeeded Future with 404 status if no corresponding tenant was found. So, a result.isNotFound() case, returning a succeeded Future, seems to be missing here.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539051325", "createdAt": "2020-12-09T06:49:29Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -53,6 +55,18 @@\n                 });\n     }\n \n+    @Override\n+    public Future<TenantResult<TenantObject>> getTenant(final String tenantId, final Span span) {\n+        return service.get(tenantId, span)\n+                .flatMap(result -> {\n+                    if (result.isOk()) {\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_OK, result.getPayload().mapTo(TenantObject.class)));\n+                    } else {\n+                        return Future.failedFuture(\"cannot get tenant [\" + tenantId + \"]: \" + result.getStatus() + \" \" + result.getPayload());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE2ODY5OQ==", "bodyText": "I adapted the JavaDoc, since there is no client code relying on this.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539168699", "createdAt": "2020-12-09T10:00:22Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -53,6 +55,18 @@\n                 });\n     }\n \n+    @Override\n+    public Future<TenantResult<TenantObject>> getTenant(final String tenantId, final Span span) {\n+        return service.get(tenantId, span)\n+                .flatMap(result -> {\n+                    if (result.isOk()) {\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_OK, result.getPayload().mapTo(TenantObject.class)));\n+                    } else {\n+                        return Future.failedFuture(\"cannot get tenant [\" + tenantId + \"]: \" + result.getStatus() + \" \" + result.getPayload());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MTMyNQ=="}, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3NjE1Nw==", "bodyText": "I think returning a succeeded Future with 404 result would be more consistent here, though. That is also the behaviour of TenantService.get and CredentialsService.get for example.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539176157", "createdAt": "2020-12-09T10:11:10Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -53,6 +55,18 @@\n                 });\n     }\n \n+    @Override\n+    public Future<TenantResult<TenantObject>> getTenant(final String tenantId, final Span span) {\n+        return service.get(tenantId, span)\n+                .flatMap(result -> {\n+                    if (result.isOk()) {\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_OK, result.getPayload().mapTo(TenantObject.class)));\n+                    } else {\n+                        return Future.failedFuture(\"cannot get tenant [\" + tenantId + \"]: \" + result.getStatus() + \" \" + result.getPayload());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MTMyNQ=="}, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3ODc2Nw==", "bodyText": "In my opinion this just adds more unnecessary code which has to be maintained (and understood). I tend to follow the YAGNI principle here rather. If there's actually more than one client, this code can still be adapted.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539178767", "createdAt": "2020-12-09T10:14:55Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -53,6 +55,18 @@\n                 });\n     }\n \n+    @Override\n+    public Future<TenantResult<TenantObject>> getTenant(final String tenantId, final Span span) {\n+        return service.get(tenantId, span)\n+                .flatMap(result -> {\n+                    if (result.isOk()) {\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_OK, result.getPayload().mapTo(TenantObject.class)));\n+                    } else {\n+                        return Future.failedFuture(\"cannot get tenant [\" + tenantId + \"]: \" + result.getStatus() + \" \" + result.getPayload());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MTMyNQ=="}, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQzMDM0MA==", "bodyText": "FMPOV, letting the places where getTenant gets called also handle the isError() case, would also make the code more robust against other TenantInformationService implementations which might (by accident) just pass along the TenantService.get result.\nAnd passing along that result would probably make the code above simpler. I guess this should work:\nreturn Future.succeededFuture(result.map(p -> p.mapTo(TenantObject.class)));  (instead of the \"if.. else\" block).\n@kaniyan @sophokles73 Other opinions?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539430340", "createdAt": "2020-12-09T15:59:49Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -53,6 +55,18 @@\n                 });\n     }\n \n+    @Override\n+    public Future<TenantResult<TenantObject>> getTenant(final String tenantId, final Span span) {\n+        return service.get(tenantId, span)\n+                .flatMap(result -> {\n+                    if (result.isOk()) {\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_OK, result.getPayload().mapTo(TenantObject.class)));\n+                    } else {\n+                        return Future.failedFuture(\"cannot get tenant [\" + tenantId + \"]: \" + result.getStatus() + \" \" + result.getPayload());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MTMyNQ=="}, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5NDMxOA==", "bodyText": "I think the result cannot be mapped to a TenantObject in an error case, since there is no such object in the payload then.\nHence the if clause is still required as far as I can see. It will then have to return null as the tenant object.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540794318", "createdAt": "2020-12-11T09:06:32Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -53,6 +55,18 @@\n                 });\n     }\n \n+    @Override\n+    public Future<TenantResult<TenantObject>> getTenant(final String tenantId, final Span span) {\n+        return service.get(tenantId, span)\n+                .flatMap(result -> {\n+                    if (result.isOk()) {\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_OK, result.getPayload().mapTo(TenantObject.class)));\n+                    } else {\n+                        return Future.failedFuture(\"cannot get tenant [\" + tenantId + \"]: \" + result.getStatus() + \" \" + result.getPayload());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MTMyNQ=="}, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg4MjYzMQ==", "bodyText": "The p -> p.mapTo(TenantObject.class) parameter will only be applied on a non-null payload, the TenantResult.map() method using a null TenantObject in the created TenantResult if the payload is null. But your solution works just as well.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540882631", "createdAt": "2020-12-11T11:31:23Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/AutowiredTenantInformationService.java", "diffHunk": "@@ -53,6 +55,18 @@\n                 });\n     }\n \n+    @Override\n+    public Future<TenantResult<TenantObject>> getTenant(final String tenantId, final Span span) {\n+        return service.get(tenantId, span)\n+                .flatMap(result -> {\n+                    if (result.isOk()) {\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_OK, result.getPayload().mapTo(TenantObject.class)));\n+                    } else {\n+                        return Future.failedFuture(\"cannot get tenant [\" + tenantId + \"]: \" + result.getStatus() + \" \" + result.getPayload());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MTMyNQ=="}, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDM5NzY3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNjo1MToyMFrOICFICw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzo0NDozM1rOICGo7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MjA0Mw==", "bodyText": "\"device's\" - same in getter below.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539052043", "createdAt": "2020-12-09T06:51:20Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -302,4 +311,25 @@ public final Device setStatus(final DeviceStatus status) {\n     public final DeviceStatus getStatus() {\n         return status;\n     }\n+\n+    /**\n+     * Sets the authorities granted to this device.\n+     *\n+     * @param authorities The devices' authorities.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3MzM2Mg==", "bodyText": "I think this is correct as this is a possessive of a plural noun:\nThe possessive of a plural noun is formed by adding only an apostrophe when the noun ends in s, and by adding both        an apostrophe and s when it ends in a letter other than s.\n\nSee: https://www.thepunctuationguide.com/apostrophe.html#possessives", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539073362", "createdAt": "2020-12-09T07:38:00Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -302,4 +311,25 @@ public final Device setStatus(final DeviceStatus status) {\n     public final DeviceStatus getStatus() {\n         return status;\n     }\n+\n+    /**\n+     * Sets the authorities granted to this device.\n+     *\n+     * @param authorities The devices' authorities.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MjA0Mw=="}, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3Njg0NQ==", "bodyText": "But it's about the authorities of one device (\"this\") here, isn't it?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539076845", "createdAt": "2020-12-09T07:44:33Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -302,4 +311,25 @@ public final Device setStatus(final DeviceStatus status) {\n     public final DeviceStatus getStatus() {\n         return status;\n     }\n+\n+    /**\n+     * Sets the authorities granted to this device.\n+     *\n+     * @param authorities The devices' authorities.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1MjA0Mw=="}, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDQxMDkzOnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/test/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationServiceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNjo1NTo0OFrOICFPSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDowNToyNVrOICMdlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1Mzg5Ng==", "bodyText": "To make this more robust, I would suggest adding:\nif (!deviceId.isPresent()) return Future.failedFuture(\"missing device id\");", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539053896", "createdAt": "2020-12-09T06:55:48Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/test/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationServiceTest.java", "diffHunk": "@@ -113,6 +165,255 @@ public void testAssertRegistrationContainsDeviceInfo(final VertxTestContext ctx)\n             }));\n     }\n \n+    /**\n+     * Verifies that a device is auto-provisioned when an authorized gateway sends data on behalf of it.\n+     *\n+     * @param ctx The vert.x test context.\n+     */\n+    @Test\n+    public void testAssertRegistrationPerformsAutoProvisioningForAuthorizedGateway(final VertxTestContext ctx) {\n+        mockAssertRegistration(GATEWAY_ID, Collections.singletonList(GATEWAY_GROUP_ID), Collections.singletonList(RegistryManagementConstants.AUTHORITY_AUTO_PROVISIONING_ENABLED));\n+        mockAssertRegistration(DEVICE_ID, true);\n+        mockAddEdgeDevice(HttpURLConnection.HTTP_CREATED);\n+\n+        service.assertRegistration(Constants.DEFAULT_TENANT, DEVICE_ID, GATEWAY_ID, span)\n+                .onComplete(ctx.succeeding(result -> {\n+                    ctx.verify(() -> {\n+                        verifySuccessfulAutoProvisioning(result);\n+                    });\n+                    ctx.completeNow();\n+                }));\n+    }\n+\n+    private void mockAssertRegistration(final String deviceId, final List<String> memberOf, final List<String> authorities) {\n+        final JsonObject registeredGateway = new JsonObject()\n+                .put(RegistryManagementConstants.FIELD_MEMBER_OF, new JsonArray(memberOf))\n+                .put(RegistryManagementConstants.FIELD_AUTHORITIES, new JsonArray(authorities));\n+\n+        when(service.processAssertRegistration(eq(DeviceKey.from(TenantKey.from(Constants.DEFAULT_TENANT), deviceId)), any(Span.class)))\n+                .thenReturn(Future.succeededFuture(RegistrationResult.from(HttpURLConnection.HTTP_OK,\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId)\n+                                .put(RegistrationConstants.FIELD_DATA, registeredGateway))));\n+\n+    }\n+\n+    private void mockAssertRegistration(final String deviceId, final boolean autoProvisioningNotificationSent) {\n+        when(service.processAssertRegistration(eq(DeviceKey.from(TenantKey.from(Constants.DEFAULT_TENANT), deviceId)), any(Span.class)))\n+                .thenReturn(Future.succeededFuture(RegistrationResult.from(HttpURLConnection.HTTP_NOT_FOUND)))\n+                .thenReturn(Future.succeededFuture(newRegistrationResult(deviceId, autoProvisioningNotificationSent)));\n+\n+    }\n+\n+    private RegistrationResult newRegistrationResult(final String deviceId, final boolean autoProvisioningNotificationSent) {\n+        return RegistrationResult.from(HttpURLConnection.HTTP_OK,\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId)\n+                        .put(RegistrationConstants.FIELD_DATA, new JsonObject()\n+                                .put(RegistrationConstants.FIELD_VIA, AbstractRegistrationServiceTest.GATEWAY_ID)\n+                                .put(RegistryManagementConstants.FIELD_STATUS, new JsonObject()\n+                                        .put(RegistrationConstants.FIELD_AUTO_PROVISIONED, true)\n+                                        .put(RegistrationConstants.FIELD_AUTO_PROVISIONING_NOTIFICATION_SENT, autoProvisioningNotificationSent))));\n+    }\n+\n+    /**\n+     * Verifies that auto-provisioning still succeeds if the device to be auto-provisioned has already been created\n+     * (e.g. by a concurrently running request) and the notification has already been sent.\n+     *\n+     * @param ctx The vert.x test context.\n+     */\n+    @Test\n+    public void testAssertRegistrationCanAutoProvisionForAlreadyPresentEdgeDevice(final VertxTestContext ctx) {\n+        mockAssertRegistration(GATEWAY_ID, Collections.singletonList(GATEWAY_GROUP_ID), Collections.singletonList(RegistryManagementConstants.AUTHORITY_AUTO_PROVISIONING_ENABLED));\n+        mockAssertRegistration(DEVICE_ID, true);\n+        mockAddEdgeDevice(HttpURLConnection.HTTP_CONFLICT);\n+\n+        service.assertRegistration(Constants.DEFAULT_TENANT, DEVICE_ID, GATEWAY_ID, span)\n+                .onComplete(ctx.succeeding(result -> {\n+                    ctx.verify(() -> {\n+                        assertThat(result.getStatus()).isEqualTo(HttpURLConnection.HTTP_OK);\n+\n+                        verify(service).createDevice(any(), any(), any(), any());\n+\n+                        verify(sender, never()).sendAndWaitForOutcome(any(), any());\n+                        verify(service, never()).updateDevice(eq(Constants.DEFAULT_TENANT), eq(DEVICE_ID), any(), any(), any());\n+                    });\n+                    ctx.completeNow();\n+                }));\n+    }\n+\n+    private void mockAddEdgeDevice(final int httpOk) {\n+        when(service.createDevice(any(), any(), any(), any()))\n+                .thenAnswer((Answer<Future<OperationResult<Id>>>) invocation -> {\n+                    final Optional<String> deviceId = invocation.getArgument(1);\n+                    return Future.succeededFuture(OperationResult.ok(httpOk, Id.of(deviceId.get()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE3MjI0NQ==", "bodyText": "Added...", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539172245", "createdAt": "2020-12-09T10:05:25Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/test/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationServiceTest.java", "diffHunk": "@@ -113,6 +165,255 @@ public void testAssertRegistrationContainsDeviceInfo(final VertxTestContext ctx)\n             }));\n     }\n \n+    /**\n+     * Verifies that a device is auto-provisioned when an authorized gateway sends data on behalf of it.\n+     *\n+     * @param ctx The vert.x test context.\n+     */\n+    @Test\n+    public void testAssertRegistrationPerformsAutoProvisioningForAuthorizedGateway(final VertxTestContext ctx) {\n+        mockAssertRegistration(GATEWAY_ID, Collections.singletonList(GATEWAY_GROUP_ID), Collections.singletonList(RegistryManagementConstants.AUTHORITY_AUTO_PROVISIONING_ENABLED));\n+        mockAssertRegistration(DEVICE_ID, true);\n+        mockAddEdgeDevice(HttpURLConnection.HTTP_CREATED);\n+\n+        service.assertRegistration(Constants.DEFAULT_TENANT, DEVICE_ID, GATEWAY_ID, span)\n+                .onComplete(ctx.succeeding(result -> {\n+                    ctx.verify(() -> {\n+                        verifySuccessfulAutoProvisioning(result);\n+                    });\n+                    ctx.completeNow();\n+                }));\n+    }\n+\n+    private void mockAssertRegistration(final String deviceId, final List<String> memberOf, final List<String> authorities) {\n+        final JsonObject registeredGateway = new JsonObject()\n+                .put(RegistryManagementConstants.FIELD_MEMBER_OF, new JsonArray(memberOf))\n+                .put(RegistryManagementConstants.FIELD_AUTHORITIES, new JsonArray(authorities));\n+\n+        when(service.processAssertRegistration(eq(DeviceKey.from(TenantKey.from(Constants.DEFAULT_TENANT), deviceId)), any(Span.class)))\n+                .thenReturn(Future.succeededFuture(RegistrationResult.from(HttpURLConnection.HTTP_OK,\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId)\n+                                .put(RegistrationConstants.FIELD_DATA, registeredGateway))));\n+\n+    }\n+\n+    private void mockAssertRegistration(final String deviceId, final boolean autoProvisioningNotificationSent) {\n+        when(service.processAssertRegistration(eq(DeviceKey.from(TenantKey.from(Constants.DEFAULT_TENANT), deviceId)), any(Span.class)))\n+                .thenReturn(Future.succeededFuture(RegistrationResult.from(HttpURLConnection.HTTP_NOT_FOUND)))\n+                .thenReturn(Future.succeededFuture(newRegistrationResult(deviceId, autoProvisioningNotificationSent)));\n+\n+    }\n+\n+    private RegistrationResult newRegistrationResult(final String deviceId, final boolean autoProvisioningNotificationSent) {\n+        return RegistrationResult.from(HttpURLConnection.HTTP_OK,\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId)\n+                        .put(RegistrationConstants.FIELD_DATA, new JsonObject()\n+                                .put(RegistrationConstants.FIELD_VIA, AbstractRegistrationServiceTest.GATEWAY_ID)\n+                                .put(RegistryManagementConstants.FIELD_STATUS, new JsonObject()\n+                                        .put(RegistrationConstants.FIELD_AUTO_PROVISIONED, true)\n+                                        .put(RegistrationConstants.FIELD_AUTO_PROVISIONING_NOTIFICATION_SENT, autoProvisioningNotificationSent))));\n+    }\n+\n+    /**\n+     * Verifies that auto-provisioning still succeeds if the device to be auto-provisioned has already been created\n+     * (e.g. by a concurrently running request) and the notification has already been sent.\n+     *\n+     * @param ctx The vert.x test context.\n+     */\n+    @Test\n+    public void testAssertRegistrationCanAutoProvisionForAlreadyPresentEdgeDevice(final VertxTestContext ctx) {\n+        mockAssertRegistration(GATEWAY_ID, Collections.singletonList(GATEWAY_GROUP_ID), Collections.singletonList(RegistryManagementConstants.AUTHORITY_AUTO_PROVISIONING_ENABLED));\n+        mockAssertRegistration(DEVICE_ID, true);\n+        mockAddEdgeDevice(HttpURLConnection.HTTP_CONFLICT);\n+\n+        service.assertRegistration(Constants.DEFAULT_TENANT, DEVICE_ID, GATEWAY_ID, span)\n+                .onComplete(ctx.succeeding(result -> {\n+                    ctx.verify(() -> {\n+                        assertThat(result.getStatus()).isEqualTo(HttpURLConnection.HTTP_OK);\n+\n+                        verify(service).createDevice(any(), any(), any(), any());\n+\n+                        verify(sender, never()).sendAndWaitForOutcome(any(), any());\n+                        verify(service, never()).updateDevice(eq(Constants.DEFAULT_TENANT), eq(DEVICE_ID), any(), any(), any());\n+                    });\n+                    ctx.completeNow();\n+                }));\n+    }\n+\n+    private void mockAddEdgeDevice(final int httpOk) {\n+        when(service.createDevice(any(), any(), any(), any()))\n+                .thenAnswer((Answer<Future<OperationResult<Id>>>) invocation -> {\n+                    final Optional<String> deviceId = invocation.getArgument(1);\n+                    return Future.succeededFuture(OperationResult.ok(httpOk, Id.of(deviceId.get()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1Mzg5Ng=="}, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 202}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDQxNDQ1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/DeviceRegistrationInformationService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNjo1NzowNVrOICFRVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNjo1NzowNVrOICFRVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA1NDQyMg==", "bodyText": "Just 2020.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r539054422", "createdAt": "2020-12-09T06:57:05Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/DeviceRegistrationInformationService.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50592ff8f74a36e6bde7f314a0ab4b2d1564e809"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzMzMDEyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODowNzo0MVrOIDWlrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODowNzo0MVrOIDWlrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4NjczNA==", "bodyText": "What will happen to opentracingTracer.getClass().getName() when opentracingTracer is null? The null check in the next line should be done first.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540386734", "createdAt": "2020-12-10T18:07:41Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {\n+        this.deviceManagementService = deviceManagementService;\n+        this.deviceRegistrationInformationService = deviceRegistrationInformationService;\n+    }\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the service to use for checking existence of tenants.\n+     * <p>\n+     * If not set, tenant existence will not be verified.\n+     *\n+     * @param tenantInformationService The tenant information service.\n+     * @throws NullPointerException if service is {@code null};\n+     */\n+    @Autowired(required = false)\n+    public final void setTenantInformationService(final TenantInformationService tenantInformationService) {\n+        this.tenantInformationService = Objects.requireNonNull(tenantInformationService);\n+        LOG.info(\"using {}\", tenantInformationService);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     * @throws NullPointerException if the opentracingTracer is {@code null}.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzM0NTg1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoxMToxNFrOIDWu_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzowMTozMFrOIFCZ_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4OTExOQ==", "bodyText": "AutoProvisionerConfigProperties#DEFAULT_RETRY_EVENT_SENDING_DELAY is inaccessible from here as it is declared as private.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540389119", "createdAt": "2020-12-10T18:11:14Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {\n+        this.deviceManagementService = deviceManagementService;\n+        this.deviceRegistrationInformationService = deviceRegistrationInformationService;\n+    }\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the service to use for checking existence of tenants.\n+     * <p>\n+     * If not set, tenant existence will not be verified.\n+     *\n+     * @param tenantInformationService The tenant information service.\n+     * @throws NullPointerException if service is {@code null};\n+     */\n+    @Autowired(required = false)\n+    public final void setTenantInformationService(final TenantInformationService tenantInformationService) {\n+        this.tenantInformationService = Objects.requireNonNull(tenantInformationService);\n+        LOG.info(\"using {}\", tenantInformationService);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     * @throws NullPointerException if the opentracingTracer is {@code null}.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);\n+    }\n+\n+    /**\n+     * Sets the configuration to use for auto-provisioning.\n+     *\n+     * @param config The configuration to set.\n+     * @throws NullPointerException if the config is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final AutoProvisionerConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    private Future<ProtonDelivery> sendAutoProvisioningEvent(\n+            final String tenantId,\n+            final String deviceId,\n+            final String gatewayId,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+\n+        LOG.debug(\"sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId);\n+\n+        final Future<TenantResult<TenantObject>> tenantTracker = tenantInformationService.getTenant(tenantId, span);\n+        final Future<DownstreamSender> senderTracker = downstreamSenderFactory.getOrCreateEventSender(tenantId);\n+\n+        return CompositeFuture.all(tenantTracker, senderTracker).compose(ok -> {\n+            final Map<String, Object> props = new HashMap<>();\n+            props.put(MessageHelper.APP_PROPERTY_QOS, QoS.AT_LEAST_ONCE.ordinal());\n+            props.put(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId);\n+            props.put(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);\n+            props.put(MessageHelper.APP_PROPERTY_GATEWAY_ID, gatewayId);\n+            props.put(MessageHelper.APP_PROPERTY_REGISTRATION_STATUS, EventConstants.RegistrationStatus.NEW.name());\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADAPTER, Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY);\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADDRESS, EventConstants.EVENT_ENDPOINT);\n+\n+            final Message msg = MessageHelper.newMessage(\n+                    ResourceIdentifier.from(EventConstants.EVENT_ENDPOINT, tenantId, deviceId),\n+                    EventConstants.CONTENT_TYPE_EMPTY_NOTIFICATION,\n+                    null,\n+                    tenantTracker.result().getPayload(),\n+                    props,\n+                    null,\n+                    false,\n+                    false);\n+\n+            final DownstreamSender sender = senderTracker.result();\n+            return sender.sendAndWaitForOutcome(msg, span.context())\n+                    .onFailure(t -> LOG.info(\"error sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId));\n+        });\n+    }\n+\n+    /**\n+     * Auto-provisions the edge device using the given device id and the given registration data.\n+     *\n+     * @param tenantId The id of the tenant for which the edge device should be provisioned.\n+     * @param deviceId The id of the edge device which should be provisioned.\n+     * @param gatewayId The id of the edge device's gateway.\n+     * @param device The registration data for the device to be auto-provisioned.\n+     * @param spanContext The tracing context to be used by this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    public Future<JsonObject> performAutoProvisioning(final String tenantId, final String deviceId,\n+            final String gatewayId, final Device device, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper\n+                .buildChildSpan(tracer, spanContext, \"auto-provision device for gateway\", Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY)\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT)\n+                .withTag(TracingHelper.TAG_GATEWAY_ID, gatewayId)\n+                .start();\n+        TracingHelper.setDeviceTags(span, tenantId, deviceId);\n+\n+        return deviceManagementService.createDevice(tenantId, Optional.of(deviceId), device, span)\n+                // make sure an HTTP_CONFLICT result is handled as an OperationResult\n+                .recover(thr -> ServiceInvocationException.extractStatusCode(thr) == HttpURLConnection.HTTP_CONFLICT\n+                        ? Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT))\n+                        : Future.failedFuture(thr))\n+                .compose(addEdgeDeviceResult -> {\n+                    if (addEdgeDeviceResult.isError()) {\n+                        if (addEdgeDeviceResult.getStatus() != HttpURLConnection.HTTP_CONFLICT) {\n+                            return Future.failedFuture(StatusCodeMapper.from(addEdgeDeviceResult.getStatus(),\n+                                    String.format(\"failed to add edge device (status %d)\", addEdgeDeviceResult.getStatus())));\n+                        }\n+\n+                        // handle HTTP_CONFLICT, meaning the device already exists\n+                        span.log(\"device already exists\");\n+                        LOG.debug(\"device [{}] for gateway [{}] already created by concurrent auto-provisioning [tenant-id: {}]\",\n+                                deviceId, gatewayId, tenantId);\n+                        return deviceRegistrationInformationService.processAssertRegistration(DeviceKey.from(TenantKey.from(tenantId), deviceId), span)\n+                                .compose(assertRegistrationResult -> {\n+                                    final JsonObject deviceData = assertRegistrationResult.getPayload()\n+                                            .getJsonObject(RegistrationConstants.FIELD_DATA, new JsonObject());\n+                                    // ensure that a notification event gets sent (even if we might send duplicate events)\n+                                    return sendDelayedAutoProvisioningNotificationIfNeeded(tenantId, deviceId, gatewayId, deviceData, span)\n+                                            .map(deviceData);\n+                                });\n+                    }\n+\n+                    span.log(\"device created\");\n+                    LOG.trace(\"device [{}] for gateway [{}] successfully created by auto-provisioning [tenant-id: {}]\",\n+                            deviceId, gatewayId, tenantId);\n+                    return sendAutoProvisioningEvent(tenantId, deviceId, gatewayId, span)\n+                            .compose(sendEmptyEventOk -> deviceRegistrationInformationService.processAssertRegistration(DeviceKey.from((TenantKey.from(tenantId)), deviceId), span)\n+                                    .compose(deviceRegistrationData -> {\n+                                        if (!deviceRegistrationData.isOk()) {\n+                                            span.log(\"update of notification flag failed\");\n+                                            LOG.warn(\"notification flag of device [{}] for gateway [{}] of tenant [tenant-id: {}] could not be updated\",\n+                                                    deviceId, gatewayId, tenantId);\n+                                            return Future.failedFuture(StatusCodeMapper.from(deviceRegistrationData.getStatus(),\n+                                                    String.format(\"update of notification flag failed (status %d)\", deviceRegistrationData.getStatus())));\n+                                        }\n+\n+                                        final JsonObject deviceData = deviceRegistrationData.getPayload()\n+                                                .getJsonObject(RegistrationConstants.FIELD_DATA, new JsonObject());\n+                                        return setAutoProvisioningNotificationSent(tenantId, deviceId, deviceData, span)\n+                                                .map(deviceData);\n+                                    }));\n+                })\n+                .onFailure(thr -> TracingHelper.logError(span, thr))\n+                .onComplete(ar -> span.finish());\n+    }\n+\n+    /**\n+     * Notify northbound applications of an auto-provisioned device.\n+     *\n+     * @param tenantId The id of the tenant for which the edge device should be provisioned.\n+     * @param deviceId The id of the edge device which should be provisioned.\n+     * @param gatewayId The id of the edge device's gateway.\n+     * @param deviceData The data of the edge device.\n+     * @param span The span to be used for tracing this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *\n+     * @see AutoProvisionerConfigProperties#DEFAULT_RETRY_EVENT_SENDING_DELAY", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645"}, "originalPosition": 312}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk3MzY5MA==", "bodyText": "I think it's ok to keep it like this. It doesn't lead to a Javadoc generation error and in an earlier discussion we kept it as well.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540973690", "createdAt": "2020-12-11T14:11:22Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {\n+        this.deviceManagementService = deviceManagementService;\n+        this.deviceRegistrationInformationService = deviceRegistrationInformationService;\n+    }\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the service to use for checking existence of tenants.\n+     * <p>\n+     * If not set, tenant existence will not be verified.\n+     *\n+     * @param tenantInformationService The tenant information service.\n+     * @throws NullPointerException if service is {@code null};\n+     */\n+    @Autowired(required = false)\n+    public final void setTenantInformationService(final TenantInformationService tenantInformationService) {\n+        this.tenantInformationService = Objects.requireNonNull(tenantInformationService);\n+        LOG.info(\"using {}\", tenantInformationService);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     * @throws NullPointerException if the opentracingTracer is {@code null}.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);\n+    }\n+\n+    /**\n+     * Sets the configuration to use for auto-provisioning.\n+     *\n+     * @param config The configuration to set.\n+     * @throws NullPointerException if the config is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final AutoProvisionerConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    private Future<ProtonDelivery> sendAutoProvisioningEvent(\n+            final String tenantId,\n+            final String deviceId,\n+            final String gatewayId,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+\n+        LOG.debug(\"sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId);\n+\n+        final Future<TenantResult<TenantObject>> tenantTracker = tenantInformationService.getTenant(tenantId, span);\n+        final Future<DownstreamSender> senderTracker = downstreamSenderFactory.getOrCreateEventSender(tenantId);\n+\n+        return CompositeFuture.all(tenantTracker, senderTracker).compose(ok -> {\n+            final Map<String, Object> props = new HashMap<>();\n+            props.put(MessageHelper.APP_PROPERTY_QOS, QoS.AT_LEAST_ONCE.ordinal());\n+            props.put(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId);\n+            props.put(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);\n+            props.put(MessageHelper.APP_PROPERTY_GATEWAY_ID, gatewayId);\n+            props.put(MessageHelper.APP_PROPERTY_REGISTRATION_STATUS, EventConstants.RegistrationStatus.NEW.name());\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADAPTER, Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY);\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADDRESS, EventConstants.EVENT_ENDPOINT);\n+\n+            final Message msg = MessageHelper.newMessage(\n+                    ResourceIdentifier.from(EventConstants.EVENT_ENDPOINT, tenantId, deviceId),\n+                    EventConstants.CONTENT_TYPE_EMPTY_NOTIFICATION,\n+                    null,\n+                    tenantTracker.result().getPayload(),\n+                    props,\n+                    null,\n+                    false,\n+                    false);\n+\n+            final DownstreamSender sender = senderTracker.result();\n+            return sender.sendAndWaitForOutcome(msg, span.context())\n+                    .onFailure(t -> LOG.info(\"error sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId));\n+        });\n+    }\n+\n+    /**\n+     * Auto-provisions the edge device using the given device id and the given registration data.\n+     *\n+     * @param tenantId The id of the tenant for which the edge device should be provisioned.\n+     * @param deviceId The id of the edge device which should be provisioned.\n+     * @param gatewayId The id of the edge device's gateway.\n+     * @param device The registration data for the device to be auto-provisioned.\n+     * @param spanContext The tracing context to be used by this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    public Future<JsonObject> performAutoProvisioning(final String tenantId, final String deviceId,\n+            final String gatewayId, final Device device, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper\n+                .buildChildSpan(tracer, spanContext, \"auto-provision device for gateway\", Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY)\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT)\n+                .withTag(TracingHelper.TAG_GATEWAY_ID, gatewayId)\n+                .start();\n+        TracingHelper.setDeviceTags(span, tenantId, deviceId);\n+\n+        return deviceManagementService.createDevice(tenantId, Optional.of(deviceId), device, span)\n+                // make sure an HTTP_CONFLICT result is handled as an OperationResult\n+                .recover(thr -> ServiceInvocationException.extractStatusCode(thr) == HttpURLConnection.HTTP_CONFLICT\n+                        ? Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT))\n+                        : Future.failedFuture(thr))\n+                .compose(addEdgeDeviceResult -> {\n+                    if (addEdgeDeviceResult.isError()) {\n+                        if (addEdgeDeviceResult.getStatus() != HttpURLConnection.HTTP_CONFLICT) {\n+                            return Future.failedFuture(StatusCodeMapper.from(addEdgeDeviceResult.getStatus(),\n+                                    String.format(\"failed to add edge device (status %d)\", addEdgeDeviceResult.getStatus())));\n+                        }\n+\n+                        // handle HTTP_CONFLICT, meaning the device already exists\n+                        span.log(\"device already exists\");\n+                        LOG.debug(\"device [{}] for gateway [{}] already created by concurrent auto-provisioning [tenant-id: {}]\",\n+                                deviceId, gatewayId, tenantId);\n+                        return deviceRegistrationInformationService.processAssertRegistration(DeviceKey.from(TenantKey.from(tenantId), deviceId), span)\n+                                .compose(assertRegistrationResult -> {\n+                                    final JsonObject deviceData = assertRegistrationResult.getPayload()\n+                                            .getJsonObject(RegistrationConstants.FIELD_DATA, new JsonObject());\n+                                    // ensure that a notification event gets sent (even if we might send duplicate events)\n+                                    return sendDelayedAutoProvisioningNotificationIfNeeded(tenantId, deviceId, gatewayId, deviceData, span)\n+                                            .map(deviceData);\n+                                });\n+                    }\n+\n+                    span.log(\"device created\");\n+                    LOG.trace(\"device [{}] for gateway [{}] successfully created by auto-provisioning [tenant-id: {}]\",\n+                            deviceId, gatewayId, tenantId);\n+                    return sendAutoProvisioningEvent(tenantId, deviceId, gatewayId, span)\n+                            .compose(sendEmptyEventOk -> deviceRegistrationInformationService.processAssertRegistration(DeviceKey.from((TenantKey.from(tenantId)), deviceId), span)\n+                                    .compose(deviceRegistrationData -> {\n+                                        if (!deviceRegistrationData.isOk()) {\n+                                            span.log(\"update of notification flag failed\");\n+                                            LOG.warn(\"notification flag of device [{}] for gateway [{}] of tenant [tenant-id: {}] could not be updated\",\n+                                                    deviceId, gatewayId, tenantId);\n+                                            return Future.failedFuture(StatusCodeMapper.from(deviceRegistrationData.getStatus(),\n+                                                    String.format(\"update of notification flag failed (status %d)\", deviceRegistrationData.getStatus())));\n+                                        }\n+\n+                                        final JsonObject deviceData = deviceRegistrationData.getPayload()\n+                                                .getJsonObject(RegistrationConstants.FIELD_DATA, new JsonObject());\n+                                        return setAutoProvisioningNotificationSent(tenantId, deviceId, deviceData, span)\n+                                                .map(deviceData);\n+                                    }));\n+                })\n+                .onFailure(thr -> TracingHelper.logError(span, thr))\n+                .onComplete(ar -> span.finish());\n+    }\n+\n+    /**\n+     * Notify northbound applications of an auto-provisioned device.\n+     *\n+     * @param tenantId The id of the tenant for which the edge device should be provisioned.\n+     * @param deviceId The id of the edge device which should be provisioned.\n+     * @param gatewayId The id of the edge device's gateway.\n+     * @param deviceData The data of the edge device.\n+     * @param span The span to be used for tracing this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *\n+     * @see AutoProvisionerConfigProperties#DEFAULT_RETRY_EVENT_SENDING_DELAY", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4OTExOQ=="}, "originalCommit": {"oid": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645"}, "originalPosition": 312}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA1ODQ0MQ==", "bodyText": "It won't throw any error. But in the generated doc, it will show as an invalid link and on clicking it takes to the target class and no information regarding that private field will be available.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r541058441", "createdAt": "2020-12-11T16:11:45Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {\n+        this.deviceManagementService = deviceManagementService;\n+        this.deviceRegistrationInformationService = deviceRegistrationInformationService;\n+    }\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the service to use for checking existence of tenants.\n+     * <p>\n+     * If not set, tenant existence will not be verified.\n+     *\n+     * @param tenantInformationService The tenant information service.\n+     * @throws NullPointerException if service is {@code null};\n+     */\n+    @Autowired(required = false)\n+    public final void setTenantInformationService(final TenantInformationService tenantInformationService) {\n+        this.tenantInformationService = Objects.requireNonNull(tenantInformationService);\n+        LOG.info(\"using {}\", tenantInformationService);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     * @throws NullPointerException if the opentracingTracer is {@code null}.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);\n+    }\n+\n+    /**\n+     * Sets the configuration to use for auto-provisioning.\n+     *\n+     * @param config The configuration to set.\n+     * @throws NullPointerException if the config is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final AutoProvisionerConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    private Future<ProtonDelivery> sendAutoProvisioningEvent(\n+            final String tenantId,\n+            final String deviceId,\n+            final String gatewayId,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+\n+        LOG.debug(\"sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId);\n+\n+        final Future<TenantResult<TenantObject>> tenantTracker = tenantInformationService.getTenant(tenantId, span);\n+        final Future<DownstreamSender> senderTracker = downstreamSenderFactory.getOrCreateEventSender(tenantId);\n+\n+        return CompositeFuture.all(tenantTracker, senderTracker).compose(ok -> {\n+            final Map<String, Object> props = new HashMap<>();\n+            props.put(MessageHelper.APP_PROPERTY_QOS, QoS.AT_LEAST_ONCE.ordinal());\n+            props.put(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId);\n+            props.put(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);\n+            props.put(MessageHelper.APP_PROPERTY_GATEWAY_ID, gatewayId);\n+            props.put(MessageHelper.APP_PROPERTY_REGISTRATION_STATUS, EventConstants.RegistrationStatus.NEW.name());\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADAPTER, Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY);\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADDRESS, EventConstants.EVENT_ENDPOINT);\n+\n+            final Message msg = MessageHelper.newMessage(\n+                    ResourceIdentifier.from(EventConstants.EVENT_ENDPOINT, tenantId, deviceId),\n+                    EventConstants.CONTENT_TYPE_EMPTY_NOTIFICATION,\n+                    null,\n+                    tenantTracker.result().getPayload(),\n+                    props,\n+                    null,\n+                    false,\n+                    false);\n+\n+            final DownstreamSender sender = senderTracker.result();\n+            return sender.sendAndWaitForOutcome(msg, span.context())\n+                    .onFailure(t -> LOG.info(\"error sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId));\n+        });\n+    }\n+\n+    /**\n+     * Auto-provisions the edge device using the given device id and the given registration data.\n+     *\n+     * @param tenantId The id of the tenant for which the edge device should be provisioned.\n+     * @param deviceId The id of the edge device which should be provisioned.\n+     * @param gatewayId The id of the edge device's gateway.\n+     * @param device The registration data for the device to be auto-provisioned.\n+     * @param spanContext The tracing context to be used by this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    public Future<JsonObject> performAutoProvisioning(final String tenantId, final String deviceId,\n+            final String gatewayId, final Device device, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper\n+                .buildChildSpan(tracer, spanContext, \"auto-provision device for gateway\", Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY)\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT)\n+                .withTag(TracingHelper.TAG_GATEWAY_ID, gatewayId)\n+                .start();\n+        TracingHelper.setDeviceTags(span, tenantId, deviceId);\n+\n+        return deviceManagementService.createDevice(tenantId, Optional.of(deviceId), device, span)\n+                // make sure an HTTP_CONFLICT result is handled as an OperationResult\n+                .recover(thr -> ServiceInvocationException.extractStatusCode(thr) == HttpURLConnection.HTTP_CONFLICT\n+                        ? Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT))\n+                        : Future.failedFuture(thr))\n+                .compose(addEdgeDeviceResult -> {\n+                    if (addEdgeDeviceResult.isError()) {\n+                        if (addEdgeDeviceResult.getStatus() != HttpURLConnection.HTTP_CONFLICT) {\n+                            return Future.failedFuture(StatusCodeMapper.from(addEdgeDeviceResult.getStatus(),\n+                                    String.format(\"failed to add edge device (status %d)\", addEdgeDeviceResult.getStatus())));\n+                        }\n+\n+                        // handle HTTP_CONFLICT, meaning the device already exists\n+                        span.log(\"device already exists\");\n+                        LOG.debug(\"device [{}] for gateway [{}] already created by concurrent auto-provisioning [tenant-id: {}]\",\n+                                deviceId, gatewayId, tenantId);\n+                        return deviceRegistrationInformationService.processAssertRegistration(DeviceKey.from(TenantKey.from(tenantId), deviceId), span)\n+                                .compose(assertRegistrationResult -> {\n+                                    final JsonObject deviceData = assertRegistrationResult.getPayload()\n+                                            .getJsonObject(RegistrationConstants.FIELD_DATA, new JsonObject());\n+                                    // ensure that a notification event gets sent (even if we might send duplicate events)\n+                                    return sendDelayedAutoProvisioningNotificationIfNeeded(tenantId, deviceId, gatewayId, deviceData, span)\n+                                            .map(deviceData);\n+                                });\n+                    }\n+\n+                    span.log(\"device created\");\n+                    LOG.trace(\"device [{}] for gateway [{}] successfully created by auto-provisioning [tenant-id: {}]\",\n+                            deviceId, gatewayId, tenantId);\n+                    return sendAutoProvisioningEvent(tenantId, deviceId, gatewayId, span)\n+                            .compose(sendEmptyEventOk -> deviceRegistrationInformationService.processAssertRegistration(DeviceKey.from((TenantKey.from(tenantId)), deviceId), span)\n+                                    .compose(deviceRegistrationData -> {\n+                                        if (!deviceRegistrationData.isOk()) {\n+                                            span.log(\"update of notification flag failed\");\n+                                            LOG.warn(\"notification flag of device [{}] for gateway [{}] of tenant [tenant-id: {}] could not be updated\",\n+                                                    deviceId, gatewayId, tenantId);\n+                                            return Future.failedFuture(StatusCodeMapper.from(deviceRegistrationData.getStatus(),\n+                                                    String.format(\"update of notification flag failed (status %d)\", deviceRegistrationData.getStatus())));\n+                                        }\n+\n+                                        final JsonObject deviceData = deviceRegistrationData.getPayload()\n+                                                .getJsonObject(RegistrationConstants.FIELD_DATA, new JsonObject());\n+                                        return setAutoProvisioningNotificationSent(tenantId, deviceId, deviceData, span)\n+                                                .map(deviceData);\n+                                    }));\n+                })\n+                .onFailure(thr -> TracingHelper.logError(span, thr))\n+                .onComplete(ar -> span.finish());\n+    }\n+\n+    /**\n+     * Notify northbound applications of an auto-provisioned device.\n+     *\n+     * @param tenantId The id of the tenant for which the edge device should be provisioned.\n+     * @param deviceId The id of the edge device which should be provisioned.\n+     * @param gatewayId The id of the edge device's gateway.\n+     * @param deviceData The data of the edge device.\n+     * @param span The span to be used for tracing this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *\n+     * @see AutoProvisionerConfigProperties#DEFAULT_RETRY_EVENT_SENDING_DELAY", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4OTExOQ=="}, "originalCommit": {"oid": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645"}, "originalPosition": 312}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE1MzIxNA==", "bodyText": "Then this javadoc part wouldn't be useful in the generated docs, but it would still be useful when browsing the code and reading the javadoc in the IDE.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542153214", "createdAt": "2020-12-14T07:01:30Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {\n+        this.deviceManagementService = deviceManagementService;\n+        this.deviceRegistrationInformationService = deviceRegistrationInformationService;\n+    }\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the service to use for checking existence of tenants.\n+     * <p>\n+     * If not set, tenant existence will not be verified.\n+     *\n+     * @param tenantInformationService The tenant information service.\n+     * @throws NullPointerException if service is {@code null};\n+     */\n+    @Autowired(required = false)\n+    public final void setTenantInformationService(final TenantInformationService tenantInformationService) {\n+        this.tenantInformationService = Objects.requireNonNull(tenantInformationService);\n+        LOG.info(\"using {}\", tenantInformationService);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     * @throws NullPointerException if the opentracingTracer is {@code null}.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);\n+    }\n+\n+    /**\n+     * Sets the configuration to use for auto-provisioning.\n+     *\n+     * @param config The configuration to set.\n+     * @throws NullPointerException if the config is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final AutoProvisionerConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    private Future<ProtonDelivery> sendAutoProvisioningEvent(\n+            final String tenantId,\n+            final String deviceId,\n+            final String gatewayId,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+\n+        LOG.debug(\"sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId);\n+\n+        final Future<TenantResult<TenantObject>> tenantTracker = tenantInformationService.getTenant(tenantId, span);\n+        final Future<DownstreamSender> senderTracker = downstreamSenderFactory.getOrCreateEventSender(tenantId);\n+\n+        return CompositeFuture.all(tenantTracker, senderTracker).compose(ok -> {\n+            final Map<String, Object> props = new HashMap<>();\n+            props.put(MessageHelper.APP_PROPERTY_QOS, QoS.AT_LEAST_ONCE.ordinal());\n+            props.put(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId);\n+            props.put(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);\n+            props.put(MessageHelper.APP_PROPERTY_GATEWAY_ID, gatewayId);\n+            props.put(MessageHelper.APP_PROPERTY_REGISTRATION_STATUS, EventConstants.RegistrationStatus.NEW.name());\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADAPTER, Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY);\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADDRESS, EventConstants.EVENT_ENDPOINT);\n+\n+            final Message msg = MessageHelper.newMessage(\n+                    ResourceIdentifier.from(EventConstants.EVENT_ENDPOINT, tenantId, deviceId),\n+                    EventConstants.CONTENT_TYPE_EMPTY_NOTIFICATION,\n+                    null,\n+                    tenantTracker.result().getPayload(),\n+                    props,\n+                    null,\n+                    false,\n+                    false);\n+\n+            final DownstreamSender sender = senderTracker.result();\n+            return sender.sendAndWaitForOutcome(msg, span.context())\n+                    .onFailure(t -> LOG.info(\"error sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId));\n+        });\n+    }\n+\n+    /**\n+     * Auto-provisions the edge device using the given device id and the given registration data.\n+     *\n+     * @param tenantId The id of the tenant for which the edge device should be provisioned.\n+     * @param deviceId The id of the edge device which should be provisioned.\n+     * @param gatewayId The id of the edge device's gateway.\n+     * @param device The registration data for the device to be auto-provisioned.\n+     * @param spanContext The tracing context to be used by this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    public Future<JsonObject> performAutoProvisioning(final String tenantId, final String deviceId,\n+            final String gatewayId, final Device device, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper\n+                .buildChildSpan(tracer, spanContext, \"auto-provision device for gateway\", Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY)\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT)\n+                .withTag(TracingHelper.TAG_GATEWAY_ID, gatewayId)\n+                .start();\n+        TracingHelper.setDeviceTags(span, tenantId, deviceId);\n+\n+        return deviceManagementService.createDevice(tenantId, Optional.of(deviceId), device, span)\n+                // make sure an HTTP_CONFLICT result is handled as an OperationResult\n+                .recover(thr -> ServiceInvocationException.extractStatusCode(thr) == HttpURLConnection.HTTP_CONFLICT\n+                        ? Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT))\n+                        : Future.failedFuture(thr))\n+                .compose(addEdgeDeviceResult -> {\n+                    if (addEdgeDeviceResult.isError()) {\n+                        if (addEdgeDeviceResult.getStatus() != HttpURLConnection.HTTP_CONFLICT) {\n+                            return Future.failedFuture(StatusCodeMapper.from(addEdgeDeviceResult.getStatus(),\n+                                    String.format(\"failed to add edge device (status %d)\", addEdgeDeviceResult.getStatus())));\n+                        }\n+\n+                        // handle HTTP_CONFLICT, meaning the device already exists\n+                        span.log(\"device already exists\");\n+                        LOG.debug(\"device [{}] for gateway [{}] already created by concurrent auto-provisioning [tenant-id: {}]\",\n+                                deviceId, gatewayId, tenantId);\n+                        return deviceRegistrationInformationService.processAssertRegistration(DeviceKey.from(TenantKey.from(tenantId), deviceId), span)\n+                                .compose(assertRegistrationResult -> {\n+                                    final JsonObject deviceData = assertRegistrationResult.getPayload()\n+                                            .getJsonObject(RegistrationConstants.FIELD_DATA, new JsonObject());\n+                                    // ensure that a notification event gets sent (even if we might send duplicate events)\n+                                    return sendDelayedAutoProvisioningNotificationIfNeeded(tenantId, deviceId, gatewayId, deviceData, span)\n+                                            .map(deviceData);\n+                                });\n+                    }\n+\n+                    span.log(\"device created\");\n+                    LOG.trace(\"device [{}] for gateway [{}] successfully created by auto-provisioning [tenant-id: {}]\",\n+                            deviceId, gatewayId, tenantId);\n+                    return sendAutoProvisioningEvent(tenantId, deviceId, gatewayId, span)\n+                            .compose(sendEmptyEventOk -> deviceRegistrationInformationService.processAssertRegistration(DeviceKey.from((TenantKey.from(tenantId)), deviceId), span)\n+                                    .compose(deviceRegistrationData -> {\n+                                        if (!deviceRegistrationData.isOk()) {\n+                                            span.log(\"update of notification flag failed\");\n+                                            LOG.warn(\"notification flag of device [{}] for gateway [{}] of tenant [tenant-id: {}] could not be updated\",\n+                                                    deviceId, gatewayId, tenantId);\n+                                            return Future.failedFuture(StatusCodeMapper.from(deviceRegistrationData.getStatus(),\n+                                                    String.format(\"update of notification flag failed (status %d)\", deviceRegistrationData.getStatus())));\n+                                        }\n+\n+                                        final JsonObject deviceData = deviceRegistrationData.getPayload()\n+                                                .getJsonObject(RegistrationConstants.FIELD_DATA, new JsonObject());\n+                                        return setAutoProvisioningNotificationSent(tenantId, deviceId, deviceData, span)\n+                                                .map(deviceData);\n+                                    }));\n+                })\n+                .onFailure(thr -> TracingHelper.logError(span, thr))\n+                .onComplete(ar -> span.finish());\n+    }\n+\n+    /**\n+     * Notify northbound applications of an auto-provisioned device.\n+     *\n+     * @param tenantId The id of the tenant for which the edge device should be provisioned.\n+     * @param deviceId The id of the edge device which should be provisioned.\n+     * @param gatewayId The id of the edge device's gateway.\n+     * @param deviceData The data of the edge device.\n+     * @param span The span to be used for tracing this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *\n+     * @see AutoProvisionerConfigProperties#DEFAULT_RETRY_EVENT_SENDING_DELAY", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4OTExOQ=="}, "originalCommit": {"oid": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645"}, "originalPosition": 312}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzM2MzI4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoxNToxNFrOIDW5UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoxNToxNFrOIDW5UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5MTc2MA==", "bodyText": "Missing null check for both arguments.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540391760", "createdAt": "2020-12-10T18:15:14Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {\n+        this.deviceManagementService = deviceManagementService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzM3MDc0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoxNzowNVrOIDW97g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoxNzowNVrOIDW97g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5Mjk0Mg==", "bodyText": "Also the span should be null checked, otherwise span.context() will throw error.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540392942", "createdAt": "2020-12-10T18:17:05Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {\n+        this.deviceManagementService = deviceManagementService;\n+        this.deviceRegistrationInformationService = deviceRegistrationInformationService;\n+    }\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the service to use for checking existence of tenants.\n+     * <p>\n+     * If not set, tenant existence will not be verified.\n+     *\n+     * @param tenantInformationService The tenant information service.\n+     * @throws NullPointerException if service is {@code null};\n+     */\n+    @Autowired(required = false)\n+    public final void setTenantInformationService(final TenantInformationService tenantInformationService) {\n+        this.tenantInformationService = Objects.requireNonNull(tenantInformationService);\n+        LOG.info(\"using {}\", tenantInformationService);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     * @throws NullPointerException if the opentracingTracer is {@code null}.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);\n+    }\n+\n+    /**\n+     * Sets the configuration to use for auto-provisioning.\n+     *\n+     * @param config The configuration to set.\n+     * @throws NullPointerException if the config is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final AutoProvisionerConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    private Future<ProtonDelivery> sendAutoProvisioningEvent(\n+            final String tenantId,\n+            final String deviceId,\n+            final String gatewayId,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzQwMzkwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoyNDo1MFrOIDXReQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoyNDo1MFrOIDXReQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5Nzk0NQ==", "bodyText": "It is a public method and FMPOV the arguments should be null checked if applicable.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540397945", "createdAt": "2020-12-10T18:24:50Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {\n+        this.deviceManagementService = deviceManagementService;\n+        this.deviceRegistrationInformationService = deviceRegistrationInformationService;\n+    }\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the service to use for checking existence of tenants.\n+     * <p>\n+     * If not set, tenant existence will not be verified.\n+     *\n+     * @param tenantInformationService The tenant information service.\n+     * @throws NullPointerException if service is {@code null};\n+     */\n+    @Autowired(required = false)\n+    public final void setTenantInformationService(final TenantInformationService tenantInformationService) {\n+        this.tenantInformationService = Objects.requireNonNull(tenantInformationService);\n+        LOG.info(\"using {}\", tenantInformationService);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     * @throws NullPointerException if the opentracingTracer is {@code null}.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);\n+    }\n+\n+    /**\n+     * Sets the configuration to use for auto-provisioning.\n+     *\n+     * @param config The configuration to set.\n+     * @throws NullPointerException if the config is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final AutoProvisionerConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    private Future<ProtonDelivery> sendAutoProvisioningEvent(\n+            final String tenantId,\n+            final String deviceId,\n+            final String gatewayId,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+\n+        LOG.debug(\"sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId);\n+\n+        final Future<TenantResult<TenantObject>> tenantTracker = tenantInformationService.getTenant(tenantId, span);\n+        final Future<DownstreamSender> senderTracker = downstreamSenderFactory.getOrCreateEventSender(tenantId);\n+\n+        return CompositeFuture.all(tenantTracker, senderTracker).compose(ok -> {\n+            final Map<String, Object> props = new HashMap<>();\n+            props.put(MessageHelper.APP_PROPERTY_QOS, QoS.AT_LEAST_ONCE.ordinal());\n+            props.put(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId);\n+            props.put(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);\n+            props.put(MessageHelper.APP_PROPERTY_GATEWAY_ID, gatewayId);\n+            props.put(MessageHelper.APP_PROPERTY_REGISTRATION_STATUS, EventConstants.RegistrationStatus.NEW.name());\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADAPTER, Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY);\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADDRESS, EventConstants.EVENT_ENDPOINT);\n+\n+            final Message msg = MessageHelper.newMessage(\n+                    ResourceIdentifier.from(EventConstants.EVENT_ENDPOINT, tenantId, deviceId),\n+                    EventConstants.CONTENT_TYPE_EMPTY_NOTIFICATION,\n+                    null,\n+                    tenantTracker.result().getPayload(),\n+                    props,\n+                    null,\n+                    false,\n+                    false);\n+\n+            final DownstreamSender sender = senderTracker.result();\n+            return sender.sendAndWaitForOutcome(msg, span.context())\n+                    .onFailure(t -> LOG.info(\"error sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId));\n+        });\n+    }\n+\n+    /**\n+     * Auto-provisions the edge device using the given device id and the given registration data.\n+     *\n+     * @param tenantId The id of the tenant for which the edge device should be provisioned.\n+     * @param deviceId The id of the edge device which should be provisioned.\n+     * @param gatewayId The id of the edge device's gateway.\n+     * @param device The registration data for the device to be auto-provisioned.\n+     * @param spanContext The tracing context to be used by this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    public Future<JsonObject> performAutoProvisioning(final String tenantId, final String deviceId,\n+            final String gatewayId, final Device device, final SpanContext spanContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645"}, "originalPosition": 242}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzQwNTA4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoyNTowN1rOIDXSMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoyNTowN1rOIDXSMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM5ODEyOQ==", "bodyText": "It is a public method and FMPOV the arguments should be null checked if applicable.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540398129", "createdAt": "2020-12-10T18:25:07Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {\n+        this.deviceManagementService = deviceManagementService;\n+        this.deviceRegistrationInformationService = deviceRegistrationInformationService;\n+    }\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the service to use for checking existence of tenants.\n+     * <p>\n+     * If not set, tenant existence will not be verified.\n+     *\n+     * @param tenantInformationService The tenant information service.\n+     * @throws NullPointerException if service is {@code null};\n+     */\n+    @Autowired(required = false)\n+    public final void setTenantInformationService(final TenantInformationService tenantInformationService) {\n+        this.tenantInformationService = Objects.requireNonNull(tenantInformationService);\n+        LOG.info(\"using {}\", tenantInformationService);\n+    }\n+\n+    /**\n+     * Sets the OpenTracing {@code Tracer} to use for tracking the processing\n+     * of messages published by devices across Hono's components.\n+     * <p>\n+     * If not set explicitly, the {@code NoopTracer} from OpenTracing will\n+     * be used.\n+     *\n+     * @param opentracingTracer The tracer.\n+     * @throws NullPointerException if the opentracingTracer is {@code null}.\n+     */\n+    @Autowired(required = false)\n+    public final void setTracer(final Tracer opentracingTracer) {\n+        LOG.info(\"using OpenTracing Tracer implementation [{}]\", opentracingTracer.getClass().getName());\n+        this.tracer = Objects.requireNonNull(opentracingTracer);\n+    }\n+\n+    /**\n+     * Sets the configuration to use for auto-provisioning.\n+     *\n+     * @param config The configuration to set.\n+     * @throws NullPointerException if the config is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final AutoProvisionerConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    private Future<ProtonDelivery> sendAutoProvisioningEvent(\n+            final String tenantId,\n+            final String deviceId,\n+            final String gatewayId,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+\n+        LOG.debug(\"sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId);\n+\n+        final Future<TenantResult<TenantObject>> tenantTracker = tenantInformationService.getTenant(tenantId, span);\n+        final Future<DownstreamSender> senderTracker = downstreamSenderFactory.getOrCreateEventSender(tenantId);\n+\n+        return CompositeFuture.all(tenantTracker, senderTracker).compose(ok -> {\n+            final Map<String, Object> props = new HashMap<>();\n+            props.put(MessageHelper.APP_PROPERTY_QOS, QoS.AT_LEAST_ONCE.ordinal());\n+            props.put(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId);\n+            props.put(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);\n+            props.put(MessageHelper.APP_PROPERTY_GATEWAY_ID, gatewayId);\n+            props.put(MessageHelper.APP_PROPERTY_REGISTRATION_STATUS, EventConstants.RegistrationStatus.NEW.name());\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADAPTER, Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY);\n+            props.put(MessageHelper.APP_PROPERTY_ORIG_ADDRESS, EventConstants.EVENT_ENDPOINT);\n+\n+            final Message msg = MessageHelper.newMessage(\n+                    ResourceIdentifier.from(EventConstants.EVENT_ENDPOINT, tenantId, deviceId),\n+                    EventConstants.CONTENT_TYPE_EMPTY_NOTIFICATION,\n+                    null,\n+                    tenantTracker.result().getPayload(),\n+                    props,\n+                    null,\n+                    false,\n+                    false);\n+\n+            final DownstreamSender sender = senderTracker.result();\n+            return sender.sendAndWaitForOutcome(msg, span.context())\n+                    .onFailure(t -> LOG.info(\"error sending auto-provisioning event for device [{}] created via gateway [{}] [tenant-id: {}]\", deviceId, gatewayId, tenantId));\n+        });\n+    }\n+\n+    /**\n+     * Auto-provisions the edge device using the given device id and the given registration data.\n+     *\n+     * @param tenantId The id of the tenant for which the edge device should be provisioned.\n+     * @param deviceId The id of the edge device which should be provisioned.\n+     * @param gatewayId The id of the edge device's gateway.\n+     * @param device The registration data for the device to be auto-provisioned.\n+     * @param spanContext The tracing context to be used by this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     */\n+    public Future<JsonObject> performAutoProvisioning(final String tenantId, final String deviceId,\n+            final String gatewayId, final Device device, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper\n+                .buildChildSpan(tracer, spanContext, \"auto-provision device for gateway\", Constants.PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY)\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT)\n+                .withTag(TracingHelper.TAG_GATEWAY_ID, gatewayId)\n+                .start();\n+        TracingHelper.setDeviceTags(span, tenantId, deviceId);\n+\n+        return deviceManagementService.createDevice(tenantId, Optional.of(deviceId), device, span)\n+                // make sure an HTTP_CONFLICT result is handled as an OperationResult\n+                .recover(thr -> ServiceInvocationException.extractStatusCode(thr) == HttpURLConnection.HTTP_CONFLICT\n+                        ? Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT))\n+                        : Future.failedFuture(thr))\n+                .compose(addEdgeDeviceResult -> {\n+                    if (addEdgeDeviceResult.isError()) {\n+                        if (addEdgeDeviceResult.getStatus() != HttpURLConnection.HTTP_CONFLICT) {\n+                            return Future.failedFuture(StatusCodeMapper.from(addEdgeDeviceResult.getStatus(),\n+                                    String.format(\"failed to add edge device (status %d)\", addEdgeDeviceResult.getStatus())));\n+                        }\n+\n+                        // handle HTTP_CONFLICT, meaning the device already exists\n+                        span.log(\"device already exists\");\n+                        LOG.debug(\"device [{}] for gateway [{}] already created by concurrent auto-provisioning [tenant-id: {}]\",\n+                                deviceId, gatewayId, tenantId);\n+                        return deviceRegistrationInformationService.processAssertRegistration(DeviceKey.from(TenantKey.from(tenantId), deviceId), span)\n+                                .compose(assertRegistrationResult -> {\n+                                    final JsonObject deviceData = assertRegistrationResult.getPayload()\n+                                            .getJsonObject(RegistrationConstants.FIELD_DATA, new JsonObject());\n+                                    // ensure that a notification event gets sent (even if we might send duplicate events)\n+                                    return sendDelayedAutoProvisioningNotificationIfNeeded(tenantId, deviceId, gatewayId, deviceData, span)\n+                                            .map(deviceData);\n+                                });\n+                    }\n+\n+                    span.log(\"device created\");\n+                    LOG.trace(\"device [{}] for gateway [{}] successfully created by auto-provisioning [tenant-id: {}]\",\n+                            deviceId, gatewayId, tenantId);\n+                    return sendAutoProvisioningEvent(tenantId, deviceId, gatewayId, span)\n+                            .compose(sendEmptyEventOk -> deviceRegistrationInformationService.processAssertRegistration(DeviceKey.from((TenantKey.from(tenantId)), deviceId), span)\n+                                    .compose(deviceRegistrationData -> {\n+                                        if (!deviceRegistrationData.isOk()) {\n+                                            span.log(\"update of notification flag failed\");\n+                                            LOG.warn(\"notification flag of device [{}] for gateway [{}] of tenant [tenant-id: {}] could not be updated\",\n+                                                    deviceId, gatewayId, tenantId);\n+                                            return Future.failedFuture(StatusCodeMapper.from(deviceRegistrationData.getStatus(),\n+                                                    String.format(\"update of notification flag failed (status %d)\", deviceRegistrationData.getStatus())));\n+                                        }\n+\n+                                        final JsonObject deviceData = deviceRegistrationData.getPayload()\n+                                                .getJsonObject(RegistrationConstants.FIELD_DATA, new JsonObject());\n+                                        return setAutoProvisioningNotificationSent(tenantId, deviceId, deviceData, span)\n+                                                .map(deviceData);\n+                                    }));\n+                })\n+                .onFailure(thr -> TracingHelper.logError(span, thr))\n+                .onComplete(ar -> span.finish());\n+    }\n+\n+    /**\n+     * Notify northbound applications of an auto-provisioned device.\n+     *\n+     * @param tenantId The id of the tenant for which the edge device should be provisioned.\n+     * @param deviceId The id of the edge device which should be provisioned.\n+     * @param gatewayId The id of the edge device's gateway.\n+     * @param deviceData The data of the edge device.\n+     * @param span The span to be used for tracing this operation.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *\n+     * @see AutoProvisionerConfigProperties#DEFAULT_RETRY_EVENT_SENDING_DELAY\n+     */\n+    public Future<Void> sendDelayedAutoProvisioningNotificationIfNeeded(final String tenantId,\n+            final String deviceId, final String gatewayId, final JsonObject deviceData, final Span span) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645"}, "originalPosition": 315}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzQyMDI0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisionerConfigProperties.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoyODo0NVrOIDXbUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODoyODo0NVrOIDXbUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMDQ2Ng==", "bodyText": "IllegalArgumentException is thrown when the retryEventSendingDelay is less than 0 but the error message doesn't match that.\nHow about retryEventSendingDelay must not be negative or retryEventSendingDelay must be >= 0?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540400466", "createdAt": "2020-12-10T18:28:45Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisionerConfigProperties.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import org.eclipse.hono.util.RegistrationConstants;\n+\n+/**\n+ * Configuration properties for Hono's gateway-based auto-provisioning.\n+ */\n+public class AutoProvisionerConfigProperties {\n+\n+    /**\n+     * Delay in milliseconds before trying to send the auto-provisioning notification if the initial attempt\n+     * to send the event hasn't completed yet.\n+     * <p>\n+     * This will only be invoked for requests that have <i>not</i> triggered the auto-provisioning,\n+     * but instead have found the {@link RegistrationConstants#FIELD_AUTO_PROVISIONING_NOTIFICATION_SENT} flag\n+     * in the device data to be {@code false}. Assuming that such a request has occurred very shortly after\n+     * the auto-provisioning, with the notification event still in the process of getting sent, the intention\n+     * here is to wait some time til the event was most probably sent. After the delay, the flag is checked\n+     * again and only if the flag is still {@code false}, meaning there was possibly an error sending the event\n+     * during auto-provisioning, the event will be sent as part of that request.\n+     */\n+    private static final long DEFAULT_RETRY_EVENT_SENDING_DELAY = 50;\n+\n+    private long retryEventSendingDelay = DEFAULT_RETRY_EVENT_SENDING_DELAY;\n+\n+    /**\n+     * Gets the delay when sending auto-provisioning notifications.\n+     *\n+     * @return The delay.\n+     */\n+    public long getRetryEventSendingDelay() {\n+        return retryEventSendingDelay;\n+    }\n+\n+    /**\n+     * Sets the delay when sending auto-provisioning notifications.\n+     *\n+     * @param retryEventSendingDelay The delay to be set.\n+     * @throws IllegalArgumentException if the number of devices is &lt; 0.\n+     */\n+    public void setRetryEventSendingDelay(final long retryEventSendingDelay) {\n+        if (retryEventSendingDelay < 0) {\n+            throw new IllegalArgumentException(\"retryEventSendingDelay must be > 0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MzQyNjU3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/DeviceRegistrationInformationService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODozMDowOFrOIDXfJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxNDo0OTo1MFrOID8D1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMTQ0NQ==", "bodyText": "IMHO the method name processAssertRegistration doesn't suit this context. As I understood, this method will return the registration information of a device. It can be something like getRegistration or getDeviceRegistration  as we have getTenant in the TenantInformationService. WDYT?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540401445", "createdAt": "2020-12-10T18:30:08Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/DeviceRegistrationInformationService.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import org.eclipse.hono.util.RegistrationResult;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.Future;\n+\n+/**\n+ * A service which provides device registration information to internal service implementations.\n+ */\n+public interface DeviceRegistrationInformationService {\n+\n+    /**\n+     * Gets device registration data by device ID.\n+     *\n+     * @param deviceKey The ID of the device to get registration data for.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation. The <em>status</em> will be\n+     *            <ul>\n+     *            <li><em>200 OK</em>, if a device with the given ID is registered for the tenant.<br>\n+     *            The <em>payload</em> will contain a JSON object with the following properties:\n+     *              <ul>\n+     *              <li><em>device-id</em> - the device identifier</li>\n+     *              <li><em>data</em> - the information registered for the device</li>\n+     *              </ul>\n+     *            </li>\n+     *            <li><em>404 Not Found</em>, if no device with the given identifier is registered for the tenant.</li>\n+     *            </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    Future<RegistrationResult> processAssertRegistration(DeviceKey deviceKey, Span span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc2MjM4Ng==", "bodyText": "Yes, that is right. Actually I changed that method to that name, but reverted it to keep the change smaller for review.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r540762386", "createdAt": "2020-12-11T08:10:23Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/DeviceRegistrationInformationService.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import org.eclipse.hono.util.RegistrationResult;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.Future;\n+\n+/**\n+ * A service which provides device registration information to internal service implementations.\n+ */\n+public interface DeviceRegistrationInformationService {\n+\n+    /**\n+     * Gets device registration data by device ID.\n+     *\n+     * @param deviceKey The ID of the device to get registration data for.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation. The <em>status</em> will be\n+     *            <ul>\n+     *            <li><em>200 OK</em>, if a device with the given ID is registered for the tenant.<br>\n+     *            The <em>payload</em> will contain a JSON object with the following properties:\n+     *              <ul>\n+     *              <li><em>device-id</em> - the device identifier</li>\n+     *              <li><em>data</em> - the information registered for the device</li>\n+     *              </ul>\n+     *            </li>\n+     *            <li><em>404 Not Found</em>, if no device with the given identifier is registered for the tenant.</li>\n+     *            </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    Future<RegistrationResult> processAssertRegistration(DeviceKey deviceKey, Span span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMTQ0NQ=="}, "originalCommit": {"oid": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAwMDY2MA==", "bodyText": "May be it can be done in a subsequent PR.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r541000660", "createdAt": "2020-12-11T14:49:50Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/DeviceRegistrationInformationService.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import org.eclipse.hono.util.RegistrationResult;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.Future;\n+\n+/**\n+ * A service which provides device registration information to internal service implementations.\n+ */\n+public interface DeviceRegistrationInformationService {\n+\n+    /**\n+     * Gets device registration data by device ID.\n+     *\n+     * @param deviceKey The ID of the device to get registration data for.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation. The <em>status</em> will be\n+     *            <ul>\n+     *            <li><em>200 OK</em>, if a device with the given ID is registered for the tenant.<br>\n+     *            The <em>payload</em> will contain a JSON object with the following properties:\n+     *              <ul>\n+     *              <li><em>device-id</em> - the device identifier</li>\n+     *              <li><em>data</em> - the information registered for the device</li>\n+     *              </ul>\n+     *            </li>\n+     *            <li><em>404 Not Found</em>, if no device with the given identifier is registered for the tenant.</li>\n+     *            </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    Future<RegistrationResult> processAssertRegistration(DeviceKey deviceKey, Span span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwMTQ0NQ=="}, "originalCommit": {"oid": "7465b5c73a33c8a529eeb7e292ef6f1670a4f645"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjE3MDc3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/eclipse/hono/util/Constants.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzoyNTowMlrOIFC_IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMTo1NTo1OFrOIFNGJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2MjcyMA==", "bodyText": "this looks a little misleading as the device registry clearly is not a protocol adapter, is it?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542162720", "createdAt": "2020-12-14T07:25:02Z", "author": {"login": "sophokles73"}, "path": "core/src/main/java/org/eclipse/hono/util/Constants.java", "diffHunk": "@@ -77,6 +77,10 @@\n      * The type of the sigfox protocol adapter.\n      */\n     public static final String PROTOCOL_ADAPTER_TYPE_SIGFOX = \"hono-sigfox\";\n+    /**\n+     * The type of the protocol adapter which actually denotes the device registry.\n+     */\n+    public static final String PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY = \"hono-device-registry\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMyODM1OQ==", "bodyText": "Yes, see the discussion we already had on this: #2094 (comment)\nSince the application property name whose value is set to the constant's value is orig_adapter I thought it doesn't make sense to \"hide\" this in the name...", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542328359", "createdAt": "2020-12-14T11:55:58Z", "author": {"login": "fkaltner"}, "path": "core/src/main/java/org/eclipse/hono/util/Constants.java", "diffHunk": "@@ -77,6 +77,10 @@\n      * The type of the sigfox protocol adapter.\n      */\n     public static final String PROTOCOL_ADAPTER_TYPE_SIGFOX = \"hono-sigfox\";\n+    /**\n+     * The type of the protocol adapter which actually denotes the device registry.\n+     */\n+    public static final String PROTOCOL_ADAPTER_TYPE_DEVICE_REGISTRY = \"hono-device-registry\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2MjcyMA=="}, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjE5NzU1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzozMzozN1rOIFDNhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxODozODo0MlrOIFfPNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2NjQwNg==", "bodyText": "If this field becomes a part of the Device object, it needs to be added to the Device Registry Management API spec as well.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542166406", "createdAt": "2020-12-14T07:33:37Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -70,6 +72,10 @@\n     @JsonProperty(RegistryManagementConstants.FIELD_MAPPER)\n     private String mapper;\n \n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTHORITIES)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYyNTU4OA==", "bodyText": "It is not returned if it is not set, but with the change this property may be set via API (and subsequently it will be returned then).\nHence I included in the specification.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542625588", "createdAt": "2020-12-14T18:38:42Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -70,6 +72,10 @@\n     @JsonProperty(RegistryManagementConstants.FIELD_MAPPER)\n     private String mapper;\n \n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTHORITIES)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2NjQwNg=="}, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjIwMjM3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzozNDo1M1rOIFDQCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzozNDo1M1rOIFDQCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2NzA1MA==", "bodyText": "in order to prevent hard to find problems when the parameter is being changed after invoking this method, the field should better be set to a copy of the given set ...", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542167050", "createdAt": "2020-12-14T07:34:53Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -302,4 +311,25 @@ public final Device setStatus(final DeviceStatus status) {\n     public final DeviceStatus getStatus() {\n         return status;\n     }\n+\n+    /**\n+     * Sets the authorities granted to this device.\n+     *\n+     * @param authorities The device's authorities.\n+     *\n+     * @return A reference to this for fluent use.\n+     */\n+    public final Device setAuthorities(final Set<String> authorities) {\n+        this.authorities = authorities;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjIwNDc5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzozNTo0NFrOIFDReg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzozNTo0NFrOIFDReg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2NzQxOA==", "bodyText": "IMHO it would be safer to return an unmodifiable view on the set in order to prevent alteration by the client", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542167418", "createdAt": "2020-12-14T07:35:44Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/Device.java", "diffHunk": "@@ -302,4 +311,25 @@ public final Device setStatus(final DeviceStatus status) {\n     public final DeviceStatus getStatus() {\n         return status;\n     }\n+\n+    /**\n+     * Sets the authorities granted to this device.\n+     *\n+     * @param authorities The device's authorities.\n+     *\n+     * @return A reference to this for fluent use.\n+     */\n+    public final Device setAuthorities(final Set<String> authorities) {\n+        this.authorities = authorities;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the authorities granted to this device.\n+     *\n+     * @return The device's authorities.\n+     */\n+    public final Set<String> getAuthorities() {\n+        return authorities;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjIxNDM1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/registration/RegistrationService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzozODozNlrOIFDWzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzozODozNlrOIFDWzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE2ODc4MQ==", "bodyText": "IMHO we should replace should with may here and we should also provide an indication of how an implementing class might verify if the device has the required authority (which one is that, by the way?) ...\nThis additional paragraph should also be added to the other variant of this method which doesn't require a Span, or is only relevant to this variant?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542168781", "createdAt": "2020-12-14T07:38:36Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/registration/RegistrationService.java", "diffHunk": "@@ -114,6 +114,9 @@\n      * Such a check might be based on a specific role that the client needs to have or on an\n      * explicitly defined relation between the gateway and the device(s).\n      * <p>\n+     * Also they should perform an automatic provisioning of edge devices, if the gateway which sends telemetry on", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjI0ODM0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/TenantInformationService.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzo0ODo0NlrOIFDpbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNjoyNDowMVrOIFYsEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3MzU0OA==", "bodyText": "can the returned future be failed as well?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542173548", "createdAt": "2020-12-14T07:48:46Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/TenantInformationService.java", "diffHunk": "@@ -42,4 +44,24 @@\n      */\n      Future<Result<TenantKey>> tenantExists(String tenantId, Span span);\n \n+    /**\n+     * Gets the tenant identified by the given id.\n+     *\n+     * @param tenantId The id identifying the tenant to obtain, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation, must not be {@code null}.\n+     *            It is not to be closed in this method! An implementation should log (error) events on this span and\n+     *            it may set tags and use this span as the parent for any spans created in this method.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *             The <em>status</em> will be\n+     *             <ul>\n+     *             <li><em>200 OK</em> if a tenant with the given ID is registered.\n+     *             The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *             <li><em>404 Not Found</em> if no tenant with the given identifier exists.</li>\n+     *             </ul>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ1MzY3Nw==", "bodyText": "No, as far as I can see not, in an error case it will always be a TenantResult with status code 404, similar to tenantExists.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542453677", "createdAt": "2020-12-14T15:03:46Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/TenantInformationService.java", "diffHunk": "@@ -42,4 +44,24 @@\n      */\n      Future<Result<TenantKey>> tenantExists(String tenantId, Span span);\n \n+    /**\n+     * Gets the tenant identified by the given id.\n+     *\n+     * @param tenantId The id identifying the tenant to obtain, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation, must not be {@code null}.\n+     *            It is not to be closed in this method! An implementation should log (error) events on this span and\n+     *            it may set tags and use this span as the parent for any spans created in this method.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *             The <em>status</em> will be\n+     *             <ul>\n+     *             <li><em>200 OK</em> if a tenant with the given ID is registered.\n+     *             The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *             <li><em>404 Not Found</em> if no tenant with the given identifier exists.</li>\n+     *             </ul>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3MzU0OA=="}, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUwMjA2OQ==", "bodyText": "Then the wording should probably changed to reflect the fact that this will always return a succeeded future?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542502069", "createdAt": "2020-12-14T16:02:59Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/TenantInformationService.java", "diffHunk": "@@ -42,4 +44,24 @@\n      */\n      Future<Result<TenantKey>> tenantExists(String tenantId, Span span);\n \n+    /**\n+     * Gets the tenant identified by the given id.\n+     *\n+     * @param tenantId The id identifying the tenant to obtain, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation, must not be {@code null}.\n+     *            It is not to be closed in this method! An implementation should log (error) events on this span and\n+     *            it may set tags and use this span as the parent for any spans created in this method.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *             The <em>status</em> will be\n+     *             <ul>\n+     *             <li><em>200 OK</em> if a tenant with the given ID is registered.\n+     *             The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *             <li><em>404 Not Found</em> if no tenant with the given identifier exists.</li>\n+     *             </ul>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3MzU0OA=="}, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUxODI4OQ==", "bodyText": "I think this method should be in line with the TenantInformationService.tenantExists method and the TenantService methods in that respect.\nThese other methods don't make the promise, that always a succeeded Future will be returned. And looking at the current implementation of TenantService.get in the JDBC implementation, the returned Future can actually be failed. This would mean that AutowiredTenantInformationService.getTenant would also return a failed Future.\nTherefore I would keep the javadoc as is, and maybe change all related method javadocs and the JDBC implementation in that respect in a separate PR.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542518289", "createdAt": "2020-12-14T16:24:01Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/tenant/TenantInformationService.java", "diffHunk": "@@ -42,4 +44,24 @@\n      */\n      Future<Result<TenantKey>> tenantExists(String tenantId, Span span);\n \n+    /**\n+     * Gets the tenant identified by the given id.\n+     *\n+     * @param tenantId The id identifying the tenant to obtain, must not be {@code null}.\n+     * @param span The active OpenTracing span for this operation, must not be {@code null}.\n+     *            It is not to be closed in this method! An implementation should log (error) events on this span and\n+     *            it may set tags and use this span as the parent for any spans created in this method.\n+     *\n+     * @return A future indicating the outcome of the operation.\n+     *             The <em>status</em> will be\n+     *             <ul>\n+     *             <li><em>200 OK</em> if a tenant with the given ID is registered.\n+     *             The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *             <li><em>404 Not Found</em> if no tenant with the given identifier exists.</li>\n+     *             </ul>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3MzU0OA=="}, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjI3OTU1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwNzo1NzoyNlrOIFD6kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoxNTo0NVrOIFP4vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3NzkzOQ==", "bodyText": "is it really necessary to implement this functionality as a component with its own life cycle?\nHow about turning this into an interface and let its methods accept the necessary collaborators as parameters (maybe hidden behind a context object facade?). That way we can test it much easier and we would be more flexible regarding the implementation of the required collaborators. We have applied this pattern in org.eclipse.hono.client.CommandTargetMapper where it turned out very helpful.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542177939", "createdAt": "2020-12-14T07:57:26Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NDA3Ng==", "bodyText": "we can defer this discussion to after the 1.5.0 release, though", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542374076", "createdAt": "2020-12-14T13:15:45Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE3NzkzOQ=="}, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjMyNTUwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwODoxMDozMVrOIFET7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxODo0ODo0NlrOIFf6Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4NDQyOA==", "bodyText": "I don't quite get why some (required) collaborators are passed in via the constructor while others are injected by means of a setter. Is there a pattern that I don't see?\nWhy do we need a dedicated DeviceRegistrationInformationService? Can't we simply use the existing RegistrationService for this purpose?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542184428", "createdAt": "2020-12-14T08:10:31Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     *\n+     * @throws NullPointerException if any argument is {@code null}.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ3NjU0OA==", "bodyText": "No, actually there is no pattern. Refactored it to using setters.\nI could not find a method in RegistrationService which just gets the registration data of a device. That's also implied by their names since they start with \"assert...\" - these methods also query the tenant service which is unnecessary overhead when the intention is just to get the registration data.\nAlso I thought RegistrationService should represent the Device Registration API. Since there is no simple \"get\" method defined there and its only for internal use I did not want to extend the API. Also I did want to add the method there in order not to mix up \"API definitions\" and \"internal helpers\".\nAnd, finally \ud83d\ude05, I got the impression that TenantInformationService was defined because of similar reasons.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542476548", "createdAt": "2020-12-14T15:31:44Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     *\n+     * @throws NullPointerException if any argument is {@code null}.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4NDQyOA=="}, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUwODUwNQ==", "bodyText": "well, the TenantInformationService has been created because there are deployment environments where Tenants will not be managed as part of the device registry and will instead be represented by e.g. custom resources in a kubernetes cluster.\nI might not fully understand what the DeviceRegistrationInformationService.processAssertRegistration method is actually returning. The JavaDoc ist quite vaguely referring to the information registered for the device.\nI wonder why the method is named processAssertRegistration if it is not about performing the assertion of the device's registration status. if it is about retrieving the device's registration information then why isn't it called getRegistrationInformation?\nit would be helpful if the JavaDoc would define more precisely what data is actually being returned by the method. You might be able to refer to the Device object definition in the Management API?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542508505", "createdAt": "2020-12-14T16:11:13Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     *\n+     * @throws NullPointerException if any argument is {@code null}.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4NDQyOA=="}, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjYzNjYxNQ==", "bodyText": "It is still named processAssertRegistration because I tried to keep the PR as small as possible, see #2094 (comment)\nI am happy to change it though, since two reviewers have now stumbled upon it - I guess the change is still \"digestible\" then.\n\nit would be helpful if the JavaDoc would define more precisely what data is actually being returned by the method. You might be able to refer to the Device object definition in the Management API?\n\nYes, that makes sense.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542636615", "createdAt": "2020-12-14T18:48:46Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private final DeviceManagementService deviceManagementService;\n+\n+    private final DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    /**\n+     * Constructs a new instance.\n+     *\n+     * @param deviceManagementService The device management service to be used.\n+     * @param deviceRegistrationInformationService The device registration information service to be used.\n+     *\n+     * @throws NullPointerException if any argument is {@code null}.\n+     */\n+    public AutoProvisioner(\n+            final DeviceManagementService deviceManagementService,\n+            final DeviceRegistrationInformationService deviceRegistrationInformationService) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4NDQyOA=="}, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNjM1MTk2OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/DeviceRegistrationInformationService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQwODoxNzowOVrOIFEiVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNTo0MjozNlrOIFWsYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4ODExOA==", "bodyText": "I do not see why we need this additional interface. Does it provide anything different from what the existing RegistrationService does?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542188118", "createdAt": "2020-12-14T08:17:09Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/DeviceRegistrationInformationService.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import org.eclipse.hono.util.RegistrationResult;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.Future;\n+\n+/**\n+ * A service which provides device registration information to internal service implementations.\n+ */\n+public interface DeviceRegistrationInformationService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ4NTYwMg==", "bodyText": "See above (#2094 (comment)).", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542485602", "createdAt": "2020-12-14T15:42:36Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/DeviceRegistrationInformationService.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import org.eclipse.hono.util.RegistrationResult;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.Future;\n+\n+/**\n+ * A service which provides device registration information to internal service implementations.\n+ */\n+public interface DeviceRegistrationInformationService {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4ODExOA=="}, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzYxNDI1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoxMjoyN1rOIFPwoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoxMjoyN1rOIFPwoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3MjAwMQ==", "bodyText": "\"shutdown process\"", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542372001", "createdAt": "2020-12-14T13:12:27Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AbstractRegistrationService.java", "diffHunk": "@@ -58,6 +62,40 @@\n \n     protected TenantInformationService tenantInformationService = new NoopTenantInformationService();\n \n+    private AutoProvisioner autoProvisioner;\n+\n+    @Override\n+    public final Future<Void> start() {\n+        return startInternal()\n+            .compose(ok -> supportsAutoProvisioning() ? autoProvisioner.start() : Future.succeededFuture())\n+            .mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        return stopInternal()\n+            .compose(ok -> supportsAutoProvisioning() ? autoProvisioner.stop() : Future.succeededFuture())\n+            .mapEmpty();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom startup logic, see {@link Lifecycle#start()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.\n+     */\n+    protected Future<Void> startInternal() {\n+        return Future.succeededFuture();\n+    }\n+\n+    /**\n+     * Enables subclasses to add custom shutdown logic, see {@link Lifecycle#stop()}.\n+     *\n+     * @return A future indicating the outcome of the startup process.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzY1MTM5OnYy", "diffSide": "RIGHT", "path": "tests/src/test/resources/deviceregistry-mongodb/application.yml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzoyMDo0NVrOIFQFvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxNTo0ODoxNVrOIFW9tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NzQwNw==", "bodyText": "This configuration block isn't needed by the changes in this PR, right? In fact I think it shouldn't be needed.\nTherefore the block could be omitted here for now and added with the followup PRs where integration tests for the auto-provisioning feature get added.\nSame for the other device registry yaml.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542377407", "createdAt": "2020-12-14T13:20:45Z", "author": {"login": "calohmn"}, "path": "tests/src/test/resources/deviceregistry-mongodb/application.yml", "diffHunk": "@@ -5,6 +5,17 @@ hono:\n   healthCheck:\n     insecurePortBindAddress: 0.0.0.0\n     insecurePort: ${vertx.health.port}\n+  messaging:\n+    name: 'Hono Device Registry MongoDb'\n+    host: ${hono.amqp-network.host}\n+    port: 5673\n+    amqpHostname: hono-internal\n+    keyPath: /etc/hono/certs/device-registry-key.pem\n+    certPath: /etc/hono/certs/device-registry-cert.pem\n+    trustStorePath: /etc/hono/certs/trusted-certs.pem\n+    linkEstablishmentTimeout: ${link.establishment.timeout}\n+    flowLatency: ${flow.latency}\n+    requestTimeout: ${request.timeout}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ5MDAzOA==", "bodyText": "Good catch! Two less files changed for this PR! \ud83c\udf89", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r542490038", "createdAt": "2020-12-14T15:48:15Z", "author": {"login": "fkaltner"}, "path": "tests/src/test/resources/deviceregistry-mongodb/application.yml", "diffHunk": "@@ -5,6 +5,17 @@ hono:\n   healthCheck:\n     insecurePortBindAddress: 0.0.0.0\n     insecurePort: ${vertx.health.port}\n+  messaging:\n+    name: 'Hono Device Registry MongoDb'\n+    host: ${hono.amqp-network.host}\n+    port: 5673\n+    amqpHostname: hono-internal\n+    keyPath: /etc/hono/certs/device-registry-key.pem\n+    certPath: /etc/hono/certs/device-registry-cert.pem\n+    trustStorePath: /etc/hono/certs/trusted-certs.pem\n+    linkEstablishmentTimeout: ${link.establishment.timeout}\n+    flowLatency: ${flow.latency}\n+    requestTimeout: ${request.timeout}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM3NzQwNw=="}, "originalCommit": {"oid": "60f734809e115a0f0825dcc7b7b8162d58d46892"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMjc5MDQ4OnYy", "diffSide": "RIGHT", "path": "tests/src/test/resources/qpid/qdrouterd-with-broker.json", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwODo0OToyOVrOIF_iOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwODo0OToyOVrOIF_iOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1NDc0NA==", "bodyText": "I believe that this is not (yet) required as the registries do not support auto-provisioning yet, right?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r543154744", "createdAt": "2020-12-15T08:49:29Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/resources/qpid/qdrouterd-with-broker.json", "diffHunk": "@@ -110,7 +110,7 @@\n       \"maxConnections\": 40,\n       \"groups\": {\n         \"Hono\": {\n-          \"users\": \"Eclipse IoT;Hono;http-adapter,Eclipse IoT;Hono;mqtt-adapter,Eclipse IoT;Hono;amqp-adapter,Eclipse IoT;Hono;coap-adapter,Eclipse IoT;Hono;command-router\",\n+          \"users\": \"Eclipse IoT;Hono;http-adapter,Eclipse IoT;Hono;mqtt-adapter,Eclipse IoT;Hono;amqp-adapter,Eclipse IoT;Hono;coap-adapter,Eclipse IoT;Hono;command-router,Eclipse IoT;Hono;device-registry\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00cb3f3823b046519c409716636186245451b471"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMjc5ODA4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/DeviceStatus.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwODo1MToxMFrOIF_mpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwOToyMDowNlrOIGAz8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1NTg3Nw==", "bodyText": "this means that the property will always be included in the JSON document. Is that what you want to achieve?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r543155877", "createdAt": "2020-12-15T08:51:10Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/DeviceStatus.java", "diffHunk": "@@ -39,6 +37,7 @@\n      *\n      * @return {@code true} if this device was auto-provisioned.\n      */\n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONED)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00cb3f3823b046519c409716636186245451b471"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3NTY2Ng==", "bodyText": "I moved that annotation to the getter, since I found out when doing manual testing for double-checking if the authorities property is included (see #2094 (comment)) that it seems like this annotation has no effect when it is put on the field level, meaning the property is serialised using a camel-cased name.\nUnfortunately I did not manage yet to find out what the root-cause for this behaviour is. There's even a unit test which is still succeeding when the property is on the field level. So I guess this must be caused by using Jackson together with Vert.x...\nBesides that I think that the property being always serialised is not the effect of this annotation being put on the method level, but stems from the primitive type being returned by the getter (which we deliberately set to avoid null-checking).\nSemantically I think it is correct: devices which were created before the implementation of auto-provisioning won't have the corresponding flag set resulting in returning false for the auto-provisioned property. In my opinion this is correct as they actually haven't been auto-provisioned.\nI didn't see any value in exposing if the device was created before or after this feature was implemented to the client which is why I deemed it acceptable.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r543175666", "createdAt": "2020-12-15T09:20:06Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/management/device/DeviceStatus.java", "diffHunk": "@@ -39,6 +37,7 @@\n      *\n      * @return {@code true} if this device was auto-provisioned.\n      */\n+    @JsonProperty(RegistryManagementConstants.FIELD_AUTO_PROVISIONED)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1NTg3Nw=="}, "originalCommit": {"oid": "00cb3f3823b046519c409716636186245451b471"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMjgxMzA5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwODo1NDozMFrOIF_vqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjowNzozOVrOIGTOuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1ODE4Nw==", "bodyText": "if we already have a DeviceManagementService then why do we also need a DeviceRegistrationInformationService? Couldn't we simply use DeviceManagementService.readDevice()?", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r543158187", "createdAt": "2020-12-15T08:54:30Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private DeviceManagementService deviceManagementService;\n+\n+    private DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the {@link DeviceManagementService} to use.\n+     *\n+     * @param deviceManagementService The service to set.\n+     *\n+     * @throws NullPointerException if the service is {@code null}.\n+     */\n+    @Autowired\n+    public void setDeviceManagementService(final DeviceManagementService deviceManagementService) {\n+        this.deviceManagementService = Objects.requireNonNull(deviceManagementService);\n+    }\n+\n+    /**\n+     * Sets the {@link DeviceRegistrationInformationService} to use.\n+     *\n+     * @param deviceRegistrationInformationService The service to set.\n+     *\n+     * @throws NullPointerException if the service is {@code null}.\n+     */\n+    @Autowired\n+    public void setDeviceRegistrationInformationService(final DeviceRegistrationInformationService deviceRegistrationInformationService) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00cb3f3823b046519c409716636186245451b471"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5MDk0NQ==", "bodyText": "Hmm. Good question. When refactoring I noticed that the implementation of the getRegistrationInformation method is slightly different from readDevice.\nI think (at least for MongoDb) it can be replaced but I didn't want to add this to the scope of this PR (especially as this will affect all registries then...)", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r543190945", "createdAt": "2020-12-15T09:41:15Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private DeviceManagementService deviceManagementService;\n+\n+    private DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the {@link DeviceManagementService} to use.\n+     *\n+     * @param deviceManagementService The service to set.\n+     *\n+     * @throws NullPointerException if the service is {@code null}.\n+     */\n+    @Autowired\n+    public void setDeviceManagementService(final DeviceManagementService deviceManagementService) {\n+        this.deviceManagementService = Objects.requireNonNull(deviceManagementService);\n+    }\n+\n+    /**\n+     * Sets the {@link DeviceRegistrationInformationService} to use.\n+     *\n+     * @param deviceRegistrationInformationService The service to set.\n+     *\n+     * @throws NullPointerException if the service is {@code null}.\n+     */\n+    @Autowired\n+    public void setDeviceRegistrationInformationService(final DeviceRegistrationInformationService deviceRegistrationInformationService) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1ODE4Nw=="}, "originalCommit": {"oid": "00cb3f3823b046519c409716636186245451b471"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI5MTQxNw==", "bodyText": "In particular, DeviceManagementService.readDevice() returns a Device object instance instead of just Json which should actually make implementation of the sendDelayedAutoProvisioningNotificationIfNeeded method easier as there is no need to parse Json ...\nSo, unless there is a more specific reason than\n\nthe implementation of the getRegistrationInformation method is slightly different from readDevice\n\nI think we should remove this field ...", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r543291417", "createdAt": "2020-12-15T12:13:12Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private DeviceManagementService deviceManagementService;\n+\n+    private DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the {@link DeviceManagementService} to use.\n+     *\n+     * @param deviceManagementService The service to set.\n+     *\n+     * @throws NullPointerException if the service is {@code null}.\n+     */\n+    @Autowired\n+    public void setDeviceManagementService(final DeviceManagementService deviceManagementService) {\n+        this.deviceManagementService = Objects.requireNonNull(deviceManagementService);\n+    }\n+\n+    /**\n+     * Sets the {@link DeviceRegistrationInformationService} to use.\n+     *\n+     * @param deviceRegistrationInformationService The service to set.\n+     *\n+     * @throws NullPointerException if the service is {@code null}.\n+     */\n+    @Autowired\n+    public void setDeviceRegistrationInformationService(final DeviceRegistrationInformationService deviceRegistrationInformationService) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1ODE4Nw=="}, "originalCommit": {"oid": "00cb3f3823b046519c409716636186245451b471"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3NzQzMg==", "bodyText": "Done.", "url": "https://github.com/eclipse/hono/pull/2094#discussion_r543477432", "createdAt": "2020-12-15T16:07:39Z", "author": {"login": "fkaltner"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/device/AutoProvisioner.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.hono.deviceregistry.service.device;\n+\n+import java.net.HttpURLConnection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.DownstreamSender;\n+import org.eclipse.hono.client.DownstreamSenderFactory;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.deviceregistry.service.tenant.NoopTenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantInformationService;\n+import org.eclipse.hono.deviceregistry.service.tenant.TenantKey;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.device.Device;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.management.device.DeviceStatus;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.EventConstants;\n+import org.eclipse.hono.util.Lifecycle;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.QoS;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.eclipse.hono.util.TenantObject;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.noop.NoopTracerFactory;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Implements gateway based auto-provisioning.\n+ */\n+public class AutoProvisioner implements Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AutoProvisioner.class);\n+\n+    private Tracer tracer = NoopTracerFactory.create();\n+\n+    private DeviceManagementService deviceManagementService;\n+\n+    private DeviceRegistrationInformationService deviceRegistrationInformationService;\n+\n+    private TenantInformationService tenantInformationService = new NoopTenantInformationService();\n+\n+    private DownstreamSenderFactory downstreamSenderFactory;\n+\n+    private Future<HonoConnection> connectionAttempt;\n+\n+    private Vertx vertx;\n+\n+    private AutoProvisionerConfigProperties config;\n+\n+    @Override\n+    public final Future<Void> start() {\n+        // Required since every endpoint may call the start() method of its referenced service leading to multiple calls\n+        // to start(). This results in an exception in the factory's connect() method.\n+        synchronized (this) {\n+            if (connectionAttempt == null) {\n+                connectionAttempt = downstreamSenderFactory.connect().map(connection -> {\n+                    LOG.info(\"connected to AMQP network\");\n+                    if (vertx == null && connection != null) {\n+                        vertx = connection.getVertx();\n+                    }\n+                    return connection;\n+                }).recover(t -> {\n+                    LOG.warn(\"failed to connect to AMQP network\", t);\n+                    return Future.failedFuture(t);\n+                });\n+            }\n+        }\n+\n+        return connectionAttempt.mapEmpty();\n+    }\n+\n+    @Override\n+    public final Future<Void> stop() {\n+        final Promise<Void> result = Promise.promise();\n+        downstreamSenderFactory.disconnect(result);\n+        return result.future();\n+    }\n+\n+    /**\n+     * Sets the vert.x instance.\n+     *\n+     * @param vertx The vert.x instance.\n+     * @throws NullPointerException if vert.x is {@code null}.\n+     */\n+    @Autowired\n+    public final void setVertx(final Vertx vertx) {\n+        this.vertx = Objects.requireNonNull(vertx);\n+    }\n+\n+    /**\n+     * Sets the factory to use for creating a client for the AMQP Messaging Network.\n+     *\n+     * @param factory The factory.\n+     * @throws NullPointerException if the factory is {@code null}.\n+     */\n+    @Autowired\n+    public final void setDownstreamSenderFactory(final DownstreamSenderFactory factory) {\n+        this.downstreamSenderFactory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Sets the {@link DeviceManagementService} to use.\n+     *\n+     * @param deviceManagementService The service to set.\n+     *\n+     * @throws NullPointerException if the service is {@code null}.\n+     */\n+    @Autowired\n+    public void setDeviceManagementService(final DeviceManagementService deviceManagementService) {\n+        this.deviceManagementService = Objects.requireNonNull(deviceManagementService);\n+    }\n+\n+    /**\n+     * Sets the {@link DeviceRegistrationInformationService} to use.\n+     *\n+     * @param deviceRegistrationInformationService The service to set.\n+     *\n+     * @throws NullPointerException if the service is {@code null}.\n+     */\n+    @Autowired\n+    public void setDeviceRegistrationInformationService(final DeviceRegistrationInformationService deviceRegistrationInformationService) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1ODE4Nw=="}, "originalCommit": {"oid": "00cb3f3823b046519c409716636186245451b471"}, "originalPosition": 156}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3216, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}