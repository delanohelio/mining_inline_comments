{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5Njc0MjA5", "number": 1841, "title": "[#1272] Implement new Command & Control handling", "bodyText": "This is the main implementation for #1272.\nKey classes:\n\nProtocolAdapterCommandConsumerFactoryImpl (formerly CommandConsumerFactoryImpl) is the main implementation class and takes care of the 2 different consumer links (tenant-scoped links and the single link with the adapter instance id).\nMappingAndDelegatingCommandHandler is the point where incoming commands, sent on the tenant-scoped address, get handled first. If necessary, commands get forwarded on the adapter instance address.\nAdapterInstanceCommandHandler is used for handling commands, having arrived at the adapter instance address.\n\nDetermining mapped gateway and target protocol adapter instance:\nThis is done in the CommandTargetMapper class (formerly GatewayMapper).\nHandling of RegistrationClientFactory, DeviceConnectionClientFactory instances:\nThe ProtocolAdapterCommandConsumerFactoryImpl and CommandTargetMapperImpl need such instances. Previously, these ClientFactories got managed in these classes (connect method got called).\nHowever, with the new need of ProtocolAdapterCommandConsumerFactoryImpl using a DeviceConnectionClientFactory, this got somewhat messy, having to override the ConnectionLifecyle methods and deciding which of ProtocolAdapterCommandConsumerFactoryImpl and CommandTargetMapperImpl should call the connect method.\nTherefore I've changed this so that the ClientFactory instances get passed on in new initialize methods.\nThe management of the ClientFactory instances (calling the connect method) gets done in the central AbstractProtocolAdapterBase class.\nA change in behaviour:\nThe DeviceConnectionService.setCommandHandlingAdapterInstance method overwrites an existing entry, not returning a \"already in use\" exception. With this, stale entries cannot block new command subscriptions.\nIn the same way, ProtocolAdapterCommandConsumerFactory.createCommandConsumer doesn't return a ResourceConflictException exception (consumer already in use) any more.\nThat ResourceConflictException was inconsistent anyway - command consumer information was not synced across protocol adapter instances.\nIn the HTTP adapter logic, there was special treatment of that ResourceConflictException case. It meant, that with 2 ttd-requests that overlapped each other, the first request returned the command message while the second returned nothing.\nNow, this is the other way round: The second request will overwrite the command handler and therefore the second request will return the command.\nI think this is not a problem, we will just have to document the change in behaviour.", "createdAt": "2020-03-17T07:39:58Z", "url": "https://github.com/eclipse/hono/pull/1841", "merged": true, "mergeCommit": {"oid": "a97b3a76e8298b811cfca4b93a5aba70441238c2"}, "closed": true, "closedAt": "2020-03-22T19:36:16Z", "author": {"login": "calohmn"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcOe6sagFqTM3NTgxNDEzNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcQMPCCgFqTM3OTAyMTk2MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1ODE0MTM1", "url": "https://github.com/eclipse/hono/pull/1841#pullrequestreview-375814135", "createdAt": "2020-03-17T08:13:14Z", "commit": {"oid": "4876be5363e63da184b42f9e138d6a90942891f7"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODoxMzoxNVrOF3RmNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODo0ODoyMFrOF3SrWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNDMxMA==", "bodyText": "why don't we simply pass the client factories into the create method?", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393504310", "createdAt": "2020-03-17T08:13:15Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/CommandTargetMapper.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client;\n+\n+import org.eclipse.hono.client.impl.CommandTargetMapperImpl;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A component for mapping an incoming command to the gateway (if applicable)\n+ * and protocol adapter instance that can handle it.\n+ */\n+public interface CommandTargetMapper {\n+\n+    /**\n+     * Creates a new {@link CommandTargetMapper} using the default implementation.\n+     *\n+     * @param tracer The tracer instance.\n+     * @return The CommandTargetMapper instance.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    static CommandTargetMapper create(final Tracer tracer) {\n+        return new CommandTargetMapperImpl(tracer);\n+    }\n+\n+    /**\n+     * Initializes the CommandTargetMapper with the given components.\n+     *\n+     * @param registrationClientFactory The factory to create a registration client instance. Note that no\n+     *            initialization of this factory will be done here, that is supposed to be done by the calling method.\n+     * @param deviceConnectionClientFactory The factory to create a device connection client instance. Note that no\n+     *            initialization of this factory will be done here, that is supposed to be done by the calling method.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    void initialize(RegistrationClientFactory registrationClientFactory,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4876be5363e63da184b42f9e138d6a90942891f7"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNDk2Nw==", "bodyText": "2019, 2020?", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393504967", "createdAt": "2020-03-17T08:14:32Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019 Contributors to the Eclipse Foundation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4876be5363e63da184b42f9e138d6a90942891f7"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNjI0Ng==", "bodyText": "how about using the adapter's container name used in the connection for the purpose of the adapter instance ID?", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393506246", "createdAt": "2020-03-17T08:17:06Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client;\n+\n+import org.eclipse.hono.client.impl.CommandConsumer;\n+import org.eclipse.hono.client.impl.ProtocolAdapterCommandConsumerFactoryImpl;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+\n+/**\n+ * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to\n+ * receive commands and send responses.\n+ */\n+public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecycle<HonoConnection> {\n+\n+    /**\n+     * Creates a new factory for an existing connection.\n+     *\n+     * @param connection The connection to the AMQP network.\n+     * @param adapterInstanceId The id of the protocol adapter instance that this factory is running in.\n+     * @return The factory.\n+     * @throws NullPointerException if connection or gatewayMapper is {@code null}.\n+     */\n+    static ProtocolAdapterCommandConsumerFactory create(final HonoConnection connection, final String adapterInstanceId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4876be5363e63da184b42f9e138d6a90942891f7"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNjQ3OQ==", "bodyText": "why not pass them in to the create method?", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393506479", "createdAt": "2020-03-17T08:17:36Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client;\n+\n+import org.eclipse.hono.client.impl.CommandConsumer;\n+import org.eclipse.hono.client.impl.ProtocolAdapterCommandConsumerFactoryImpl;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+\n+/**\n+ * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to\n+ * receive commands and send responses.\n+ */\n+public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecycle<HonoConnection> {\n+\n+    /**\n+     * Creates a new factory for an existing connection.\n+     *\n+     * @param connection The connection to the AMQP network.\n+     * @param adapterInstanceId The id of the protocol adapter instance that this factory is running in.\n+     * @return The factory.\n+     * @throws NullPointerException if connection or gatewayMapper is {@code null}.\n+     */\n+    static ProtocolAdapterCommandConsumerFactory create(final HonoConnection connection, final String adapterInstanceId) {\n+        return new ProtocolAdapterCommandConsumerFactoryImpl(connection, adapterInstanceId);\n+    }\n+\n+    /**\n+     * Initializes the ProtocolAdapterCommandConsumerFactory with the given components.\n+     *\n+     * @param commandTargetMapper The component for mapping an incoming command to the gateway (if applicable) and\n+     *            protocol adapter instance that can handle it. Note that no initialization of this factory will be done\n+     *            here, that is supposed to be done by the calling method.\n+     * @param deviceConnectionClientFactory The factory to create a device connection client instance. Note that no\n+     *            initialization of this factory will be done here, that is supposed to be done by the calling method.\n+     */\n+    void initialize(CommandTargetMapper commandTargetMapper,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4876be5363e63da184b42f9e138d6a90942891f7"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNzE3Mw==", "bodyText": "what happens if I invoke this method multiple times with the same params?", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393507173", "createdAt": "2020-03-17T08:19:01Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client;\n+\n+import org.eclipse.hono.client.impl.CommandConsumer;\n+import org.eclipse.hono.client.impl.ProtocolAdapterCommandConsumerFactoryImpl;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+\n+/**\n+ * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to\n+ * receive commands and send responses.\n+ */\n+public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecycle<HonoConnection> {\n+\n+    /**\n+     * Creates a new factory for an existing connection.\n+     *\n+     * @param connection The connection to the AMQP network.\n+     * @param adapterInstanceId The id of the protocol adapter instance that this factory is running in.\n+     * @return The factory.\n+     * @throws NullPointerException if connection or gatewayMapper is {@code null}.\n+     */\n+    static ProtocolAdapterCommandConsumerFactory create(final HonoConnection connection, final String adapterInstanceId) {\n+        return new ProtocolAdapterCommandConsumerFactoryImpl(connection, adapterInstanceId);\n+    }\n+\n+    /**\n+     * Initializes the ProtocolAdapterCommandConsumerFactory with the given components.\n+     *\n+     * @param commandTargetMapper The component for mapping an incoming command to the gateway (if applicable) and\n+     *            protocol adapter instance that can handle it. Note that no initialization of this factory will be done\n+     *            here, that is supposed to be done by the calling method.\n+     * @param deviceConnectionClientFactory The factory to create a device connection client instance. Note that no\n+     *            initialization of this factory will be done here, that is supposed to be done by the calling method.\n+     */\n+    void initialize(CommandTargetMapper commandTargetMapper,\n+            BasicDeviceConnectionClientFactory deviceConnectionClientFactory);\n+\n+    /**\n+     * Creates a command consumer for a device.\n+     * <p>\n+     * For each device only one command consumer may be active at any given time.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4876be5363e63da184b42f9e138d6a90942891f7"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNzYxMA==", "bodyText": "for a device that is connected via a gateway?", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393507610", "createdAt": "2020-03-17T08:19:57Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/ProtocolAdapterCommandConsumerFactory.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client;\n+\n+import org.eclipse.hono.client.impl.CommandConsumer;\n+import org.eclipse.hono.client.impl.ProtocolAdapterCommandConsumerFactoryImpl;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+\n+/**\n+ * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to\n+ * receive commands and send responses.\n+ */\n+public interface ProtocolAdapterCommandConsumerFactory extends ConnectionLifecycle<HonoConnection> {\n+\n+    /**\n+     * Creates a new factory for an existing connection.\n+     *\n+     * @param connection The connection to the AMQP network.\n+     * @param adapterInstanceId The id of the protocol adapter instance that this factory is running in.\n+     * @return The factory.\n+     * @throws NullPointerException if connection or gatewayMapper is {@code null}.\n+     */\n+    static ProtocolAdapterCommandConsumerFactory create(final HonoConnection connection, final String adapterInstanceId) {\n+        return new ProtocolAdapterCommandConsumerFactoryImpl(connection, adapterInstanceId);\n+    }\n+\n+    /**\n+     * Initializes the ProtocolAdapterCommandConsumerFactory with the given components.\n+     *\n+     * @param commandTargetMapper The component for mapping an incoming command to the gateway (if applicable) and\n+     *            protocol adapter instance that can handle it. Note that no initialization of this factory will be done\n+     *            here, that is supposed to be done by the calling method.\n+     * @param deviceConnectionClientFactory The factory to create a device connection client instance. Note that no\n+     *            initialization of this factory will be done here, that is supposed to be done by the calling method.\n+     */\n+    void initialize(CommandTargetMapper commandTargetMapper,\n+            BasicDeviceConnectionClientFactory deviceConnectionClientFactory);\n+\n+    /**\n+     * Creates a command consumer for a device.\n+     * <p>\n+     * For each device only one command consumer may be active at any given time.\n+     * It is the responsibility of the calling code to properly close a consumer\n+     * once it is no longer needed by invoking its {@link CommandConsumer#close(Handler)}\n+     * method.\n+     * <p>\n+     * Note that {@link #initialize(CommandTargetMapper, BasicDeviceConnectionClientFactory)} has to have been called\n+     * already, otherwise a failed future is returned.\n+     * \n+     * @param tenantId The tenant to consume commands from.\n+     * @param deviceId The device for which the consumer will be created.\n+     * @param commandHandler The handler to invoke with every command received.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future will be completed with the newly created consumer once the link\n+     *         has been established.\n+     *         <p>\n+     *         The future will be failed with a {@link ServiceInvocationException} with an error code indicating\n+     *         the cause of the failure.\n+     * @throws NullPointerException if any of tenant, device ID or command handler are {@code null}.\n+     */\n+    Future<MessageConsumer> createCommandConsumer(\n+            String tenantId,\n+            String deviceId,\n+            Handler<CommandContext> commandHandler);\n+\n+    /**\n+     * Creates a command consumer for a device.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4876be5363e63da184b42f9e138d6a90942891f7"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwOTE2Mg==", "bodyText": "how about returning a boolean indicating whether a handler has been replaced or not?", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393509162", "createdAt": "2020-03-17T08:23:13Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.auth.Device;\n+import org.eclipse.hono.client.Command;\n+import org.eclipse.hono.client.CommandContext;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.vertx.core.Handler;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+\n+/**\n+ * Handler for commands received at the protocol adapter specific address.\n+ */\n+public final class AdapterInstanceCommandHandler {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AdapterInstanceCommandHandler.class);\n+\n+    private final Map<String, CommandHandlerWrapper> commandHandlers = new HashMap<>();\n+    private final Tracer tracer;\n+\n+    /**\n+     * Creates a new AdapterInstanceCommandHandler instance.\n+     *\n+     * @param tracer The tracer instance.\n+     */\n+    public AdapterInstanceCommandHandler(final Tracer tracer) {\n+        this.tracer = tracer;\n+    }\n+\n+    /**\n+     * Handles a received command message.\n+     *\n+     * @param msg The command message.\n+     * @param delivery The delivery.\n+     */\n+    public void handleCommandMessage(final Message msg, final ProtonDelivery delivery) {\n+        // command could have been mapped to a gateway, but the original address stays the same in the message address in that case\n+        final ResourceIdentifier resourceIdentifier = msg.getAddress() != null ? ResourceIdentifier.fromString(msg.getAddress()) : null;\n+        if (resourceIdentifier == null || resourceIdentifier.getResourceId() == null) {\n+            LOG.debug(\"address of command message is invalid: {}\", msg.getAddress());\n+            final Rejected rejected = new Rejected();\n+            rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"invalid command target address\"));\n+            delivery.disposition(rejected, true);\n+            return;\n+        }\n+        final String tenantId = resourceIdentifier.getTenantId();\n+        final String originalDeviceId = resourceIdentifier.getResourceId();\n+        // fetch \"via\" property (if set)\n+        String gatewayId = MessageHelper.getApplicationProperty(msg.getApplicationProperties(), MessageHelper.APP_PROPERTY_CMD_VIA, String.class);\n+        final CommandHandlerWrapper commandHandler = getDeviceSpecificCommandHandler(tenantId, originalDeviceId, gatewayId);\n+        if (commandHandler != null && gatewayId == null && commandHandler.getGatewayId() != null) {\n+            // there's a gateway having specifically subscribed for commands to that device here;\n+            // in that case the command handler was registered with the specific device id, not the gateway\n+            // (\"deviceConnectionService.setCommandHandlingAdapterInstance()\" doesn't have an extra gateway id parameter)\n+            // => therefore no gateway information was transported with the incoming message here and we have to take\n+            //    the gateway information from the chosen commandHandler.\n+            gatewayId = commandHandler.getGatewayId();\n+        }\n+        final Command command = Command.from(msg, tenantId, gatewayId != null ? gatewayId : originalDeviceId);\n+\n+        final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, msg);\n+        final Span currentSpan = CommandConsumer.createSpan(\"send command\", tenantId, originalDeviceId,\n+                gatewayId, tracer, spanContext);\n+        CommandConsumer.logReceivedCommandToSpan(command, currentSpan);\n+\n+        if (commandHandler != null) {\n+            LOG.trace(\"using [{}] for received command [{}]\", commandHandler, command);\n+            // command.isValid() check not done here - it is to be done in the command handler\n+            commandHandler.handleCommand(CommandContext.from(command, delivery, currentSpan));\n+        } else {\n+            LOG.info(\"no command handler found for command with device id {}, gateway id {} [tenant-id: {}]\",\n+                    originalDeviceId, gatewayId, tenantId);\n+            TracingHelper.logError(currentSpan, \"no command handler found for command\");\n+            currentSpan.finish();\n+            ProtonHelper.released(delivery, true);\n+        }\n+    }\n+\n+    /**\n+     * Adds a handler for commands targeted at a device that is connected either directly or via a gateway.\n+     *\n+     * @param tenantId The tenant id.\n+     * @param deviceId The identifier of the device that is the target of the commands being handled.\n+     * @param gatewayId The identifier of the gateway that is acting on behalf of the device that is\n+     *                  the target of the commands being handled, or {@code null} otherwise.\n+     * @param commandHandler The command handler.\n+     * @throws NullPointerException If any of tenantId, deviceId or commandHandler is {@code null}.\n+     */\n+    public void addDeviceSpecificCommandHandler(final String tenantId, final String deviceId,\n+            final String gatewayId, final Handler<CommandContext> commandHandler) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(commandHandler);\n+\n+        final String key = getDeviceKey(tenantId, deviceId);\n+        if (commandHandlers.containsKey(key)) {\n+            LOG.debug(\"replacing existing command consumer [tenant-id: {}, device-id: {}]\", tenantId, deviceId);\n+            // TODO find provide a notification here so that potential resources associated with the replaced consumer can be freed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4876be5363e63da184b42f9e138d6a90942891f7"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwOTg2Mg==", "bodyText": "what if originalDeviceId is null?", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393509862", "createdAt": "2020-03-17T08:24:33Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.auth.Device;\n+import org.eclipse.hono.client.Command;\n+import org.eclipse.hono.client.CommandContext;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.vertx.core.Handler;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+\n+/**\n+ * Handler for commands received at the protocol adapter specific address.\n+ */\n+public final class AdapterInstanceCommandHandler {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AdapterInstanceCommandHandler.class);\n+\n+    private final Map<String, CommandHandlerWrapper> commandHandlers = new HashMap<>();\n+    private final Tracer tracer;\n+\n+    /**\n+     * Creates a new AdapterInstanceCommandHandler instance.\n+     *\n+     * @param tracer The tracer instance.\n+     */\n+    public AdapterInstanceCommandHandler(final Tracer tracer) {\n+        this.tracer = tracer;\n+    }\n+\n+    /**\n+     * Handles a received command message.\n+     *\n+     * @param msg The command message.\n+     * @param delivery The delivery.\n+     */\n+    public void handleCommandMessage(final Message msg, final ProtonDelivery delivery) {\n+        // command could have been mapped to a gateway, but the original address stays the same in the message address in that case\n+        final ResourceIdentifier resourceIdentifier = msg.getAddress() != null ? ResourceIdentifier.fromString(msg.getAddress()) : null;\n+        if (resourceIdentifier == null || resourceIdentifier.getResourceId() == null) {\n+            LOG.debug(\"address of command message is invalid: {}\", msg.getAddress());\n+            final Rejected rejected = new Rejected();\n+            rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"invalid command target address\"));\n+            delivery.disposition(rejected, true);\n+            return;\n+        }\n+        final String tenantId = resourceIdentifier.getTenantId();\n+        final String originalDeviceId = resourceIdentifier.getResourceId();\n+        // fetch \"via\" property (if set)\n+        String gatewayId = MessageHelper.getApplicationProperty(msg.getApplicationProperties(), MessageHelper.APP_PROPERTY_CMD_VIA, String.class);\n+        final CommandHandlerWrapper commandHandler = getDeviceSpecificCommandHandler(tenantId, originalDeviceId, gatewayId);\n+        if (commandHandler != null && gatewayId == null && commandHandler.getGatewayId() != null) {\n+            // there's a gateway having specifically subscribed for commands to that device here;\n+            // in that case the command handler was registered with the specific device id, not the gateway\n+            // (\"deviceConnectionService.setCommandHandlingAdapterInstance()\" doesn't have an extra gateway id parameter)\n+            // => therefore no gateway information was transported with the incoming message here and we have to take\n+            //    the gateway information from the chosen commandHandler.\n+            gatewayId = commandHandler.getGatewayId();\n+        }\n+        final Command command = Command.from(msg, tenantId, gatewayId != null ? gatewayId : originalDeviceId);\n+\n+        final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, msg);\n+        final Span currentSpan = CommandConsumer.createSpan(\"send command\", tenantId, originalDeviceId,\n+                gatewayId, tracer, spanContext);\n+        CommandConsumer.logReceivedCommandToSpan(command, currentSpan);\n+\n+        if (commandHandler != null) {\n+            LOG.trace(\"using [{}] for received command [{}]\", commandHandler, command);\n+            // command.isValid() check not done here - it is to be done in the command handler\n+            commandHandler.handleCommand(CommandContext.from(command, delivery, currentSpan));\n+        } else {\n+            LOG.info(\"no command handler found for command with device id {}, gateway id {} [tenant-id: {}]\",\n+                    originalDeviceId, gatewayId, tenantId);\n+            TracingHelper.logError(currentSpan, \"no command handler found for command\");\n+            currentSpan.finish();\n+            ProtonHelper.released(delivery, true);\n+        }\n+    }\n+\n+    /**\n+     * Adds a handler for commands targeted at a device that is connected either directly or via a gateway.\n+     *\n+     * @param tenantId The tenant id.\n+     * @param deviceId The identifier of the device that is the target of the commands being handled.\n+     * @param gatewayId The identifier of the gateway that is acting on behalf of the device that is\n+     *                  the target of the commands being handled, or {@code null} otherwise.\n+     * @param commandHandler The command handler.\n+     * @throws NullPointerException If any of tenantId, deviceId or commandHandler is {@code null}.\n+     */\n+    public void addDeviceSpecificCommandHandler(final String tenantId, final String deviceId,\n+            final String gatewayId, final Handler<CommandContext> commandHandler) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(commandHandler);\n+\n+        final String key = getDeviceKey(tenantId, deviceId);\n+        if (commandHandlers.containsKey(key)) {\n+            LOG.debug(\"replacing existing command consumer [tenant-id: {}, device-id: {}]\", tenantId, deviceId);\n+            // TODO find provide a notification here so that potential resources associated with the replaced consumer can be freed\n+        }\n+        commandHandlers.put(key, new CommandHandlerWrapper(tenantId, deviceId, gatewayId, commandHandler));\n+    }\n+\n+    /**\n+     * Gets a handler for the given device id or for the given gateway id.\n+     *\n+     * @param tenantId The tenant id.\n+     * @param originalDeviceId The device id that the command is originally targeted at.\n+     * @param gatewayId The gateway id. May be {@code null}.\n+     * @return The handler or {@code null}.\n+     */\n+    public CommandHandlerWrapper getDeviceSpecificCommandHandler(final String tenantId, final String originalDeviceId, final String gatewayId) {\n+        // look for a handler with the original device id first\n+        CommandHandlerWrapper handler = commandHandlers.get(getDeviceKey(tenantId, originalDeviceId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4876be5363e63da184b42f9e138d6a90942891f7"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxNDMxNg==", "bodyText": "who is finishing the currentSpan?", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393514316", "createdAt": "2020-03-17T08:33:35Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/AdapterInstanceCommandHandler.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.auth.Device;\n+import org.eclipse.hono.client.Command;\n+import org.eclipse.hono.client.CommandContext;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.vertx.core.Handler;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+\n+/**\n+ * Handler for commands received at the protocol adapter specific address.\n+ */\n+public final class AdapterInstanceCommandHandler {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AdapterInstanceCommandHandler.class);\n+\n+    private final Map<String, CommandHandlerWrapper> commandHandlers = new HashMap<>();\n+    private final Tracer tracer;\n+\n+    /**\n+     * Creates a new AdapterInstanceCommandHandler instance.\n+     *\n+     * @param tracer The tracer instance.\n+     */\n+    public AdapterInstanceCommandHandler(final Tracer tracer) {\n+        this.tracer = tracer;\n+    }\n+\n+    /**\n+     * Handles a received command message.\n+     *\n+     * @param msg The command message.\n+     * @param delivery The delivery.\n+     */\n+    public void handleCommandMessage(final Message msg, final ProtonDelivery delivery) {\n+        // command could have been mapped to a gateway, but the original address stays the same in the message address in that case\n+        final ResourceIdentifier resourceIdentifier = msg.getAddress() != null ? ResourceIdentifier.fromString(msg.getAddress()) : null;\n+        if (resourceIdentifier == null || resourceIdentifier.getResourceId() == null) {\n+            LOG.debug(\"address of command message is invalid: {}\", msg.getAddress());\n+            final Rejected rejected = new Rejected();\n+            rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"invalid command target address\"));\n+            delivery.disposition(rejected, true);\n+            return;\n+        }\n+        final String tenantId = resourceIdentifier.getTenantId();\n+        final String originalDeviceId = resourceIdentifier.getResourceId();\n+        // fetch \"via\" property (if set)\n+        String gatewayId = MessageHelper.getApplicationProperty(msg.getApplicationProperties(), MessageHelper.APP_PROPERTY_CMD_VIA, String.class);\n+        final CommandHandlerWrapper commandHandler = getDeviceSpecificCommandHandler(tenantId, originalDeviceId, gatewayId);\n+        if (commandHandler != null && gatewayId == null && commandHandler.getGatewayId() != null) {\n+            // there's a gateway having specifically subscribed for commands to that device here;\n+            // in that case the command handler was registered with the specific device id, not the gateway\n+            // (\"deviceConnectionService.setCommandHandlingAdapterInstance()\" doesn't have an extra gateway id parameter)\n+            // => therefore no gateway information was transported with the incoming message here and we have to take\n+            //    the gateway information from the chosen commandHandler.\n+            gatewayId = commandHandler.getGatewayId();\n+        }\n+        final Command command = Command.from(msg, tenantId, gatewayId != null ? gatewayId : originalDeviceId);\n+\n+        final SpanContext spanContext = TracingHelper.extractSpanContext(tracer, msg);\n+        final Span currentSpan = CommandConsumer.createSpan(\"send command\", tenantId, originalDeviceId,\n+                gatewayId, tracer, spanContext);\n+        CommandConsumer.logReceivedCommandToSpan(command, currentSpan);\n+\n+        if (commandHandler != null) {\n+            LOG.trace(\"using [{}] for received command [{}]\", commandHandler, command);\n+            // command.isValid() check not done here - it is to be done in the command handler\n+            commandHandler.handleCommand(CommandContext.from(command, delivery, currentSpan));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4876be5363e63da184b42f9e138d6a90942891f7"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxNTY5Nw==", "bodyText": "these should be moved down to after the private final fields ...", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393515697", "createdAt": "2020-03-17T08:36:18Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/CommandTargetMapperImpl.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.net.HttpURLConnection;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.hono.client.BasicDeviceConnectionClientFactory;\n+import org.eclipse.hono.client.CommandTargetMapper;\n+import org.eclipse.hono.client.RegistrationClientFactory;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A component for mapping an incoming command to the gateway (if applicable)\n+ * and protocol adapter instance that can handle it.\n+ */\n+public class CommandTargetMapperImpl implements CommandTargetMapper {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(CommandTargetMapperImpl.class);\n+\n+    private final Tracer tracer;\n+    private RegistrationClientFactory registrationClientFactory;\n+    private BasicDeviceConnectionClientFactory deviceConnectionClientFactory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4876be5363e63da184b42f9e138d6a90942891f7"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUxOTM5Mw==", "bodyText": "how about factoring this out into its own method?\nwe could also move it up one level in the compose hierarchy FMPOV ...", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393519393", "createdAt": "2020-03-17T08:43:25Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/CommandTargetMapperImpl.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.net.HttpURLConnection;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.hono.client.BasicDeviceConnectionClientFactory;\n+import org.eclipse.hono.client.CommandTargetMapper;\n+import org.eclipse.hono.client.RegistrationClientFactory;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A component for mapping an incoming command to the gateway (if applicable)\n+ * and protocol adapter instance that can handle it.\n+ */\n+public class CommandTargetMapperImpl implements CommandTargetMapper {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(CommandTargetMapperImpl.class);\n+\n+    private final Tracer tracer;\n+    private RegistrationClientFactory registrationClientFactory;\n+    private BasicDeviceConnectionClientFactory deviceConnectionClientFactory;\n+    private final AtomicBoolean initialized = new AtomicBoolean(false);\n+\n+    /**\n+     * Creates a new GatewayMapperImpl instance.\n+     *\n+     * @param tracer The tracer instance.\n+     * @throws NullPointerException if tracer is {@code null}.\n+     */\n+    public CommandTargetMapperImpl(final Tracer tracer) {\n+        this.tracer = Objects.requireNonNull(tracer);\n+    }\n+\n+    @Override\n+    public void initialize(final RegistrationClientFactory registrationClientFactory,\n+            final BasicDeviceConnectionClientFactory deviceConnectionClientFactory) {\n+        this.registrationClientFactory = Objects.requireNonNull(registrationClientFactory);\n+        this.deviceConnectionClientFactory = Objects.requireNonNull(deviceConnectionClientFactory);\n+        initialized.set(true);\n+    }\n+\n+    @Override\n+    public final Future<JsonObject> getTargetGatewayAndAdapterInstance(final String tenantId, final String deviceId, final SpanContext context) {\n+        if (!initialized.get()) {\n+            LOG.error(\"not initialized\");\n+            return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+        }\n+        final Span span = TracingHelper\n+                .buildChildSpan(tracer, context, \"get target gateway and adapter instance\",\n+                        CommandTargetMapper.class.getSimpleName())\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CONSUMER)\n+                .withTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId)\n+                .withTag(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId)\n+                .start();\n+\n+        return registrationClientFactory.getOrCreateRegistrationClient(tenantId)\n+                .compose(client -> client.assertRegistration(deviceId, null, span.context()))\n+                .recover(t -> {\n+                    LOG.debug(\"Error getting registration assertion\", t);\n+                    return Future.failedFuture(t);\n+                })\n+                .compose(registrationAssertionJson -> {\n+                    final Object viaObject = registrationAssertionJson.getValue(RegistrationConstants.FIELD_VIA);\n+                    @SuppressWarnings(\"unchecked\")\n+                    final List<String> viaGateways = viaObject instanceof JsonArray\n+                            ? new ArrayList<String>(((JsonArray) viaObject).getList())\n+                            : Collections.emptyList();\n+                    return deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenantId)\n+                            .compose(client -> client.getCommandHandlingAdapterInstances(deviceId, viaGateways, span.context()))\n+                            .compose(resultJson -> {\n+                                final JsonArray instancesArray = resultJson.getJsonArray(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES);\n+                                if (instancesArray == null || instancesArray.isEmpty()) {\n+                                    LOG.error(\"Invalid result JSON; field '{}' is null or empty\", DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES);\n+                                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                                }\n+\n+                                final JsonObject targetInstanceObject;\n+                                try {\n+                                    if (instancesArray.size() == 1) {\n+                                        targetInstanceObject = instancesArray.getJsonObject(0);\n+                                    } else {\n+                                        targetInstanceObject = chooseTargetGatewayAndAdapterInstance(instancesArray);\n+                                    }\n+                                } catch (final ClassCastException e) {\n+                                    LOG.error(\"Invalid result JSON\", e);\n+                                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                                }\n+                                final String targetDevice = targetInstanceObject.getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);\n+                                final String targetAdapterInstance = targetInstanceObject.getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);\n+                                if (targetDevice == null || targetAdapterInstance == null) {\n+                                    LOG.error(\"Invalid result JSON, missing target device and/or adapter instance\");\n+                                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                                }\n+                                if (!targetDevice.equals(deviceId)) {\n+                                    // target device is a gateway\n+                                    if (!viaGateways.contains(targetDevice)) {\n+                                        LOG.error(\"Invalid result JSON, target gateway {} is not in via gateways list\", targetDevice);\n+                                        return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                                    }\n+                                    span.setTag(MessageHelper.APP_PROPERTY_GATEWAY_ID, targetDevice);\n+                                }\n+                                span.finish();\n+                                return Future.succeededFuture(targetInstanceObject);\n+                            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4876be5363e63da184b42f9e138d6a90942891f7"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyMjAxMA==", "bodyText": "shouldn't this better return an ordered list of adapter instances so that an adapter can try to forward the command to one after the other if one of them rejects the command?", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393522010", "createdAt": "2020-03-17T08:48:20Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/CommandTargetMapperImpl.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.net.HttpURLConnection;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.eclipse.hono.client.BasicDeviceConnectionClientFactory;\n+import org.eclipse.hono.client.CommandTargetMapper;\n+import org.eclipse.hono.client.RegistrationClientFactory;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A component for mapping an incoming command to the gateway (if applicable)\n+ * and protocol adapter instance that can handle it.\n+ */\n+public class CommandTargetMapperImpl implements CommandTargetMapper {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(CommandTargetMapperImpl.class);\n+\n+    private final Tracer tracer;\n+    private RegistrationClientFactory registrationClientFactory;\n+    private BasicDeviceConnectionClientFactory deviceConnectionClientFactory;\n+    private final AtomicBoolean initialized = new AtomicBoolean(false);\n+\n+    /**\n+     * Creates a new GatewayMapperImpl instance.\n+     *\n+     * @param tracer The tracer instance.\n+     * @throws NullPointerException if tracer is {@code null}.\n+     */\n+    public CommandTargetMapperImpl(final Tracer tracer) {\n+        this.tracer = Objects.requireNonNull(tracer);\n+    }\n+\n+    @Override\n+    public void initialize(final RegistrationClientFactory registrationClientFactory,\n+            final BasicDeviceConnectionClientFactory deviceConnectionClientFactory) {\n+        this.registrationClientFactory = Objects.requireNonNull(registrationClientFactory);\n+        this.deviceConnectionClientFactory = Objects.requireNonNull(deviceConnectionClientFactory);\n+        initialized.set(true);\n+    }\n+\n+    @Override\n+    public final Future<JsonObject> getTargetGatewayAndAdapterInstance(final String tenantId, final String deviceId, final SpanContext context) {\n+        if (!initialized.get()) {\n+            LOG.error(\"not initialized\");\n+            return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+        }\n+        final Span span = TracingHelper\n+                .buildChildSpan(tracer, context, \"get target gateway and adapter instance\",\n+                        CommandTargetMapper.class.getSimpleName())\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CONSUMER)\n+                .withTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId)\n+                .withTag(MessageHelper.APP_PROPERTY_DEVICE_ID, deviceId)\n+                .start();\n+\n+        return registrationClientFactory.getOrCreateRegistrationClient(tenantId)\n+                .compose(client -> client.assertRegistration(deviceId, null, span.context()))\n+                .recover(t -> {\n+                    LOG.debug(\"Error getting registration assertion\", t);\n+                    return Future.failedFuture(t);\n+                })\n+                .compose(registrationAssertionJson -> {\n+                    final Object viaObject = registrationAssertionJson.getValue(RegistrationConstants.FIELD_VIA);\n+                    @SuppressWarnings(\"unchecked\")\n+                    final List<String> viaGateways = viaObject instanceof JsonArray\n+                            ? new ArrayList<String>(((JsonArray) viaObject).getList())\n+                            : Collections.emptyList();\n+                    return deviceConnectionClientFactory.getOrCreateDeviceConnectionClient(tenantId)\n+                            .compose(client -> client.getCommandHandlingAdapterInstances(deviceId, viaGateways, span.context()))\n+                            .compose(resultJson -> {\n+                                final JsonArray instancesArray = resultJson.getJsonArray(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES);\n+                                if (instancesArray == null || instancesArray.isEmpty()) {\n+                                    LOG.error(\"Invalid result JSON; field '{}' is null or empty\", DeviceConnectionConstants.FIELD_ADAPTER_INSTANCES);\n+                                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                                }\n+\n+                                final JsonObject targetInstanceObject;\n+                                try {\n+                                    if (instancesArray.size() == 1) {\n+                                        targetInstanceObject = instancesArray.getJsonObject(0);\n+                                    } else {\n+                                        targetInstanceObject = chooseTargetGatewayAndAdapterInstance(instancesArray);\n+                                    }\n+                                } catch (final ClassCastException e) {\n+                                    LOG.error(\"Invalid result JSON\", e);\n+                                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                                }\n+                                final String targetDevice = targetInstanceObject.getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);\n+                                final String targetAdapterInstance = targetInstanceObject.getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);\n+                                if (targetDevice == null || targetAdapterInstance == null) {\n+                                    LOG.error(\"Invalid result JSON, missing target device and/or adapter instance\");\n+                                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                                }\n+                                if (!targetDevice.equals(deviceId)) {\n+                                    // target device is a gateway\n+                                    if (!viaGateways.contains(targetDevice)) {\n+                                        LOG.error(\"Invalid result JSON, target gateway {} is not in via gateways list\", targetDevice);\n+                                        return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                                    }\n+                                    span.setTag(MessageHelper.APP_PROPERTY_GATEWAY_ID, targetDevice);\n+                                }\n+                                span.finish();\n+                                return Future.succeededFuture(targetInstanceObject);\n+                            });\n+                }).recover(t -> {\n+                    LOG.debug(\"Error getting target gateway and adapter instance\", t);\n+                    TracingHelper.logError(span, t);\n+                    Tags.HTTP_STATUS.set(span, ServiceInvocationException.extractStatusCode(t));\n+                    span.finish();\n+                    return Future.failedFuture(t);\n+                });\n+    }\n+\n+    /**\n+     * Chooses the target gateway and adapter instance from the given list of entries.\n+     * <p>\n+     * This method returns first entry from the given list.\n+     * <p>\n+     * Subclasses may override this method in order to apply a different algorithm.\n+     *\n+     * @param instancesArray The JSON array containing the target gateway and adapter instance entries to choose from.\n+     * @return The chosen JSON object.\n+     */\n+    protected JsonObject chooseTargetGatewayAndAdapterInstance(final JsonArray instancesArray) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4876be5363e63da184b42f9e138d6a90942891f7"}, "originalPosition": 156}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4876be5363e63da184b42f9e138d6a90942891f7", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/4876be5363e63da184b42f9e138d6a90942891f7", "committedDate": "2020-03-17T07:34:31Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}, "afterCommit": {"oid": "ef80b826b738980c6395b7632a2c60c819506d85", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/ef80b826b738980c6395b7632a2c60c819506d85", "committedDate": "2020-03-17T14:24:08Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ef80b826b738980c6395b7632a2c60c819506d85", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/ef80b826b738980c6395b7632a2c60c819506d85", "committedDate": "2020-03-17T14:24:08Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}, "afterCommit": {"oid": "f798f11d34680c31e27e52fe1da1ed1ce5c39d1c", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/f798f11d34680c31e27e52fe1da1ed1ce5c39d1c", "committedDate": "2020-03-17T15:16:10Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f798f11d34680c31e27e52fe1da1ed1ce5c39d1c", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/f798f11d34680c31e27e52fe1da1ed1ce5c39d1c", "committedDate": "2020-03-17T15:16:10Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}, "afterCommit": {"oid": "22f0073941892c831a32b49381de67e038ae5697", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/22f0073941892c831a32b49381de67e038ae5697", "committedDate": "2020-03-17T15:23:43Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2MTk4Mzg0", "url": "https://github.com/eclipse/hono/pull/1841#pullrequestreview-376198384", "createdAt": "2020-03-17T16:25:33Z", "commit": {"oid": "22f0073941892c831a32b49381de67e038ae5697"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjoyNTozM1rOF3kECg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjozMjo0M1rOF3kXZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgwNjg1OA==", "bodyText": "2019, 2020?", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393806858", "createdAt": "2020-03-17T16:25:33Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandler.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019 Contributors to the Eclipse Foundation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22f0073941892c831a32b49381de67e038ae5697"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzgxMTgxMw==", "bodyText": "I had hoped that we would be able to get rid of the second parameter altogether. But that might be done in a future PR ...", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r393811813", "createdAt": "2020-03-17T16:32:43Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/ProtocolAdapterCommandConsumerFactoryImpl.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/*******************************************************************************\n+ * Copyright (c) 2018, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.net.HttpURLConnection;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.hono.client.BasicDeviceConnectionClientFactory;\n+import org.eclipse.hono.client.CommandContext;\n+import org.eclipse.hono.client.CommandResponseSender;\n+import org.eclipse.hono.client.CommandTargetMapper;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.MessageConsumer;\n+import org.eclipse.hono.client.ProtocolAdapterCommandConsumerFactory;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.util.CommandConstants;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.eventbus.Message;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonReceiver;\n+\n+/**\n+ * A factory for creating clients for the <em>AMQP 1.0 Messaging Network</em> to receive commands and send responses.\n+ * <p>\n+ * The factory uses two kinds of consumer links to receive commands:\n+ * <ul>\n+ * <li>A single consumer link on an address containing the protocol adapter instance id.</li>\n+ * <li>A tenant-scoped link, created (if not already existing for that tenant) when\n+ * {@link #createCommandConsumer(String, String, Handler)} is invoked.</li>\n+ * </ul>\n+ * <p>\n+ * Command messages are first received on the tenant-scoped consumer address. It is then determined whether there is\n+ * a consumer and corresponding command handler for the command message's target device or one of the device's\n+ * possible gateways. If found, that handler is either invoked directly, or, if it is on another protocol adapter\n+ * instance, the command message is sent to that protocol adapter instance to be handled there.\n+ */\n+public class ProtocolAdapterCommandConsumerFactoryImpl extends AbstractHonoClientFactory implements ProtocolAdapterCommandConsumerFactory {\n+\n+    private static final int RECREATE_CONSUMERS_DELAY = 20;\n+\n+    /**\n+     * Cache key used here is the tenant id.\n+     */\n+    private CachingClientFactory<MessageConsumer> mappingAndDelegatingCommandConsumerFactory;\n+\n+    private final String adapterInstanceId;\n+    private final AdapterInstanceCommandHandler adapterInstanceCommandHandler;\n+    private final AtomicBoolean recreatingConsumers = new AtomicBoolean(false);\n+    private final AtomicBoolean tryAgainRecreatingConsumers = new AtomicBoolean(false);\n+\n+    private BasicDeviceConnectionClientFactory deviceConnectionClientFactory;\n+    private MappingAndDelegatingCommandHandler mappingAndDelegatingCommandHandler;\n+    private ProtonReceiver adapterSpecificConsumer;\n+    private final AtomicBoolean initialized = new AtomicBoolean(false);\n+\n+    /**\n+     * Creates a new factory for an existing connection.\n+     * \n+     * @param connection The connection to the AMQP network.\n+     * @param adapterInstanceId The id of the protocol adapter instance that this factory is running in.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    public ProtocolAdapterCommandConsumerFactoryImpl(final HonoConnection connection, final String adapterInstanceId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22f0073941892c831a32b49381de67e038ae5697"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3NTU2NTYy", "url": "https://github.com/eclipse/hono/pull/1841#pullrequestreview-377556562", "createdAt": "2020-03-19T09:38:27Z", "commit": {"oid": "22f0073941892c831a32b49381de67e038ae5697"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwOTozODoyN1rOF4moXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwOTozODoyN1rOF4moXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg5NzUwMg==", "bodyText": "I think \"if applicable\" needs a bit more explanation here (and in the following javacdocs of this interface). It think it is an integral aspect, and it would help, explaining a bit more when it might be applicable.", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r394897502", "createdAt": "2020-03-19T09:38:27Z", "author": {"login": "ctron"}, "path": "client/src/main/java/org/eclipse/hono/client/CommandTargetMapper.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client;\n+\n+import org.eclipse.hono.client.impl.CommandTargetMapperImpl;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A component for mapping an incoming command to the gateway (if applicable)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22f0073941892c831a32b49381de67e038ae5697"}, "originalPosition": 25}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "22f0073941892c831a32b49381de67e038ae5697", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/22f0073941892c831a32b49381de67e038ae5697", "committedDate": "2020-03-17T15:23:43Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}, "afterCommit": {"oid": "0dc0886964bc7e0c7db76d91b38fda20850c4bf3", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/0dc0886964bc7e0c7db76d91b38fda20850c4bf3", "committedDate": "2020-03-19T17:44:59Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4Mjc5OTM2", "url": "https://github.com/eclipse/hono/pull/1841#pullrequestreview-378279936", "createdAt": "2020-03-20T07:51:29Z", "commit": {"oid": "0dc0886964bc7e0c7db76d91b38fda20850c4bf3"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNzo1MToyOVrOF5KDoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwODowNzo0NFrOF5KZ8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3NzkyMA==", "bodyText": "should be added to @throws ...", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395477920", "createdAt": "2020-03-20T07:51:29Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/CommandHandlerWrapper.java", "diffHunk": "@@ -24,28 +24,36 @@\n  */\n public final class CommandHandlerWrapper {\n \n+    private final String tenantId;\n     private final String deviceId;\n     private final String gatewayId;\n     private final Handler<CommandContext> commandHandler;\n-    private final Handler<Void> remoteCloseHandler;\n \n     /**\n      * Creates a new CommandHandlerWrapper.\n-     * \n+     *\n+     * @param tenantId The tenant id.\n      * @param deviceId The identifier of the device that is the target of the commands being handled.\n      * @param gatewayId The identifier of the gateway that is acting on behalf of the device that is\n      *                  the target of the commands being handled, or {@code null} otherwise.\n      * @param commandHandler The command handler.\n-     * @param remoteCloseHandler The handler to be invoked when the command consumer is closed remotely. May be\n-     *            {@code null}.\n      * @throws NullPointerException If deviceId or commandHandler is {@code null}.\n      */\n-    public CommandHandlerWrapper(final String deviceId, final String gatewayId,\n-            final Handler<CommandContext> commandHandler, final Handler<Void> remoteCloseHandler) {\n+    public CommandHandlerWrapper(final String tenantId, final String deviceId, final String gatewayId,\n+                                 final Handler<CommandContext> commandHandler) {\n+        this.tenantId = Objects.requireNonNull(tenantId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dc0886964bc7e0c7db76d91b38fda20850c4bf3"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ3ODU4Mw==", "bodyText": "FMPOV adapterInstanceId looks like a required param, doesn't it?", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395478583", "createdAt": "2020-03-20T07:53:23Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/DelegatedCommandSenderImpl.java", "diffHunk": "@@ -225,21 +222,19 @@ private static Message createDelegatedCommandMessage(final Message originalMessa\n      * Creates a new sender for sending the delegated command messages to the AMQP network.\n      *\n      * @param con The connection to the AMQP network.\n-     * @param tenantId The tenant identifier.\n-     * @param deviceId The device identifier.\n+     * @param adapterInstanceId The protocol adapter instance id.\n      * @param closeHook A handler to invoke if the peer closes the link unexpectedly (may be {@code null}).\n      * @return A future indicating the result of the creation attempt.\n      * @throws NullPointerException if con is {@code null}.\n      */\n     public static Future<DelegatedCommandSender> create(\n             final HonoConnection con,\n-            final String tenantId,\n-            final String deviceId,\n+            final String adapterInstanceId,\n             final Handler<String> closeHook) {\n \n         Objects.requireNonNull(con);\n \n-        final String targetAddress = getTargetAddress(tenantId, deviceId);\n+        final String targetAddress = getTargetAddress(adapterInstanceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dc0886964bc7e0c7db76d91b38fda20850c4bf3"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ4Mjc3Mw==", "bodyText": "it doesn't look like this can happen, can it?", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395482773", "createdAt": "2020-03-20T08:05:30Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandler.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.Command;\n+import org.eclipse.hono.client.CommandContext;\n+import org.eclipse.hono.client.CommandTargetMapper;\n+import org.eclipse.hono.client.DelegatedCommandSender;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.CommandConstants;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Handler for commands received at the tenant-specific address.\n+ */\n+public class MappingAndDelegatingCommandHandler {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MappingAndDelegatingCommandHandler.class);\n+\n+    /**\n+     * Used for integration tests (with only a single instance of each protocol adapter):\n+     * <p>\n+     * System property value defining whether incoming command messages on the tenant\n+     * scoped consumer may be rerouted via the AMQP messaging network to a device-specific\n+     * consumer even if there is a local handler for the command.<p>\n+     * The second condition for the rerouting to take place is that the command message\n+     * contains a {@link #FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY} application\n+     * property with a {@code true} value.\n+     */\n+    private static final Boolean FORCED_COMMAND_REROUTING_ENABLED = Boolean\n+            .valueOf(System.getProperty(\"enableForcedCommandRerouting\", \"false\"));\n+    /**\n+     * Name of the boolean command message application property with which commands are\n+     * forced to be rerouted via the AMQP messaging network to a device-specific consumer.\n+     * Precondition is that the {@link #FORCED_COMMAND_REROUTING_ENABLED} system property\n+     * is set to {@code true}.\n+     */\n+    private static final String FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY = \"force-command-rerouting\";\n+\n+    private final HonoConnection connection;\n+    private final CommandTargetMapper commandTargetMapper;\n+    private final AdapterInstanceCommandHandler adapterInstanceCommandHandler;\n+    private final String adapterInstanceId;\n+    private final CachingClientFactory<DelegatedCommandSender> delegatedCommandSenderFactory;\n+\n+    /**\n+     * Creates a new MappingAndDelegatingCommandHandler instance.\n+     *\n+     * @param connection The connection to the AMQP network.\n+     * @param commandTargetMapper The mapper component to determine the command target.\n+     * @param adapterInstanceCommandHandler The handler to delegate command handling to if the command is to be\n+     *                                      handled by the local adapter instance.\n+     * @param adapterInstanceId The id of the protocol adapter instance that this handler is running in.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    public MappingAndDelegatingCommandHandler(final HonoConnection connection,\n+            final CommandTargetMapper commandTargetMapper,\n+            final AdapterInstanceCommandHandler adapterInstanceCommandHandler, final String adapterInstanceId) {\n+        this.connection = Objects.requireNonNull(connection);\n+        this.commandTargetMapper = Objects.requireNonNull(commandTargetMapper);\n+        this.adapterInstanceCommandHandler = Objects.requireNonNull(adapterInstanceCommandHandler);\n+        this.adapterInstanceId = Objects.requireNonNull(adapterInstanceId);\n+\n+        this.delegatedCommandSenderFactory = new CachingClientFactory<>(connection.getVertx(), s -> s.isOpen());\n+    }\n+\n+    /**\n+     * Determines the target gateway (if applicable) and protocol adapter instance for an incoming command\n+     * and delegates the command either to the local AdapterInstanceCommandHandler or to the resulting\n+     * protocol adapter instance.\n+     *\n+     * @param tenantId The tenant id.\n+     * @param originalMessageDelivery The delivery of the command message.\n+     * @param message The command message.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    public void mapAndDelegateIncomingCommandMessage(final String tenantId,\n+            final ProtonDelivery originalMessageDelivery, final Message message) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(originalMessageDelivery);\n+        Objects.requireNonNull(message);\n+\n+        // this is the place where a command message on the \"command/tenant\" address arrives *first*\n+        final String deviceId = message.getAddress() != null ? ResourceIdentifier.fromString(message.getAddress()).getResourceId() : null;\n+        if (deviceId == null) {\n+            LOG.debug(\"address of command message is invalid: {}\", message.getAddress());\n+            final Rejected rejected = new Rejected();\n+            rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"invalid command target address\"));\n+            originalMessageDelivery.disposition(rejected, true);\n+            return;\n+        }\n+        final Command command = Command.from(message, tenantId, deviceId);\n+        LOG.trace(\"received command [{}]\", command);\n+        final SpanContext spanContext = TracingHelper.extractSpanContext(connection.getTracer(), message);\n+        final Span currentSpan = CommandConsumer.createSpan(\"map and delegate command\", tenantId, deviceId, null,\n+                connection.getTracer(), spanContext);\n+        CommandConsumer.logReceivedCommandToSpan(command, currentSpan);\n+        final CommandContext commandContext = CommandContext.from(command, originalMessageDelivery, currentSpan);\n+        if (command.isValid()) {\n+            mapAndDelegateIncomingCommand(commandContext);\n+        } else {\n+            // command is invalid, try to find local command handler to let it reject the command (and also report metrics for that), otherwise reject it directly\n+            commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId, deviceId, spanContext)\n+                    .setHandler(ar -> {\n+                        CommandHandlerWrapper commandHandler = null;\n+                        if (ar.succeeded()) {\n+                            final String targetDevice = ar.result().getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);\n+                            final String targetAdapterInstance = ar.result().getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);\n+                            if (adapterInstanceId.equals(targetAdapterInstance)) {\n+                                final String gatewayId = !deviceId.equals(targetDevice) ? targetDevice : null;\n+                                commandHandler = adapterInstanceCommandHandler\n+                                        .getDeviceSpecificCommandHandler(tenantId, deviceId, gatewayId);\n+                            }\n+                        }\n+                        if (commandHandler != null) {\n+                            // let the device specific handler reject the command\n+                            commandHandler.handleCommand(commandContext);\n+                        } else {\n+                            LOG.debug(\"command message is invalid: {}\", command);\n+                            commandContext.reject(new ErrorCondition(Constants.AMQP_BAD_REQUEST,\n+                                    \"malformed command message\"));\n+                        }\n+                    });\n+\n+        }\n+    }\n+\n+    private void mapAndDelegateIncomingCommand(final CommandContext originalCommandContext) {\n+        final Command originalCommand = originalCommandContext.getCommand();\n+        if (!originalCommand.isValid()) {\n+            originalCommandContext.reject(new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"malformed command message\"));\n+            return;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dc0886964bc7e0c7db76d91b38fda20850c4bf3"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ4MzYzNA==", "bodyText": "this is the same code as in the main method, isn't it? would it be possible to change the behavior so that we first try to delegate processing of a command to a local handler in any case (regardless of whether a command is valid or not) and then, if valid, forward it to the correct adapter instance?", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395483634", "createdAt": "2020-03-20T08:07:44Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/MappingAndDelegatingCommandHandler.java", "diffHunk": "@@ -0,0 +1,288 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.Command;\n+import org.eclipse.hono.client.CommandContext;\n+import org.eclipse.hono.client.CommandTargetMapper;\n+import org.eclipse.hono.client.DelegatedCommandSender;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.CommandConstants;\n+import org.eclipse.hono.util.Constants;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.ResourceIdentifier;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.proton.ProtonDelivery;\n+\n+/**\n+ * Handler for commands received at the tenant-specific address.\n+ */\n+public class MappingAndDelegatingCommandHandler {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MappingAndDelegatingCommandHandler.class);\n+\n+    /**\n+     * Used for integration tests (with only a single instance of each protocol adapter):\n+     * <p>\n+     * System property value defining whether incoming command messages on the tenant\n+     * scoped consumer may be rerouted via the AMQP messaging network to a device-specific\n+     * consumer even if there is a local handler for the command.<p>\n+     * The second condition for the rerouting to take place is that the command message\n+     * contains a {@link #FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY} application\n+     * property with a {@code true} value.\n+     */\n+    private static final Boolean FORCED_COMMAND_REROUTING_ENABLED = Boolean\n+            .valueOf(System.getProperty(\"enableForcedCommandRerouting\", \"false\"));\n+    /**\n+     * Name of the boolean command message application property with which commands are\n+     * forced to be rerouted via the AMQP messaging network to a device-specific consumer.\n+     * Precondition is that the {@link #FORCED_COMMAND_REROUTING_ENABLED} system property\n+     * is set to {@code true}.\n+     */\n+    private static final String FORCE_COMMAND_REROUTING_APPLICATION_PROPERTY = \"force-command-rerouting\";\n+\n+    private final HonoConnection connection;\n+    private final CommandTargetMapper commandTargetMapper;\n+    private final AdapterInstanceCommandHandler adapterInstanceCommandHandler;\n+    private final String adapterInstanceId;\n+    private final CachingClientFactory<DelegatedCommandSender> delegatedCommandSenderFactory;\n+\n+    /**\n+     * Creates a new MappingAndDelegatingCommandHandler instance.\n+     *\n+     * @param connection The connection to the AMQP network.\n+     * @param commandTargetMapper The mapper component to determine the command target.\n+     * @param adapterInstanceCommandHandler The handler to delegate command handling to if the command is to be\n+     *                                      handled by the local adapter instance.\n+     * @param adapterInstanceId The id of the protocol adapter instance that this handler is running in.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    public MappingAndDelegatingCommandHandler(final HonoConnection connection,\n+            final CommandTargetMapper commandTargetMapper,\n+            final AdapterInstanceCommandHandler adapterInstanceCommandHandler, final String adapterInstanceId) {\n+        this.connection = Objects.requireNonNull(connection);\n+        this.commandTargetMapper = Objects.requireNonNull(commandTargetMapper);\n+        this.adapterInstanceCommandHandler = Objects.requireNonNull(adapterInstanceCommandHandler);\n+        this.adapterInstanceId = Objects.requireNonNull(adapterInstanceId);\n+\n+        this.delegatedCommandSenderFactory = new CachingClientFactory<>(connection.getVertx(), s -> s.isOpen());\n+    }\n+\n+    /**\n+     * Determines the target gateway (if applicable) and protocol adapter instance for an incoming command\n+     * and delegates the command either to the local AdapterInstanceCommandHandler or to the resulting\n+     * protocol adapter instance.\n+     *\n+     * @param tenantId The tenant id.\n+     * @param originalMessageDelivery The delivery of the command message.\n+     * @param message The command message.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    public void mapAndDelegateIncomingCommandMessage(final String tenantId,\n+            final ProtonDelivery originalMessageDelivery, final Message message) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(originalMessageDelivery);\n+        Objects.requireNonNull(message);\n+\n+        // this is the place where a command message on the \"command/tenant\" address arrives *first*\n+        final String deviceId = message.getAddress() != null ? ResourceIdentifier.fromString(message.getAddress()).getResourceId() : null;\n+        if (deviceId == null) {\n+            LOG.debug(\"address of command message is invalid: {}\", message.getAddress());\n+            final Rejected rejected = new Rejected();\n+            rejected.setError(new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"invalid command target address\"));\n+            originalMessageDelivery.disposition(rejected, true);\n+            return;\n+        }\n+        final Command command = Command.from(message, tenantId, deviceId);\n+        LOG.trace(\"received command [{}]\", command);\n+        final SpanContext spanContext = TracingHelper.extractSpanContext(connection.getTracer(), message);\n+        final Span currentSpan = CommandConsumer.createSpan(\"map and delegate command\", tenantId, deviceId, null,\n+                connection.getTracer(), spanContext);\n+        CommandConsumer.logReceivedCommandToSpan(command, currentSpan);\n+        final CommandContext commandContext = CommandContext.from(command, originalMessageDelivery, currentSpan);\n+        if (command.isValid()) {\n+            mapAndDelegateIncomingCommand(commandContext);\n+        } else {\n+            // command is invalid, try to find local command handler to let it reject the command (and also report metrics for that), otherwise reject it directly\n+            commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId, deviceId, spanContext)\n+                    .setHandler(ar -> {\n+                        CommandHandlerWrapper commandHandler = null;\n+                        if (ar.succeeded()) {\n+                            final String targetDevice = ar.result().getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);\n+                            final String targetAdapterInstance = ar.result().getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);\n+                            if (adapterInstanceId.equals(targetAdapterInstance)) {\n+                                final String gatewayId = !deviceId.equals(targetDevice) ? targetDevice : null;\n+                                commandHandler = adapterInstanceCommandHandler\n+                                        .getDeviceSpecificCommandHandler(tenantId, deviceId, gatewayId);\n+                            }\n+                        }\n+                        if (commandHandler != null) {\n+                            // let the device specific handler reject the command\n+                            commandHandler.handleCommand(commandContext);\n+                        } else {\n+                            LOG.debug(\"command message is invalid: {}\", command);\n+                            commandContext.reject(new ErrorCondition(Constants.AMQP_BAD_REQUEST,\n+                                    \"malformed command message\"));\n+                        }\n+                    });\n+\n+        }\n+    }\n+\n+    private void mapAndDelegateIncomingCommand(final CommandContext originalCommandContext) {\n+        final Command originalCommand = originalCommandContext.getCommand();\n+        if (!originalCommand.isValid()) {\n+            originalCommandContext.reject(new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"malformed command message\"));\n+            return;\n+        }\n+        final String tenantId = originalCommand.getTenant();\n+        final String originalDeviceId = originalCommand.getDeviceId();\n+        // determine last used gateway device id\n+        LOG.trace(\"determine command target gateway/adapter for [{}]\", originalCommand);\n+        final Future<JsonObject> commandTargetFuture = commandTargetMapper.getTargetGatewayAndAdapterInstance(tenantId, originalDeviceId,\n+                originalCommandContext.getTracingContext());\n+\n+        commandTargetFuture.setHandler(commandTargetResult -> {\n+            if (commandTargetResult.succeeded()) {\n+                final String targetDeviceId = commandTargetResult.result().getString(DeviceConnectionConstants.FIELD_PAYLOAD_DEVICE_ID);\n+                final String targetAdapterInstance = commandTargetResult.result().getString(DeviceConnectionConstants.FIELD_ADAPTER_INSTANCE_ID);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0dc0886964bc7e0c7db76d91b38fda20850c4bf3"}, "originalPosition": 176}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0dc0886964bc7e0c7db76d91b38fda20850c4bf3", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/0dc0886964bc7e0c7db76d91b38fda20850c4bf3", "committedDate": "2020-03-19T17:44:59Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}, "afterCommit": {"oid": "ec04ccaf65ad1a9a9998d1eda961116cd55f4b91", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/ec04ccaf65ad1a9a9998d1eda961116cd55f4b91", "committedDate": "2020-03-20T13:50:46Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ec04ccaf65ad1a9a9998d1eda961116cd55f4b91", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/ec04ccaf65ad1a9a9998d1eda961116cd55f4b91", "committedDate": "2020-03-20T13:50:46Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}, "afterCommit": {"oid": "2c3669020f9518c76628ba45a75df6fc20a7d814", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/2c3669020f9518c76628ba45a75df6fc20a7d814", "committedDate": "2020-03-20T16:57:10Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NjkwODM5", "url": "https://github.com/eclipse/hono/pull/1841#pullrequestreview-378690839", "createdAt": "2020-03-20T17:45:14Z", "commit": {"oid": "2c3669020f9518c76628ba45a75df6fc20a7d814"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzo0NToxNFrOF5dfbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzo0NToxNFrOF5dfbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5NjMzMw==", "bodyText": "the protocol adapter instance?", "url": "https://github.com/eclipse/hono/pull/1841#discussion_r395796333", "createdAt": "2020-03-20T17:45:14Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/CommandTargetMapper.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client;\n+\n+import org.eclipse.hono.client.impl.CommandTargetMapperImpl;\n+import org.eclipse.hono.util.DeviceConnectionConstants;\n+\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A component for determining where a incoming command message should be targeted at when processing the message in a\n+ * protocol adapter.\n+ * <p>\n+ * This refers to finding the <em>protocol handler instance</em> that a device or gateway has connected to in order to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c3669020f9518c76628ba45a75df6fc20a7d814"}, "originalPosition": 28}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2c3669020f9518c76628ba45a75df6fc20a7d814", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/2c3669020f9518c76628ba45a75df6fc20a7d814", "committedDate": "2020-03-20T16:57:10Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}, "afterCommit": {"oid": "b02d8964f84f4c8ca79d9f0b3c7b863e1db71a8e", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/b02d8964f84f4c8ca79d9f0b3c7b863e1db71a8e", "committedDate": "2020-03-20T17:52:14Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16c4abe919443eb515585739cb728a9630e524d7", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/16c4abe919443eb515585739cb728a9630e524d7", "committedDate": "2020-03-20T19:24:30Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b02d8964f84f4c8ca79d9f0b3c7b863e1db71a8e", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/b02d8964f84f4c8ca79d9f0b3c7b863e1db71a8e", "committedDate": "2020-03-20T17:52:14Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}, "afterCommit": {"oid": "16c4abe919443eb515585739cb728a9630e524d7", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/16c4abe919443eb515585739cb728a9630e524d7", "committedDate": "2020-03-20T19:24:30Z", "message": "[#1272] Implement new Command & Control handling.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MDIxOTYw", "url": "https://github.com/eclipse/hono/pull/1841#pullrequestreview-379021960", "createdAt": "2020-03-22T16:24:09Z", "commit": {"oid": "16c4abe919443eb515585739cb728a9630e524d7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 801, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}