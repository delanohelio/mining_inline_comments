{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczNzU4MDcx", "number": 1762, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDoyNToyNlrODfH3Yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMToyNzozM1rODiSygA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzOTYxMzE1OnYy", "diffSide": "RIGHT", "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDoyNToyNlrOFopJUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMTo0NzozM1rOForpDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE2MTQ5MQ==", "bodyText": "missing requestProcessed param javadoc,\nparam ctx -> wrong param name", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r378161491", "createdAt": "2020-02-12T10:25:26Z", "author": {"login": "calohmn"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "diffHunk": "@@ -715,4 +796,348 @@ protected void preShutdown() {\n             final Device authenticatedDevice) {\n         return Future.succeededFuture(true);\n     }\n+\n+    /**\n+     * Gets the value of the {@link org.eclipse.hono.util.Constants#HEADER_TIME_TILL_DISCONNECT} query parameter of the\n+     * CoAP request.\n+     *\n+     * @param context The CoAP context containing the request.\n+     * @return The time till disconnect or {@code null} if\n+     *         <ul>\n+     *         <li>the request doesn't contain a {@link org.eclipse.hono.util.Constants#HEADER_TIME_TILL_DISCONNECT}\n+     *         query parameter.</li>\n+     *         <li>the contained value cannot be parsed as an Integer</li>\n+     *         </ul>\n+     * @throws NullPointerException if context is {@code null}.\n+     */\n+    protected Integer getTimeUntilDisconnectFromRequest(final CoapContext context) {\n+        Objects.requireNonNull(context);\n+\n+        try {\n+            final Optional<String> timeTilDisconnectHeader = Optional\n+                    .ofNullable(context.getQueryParameter(Constants.HEADER_TIME_TILL_DISCONNECT));\n+\n+            if (timeTilDisconnectHeader.isPresent()) {\n+                return Integer.parseInt(timeTilDisconnectHeader.get());\n+            }\n+        } catch (final NumberFormatException e) {\n+        }\n+\n+        return null;\n+    }\n+\n+    private void setResponsePayload(final CoapContext context, final CommandContext commandContext,\n+            final Span currentSpan) {\n+        if (commandContext == null) {\n+            setEmptyResponsePayload(context, currentSpan);\n+        } else {\n+            setNonEmptyResponsePayload(context, commandContext, currentSpan);\n+        }\n+    }\n+\n+    /**\n+     * Respond to a request with an empty command response.\n+     * <p>\n+     * The default implementation simply sets a status of {@link ResponseCode#CHANGED}.\n+     *\n+     * @param context context to apply the empty response.\n+     * @param currentSpan The current tracing span.\n+     */\n+    protected void setEmptyResponsePayload(final CoapContext context, final Span currentSpan) {\n+        context.respondWithCode(ResponseCode.CHANGED);\n+    }\n+\n+    /**\n+     * Response to a request with a non-empty command response.\n+     * <p>\n+     * The default implementation sets the command headers and the status to {@link ResponseCode#CONTENT}.\n+     *\n+     * @param context context to apply the response.\n+     * @param commandContext The command context, will not be {@code null}.\n+     * @param currentSpan The current tracing span.\n+     */\n+    protected void setNonEmptyResponsePayload(final CoapContext context, final CommandContext commandContext,\n+            final Span currentSpan) {\n+\n+        final Command command = commandContext.getCommand();\n+        final Response response = new Response(ResponseCode.CONTENT);\n+        final OptionSet options = response.getOptions();\n+        options.addLocationQuery(Constants.HEADER_COMMAND + \"=\" + command.getName());\n+        currentSpan.setTag(Constants.HEADER_COMMAND, command.getName());\n+        log.debug(\"adding command [name: {}, request-id: {}] to response for device [tenant-id: {}, device-id: {}]\",\n+                command.getName(), command.getRequestId(), command.getTenant(), command.getDeviceId());\n+\n+        if (!command.isOneWay()) {\n+            options.addLocationQuery(Constants.HEADER_COMMAND_REQUEST_ID + \"=\" + command.getRequestId());\n+            currentSpan.setTag(Constants.HEADER_COMMAND_REQUEST_ID, command.getRequestId());\n+        }\n+        if (command.isTargetedAtGateway()) {\n+            options.addLocationQuery(Constants.HEADER_COMMAND_TARGET_DEVICE + \"=\" + command.getOriginalDeviceId());\n+            currentSpan.setTag(Constants.HEADER_COMMAND_TARGET_DEVICE, command.getOriginalDeviceId());\n+        }\n+        final int contentType = MediaTypeRegistry.parse(command.getContentType());\n+        options.setContentFormat(contentType);\n+        response.setPayload(command.getPayload().getBytes());\n+        context.getExchange().respond(response);\n+    }\n+\n+    /**\n+     * Creates a consumer for command messages to be sent to a device.\n+     *\n+     * @param ttdSecs The number of seconds the device waits for a command.\n+     * @param tenantObject The tenant configuration object.\n+     * @param deviceId The identifier of the device.\n+     * @param gatewayId The identifier of the gateway that is acting on behalf of the device or {@code null} otherwise.\n+     * @param context The device's currently executing CoAP request context.\n+     * @param responseReady A future to complete once one of the following conditions are met:\n+     *            <ul>\n+     *            <li>the request did not include a <em>hono-ttd</em> query-parameter or</li>\n+     *            <li>a command has been received and the response ready future has not yet been completed or</li>\n+     *            <li>the ttd has expired</li>\n+     *            </ul>\n+     * @param currentSpan The OpenTracing Span to use for tracking the processing of the request.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future will be completed with the created message consumer or {@code null}, if the response can be\n+     *         sent back to the device without waiting for a command.\n+     *         <p>\n+     *         The future will be failed with a {@code ServiceInvocationException} if the message consumer could not be\n+     *         created. The future will be failed with a {@code ResourceConflictException} if the message consumer for\n+     *         the device is already in use and the request contains an empty notification (which does not need to be\n+     *         forwarded downstream).\n+     * @throws NullPointerException if any of the parameters other than TTD or gatewayId is {@code null}.\n+     */\n+    protected final Future<MessageConsumer> createCommandConsumer(\n+            final Integer ttdSecs,\n+            final TenantObject tenantObject,\n+            final String deviceId,\n+            final String gatewayId,\n+            final CoapContext context,\n+            final Handler<AsyncResult<Void>> responseReady,\n+            final Span currentSpan) {\n+\n+        Objects.requireNonNull(tenantObject);\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(context);\n+        Objects.requireNonNull(responseReady);\n+        Objects.requireNonNull(currentSpan);\n+\n+        final AtomicBoolean requestProcessed = new AtomicBoolean(false);\n+\n+        if (ttdSecs == null || ttdSecs <= 0) {\n+            // no need to wait for a command\n+            if (requestProcessed.compareAndSet(false, true)) {\n+                responseReady.handle(Future.succeededFuture());\n+            }\n+            return Future.succeededFuture();\n+        }\n+\n+        currentSpan.setTag(MessageHelper.APP_PROPERTY_DEVICE_TTD, ttdSecs);\n+        final Handler<CommandContext> commandHandler = commandContext -> {\n+\n+            Tags.COMPONENT.set(commandContext.getCurrentSpan(), getTypeName());\n+            final Command command = commandContext.getCommand();\n+            final Sample commandSample = getMetrics().startTimer();\n+            if (isCommandValid(command, currentSpan)) {\n+\n+                if (requestProcessed.compareAndSet(false, true)) {\n+                    checkMessageLimit(tenantObject, command.getPayloadSize(), currentSpan.context())\n+                            .setHandler(result -> {\n+                                if (result.succeeded()) {\n+                                    addMicrometerSample(commandContext, commandSample);\n+                                    // put command context to routing context and notify\n+                                    context.put(CommandContext.KEY_COMMAND_CONTEXT, commandContext);\n+                                } else {\n+                                    // issue credit so that application(s) can send the next command\n+                                    commandContext.reject(getErrorCondition(result.cause()), 1);\n+                                    metrics.reportCommand(\n+                                            command.isOneWay() ? Direction.ONE_WAY : Direction.REQUEST,\n+                                            tenantObject.getTenantId(),\n+                                            tenantObject,\n+                                            ProcessingOutcome.from(result.cause()),\n+                                            command.getPayloadSize(),\n+                                            commandSample);\n+                                }\n+                                cancelCommandReceptionTimer(context);\n+                                setTtdStatus(context, TtdStatus.COMMAND);\n+                                responseReady.handle(Future.succeededFuture());\n+                            });\n+                } else {\n+                    // the timer has already fired, release the command\n+                    getMetrics().reportCommand(\n+                            command.isOneWay() ? Direction.ONE_WAY : Direction.REQUEST,\n+                            tenantObject.getTenantId(),\n+                            tenantObject,\n+                            ProcessingOutcome.UNDELIVERABLE,\n+                            command.getPayloadSize(),\n+                            commandSample);\n+                    log.debug(\"command for device has already fired [tenantId: {}, deviceId: {}]\",\n+                            tenantObject.getTenantId(), deviceId);\n+                    commandContext.release();\n+                }\n+\n+            } else {\n+                getMetrics().reportCommand(\n+                        command.isOneWay() ? Direction.ONE_WAY : Direction.REQUEST,\n+                        tenantObject.getTenantId(),\n+                        tenantObject,\n+                        ProcessingOutcome.UNPROCESSABLE,\n+                        command.getPayloadSize(),\n+                        commandSample);\n+                log.debug(\"command message is invalid: {}\", command);\n+                commandContext.reject(new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"malformed command message\"));\n+            }\n+            // we do not issue any new credit because the\n+            // consumer is supposed to deliver a single command\n+            // only per HTTP request\n+        };\n+\n+        final Handler<Void> remoteCloseHandler = remoteDetach -> {\n+            log.debug(\"peer closed command receiver link [tenant-id: {}, device-id: {}, gateway-id: {}]\",\n+                    tenantObject.getTenantId(), deviceId, gatewayId);\n+            // command consumer is closed by closeHandler, no explicit close necessary here\n+        };\n+\n+        // First check whether the tenant has been configured to support concurrent ttd-param requests from the same\n+        // gateway for different devices. In that case a device-specific (instead of a gateway-specific) consumer link\n+        // will be created below\n+        // (preventing multiple consumer links on the same gateway address from multiple HTTP adapter instances).\n+        final Future<MessageConsumer> commandConsumerFuture = isSupportConcurrentGatewayDeviceCommandRequests(\n+                tenantObject)\n+                        .compose(supportConcurrentGatewayDeviceCommandRequests -> {\n+                            if (gatewayId != null && !supportConcurrentGatewayDeviceCommandRequests) {\n+                                // gateway scenario\n+                                return getCommandConsumerFactory().createCommandConsumer(\n+                                        tenantObject.getTenantId(),\n+                                        deviceId,\n+                                        gatewayId,\n+                                        commandHandler,\n+                                        remoteCloseHandler);\n+                            } else {\n+                                if (gatewayId != null) {\n+                                    log.trace(\n+                                            \"gateway mapping disabled for tenant [{}], will create device-specific consumer\",\n+                                            tenantObject.getTenantId());\n+                                }\n+                                return getCommandConsumerFactory().createCommandConsumer(\n+                                        tenantObject.getTenantId(),\n+                                        deviceId,\n+                                        commandHandler,\n+                                        remoteCloseHandler);\n+                            }\n+                        });\n+        return commandConsumerFuture\n+                .map(consumer -> {\n+                    if (!requestProcessed.get()) {\n+                        // if the request was not responded already, add a timer for triggering an empty response\n+                        addCommandReceptionTimer(context, requestProcessed, responseReady, ttdSecs);\n+                        context.getExchange().accept();\n+                    }\n+                    return consumer;\n+                })\n+                .recover(t -> {\n+                    if (t instanceof ResourceConflictException) {\n+                        // another request from the same device that contains\n+                        // a TTD value is already being processed\n+                        if (context.isEmptyNotification()) {\n+                            // no need to forward message downstream\n+                            return Future.failedFuture(t);\n+                        } else {\n+                            // let the other request handle the command (if any)\n+                            if (requestProcessed.compareAndSet(false, true)) {\n+                                responseReady.handle(Future.succeededFuture());\n+                            }\n+                            return Future.succeededFuture();\n+                        }\n+                    } else {\n+                        return Future.failedFuture(t);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Validate if a command is valid and can be sent as response.\n+     * <p>\n+     * The default implementation will call {@link Command#isValid()}. Protocol adapters may override this, but should\n+     * consider calling the super method.\n+     *\n+     * @param command The command to validate, will never be {@code null}.\n+     * @param currentSpan The current tracing span.\n+     * @return {@code true} if the command is valid, {@code false} otherwise.\n+     */\n+    protected boolean isCommandValid(final Command command, final Span currentSpan) {\n+        return command.isValid();\n+    }\n+\n+    /**\n+     * Sets a timer to trigger the sending of a (empty) response to a device if no command has been received from an\n+     * application within a given amount of time.\n+     * <p>\n+     * The created timer's ID is put to the routing context using key {@link #KEY_TIMER_ID}.\n+     *\n+     * @param ctx The device's currently executing HTTP request.\n+     * @param responseReady The future to complete when the time has expired.\n+     * @param delaySecs The number of seconds to wait for a command.\n+     */\n+    private void addCommandReceptionTimer(\n+            final CoapContext context,\n+            final AtomicBoolean requestProcessed,\n+            final Handler<AsyncResult<Void>> responseReady,\n+            final long delaySecs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae60a16e87a8ca1fb7cb2033815296270b619244"}, "originalPosition": 511}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIwMjM4Mw==", "bodyText": "missing requestProcessed param javadoc\n\nUups, that's a copy & paste error, it's missing in the http adapter as well.\nFixed, both.", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r378202383", "createdAt": "2020-02-12T11:47:33Z", "author": {"login": "boaks"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "diffHunk": "@@ -715,4 +796,348 @@ protected void preShutdown() {\n             final Device authenticatedDevice) {\n         return Future.succeededFuture(true);\n     }\n+\n+    /**\n+     * Gets the value of the {@link org.eclipse.hono.util.Constants#HEADER_TIME_TILL_DISCONNECT} query parameter of the\n+     * CoAP request.\n+     *\n+     * @param context The CoAP context containing the request.\n+     * @return The time till disconnect or {@code null} if\n+     *         <ul>\n+     *         <li>the request doesn't contain a {@link org.eclipse.hono.util.Constants#HEADER_TIME_TILL_DISCONNECT}\n+     *         query parameter.</li>\n+     *         <li>the contained value cannot be parsed as an Integer</li>\n+     *         </ul>\n+     * @throws NullPointerException if context is {@code null}.\n+     */\n+    protected Integer getTimeUntilDisconnectFromRequest(final CoapContext context) {\n+        Objects.requireNonNull(context);\n+\n+        try {\n+            final Optional<String> timeTilDisconnectHeader = Optional\n+                    .ofNullable(context.getQueryParameter(Constants.HEADER_TIME_TILL_DISCONNECT));\n+\n+            if (timeTilDisconnectHeader.isPresent()) {\n+                return Integer.parseInt(timeTilDisconnectHeader.get());\n+            }\n+        } catch (final NumberFormatException e) {\n+        }\n+\n+        return null;\n+    }\n+\n+    private void setResponsePayload(final CoapContext context, final CommandContext commandContext,\n+            final Span currentSpan) {\n+        if (commandContext == null) {\n+            setEmptyResponsePayload(context, currentSpan);\n+        } else {\n+            setNonEmptyResponsePayload(context, commandContext, currentSpan);\n+        }\n+    }\n+\n+    /**\n+     * Respond to a request with an empty command response.\n+     * <p>\n+     * The default implementation simply sets a status of {@link ResponseCode#CHANGED}.\n+     *\n+     * @param context context to apply the empty response.\n+     * @param currentSpan The current tracing span.\n+     */\n+    protected void setEmptyResponsePayload(final CoapContext context, final Span currentSpan) {\n+        context.respondWithCode(ResponseCode.CHANGED);\n+    }\n+\n+    /**\n+     * Response to a request with a non-empty command response.\n+     * <p>\n+     * The default implementation sets the command headers and the status to {@link ResponseCode#CONTENT}.\n+     *\n+     * @param context context to apply the response.\n+     * @param commandContext The command context, will not be {@code null}.\n+     * @param currentSpan The current tracing span.\n+     */\n+    protected void setNonEmptyResponsePayload(final CoapContext context, final CommandContext commandContext,\n+            final Span currentSpan) {\n+\n+        final Command command = commandContext.getCommand();\n+        final Response response = new Response(ResponseCode.CONTENT);\n+        final OptionSet options = response.getOptions();\n+        options.addLocationQuery(Constants.HEADER_COMMAND + \"=\" + command.getName());\n+        currentSpan.setTag(Constants.HEADER_COMMAND, command.getName());\n+        log.debug(\"adding command [name: {}, request-id: {}] to response for device [tenant-id: {}, device-id: {}]\",\n+                command.getName(), command.getRequestId(), command.getTenant(), command.getDeviceId());\n+\n+        if (!command.isOneWay()) {\n+            options.addLocationQuery(Constants.HEADER_COMMAND_REQUEST_ID + \"=\" + command.getRequestId());\n+            currentSpan.setTag(Constants.HEADER_COMMAND_REQUEST_ID, command.getRequestId());\n+        }\n+        if (command.isTargetedAtGateway()) {\n+            options.addLocationQuery(Constants.HEADER_COMMAND_TARGET_DEVICE + \"=\" + command.getOriginalDeviceId());\n+            currentSpan.setTag(Constants.HEADER_COMMAND_TARGET_DEVICE, command.getOriginalDeviceId());\n+        }\n+        final int contentType = MediaTypeRegistry.parse(command.getContentType());\n+        options.setContentFormat(contentType);\n+        response.setPayload(command.getPayload().getBytes());\n+        context.getExchange().respond(response);\n+    }\n+\n+    /**\n+     * Creates a consumer for command messages to be sent to a device.\n+     *\n+     * @param ttdSecs The number of seconds the device waits for a command.\n+     * @param tenantObject The tenant configuration object.\n+     * @param deviceId The identifier of the device.\n+     * @param gatewayId The identifier of the gateway that is acting on behalf of the device or {@code null} otherwise.\n+     * @param context The device's currently executing CoAP request context.\n+     * @param responseReady A future to complete once one of the following conditions are met:\n+     *            <ul>\n+     *            <li>the request did not include a <em>hono-ttd</em> query-parameter or</li>\n+     *            <li>a command has been received and the response ready future has not yet been completed or</li>\n+     *            <li>the ttd has expired</li>\n+     *            </ul>\n+     * @param currentSpan The OpenTracing Span to use for tracking the processing of the request.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future will be completed with the created message consumer or {@code null}, if the response can be\n+     *         sent back to the device without waiting for a command.\n+     *         <p>\n+     *         The future will be failed with a {@code ServiceInvocationException} if the message consumer could not be\n+     *         created. The future will be failed with a {@code ResourceConflictException} if the message consumer for\n+     *         the device is already in use and the request contains an empty notification (which does not need to be\n+     *         forwarded downstream).\n+     * @throws NullPointerException if any of the parameters other than TTD or gatewayId is {@code null}.\n+     */\n+    protected final Future<MessageConsumer> createCommandConsumer(\n+            final Integer ttdSecs,\n+            final TenantObject tenantObject,\n+            final String deviceId,\n+            final String gatewayId,\n+            final CoapContext context,\n+            final Handler<AsyncResult<Void>> responseReady,\n+            final Span currentSpan) {\n+\n+        Objects.requireNonNull(tenantObject);\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(context);\n+        Objects.requireNonNull(responseReady);\n+        Objects.requireNonNull(currentSpan);\n+\n+        final AtomicBoolean requestProcessed = new AtomicBoolean(false);\n+\n+        if (ttdSecs == null || ttdSecs <= 0) {\n+            // no need to wait for a command\n+            if (requestProcessed.compareAndSet(false, true)) {\n+                responseReady.handle(Future.succeededFuture());\n+            }\n+            return Future.succeededFuture();\n+        }\n+\n+        currentSpan.setTag(MessageHelper.APP_PROPERTY_DEVICE_TTD, ttdSecs);\n+        final Handler<CommandContext> commandHandler = commandContext -> {\n+\n+            Tags.COMPONENT.set(commandContext.getCurrentSpan(), getTypeName());\n+            final Command command = commandContext.getCommand();\n+            final Sample commandSample = getMetrics().startTimer();\n+            if (isCommandValid(command, currentSpan)) {\n+\n+                if (requestProcessed.compareAndSet(false, true)) {\n+                    checkMessageLimit(tenantObject, command.getPayloadSize(), currentSpan.context())\n+                            .setHandler(result -> {\n+                                if (result.succeeded()) {\n+                                    addMicrometerSample(commandContext, commandSample);\n+                                    // put command context to routing context and notify\n+                                    context.put(CommandContext.KEY_COMMAND_CONTEXT, commandContext);\n+                                } else {\n+                                    // issue credit so that application(s) can send the next command\n+                                    commandContext.reject(getErrorCondition(result.cause()), 1);\n+                                    metrics.reportCommand(\n+                                            command.isOneWay() ? Direction.ONE_WAY : Direction.REQUEST,\n+                                            tenantObject.getTenantId(),\n+                                            tenantObject,\n+                                            ProcessingOutcome.from(result.cause()),\n+                                            command.getPayloadSize(),\n+                                            commandSample);\n+                                }\n+                                cancelCommandReceptionTimer(context);\n+                                setTtdStatus(context, TtdStatus.COMMAND);\n+                                responseReady.handle(Future.succeededFuture());\n+                            });\n+                } else {\n+                    // the timer has already fired, release the command\n+                    getMetrics().reportCommand(\n+                            command.isOneWay() ? Direction.ONE_WAY : Direction.REQUEST,\n+                            tenantObject.getTenantId(),\n+                            tenantObject,\n+                            ProcessingOutcome.UNDELIVERABLE,\n+                            command.getPayloadSize(),\n+                            commandSample);\n+                    log.debug(\"command for device has already fired [tenantId: {}, deviceId: {}]\",\n+                            tenantObject.getTenantId(), deviceId);\n+                    commandContext.release();\n+                }\n+\n+            } else {\n+                getMetrics().reportCommand(\n+                        command.isOneWay() ? Direction.ONE_WAY : Direction.REQUEST,\n+                        tenantObject.getTenantId(),\n+                        tenantObject,\n+                        ProcessingOutcome.UNPROCESSABLE,\n+                        command.getPayloadSize(),\n+                        commandSample);\n+                log.debug(\"command message is invalid: {}\", command);\n+                commandContext.reject(new ErrorCondition(Constants.AMQP_BAD_REQUEST, \"malformed command message\"));\n+            }\n+            // we do not issue any new credit because the\n+            // consumer is supposed to deliver a single command\n+            // only per HTTP request\n+        };\n+\n+        final Handler<Void> remoteCloseHandler = remoteDetach -> {\n+            log.debug(\"peer closed command receiver link [tenant-id: {}, device-id: {}, gateway-id: {}]\",\n+                    tenantObject.getTenantId(), deviceId, gatewayId);\n+            // command consumer is closed by closeHandler, no explicit close necessary here\n+        };\n+\n+        // First check whether the tenant has been configured to support concurrent ttd-param requests from the same\n+        // gateway for different devices. In that case a device-specific (instead of a gateway-specific) consumer link\n+        // will be created below\n+        // (preventing multiple consumer links on the same gateway address from multiple HTTP adapter instances).\n+        final Future<MessageConsumer> commandConsumerFuture = isSupportConcurrentGatewayDeviceCommandRequests(\n+                tenantObject)\n+                        .compose(supportConcurrentGatewayDeviceCommandRequests -> {\n+                            if (gatewayId != null && !supportConcurrentGatewayDeviceCommandRequests) {\n+                                // gateway scenario\n+                                return getCommandConsumerFactory().createCommandConsumer(\n+                                        tenantObject.getTenantId(),\n+                                        deviceId,\n+                                        gatewayId,\n+                                        commandHandler,\n+                                        remoteCloseHandler);\n+                            } else {\n+                                if (gatewayId != null) {\n+                                    log.trace(\n+                                            \"gateway mapping disabled for tenant [{}], will create device-specific consumer\",\n+                                            tenantObject.getTenantId());\n+                                }\n+                                return getCommandConsumerFactory().createCommandConsumer(\n+                                        tenantObject.getTenantId(),\n+                                        deviceId,\n+                                        commandHandler,\n+                                        remoteCloseHandler);\n+                            }\n+                        });\n+        return commandConsumerFuture\n+                .map(consumer -> {\n+                    if (!requestProcessed.get()) {\n+                        // if the request was not responded already, add a timer for triggering an empty response\n+                        addCommandReceptionTimer(context, requestProcessed, responseReady, ttdSecs);\n+                        context.getExchange().accept();\n+                    }\n+                    return consumer;\n+                })\n+                .recover(t -> {\n+                    if (t instanceof ResourceConflictException) {\n+                        // another request from the same device that contains\n+                        // a TTD value is already being processed\n+                        if (context.isEmptyNotification()) {\n+                            // no need to forward message downstream\n+                            return Future.failedFuture(t);\n+                        } else {\n+                            // let the other request handle the command (if any)\n+                            if (requestProcessed.compareAndSet(false, true)) {\n+                                responseReady.handle(Future.succeededFuture());\n+                            }\n+                            return Future.succeededFuture();\n+                        }\n+                    } else {\n+                        return Future.failedFuture(t);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Validate if a command is valid and can be sent as response.\n+     * <p>\n+     * The default implementation will call {@link Command#isValid()}. Protocol adapters may override this, but should\n+     * consider calling the super method.\n+     *\n+     * @param command The command to validate, will never be {@code null}.\n+     * @param currentSpan The current tracing span.\n+     * @return {@code true} if the command is valid, {@code false} otherwise.\n+     */\n+    protected boolean isCommandValid(final Command command, final Span currentSpan) {\n+        return command.isValid();\n+    }\n+\n+    /**\n+     * Sets a timer to trigger the sending of a (empty) response to a device if no command has been received from an\n+     * application within a given amount of time.\n+     * <p>\n+     * The created timer's ID is put to the routing context using key {@link #KEY_TIMER_ID}.\n+     *\n+     * @param ctx The device's currently executing HTTP request.\n+     * @param responseReady The future to complete when the time has expired.\n+     * @param delaySecs The number of seconds to wait for a command.\n+     */\n+    private void addCommandReceptionTimer(\n+            final CoapContext context,\n+            final AtomicBoolean requestProcessed,\n+            final Handler<AsyncResult<Void>> responseReady,\n+            final long delaySecs) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE2MTQ5MQ=="}, "originalCommit": {"oid": "ae60a16e87a8ca1fb7cb2033815296270b619244"}, "originalPosition": 511}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzOTY0NTg0OnYy", "diffSide": "RIGHT", "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDozNDo0OFrOFopdkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMTo0Nzo0MlrOForpYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE2NjY3Mw==", "bodyText": "\"answered\"", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r378166673", "createdAt": "2020-02-12T10:34:48Z", "author": {"login": "calohmn"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "diffHunk": "@@ -595,6 +611,7 @@ protected void preShutdown() {\n      * follows:\n      * <ul>\n      * <li>2.04 (Changed) - if the message has been forwarded downstream.</li>\n+     * <li>2.05 (Content) - if the message has been answer with a command.</li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae60a16e87a8ca1fb7cb2033815296270b619244"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIwMjQ2NA==", "bodyText": "fixed", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r378202464", "createdAt": "2020-02-12T11:47:42Z", "author": {"login": "boaks"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "diffHunk": "@@ -595,6 +611,7 @@ protected void preShutdown() {\n      * follows:\n      * <ul>\n      * <li>2.04 (Changed) - if the message has been forwarded downstream.</li>\n+     * <li>2.05 (Content) - if the message has been answer with a command.</li>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE2NjY3Mw=="}, "originalCommit": {"oid": "ae60a16e87a8ca1fb7cb2033815296270b619244"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzOTc0ODc5OnYy", "diffSide": "RIGHT", "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMTowNTozOVrOFoqc7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMTo0Nzo1N1rOForp4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE4Mjg5NA==", "bodyText": "It looks like the commandConsumerTracker is not used below in the sense that it is composed with other Futures, to handle command consumer creation failures.\nIf I understand the intention here correctly, the command and control handling in doUploadMessage is similar to the one in the HTTP adapter, meaning that when the returned Future of  doUploadMessage  is finished, the created command consumer is to be closed again already, right?\nThe line below:\nOptional.ofNullable(commandConsumerTracker.result()).ifPresent(consumer -> consumer.close(null));\nmeans: If the command consumer creation was successfully finished, close the consumer.\nBut what if at that point in time, the consumer creation wasn't finished yet. When the creation succeeds at a later point, the consumer will never get closed.\nTherefore the code here has to be adapted to make sure that a successfully created command consumer is closed under all circumstances. That means, making sure that some logic is done after the commandConsumerTracker is completed (using commandConsumerTracker.compose or CompositeFuture.join as done here).", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r378182894", "createdAt": "2020-02-12T11:05:39Z", "author": {"login": "calohmn"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "diffHunk": "@@ -645,34 +666,91 @@ protected void preShutdown() {\n                     .withTag(TracingHelper.TAG_AUTHENTICATED.getKey(), authenticatedDevice != null)\n                     .start();\n \n+            final Promise<Void> responseReady = Promise.promise();\n+\n             final Future<JsonObject> tokenTracker = getRegistrationAssertion(\n                     device.getTenantId(), device.getDeviceId(),\n                     authenticatedDevice,\n                     currentSpan.context());\n-            final Future<TenantObject> tenantTracker = getTenantConfiguration(device.getTenantId(), currentSpan.context());\n+            final Future<TenantObject> tenantTracker = getTenantConfiguration(device.getTenantId(),\n+                    currentSpan.context());\n             final Future<TenantObject> tenantValidationTracker = tenantTracker\n                     .compose(tenantObject -> CompositeFuture\n                             .all(isAdapterEnabled(tenantObject),\n                                     checkMessageLimit(tenantObject, payload.length(), currentSpan.context()))\n                             .map(success -> tenantObject));\n+\n+            // we only need to consider TTD if the device and tenant are enabled and the adapter\n+            // is enabled for the tenant\n+            final Future<Integer> ttdTracker = CompositeFuture.all(tenantValidationTracker, tokenTracker)\n+                    .compose(ok -> {\n+                        final Integer ttdParam = getTimeUntilDisconnectFromRequest(context);\n+                        return getTimeUntilDisconnect(tenantTracker.result(), ttdParam).map(effectiveTtd -> {\n+                            if (effectiveTtd != null) {\n+                                currentSpan.setTag(MessageHelper.APP_PROPERTY_DEVICE_TTD, effectiveTtd);\n+                            }\n+                            return effectiveTtd;\n+                        });\n+                    });\n+            final Future<MessageConsumer> commandConsumerTracker = ttdTracker", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae60a16e87a8ca1fb7cb2033815296270b619244"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIwMjU5Mw==", "bodyText": "Hopefully fixed :-).", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r378202593", "createdAt": "2020-02-12T11:47:57Z", "author": {"login": "boaks"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "diffHunk": "@@ -645,34 +666,91 @@ protected void preShutdown() {\n                     .withTag(TracingHelper.TAG_AUTHENTICATED.getKey(), authenticatedDevice != null)\n                     .start();\n \n+            final Promise<Void> responseReady = Promise.promise();\n+\n             final Future<JsonObject> tokenTracker = getRegistrationAssertion(\n                     device.getTenantId(), device.getDeviceId(),\n                     authenticatedDevice,\n                     currentSpan.context());\n-            final Future<TenantObject> tenantTracker = getTenantConfiguration(device.getTenantId(), currentSpan.context());\n+            final Future<TenantObject> tenantTracker = getTenantConfiguration(device.getTenantId(),\n+                    currentSpan.context());\n             final Future<TenantObject> tenantValidationTracker = tenantTracker\n                     .compose(tenantObject -> CompositeFuture\n                             .all(isAdapterEnabled(tenantObject),\n                                     checkMessageLimit(tenantObject, payload.length(), currentSpan.context()))\n                             .map(success -> tenantObject));\n+\n+            // we only need to consider TTD if the device and tenant are enabled and the adapter\n+            // is enabled for the tenant\n+            final Future<Integer> ttdTracker = CompositeFuture.all(tenantValidationTracker, tokenTracker)\n+                    .compose(ok -> {\n+                        final Integer ttdParam = getTimeUntilDisconnectFromRequest(context);\n+                        return getTimeUntilDisconnect(tenantTracker.result(), ttdParam).map(effectiveTtd -> {\n+                            if (effectiveTtd != null) {\n+                                currentSpan.setTag(MessageHelper.APP_PROPERTY_DEVICE_TTD, effectiveTtd);\n+                            }\n+                            return effectiveTtd;\n+                        });\n+                    });\n+            final Future<MessageConsumer> commandConsumerTracker = ttdTracker", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE4Mjg5NA=="}, "originalCommit": {"oid": "ae60a16e87a8ca1fb7cb2033815296270b619244"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MzMyMzkwOnYy", "diffSide": "LEFT", "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwOTozODozM1rOFpM5Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxMTozMToxMFrOFpzvrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0NzE2Nw==", "bodyText": "is there a particular reason why you want to remove these tags?", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r378747167", "createdAt": "2020-02-13T09:38:33Z", "author": {"login": "sophokles73"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "diffHunk": "@@ -633,46 +650,105 @@ protected void preShutdown() {\n             context.respondWithCode(ResponseCode.NOT_ACCEPTABLE);\n             return Future.succeededFuture(ResponseCode.NOT_ACCEPTABLE);\n         } else {\n+            final String gatewayId = authenticatedDevice != null\n+                    && !device.getDeviceId().equals(authenticatedDevice.getDeviceId())\n+                            ? authenticatedDevice.getDeviceId()\n+                            : null;\n \n             final Span currentSpan = TracingHelper\n                     .buildChildSpan(tracer, context.getTracingContext(),\n                             \"upload \" + endpoint.getCanonicalName())\n                     .ignoreActiveSpan()\n-                    .withTag(Tags.COMPONENT.getKey(), getTypeName())\n-                    .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30c8cd4370c2626969da0d7cdb8d40ba13da0bfc"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjE0OQ==", "bodyText": "They are already included in the parent spawn.\nI recognized, that the \"kind\" changes from \"server\" to \"client\". And coap uses \"http-uri\".\nSo my impression was, that the tags are not consequent maintained. Therefore I adjusted them in the was, I thought it is useful.", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r379312149", "createdAt": "2020-02-14T08:53:33Z", "author": {"login": "boaks"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "diffHunk": "@@ -633,46 +650,105 @@ protected void preShutdown() {\n             context.respondWithCode(ResponseCode.NOT_ACCEPTABLE);\n             return Future.succeededFuture(ResponseCode.NOT_ACCEPTABLE);\n         } else {\n+            final String gatewayId = authenticatedDevice != null\n+                    && !device.getDeviceId().equals(authenticatedDevice.getDeviceId())\n+                            ? authenticatedDevice.getDeviceId()\n+                            : null;\n \n             final Span currentSpan = TracingHelper\n                     .buildChildSpan(tracer, context.getTracingContext(),\n                             \"upload \" + endpoint.getCanonicalName())\n                     .ignoreActiveSpan()\n-                    .withTag(Tags.COMPONENT.getKey(), getTypeName())\n-                    .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0NzE2Nw=="}, "originalCommit": {"oid": "30c8cd4370c2626969da0d7cdb8d40ba13da0bfc"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM2NTA4OA==", "bodyText": "The kind changes from server to client because this new span is used to track the protocol adapter's (client) request to the AMQP Messaging Network to forward the message to a downstream consumer. The parent span has been created in response to a device's request to upload data (hence server).\nThe tags are not inherited, thus it makes sense to set them on each new span so that they can easily be found when searching for tag values. FMPOV you should therefore revert this change ...", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r379365088", "createdAt": "2020-02-14T10:46:11Z", "author": {"login": "sophokles73"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "diffHunk": "@@ -633,46 +650,105 @@ protected void preShutdown() {\n             context.respondWithCode(ResponseCode.NOT_ACCEPTABLE);\n             return Future.succeededFuture(ResponseCode.NOT_ACCEPTABLE);\n         } else {\n+            final String gatewayId = authenticatedDevice != null\n+                    && !device.getDeviceId().equals(authenticatedDevice.getDeviceId())\n+                            ? authenticatedDevice.getDeviceId()\n+                            : null;\n \n             final Span currentSpan = TracingHelper\n                     .buildChildSpan(tracer, context.getTracingContext(),\n                             \"upload \" + endpoint.getCanonicalName())\n                     .ignoreActiveSpan()\n-                    .withTag(Tags.COMPONENT.getKey(), getTypeName())\n-                    .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0NzE2Nw=="}, "originalCommit": {"oid": "30c8cd4370c2626969da0d7cdb8d40ba13da0bfc"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM4MzcyNA==", "bodyText": "done.", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r379383724", "createdAt": "2020-02-14T11:31:10Z", "author": {"login": "boaks"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "diffHunk": "@@ -633,46 +650,105 @@ protected void preShutdown() {\n             context.respondWithCode(ResponseCode.NOT_ACCEPTABLE);\n             return Future.succeededFuture(ResponseCode.NOT_ACCEPTABLE);\n         } else {\n+            final String gatewayId = authenticatedDevice != null\n+                    && !device.getDeviceId().equals(authenticatedDevice.getDeviceId())\n+                            ? authenticatedDevice.getDeviceId()\n+                            : null;\n \n             final Span currentSpan = TracingHelper\n                     .buildChildSpan(tracer, context.getTracingContext(),\n                             \"upload \" + endpoint.getCanonicalName())\n                     .ignoreActiveSpan()\n-                    .withTag(Tags.COMPONENT.getKey(), getTypeName())\n-                    .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0NzE2Nw=="}, "originalCommit": {"oid": "30c8cd4370c2626969da0d7cdb8d40ba13da0bfc"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MzMyODc5OnYy", "diffSide": "RIGHT", "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QwOTo0MDowM1rOFpM8LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwOTo0NDozNFrOFpwylw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0Nzk0OA==", "bodyText": "how about moving this method to CoapContext?", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r378747948", "createdAt": "2020-02-13T09:40:03Z", "author": {"login": "sophokles73"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "diffHunk": "@@ -715,4 +794,348 @@ protected void preShutdown() {\n             final Device authenticatedDevice) {\n         return Future.succeededFuture(true);\n     }\n+\n+    /**\n+     * Gets the value of the {@link org.eclipse.hono.util.Constants#HEADER_TIME_TILL_DISCONNECT} query parameter of the\n+     * CoAP request.\n+     *\n+     * @param context The CoAP context containing the request.\n+     * @return The time till disconnect or {@code null} if\n+     *         <ul>\n+     *         <li>the request doesn't contain a {@link org.eclipse.hono.util.Constants#HEADER_TIME_TILL_DISCONNECT}\n+     *         query parameter.</li>\n+     *         <li>the contained value cannot be parsed as an Integer</li>\n+     *         </ul>\n+     * @throws NullPointerException if context is {@code null}.\n+     */\n+    protected Integer getTimeUntilDisconnectFromRequest(final CoapContext context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30c8cd4370c2626969da0d7cdb8d40ba13da0bfc"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMxMjQ3MA==", "bodyText": "Possible.", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r379312470", "createdAt": "2020-02-14T08:54:11Z", "author": {"login": "boaks"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "diffHunk": "@@ -715,4 +794,348 @@ protected void preShutdown() {\n             final Device authenticatedDevice) {\n         return Future.succeededFuture(true);\n     }\n+\n+    /**\n+     * Gets the value of the {@link org.eclipse.hono.util.Constants#HEADER_TIME_TILL_DISCONNECT} query parameter of the\n+     * CoAP request.\n+     *\n+     * @param context The CoAP context containing the request.\n+     * @return The time till disconnect or {@code null} if\n+     *         <ul>\n+     *         <li>the request doesn't contain a {@link org.eclipse.hono.util.Constants#HEADER_TIME_TILL_DISCONNECT}\n+     *         query parameter.</li>\n+     *         <li>the contained value cannot be parsed as an Integer</li>\n+     *         </ul>\n+     * @throws NullPointerException if context is {@code null}.\n+     */\n+    protected Integer getTimeUntilDisconnectFromRequest(final CoapContext context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0Nzk0OA=="}, "originalCommit": {"oid": "30c8cd4370c2626969da0d7cdb8d40ba13da0bfc"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMzNTMxOQ==", "bodyText": "Done.", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r379335319", "createdAt": "2020-02-14T09:44:34Z", "author": {"login": "boaks"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "diffHunk": "@@ -715,4 +794,348 @@ protected void preShutdown() {\n             final Device authenticatedDevice) {\n         return Future.succeededFuture(true);\n     }\n+\n+    /**\n+     * Gets the value of the {@link org.eclipse.hono.util.Constants#HEADER_TIME_TILL_DISCONNECT} query parameter of the\n+     * CoAP request.\n+     *\n+     * @param context The CoAP context containing the request.\n+     * @return The time till disconnect or {@code null} if\n+     *         <ul>\n+     *         <li>the request doesn't contain a {@link org.eclipse.hono.util.Constants#HEADER_TIME_TILL_DISCONNECT}\n+     *         query parameter.</li>\n+     *         <li>the contained value cannot be parsed as an Integer</li>\n+     *         </ul>\n+     * @throws NullPointerException if context is {@code null}.\n+     */\n+    protected Integer getTimeUntilDisconnectFromRequest(final CoapContext context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc0Nzk0OA=="}, "originalCommit": {"oid": "30c8cd4370c2626969da0d7cdb8d40ba13da0bfc"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1NjQzNTM1OnYy", "diffSide": "RIGHT", "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/CoapContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNDo1OTo0MFrOFrFphA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQwODo1ODo0M1rOFrfxTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcyNTYzNg==", "bodyText": "{@code null} instead of link", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r380725636", "createdAt": "2020-02-18T14:59:40Z", "author": {"login": "calohmn"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/CoapContext.java", "diffHunk": "@@ -94,4 +108,109 @@ public Sample getTimer() {\n     public void respondWithCode(final ResponseCode responseCode) {\n         exchange.respond(responseCode);\n     }\n+\n+    /**\n+     * Sends a response with text payload to the device.\n+     * \n+     * @param responseCode The code to set in the response.\n+     * @param payload The payload text to set in the response.\n+     */\n+    public void respondWithCode(final ResponseCode responseCode, final String payload) {\n+        exchange.respond(responseCode, payload);\n+    }\n+\n+    /**\n+     * Sends a response with payload to the device.\n+     * \n+     * @param responseCode The code to set in the response.\n+     * @param payload The payload to set in the response.\n+     * @param contentFormat The content format to set in the response.\n+     */\n+    public void respondWithCode(final ResponseCode responseCode, final String payload, final int contentFormat) {\n+        exchange.respond(responseCode, payload, contentFormat);\n+    }\n+\n+    /**\n+     * Get CoAP query parameter.\n+     * \n+     * @param name parameter name\n+     * @return value of query parameter, or {@code null}, if not provided in request,\n+     */\n+    public String getQueryParameter(final String name) {\n+        return exchange.getQueryParameter(name);\n+    }\n+\n+    /**\n+     * Gets the value of the {@link org.eclipse.hono.util.Constants#HEADER_TIME_TILL_DISCONNECT} query parameter of the\n+     * CoAP request.\n+     *\n+     * @return The time till disconnect or {@code null} if\n+     *         <ul>\n+     *         <li>the request doesn't contain a {@link org.eclipse.hono.util.Constants#HEADER_TIME_TILL_DISCONNECT}\n+     *         query parameter.</li>\n+     *         <li>the contained value cannot be parsed as an Integer</li>\n+     *         </ul>\n+     */\n+    public Integer getTimeUntilDisconnect() {\n+        return getIntegerQueryParameter(Constants.HEADER_TIME_TILL_DISCONNECT);\n+    }\n+\n+    /**\n+     * Check, if request represents a empty notification, just to check, if commands are available.\n+     * \n+     * @return {@code true}, if request is a empty notification, {@code false}, otherwise.\n+     */\n+    public boolean isEmptyNotification() {\n+        return exchange.getQueryParameter(PARAM_EMPTY_CONTENT) != null;\n+    }\n+\n+    /**\n+     * Get command request id of response for command.\n+     * \n+     * @return command request id.\n+     */\n+    public String getCommandRequestId() {\n+        final List<String> pathList = exchange.getRequestOptions().getUriPath();\n+        if (pathList.size() == 3 || pathList.size() == 5) {\n+            if (pathList.get(1).equals(\"res\")) {\n+                return pathList.get(pathList.size() - 1);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get command response status of response for command.\n+     * \n+     * @return status, or {@link null}, if not available.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1344d474ce08a41be49e17c1a34d3082c4173d98"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE1MzYxNQ==", "bodyText": "Uups .. you're right!", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r381153615", "createdAt": "2020-02-19T08:58:43Z", "author": {"login": "boaks"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/CoapContext.java", "diffHunk": "@@ -94,4 +108,109 @@ public Sample getTimer() {\n     public void respondWithCode(final ResponseCode responseCode) {\n         exchange.respond(responseCode);\n     }\n+\n+    /**\n+     * Sends a response with text payload to the device.\n+     * \n+     * @param responseCode The code to set in the response.\n+     * @param payload The payload text to set in the response.\n+     */\n+    public void respondWithCode(final ResponseCode responseCode, final String payload) {\n+        exchange.respond(responseCode, payload);\n+    }\n+\n+    /**\n+     * Sends a response with payload to the device.\n+     * \n+     * @param responseCode The code to set in the response.\n+     * @param payload The payload to set in the response.\n+     * @param contentFormat The content format to set in the response.\n+     */\n+    public void respondWithCode(final ResponseCode responseCode, final String payload, final int contentFormat) {\n+        exchange.respond(responseCode, payload, contentFormat);\n+    }\n+\n+    /**\n+     * Get CoAP query parameter.\n+     * \n+     * @param name parameter name\n+     * @return value of query parameter, or {@code null}, if not provided in request,\n+     */\n+    public String getQueryParameter(final String name) {\n+        return exchange.getQueryParameter(name);\n+    }\n+\n+    /**\n+     * Gets the value of the {@link org.eclipse.hono.util.Constants#HEADER_TIME_TILL_DISCONNECT} query parameter of the\n+     * CoAP request.\n+     *\n+     * @return The time till disconnect or {@code null} if\n+     *         <ul>\n+     *         <li>the request doesn't contain a {@link org.eclipse.hono.util.Constants#HEADER_TIME_TILL_DISCONNECT}\n+     *         query parameter.</li>\n+     *         <li>the contained value cannot be parsed as an Integer</li>\n+     *         </ul>\n+     */\n+    public Integer getTimeUntilDisconnect() {\n+        return getIntegerQueryParameter(Constants.HEADER_TIME_TILL_DISCONNECT);\n+    }\n+\n+    /**\n+     * Check, if request represents a empty notification, just to check, if commands are available.\n+     * \n+     * @return {@code true}, if request is a empty notification, {@code false}, otherwise.\n+     */\n+    public boolean isEmptyNotification() {\n+        return exchange.getQueryParameter(PARAM_EMPTY_CONTENT) != null;\n+    }\n+\n+    /**\n+     * Get command request id of response for command.\n+     * \n+     * @return command request id.\n+     */\n+    public String getCommandRequestId() {\n+        final List<String> pathList = exchange.getRequestOptions().getUriPath();\n+        if (pathList.size() == 3 || pathList.size() == 5) {\n+            if (pathList.get(1).equals(\"res\")) {\n+                return pathList.get(pathList.size() - 1);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get command response status of response for command.\n+     * \n+     * @return status, or {@link null}, if not available.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDcyNTYzNg=="}, "originalCommit": {"oid": "1344d474ce08a41be49e17c1a34d3082c4173d98"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTY3MzA4OnYy", "diffSide": "RIGHT", "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNzoxMDo0MFrOFsb2-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxMjoyMjo0MFrOFs1NQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEzODEwNQ==", "bodyText": "payloadSize?", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r382138105", "createdAt": "2020-02-20T17:10:40Z", "author": {"login": "sophokles73"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "diffHunk": "@@ -1112,4 +1096,95 @@ private TtdStatus getTtdStatus(final CoapContext context) {\n \n         return Future.succeededFuture(result);\n     }\n+\n+    /**\n+     * Uploads a command response message to Hono.\n+     *\n+     * @param context The context representing the request to be processed.\n+     * @param authenticatedDevice authenticated device\n+     * @param device message's origin device\n+     * @return A succeeded future containing the CoAP status code that has been returned to the device.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    public final Future<ResponseCode> uploadCommandResponseMessage(final CoapContext context, final Device authenticatedDevice,\n+                final Device device) {\n+\n+        Objects.requireNonNull(context);\n+        Objects.requireNonNull(authenticatedDevice);\n+        Objects.requireNonNull(device);\n+\n+        final Buffer payload = context.getPayload();\n+        final String contentType = MediaTypeRegistry.toString(context.getExchange().getRequestOptions().getContentFormat());\n+        final String commandRequestId = context.getCommandRequestId();\n+        final Integer responseStatus = context.getCommandResponseStatus();\n+        log.debug(\"processing response to command [tenantId: {}, deviceId: {}, cmd-req-id: {}, status code: {}]\",\n+                device.getTenantId(), device.getDeviceId(), commandRequestId, responseStatus);\n+\n+        final Span currentSpan = TracingHelper\n+                .buildChildSpan(tracer, context.getTracingContext(), \"upload Command response\")\n+                .ignoreActiveSpan()\n+                .withTag(Tags.COMPONENT.getKey(), getTypeName())\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT)\n+                .withTag(MessageHelper.APP_PROPERTY_TENANT_ID, device.getTenantId())\n+                .withTag(MessageHelper.APP_PROPERTY_DEVICE_ID, device.getDeviceId())\n+                .withTag(Constants.HEADER_COMMAND_RESPONSE_STATUS, responseStatus)\n+                .withTag(Constants.HEADER_COMMAND_REQUEST_ID, commandRequestId)\n+                .withTag(TracingHelper.TAG_AUTHENTICATED.getKey(), authenticatedDevice != null)\n+                .start();\n+\n+        final CommandResponse cmdResponseOrNull = CommandResponse.from(commandRequestId, device.getTenantId(), device.getDeviceId(), payload,\n+                contentType, responseStatus);\n+        final Future<TenantObject> tenantTracker = getTenantConfiguration(device.getTenantId(), currentSpan.context());\n+        final Future<CommandResponse> commandResponseTracker = cmdResponseOrNull != null\n+                ? Future.succeededFuture(cmdResponseOrNull)\n+                : Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST,\n+                        String.format(\"command-request-id [%s] or status code [%s] is missing/invalid\",\n+                                commandRequestId, responseStatus)));\n+\n+        final int payloadSize = Optional.ofNullable(payload).map(Buffer::length).orElse(0);\n+        return CompositeFuture.all(tenantTracker, commandResponseTracker)\n+                .compose(commandResponse -> {\n+                    final Future<JsonObject> deviceRegistrationTracker = getRegistrationAssertion(\n+                            device.getTenantId(),\n+                            device.getDeviceId(),\n+                            authenticatedDevice,\n+                            currentSpan.context());\n+                    final Future<Void> tenantValidationTracker = CompositeFuture\n+                            .all(isAdapterEnabled(tenantTracker.result()),\n+                                    checkMessageLimit(tenantTracker.result(), payloadSize, currentSpan.context()))\n+                            .map(ok -> null);\n+\n+                    return CompositeFuture.all(tenantValidationTracker, deviceRegistrationTracker)\n+                            .compose(ok -> sendCommandResponse(device.getTenantId(), commandResponseTracker.result(), currentSpan.context()))\n+                            .map(delivery -> {\n+                                log.trace(\"delivered command response [command-request-id: {}] to application\",\n+                                        commandRequestId);\n+                                currentSpan.log(\"delivered command response to application\");\n+                                currentSpan.finish();\n+                                metrics.reportCommand(\n+                                        Direction.RESPONSE,\n+                                        device.getTenantId(),\n+                                        tenantTracker.result(),\n+                                        ProcessingOutcome.FORWARDED,\n+                                        payloadSize,\n+                                        context.getTimer());\n+                                context.respondWithCode(ResponseCode.CHANGED);\n+                                return ResponseCode.CHANGED;\n+                            });\n+                }).otherwise(t -> {\n+                    log.debug(\"could not send command response [command-request-id: {}] to application\",\n+                            commandRequestId, t);\n+                    TracingHelper.logError(currentSpan, t);\n+                    currentSpan.finish();\n+                    metrics.reportCommand(\n+                            Direction.RESPONSE,\n+                            device.getTenantId(),\n+                            tenantTracker.result(),\n+                            ProcessingOutcome.from(t),\n+                            payload.length(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "edbe1eaff51f7e89790c460e278559908a6541ca"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjU1MzQwOA==", "bodyText": "Here it seems to be cosmetic, payload will be always provided but may be empty.\nAnyway, if will remove the payloadSize and use always the payload.length(), though it's very straight forward, when payload is never null.\nJust to mention: the \"payload.length()\" is copied from http, where payload may be null. So it may cause troubles there.", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r382553408", "createdAt": "2020-02-21T12:22:40Z", "author": {"login": "boaks"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/AbstractVertxBasedCoapAdapter.java", "diffHunk": "@@ -1112,4 +1096,95 @@ private TtdStatus getTtdStatus(final CoapContext context) {\n \n         return Future.succeededFuture(result);\n     }\n+\n+    /**\n+     * Uploads a command response message to Hono.\n+     *\n+     * @param context The context representing the request to be processed.\n+     * @param authenticatedDevice authenticated device\n+     * @param device message's origin device\n+     * @return A succeeded future containing the CoAP status code that has been returned to the device.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    public final Future<ResponseCode> uploadCommandResponseMessage(final CoapContext context, final Device authenticatedDevice,\n+                final Device device) {\n+\n+        Objects.requireNonNull(context);\n+        Objects.requireNonNull(authenticatedDevice);\n+        Objects.requireNonNull(device);\n+\n+        final Buffer payload = context.getPayload();\n+        final String contentType = MediaTypeRegistry.toString(context.getExchange().getRequestOptions().getContentFormat());\n+        final String commandRequestId = context.getCommandRequestId();\n+        final Integer responseStatus = context.getCommandResponseStatus();\n+        log.debug(\"processing response to command [tenantId: {}, deviceId: {}, cmd-req-id: {}, status code: {}]\",\n+                device.getTenantId(), device.getDeviceId(), commandRequestId, responseStatus);\n+\n+        final Span currentSpan = TracingHelper\n+                .buildChildSpan(tracer, context.getTracingContext(), \"upload Command response\")\n+                .ignoreActiveSpan()\n+                .withTag(Tags.COMPONENT.getKey(), getTypeName())\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT)\n+                .withTag(MessageHelper.APP_PROPERTY_TENANT_ID, device.getTenantId())\n+                .withTag(MessageHelper.APP_PROPERTY_DEVICE_ID, device.getDeviceId())\n+                .withTag(Constants.HEADER_COMMAND_RESPONSE_STATUS, responseStatus)\n+                .withTag(Constants.HEADER_COMMAND_REQUEST_ID, commandRequestId)\n+                .withTag(TracingHelper.TAG_AUTHENTICATED.getKey(), authenticatedDevice != null)\n+                .start();\n+\n+        final CommandResponse cmdResponseOrNull = CommandResponse.from(commandRequestId, device.getTenantId(), device.getDeviceId(), payload,\n+                contentType, responseStatus);\n+        final Future<TenantObject> tenantTracker = getTenantConfiguration(device.getTenantId(), currentSpan.context());\n+        final Future<CommandResponse> commandResponseTracker = cmdResponseOrNull != null\n+                ? Future.succeededFuture(cmdResponseOrNull)\n+                : Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST,\n+                        String.format(\"command-request-id [%s] or status code [%s] is missing/invalid\",\n+                                commandRequestId, responseStatus)));\n+\n+        final int payloadSize = Optional.ofNullable(payload).map(Buffer::length).orElse(0);\n+        return CompositeFuture.all(tenantTracker, commandResponseTracker)\n+                .compose(commandResponse -> {\n+                    final Future<JsonObject> deviceRegistrationTracker = getRegistrationAssertion(\n+                            device.getTenantId(),\n+                            device.getDeviceId(),\n+                            authenticatedDevice,\n+                            currentSpan.context());\n+                    final Future<Void> tenantValidationTracker = CompositeFuture\n+                            .all(isAdapterEnabled(tenantTracker.result()),\n+                                    checkMessageLimit(tenantTracker.result(), payloadSize, currentSpan.context()))\n+                            .map(ok -> null);\n+\n+                    return CompositeFuture.all(tenantValidationTracker, deviceRegistrationTracker)\n+                            .compose(ok -> sendCommandResponse(device.getTenantId(), commandResponseTracker.result(), currentSpan.context()))\n+                            .map(delivery -> {\n+                                log.trace(\"delivered command response [command-request-id: {}] to application\",\n+                                        commandRequestId);\n+                                currentSpan.log(\"delivered command response to application\");\n+                                currentSpan.finish();\n+                                metrics.reportCommand(\n+                                        Direction.RESPONSE,\n+                                        device.getTenantId(),\n+                                        tenantTracker.result(),\n+                                        ProcessingOutcome.FORWARDED,\n+                                        payloadSize,\n+                                        context.getTimer());\n+                                context.respondWithCode(ResponseCode.CHANGED);\n+                                return ResponseCode.CHANGED;\n+                            });\n+                }).otherwise(t -> {\n+                    log.debug(\"could not send command response [command-request-id: {}] to application\",\n+                            commandRequestId, t);\n+                    TracingHelper.logError(currentSpan, t);\n+                    currentSpan.finish();\n+                    metrics.reportCommand(\n+                            Direction.RESPONSE,\n+                            device.getTenantId(),\n+                            tenantTracker.result(),\n+                            ProcessingOutcome.from(t),\n+                            payload.length(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEzODEwNQ=="}, "originalCommit": {"oid": "edbe1eaff51f7e89790c460e278559908a6541ca"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3Mjg1MzE0OnYy", "diffSide": "RIGHT", "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/DefaultDeviceResolver.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMToyNDozOFrOFtdXRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNToyNTo0MVrOFuKbDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMTMzNA==", "bodyText": "if these spans are suppose to be used for tracking the retrieval of the PSK from the device registry, then FMPOV the kind is SPAN_KIND_CLIENT.", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r383211334", "createdAt": "2020-02-24T11:24:38Z", "author": {"login": "sophokles73"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/DefaultDeviceResolver.java", "diffHunk": "@@ -103,6 +116,13 @@ private static SecretKey getKey(final JsonObject candidateSecret) {\n         }\n     }\n \n+    private Span newSpan(final String operation) {\n+        return tracer.buildSpan(operation)\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e010494f99f74f420645f6d06a81f2bc647c93"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5MDI3MQ==", "bodyText": "FMPOV, two spans are used for that. The outer one describes the incoming dtls handshake message (dtls server), the inner, the \"getCredentials\" call (amqp client). So, aligned to the POST stuff, I chose \"server\" for the outer and \"client\" for the inner.", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r383890271", "createdAt": "2020-02-25T13:52:01Z", "author": {"login": "boaks"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/DefaultDeviceResolver.java", "diffHunk": "@@ -103,6 +116,13 @@ private static SecretKey getKey(final JsonObject candidateSecret) {\n         }\n     }\n \n+    private Span newSpan(final String operation) {\n+        return tracer.buildSpan(operation)\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMTMzNA=="}, "originalCommit": {"oid": "56e010494f99f74f420645f6d06a81f2bc647c93"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxODEwMg==", "bodyText": "Can you point me to the place where the outer Span for tracing the DTLS handshake is created? I am afraid that I couldn't find it.", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r383918102", "createdAt": "2020-02-25T14:38:21Z", "author": {"login": "sophokles73"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/DefaultDeviceResolver.java", "diffHunk": "@@ -103,6 +116,13 @@ private static SecretKey getKey(final JsonObject candidateSecret) {\n         }\n     }\n \n+    private Span newSpan(final String operation) {\n+        return tracer.buildSpan(operation)\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMTMzNA=="}, "originalCommit": {"oid": "56e010494f99f74f420645f6d06a81f2bc647c93"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0OTU4MQ==", "bodyText": "FMPOV that are the callbacks\n@Override\npublic SecretKey getKey(final PskPublicInformation identity)\n \n@Override\npublic AdditionalInfo getInfo(final Principal clientIdentity)", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r383949581", "createdAt": "2020-02-25T15:25:41Z", "author": {"login": "boaks"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/DefaultDeviceResolver.java", "diffHunk": "@@ -103,6 +116,13 @@ private static SecretKey getKey(final JsonObject candidateSecret) {\n         }\n     }\n \n+    private Span newSpan(final String operation) {\n+        return tracer.buildSpan(operation)\n+                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_SERVER)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMTMzNA=="}, "originalCommit": {"oid": "56e010494f99f74f420645f6d06a81f2bc647c93"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3Mjg1NjEwOnYy", "diffSide": "RIGHT", "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/DefaultDeviceResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMToyNTo1MFrOFtdZHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzo1ODo0NlrOFuHCxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMTgwNg==", "bodyText": "IMHO the operation should be a little more expressive, e.g. get device identity info or something like that?", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r383211806", "createdAt": "2020-02-24T11:25:50Z", "author": {"login": "sophokles73"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/DefaultDeviceResolver.java", "diffHunk": "@@ -111,12 +131,15 @@ public AdditionalInfo getInfo(final Principal clientIdentity) {\n         final Map<String, Object> result = new HashMap<>();\n \n         if (clientIdentity instanceof PreSharedKeyIdentity) {\n+            final Span span = newSpan(\"PSK-INFO\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e010494f99f74f420645f6d06a81f2bc647c93"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5NDIxMw==", "bodyText": "Adapted to \"PSK-getDeviceIdentityInfo\"", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r383894213", "createdAt": "2020-02-25T13:58:46Z", "author": {"login": "boaks"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/DefaultDeviceResolver.java", "diffHunk": "@@ -111,12 +131,15 @@ public AdditionalInfo getInfo(final Principal clientIdentity) {\n         final Map<String, Object> result = new HashMap<>();\n \n         if (clientIdentity instanceof PreSharedKeyIdentity) {\n+            final Span span = newSpan(\"PSK-INFO\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMTgwNg=="}, "originalCommit": {"oid": "56e010494f99f74f420645f6d06a81f2bc647c93"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3Mjg1ODQyOnYy", "diffSide": "RIGHT", "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/DefaultDeviceResolver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMToyNjo0NlrOFtdakg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzo1OToyNlrOFuHERg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMjE3OA==", "bodyText": "more expressive name?", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r383212178", "createdAt": "2020-02-24T11:26:46Z", "author": {"login": "sophokles73"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/DefaultDeviceResolver.java", "diffHunk": "@@ -142,16 +167,20 @@ public AdditionalInfo getInfo(final Principal clientIdentity) {\n \n     @Override\n     public SecretKey getKey(final PskPublicInformation identity) {\n+        final Span span = newSpan(\"PSK-KEY\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e010494f99f74f420645f6d06a81f2bc647c93"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5NDU5OA==", "bodyText": "Adapted to \"PSK-getSecretKey\"", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r383894598", "createdAt": "2020-02-25T13:59:26Z", "author": {"login": "boaks"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/DefaultDeviceResolver.java", "diffHunk": "@@ -142,16 +167,20 @@ public AdditionalInfo getInfo(final Principal clientIdentity) {\n \n     @Override\n     public SecretKey getKey(final PskPublicInformation identity) {\n+        final Span span = newSpan(\"PSK-KEY\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMjE3OA=="}, "originalCommit": {"oid": "56e010494f99f74f420645f6d06a81f2bc647c93"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3Mjg2MDE2OnYy", "diffSide": "RIGHT", "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/DefaultDeviceResolver.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxMToyNzozM1rOFtdbpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzo0NTo0M1rOFuGlEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMjQ1NA==", "bodyText": "are you sure that this should be set as a tag instead of just being logged to the span?\nif this indeed needs to be a tag then I'd rather have a constant for the Tag or at least its name ...", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r383212454", "createdAt": "2020-02-24T11:27:33Z", "author": {"login": "sophokles73"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/DefaultDeviceResolver.java", "diffHunk": "@@ -160,13 +189,18 @@ public SecretKey getKey(final PskPublicInformation identity) {\n                 }\n             });\n         });\n+        SecretKey key;\n         try {\n             // credentials client will wait limited time only\n-            return secret.join();\n+            key = secret.join();\n+            span.setTag(\"secret\", true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56e010494f99f74f420645f6d06a81f2bc647c93"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg0NzQ2NA==", "bodyText": "I have no glue, what the difference of a tag or logged should be :-).", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r383847464", "createdAt": "2020-02-25T12:26:40Z", "author": {"login": "boaks"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/DefaultDeviceResolver.java", "diffHunk": "@@ -160,13 +189,18 @@ public SecretKey getKey(final PskPublicInformation identity) {\n                 }\n             });\n         });\n+        SecretKey key;\n         try {\n             // credentials client will wait limited time only\n-            return secret.join();\n+            key = secret.join();\n+            span.setTag(\"secret\", true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMjQ1NA=="}, "originalCommit": {"oid": "56e010494f99f74f420645f6d06a81f2bc647c93"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2MDQxMg==", "bodyText": "A tag on a Span is a searchable label, if you will. You can use it to find Spans that have a particular tag value. A Span's log is not searchable per se and is usually only shown, once a Span of interest has been identified. From what I see in the code, the outcome of retrieving the secret should either be logged to the Span (span.log()) or should be reflected by means of the standard http.status_code tag, e.g. setting it to 200 or 404 ...", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r383860412", "createdAt": "2020-02-25T12:55:10Z", "author": {"login": "sophokles73"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/DefaultDeviceResolver.java", "diffHunk": "@@ -160,13 +189,18 @@ public SecretKey getKey(final PskPublicInformation identity) {\n                 }\n             });\n         });\n+        SecretKey key;\n         try {\n             // credentials client will wait limited time only\n-            return secret.join();\n+            key = secret.join();\n+            span.setTag(\"secret\", true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMjQ1NA=="}, "originalCommit": {"oid": "56e010494f99f74f420645f6d06a81f2bc647c93"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4NjYxMA==", "bodyText": "OK, I will adapt it to \"log\".", "url": "https://github.com/eclipse/hono/pull/1762#discussion_r383886610", "createdAt": "2020-02-25T13:45:43Z", "author": {"login": "boaks"}, "path": "adapters/coap-vertx-base/src/main/java/org/eclipse/hono/adapter/coap/DefaultDeviceResolver.java", "diffHunk": "@@ -160,13 +189,18 @@ public SecretKey getKey(final PskPublicInformation identity) {\n                 }\n             });\n         });\n+        SecretKey key;\n         try {\n             // credentials client will wait limited time only\n-            return secret.join();\n+            key = secret.join();\n+            span.setTag(\"secret\", true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIxMjQ1NA=="}, "originalCommit": {"oid": "56e010494f99f74f420645f6d06a81f2bc647c93"}, "originalPosition": 122}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3424, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}