{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxMTM2OTYx", "number": 1845, "reviewThreads": {"totalCount": 114, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMjowNTowNlrOD3mIww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODozODo0M1rOD8YQQQ==", "hasNextPage": false, "hasPreviousPage": true}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjIzMTA3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMjowNTowNlrOGN7uSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTozMTo1NlrOGOEnYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI2MzE3Nw==", "bodyText": "remove .", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417263177", "createdAt": "2020-04-29T12:05:06Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(String.format(\"conflict updating tenant [%s]. An existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);\n+                        TracingHelper.logError(span, \"An existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found.\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId) {\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Tenant [%s] not found.\",\n+                                        findQuery.getString(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID))))));\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(span);\n+\n+        final String tenantIdOrGenerated = tenantId.orElse(DeviceRegistryUtils.getUniqueIdentifier());\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantIdOrGenerated)\n+                .compose(ok -> processCreateTenant(tenantIdOrGenerated, tenantObj, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Id>> processCreateTenant(final String tenantId, final Tenant tenantObj,\n+            final Span span) {\n+\n+        final TenantDto newTenantDto = new TenantDto(tenantId, tenantObj,\n+                new Versioned<>(tenantObj).getVersion());\n+\n+        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+        final Promise<String> createTenantPromise = Promise.promise();\n+        mongoClient.insert(config.getCollectionName(), newTenantDtoJson, createTenantPromise);\n+        return createTenantPromise.future()\n+                .compose(tenantObjectIdResult -> {\n+                    span.log(\"successfully created tenant.\");\n+                    return Future.succeededFuture(OperationResult.ok(\n+                            HttpURLConnection.HTTP_CREATED,\n+                            Id.of(tenantId),\n+                            Optional.empty(),\n+                            Optional.of(newTenantDto.getVersion())));\n+                })\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(String.format(\"The tenant [%s] already exists or an existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);\n+                        TracingHelper.logError(span, \"The tenant with the given identifier already exists or an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else {\n+                        LOG.error(String.format(\"Error adding Tenant [%s].\", tenantId), error);\n+                        TracingHelper.logError(span, \"Error adding Tenant.\", error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 414}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwODg2Ng==", "bodyText": "Updated", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417408866", "createdAt": "2020-04-29T15:31:56Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(String.format(\"conflict updating tenant [%s]. An existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);\n+                        TracingHelper.logError(span, \"An existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found.\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId) {\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Tenant [%s] not found.\",\n+                                        findQuery.getString(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID))))));\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(span);\n+\n+        final String tenantIdOrGenerated = tenantId.orElse(DeviceRegistryUtils.getUniqueIdentifier());\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantIdOrGenerated)\n+                .compose(ok -> processCreateTenant(tenantIdOrGenerated, tenantObj, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Id>> processCreateTenant(final String tenantId, final Tenant tenantObj,\n+            final Span span) {\n+\n+        final TenantDto newTenantDto = new TenantDto(tenantId, tenantObj,\n+                new Versioned<>(tenantObj).getVersion());\n+\n+        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+        final Promise<String> createTenantPromise = Promise.promise();\n+        mongoClient.insert(config.getCollectionName(), newTenantDtoJson, createTenantPromise);\n+        return createTenantPromise.future()\n+                .compose(tenantObjectIdResult -> {\n+                    span.log(\"successfully created tenant.\");\n+                    return Future.succeededFuture(OperationResult.ok(\n+                            HttpURLConnection.HTTP_CREATED,\n+                            Id.of(tenantId),\n+                            Optional.empty(),\n+                            Optional.of(newTenantDto.getVersion())));\n+                })\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(String.format(\"The tenant [%s] already exists or an existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);\n+                        TracingHelper.logError(span, \"The tenant with the given identifier already exists or an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else {\n+                        LOG.error(String.format(\"Error adding Tenant [%s].\", tenantId), error);\n+                        TracingHelper.logError(span, \"Error adding Tenant.\", error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI2MzE3Nw=="}, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 414}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjI0NDI4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMjowOTowOVrOGN72ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTozMTo1MlrOGOEnJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI2NTI1OA==", "bodyText": "this seems to be a constant value ...", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417265258", "createdAt": "2020-04-29T12:09:09Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -46,6 +48,22 @@ public MongoDbDocumentBuilder withDeviceId(final String deviceId) {\n         return this;\n     }\n \n+    /**\n+     * Sets the json object with the given subject DN.\n+     *\n+     * @param SubjectDn The subject DN.\n+     * @return a reference to this for fluent use.\n+     */\n+    public MongoDbDocumentBuilder withCa(final String SubjectDn) {\n+        document.put(\n+                String.format(\"%s.%s.%s\",\n+                              RegistryManagementConstants.FIELD_TENANT,\n+                              RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                              AuthenticationConstants.FIELD_SUBJECT_DN),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwODgwNw==", "bodyText": "That is right, moved into a constant.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417408807", "createdAt": "2020-04-29T15:31:52Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -46,6 +48,22 @@ public MongoDbDocumentBuilder withDeviceId(final String deviceId) {\n         return this;\n     }\n \n+    /**\n+     * Sets the json object with the given subject DN.\n+     *\n+     * @param SubjectDn The subject DN.\n+     * @return a reference to this for fluent use.\n+     */\n+    public MongoDbDocumentBuilder withCa(final String SubjectDn) {\n+        document.put(\n+                String.format(\"%s.%s.%s\",\n+                              RegistryManagementConstants.FIELD_TENANT,\n+                              RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                              AuthenticationConstants.FIELD_SUBJECT_DN),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI2NTI1OA=="}, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODQ4OTY0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODozMTowNFrOGRI9mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDoxNToxM1rOGRMcBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyNTgxNw==", "bodyText": "I don't get the need for having both the get and the getForCertificateAuthority method.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420625817", "createdAt": "2020-05-06T08:31:04Z", "author": {"login": "ctron"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final MongoClient mongoClient;\n+    private final MongoDbCallExecutor mongoDbCallExecutor;\n+    private final MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Creates a new service for configuration properties.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param mongoClient The client for accessing the Mongo DB instance.\n+     * @param config The properties for configuring this service.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public MongoDbBasedTenantService(\n+            final Vertx vertx,\n+            final MongoClient mongoClient,\n+            final MongoDbBasedTenantsConfigProperties config) {\n+\n+        Objects.requireNonNull(vertx);\n+        Objects.requireNonNull(mongoClient);\n+        Objects.requireNonNull(config);\n+\n+        this.mongoClient = mongoClient;\n+        this.mongoDbCallExecutor = new MongoDbCallExecutor(vertx, mongoClient);\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(\n+            final String tenantId,\n+            final Tenant tenantObj,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(\n+            final String tenantId,\n+            final Tenant newTenant,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject updateTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(\n+                                \"conflict updating tenant [{}]. An existing tenant uses a certificate authority with the same Subject DN\",\n+                                tenantId,\n+                                error);\n+                        TracingHelper.logError(span,\n+                                \"an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY4Mjc1Ng==", "bodyText": "Can be merged. The structure is now obsolete due to refactoring.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420682756", "createdAt": "2020-05-06T10:15:13Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final MongoClient mongoClient;\n+    private final MongoDbCallExecutor mongoDbCallExecutor;\n+    private final MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Creates a new service for configuration properties.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param mongoClient The client for accessing the Mongo DB instance.\n+     * @param config The properties for configuring this service.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public MongoDbBasedTenantService(\n+            final Vertx vertx,\n+            final MongoClient mongoClient,\n+            final MongoDbBasedTenantsConfigProperties config) {\n+\n+        Objects.requireNonNull(vertx);\n+        Objects.requireNonNull(mongoClient);\n+        Objects.requireNonNull(config);\n+\n+        this.mongoClient = mongoClient;\n+        this.mongoDbCallExecutor = new MongoDbCallExecutor(vertx, mongoClient);\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(\n+            final String tenantId,\n+            final Tenant tenantObj,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(\n+            final String tenantId,\n+            final Tenant newTenant,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject updateTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(\n+                                \"conflict updating tenant [{}]. An existing tenant uses a certificate authority with the same Subject DN\",\n+                                tenantId,\n+                                error);\n+                        TracingHelper.logError(span,\n+                                \"an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyNTgxNw=="}, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODQ5MzM2OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODozMjowNVrOGRJAAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMTowNTo0OVrOGR5iKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyNjQzNQ==", "bodyText": "I don't think this is correct, as in case of a null value in the subjectDN parameter, the result would not be a NPE, but a proper result with HTTP_BAD_REQUEST.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420626435", "createdAt": "2020-05-06T08:32:05Z", "author": {"login": "ctron"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final MongoClient mongoClient;\n+    private final MongoDbCallExecutor mongoDbCallExecutor;\n+    private final MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Creates a new service for configuration properties.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param mongoClient The client for accessing the Mongo DB instance.\n+     * @param config The properties for configuring this service.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public MongoDbBasedTenantService(\n+            final Vertx vertx,\n+            final MongoClient mongoClient,\n+            final MongoDbBasedTenantsConfigProperties config) {\n+\n+        Objects.requireNonNull(vertx);\n+        Objects.requireNonNull(mongoClient);\n+        Objects.requireNonNull(config);\n+\n+        this.mongoClient = mongoClient;\n+        this.mongoDbCallExecutor = new MongoDbCallExecutor(vertx, mongoClient);\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(\n+            final String tenantId,\n+            final Tenant tenantObj,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(\n+            final String tenantId,\n+            final Tenant newTenant,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject updateTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(\n+                                \"conflict updating tenant [{}]. An existing tenant uses a certificate authority with the same Subject DN\",\n+                                tenantId,\n+                                error);\n+                        TracingHelper.logError(span,\n+                                \"an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 270}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY4MTY0Mg==", "bodyText": "I have oriented myself to another file base service, but throwing NPE makes little sense when it is checked afterwards.\nIn the inheriting method get, NPE is expected to be present when subjectDn == null. Should HTTP_BAD_REQUEST be returned at this point?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420681642", "createdAt": "2020-05-06T10:13:02Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final MongoClient mongoClient;\n+    private final MongoDbCallExecutor mongoDbCallExecutor;\n+    private final MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Creates a new service for configuration properties.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param mongoClient The client for accessing the Mongo DB instance.\n+     * @param config The properties for configuring this service.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public MongoDbBasedTenantService(\n+            final Vertx vertx,\n+            final MongoClient mongoClient,\n+            final MongoDbBasedTenantsConfigProperties config) {\n+\n+        Objects.requireNonNull(vertx);\n+        Objects.requireNonNull(mongoClient);\n+        Objects.requireNonNull(config);\n+\n+        this.mongoClient = mongoClient;\n+        this.mongoDbCallExecutor = new MongoDbCallExecutor(vertx, mongoClient);\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(\n+            final String tenantId,\n+            final Tenant tenantObj,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(\n+            final String tenantId,\n+            final Tenant newTenant,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject updateTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(\n+                                \"conflict updating tenant [{}]. An existing tenant uses a certificate authority with the same Subject DN\",\n+                                tenantId,\n+                                error);\n+                        TracingHelper.logError(span,\n+                                \"an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyNjQzNQ=="}, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 270}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY5MDIzMw==", "bodyText": "I think it should either be a NPE or HTTP_BAD_REQUEST but not both. And the javadoc should document what is happening.\nMy personal preference would be to throw a ServiceInvocationException with the status code of HTTP_BAD_REQUEST. This would give you information what happened, and a stack trace of where.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420690233", "createdAt": "2020-05-06T10:30:05Z", "author": {"login": "ctron"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final MongoClient mongoClient;\n+    private final MongoDbCallExecutor mongoDbCallExecutor;\n+    private final MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Creates a new service for configuration properties.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param mongoClient The client for accessing the Mongo DB instance.\n+     * @param config The properties for configuring this service.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public MongoDbBasedTenantService(\n+            final Vertx vertx,\n+            final MongoClient mongoClient,\n+            final MongoDbBasedTenantsConfigProperties config) {\n+\n+        Objects.requireNonNull(vertx);\n+        Objects.requireNonNull(mongoClient);\n+        Objects.requireNonNull(config);\n+\n+        this.mongoClient = mongoClient;\n+        this.mongoDbCallExecutor = new MongoDbCallExecutor(vertx, mongoClient);\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(\n+            final String tenantId,\n+            final Tenant tenantObj,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(\n+            final String tenantId,\n+            final Tenant newTenant,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject updateTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(\n+                                \"conflict updating tenant [{}]. An existing tenant uses a certificate authority with the same Subject DN\",\n+                                tenantId,\n+                                error);\n+                        TracingHelper.logError(span,\n+                                \"an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyNjQzNQ=="}, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 270}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxOTEwOA==", "bodyText": "I suggest to remove the NPE checks and return HTTP_BAD_REQUEST for all methods that inherit from TenantService.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420919108", "createdAt": "2020-05-06T16:18:14Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final MongoClient mongoClient;\n+    private final MongoDbCallExecutor mongoDbCallExecutor;\n+    private final MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Creates a new service for configuration properties.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param mongoClient The client for accessing the Mongo DB instance.\n+     * @param config The properties for configuring this service.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public MongoDbBasedTenantService(\n+            final Vertx vertx,\n+            final MongoClient mongoClient,\n+            final MongoDbBasedTenantsConfigProperties config) {\n+\n+        Objects.requireNonNull(vertx);\n+        Objects.requireNonNull(mongoClient);\n+        Objects.requireNonNull(config);\n+\n+        this.mongoClient = mongoClient;\n+        this.mongoDbCallExecutor = new MongoDbCallExecutor(vertx, mongoClient);\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(\n+            final String tenantId,\n+            final Tenant tenantObj,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(\n+            final String tenantId,\n+            final Tenant newTenant,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject updateTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(\n+                                \"conflict updating tenant [{}]. An existing tenant uses a certificate authority with the same Subject DN\",\n+                                tenantId,\n+                                error);\n+                        TracingHelper.logError(span,\n+                                \"an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyNjQzNQ=="}, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 270}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQyMTYxMA==", "bodyText": "Further discussed in #1845 (comment)", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r421421610", "createdAt": "2020-05-07T11:05:49Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final MongoClient mongoClient;\n+    private final MongoDbCallExecutor mongoDbCallExecutor;\n+    private final MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Creates a new service for configuration properties.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param mongoClient The client for accessing the Mongo DB instance.\n+     * @param config The properties for configuring this service.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public MongoDbBasedTenantService(\n+            final Vertx vertx,\n+            final MongoClient mongoClient,\n+            final MongoDbBasedTenantsConfigProperties config) {\n+\n+        Objects.requireNonNull(vertx);\n+        Objects.requireNonNull(mongoClient);\n+        Objects.requireNonNull(config);\n+\n+        this.mongoClient = mongoClient;\n+        this.mongoDbCallExecutor = new MongoDbCallExecutor(vertx, mongoClient);\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(\n+            final String tenantId,\n+            final Tenant tenantObj,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(\n+            final String tenantId,\n+            final Tenant newTenant,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject updateTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(\n+                                \"conflict updating tenant [{}]. An existing tenant uses a certificate authority with the same Subject DN\",\n+                                tenantId,\n+                                error);\n+                        TracingHelper.logError(span,\n+                                \"an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyNjQzNQ=="}, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 270}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODUwMjc4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODozNDo0OFrOGRJF7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDoxNTo1OVrOGRMdcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyNzk0OQ==", "bodyText": "While this would throw a NPE, the call to getForCertificateAuthority would return HTTP_BAD_REQUEST. I think it is confusing.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420627949", "createdAt": "2020-05-06T08:34:48Z", "author": {"login": "ctron"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final MongoClient mongoClient;\n+    private final MongoDbCallExecutor mongoDbCallExecutor;\n+    private final MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Creates a new service for configuration properties.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param mongoClient The client for accessing the Mongo DB instance.\n+     * @param config The properties for configuring this service.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public MongoDbBasedTenantService(\n+            final Vertx vertx,\n+            final MongoClient mongoClient,\n+            final MongoDbBasedTenantsConfigProperties config) {\n+\n+        Objects.requireNonNull(vertx);\n+        Objects.requireNonNull(mongoClient);\n+        Objects.requireNonNull(config);\n+\n+        this.mongoClient = mongoClient;\n+        this.mongoDbCallExecutor = new MongoDbCallExecutor(vertx, mongoClient);\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(\n+            final String tenantId,\n+            final Tenant tenantObj,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(\n+            final String tenantId,\n+            final Tenant newTenant,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject updateTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(\n+                                \"conflict updating tenant [{}]. An existing tenant uses a certificate authority with the same Subject DN\",\n+                                tenantId,\n+                                error);\n+                        TracingHelper.logError(span,\n+                                \"an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY4MzEyMw==", "bodyText": "see #1845 (comment)", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420683123", "createdAt": "2020-05-06T10:15:59Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final MongoClient mongoClient;\n+    private final MongoDbCallExecutor mongoDbCallExecutor;\n+    private final MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Creates a new service for configuration properties.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param mongoClient The client for accessing the Mongo DB instance.\n+     * @param config The properties for configuring this service.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public MongoDbBasedTenantService(\n+            final Vertx vertx,\n+            final MongoClient mongoClient,\n+            final MongoDbBasedTenantsConfigProperties config) {\n+\n+        Objects.requireNonNull(vertx);\n+        Objects.requireNonNull(mongoClient);\n+        Objects.requireNonNull(config);\n+\n+        this.mongoClient = mongoClient;\n+        this.mongoDbCallExecutor = new MongoDbCallExecutor(vertx, mongoClient);\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(\n+            final String tenantId,\n+            final Tenant tenantObj,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(\n+            final String tenantId,\n+            final Tenant newTenant,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject updateTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(\n+                                \"conflict updating tenant [{}]. An existing tenant uses a certificate authority with the same Subject DN\",\n+                                tenantId,\n+                                error);\n+                        TracingHelper.logError(span,\n+                                \"an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyNzk0OQ=="}, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 249}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODUxMzIzOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODozODowNVrOGRJM5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDowNjowOVrOGRMKhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyOTczNQ==", "bodyText": "I think we have the convention of lower camel case names for parameters.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420629735", "createdAt": "2020-05-06T08:38:05Z", "author": {"login": "ctron"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -44,6 +50,19 @@ public static MongoDbDocumentBuilder forTenantId(final String tenant) {\n         return builder.withTenantId(tenant);\n     }\n \n+    /**\n+     * Creates a new builder for a given subject DN.\n+     *\n+     * @param SubjectDn The subject DN to add to the document.\n+     * @return The new document builder.\n+     * @throws NullPointerException if SubjectDn is {@code null}.\n+     */\n+    public static MongoDbDocumentBuilder forSubjectDN(final String SubjectDn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY3ODI3Ng==", "bodyText": "fixed", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420678276", "createdAt": "2020-05-06T10:06:09Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -44,6 +50,19 @@ public static MongoDbDocumentBuilder forTenantId(final String tenant) {\n         return builder.withTenantId(tenant);\n     }\n \n+    /**\n+     * Creates a new builder for a given subject DN.\n+     *\n+     * @param SubjectDn The subject DN to add to the document.\n+     * @return The new document builder.\n+     * @throws NullPointerException if SubjectDn is {@code null}.\n+     */\n+    public static MongoDbDocumentBuilder forSubjectDN(final String SubjectDn) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyOTczNQ=="}, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODUyMzMwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODo0MTowNlrOGRJTmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDowNjowNlrOGRMKYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMTQ0OA==", "bodyText": "Parameter case.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420631448", "createdAt": "2020-05-06T08:41:06Z", "author": {"login": "ctron"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -80,6 +99,17 @@ public MongoDbDocumentBuilder withDeviceId(final String deviceId) {\n         return this;\n     }\n \n+    /**\n+     * Sets the json object with the given subject DN.\n+     *\n+     * @param SubjectDn The subject DN.\n+     * @return a reference to this for fluent use.\n+     */\n+    public MongoDbDocumentBuilder withCa(final String SubjectDn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY3ODI0MQ==", "bodyText": "fixed", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420678241", "createdAt": "2020-05-06T10:06:06Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -80,6 +99,17 @@ public MongoDbDocumentBuilder withDeviceId(final String deviceId) {\n         return this;\n     }\n \n+    /**\n+     * Sets the json object with the given subject DN.\n+     *\n+     * @param SubjectDn The subject DN.\n+     * @return a reference to this for fluent use.\n+     */\n+    public MongoDbDocumentBuilder withCa(final String SubjectDn) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMTQ0OA=="}, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODUyOTIwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODo0Mjo0M1rOGRJXUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODozMjowM1rOGUnFKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMjQwMQ==", "bodyText": "I don't understand the concept of this class. Why not simply create static methods, returning JsonObject, looking at the rest of the locations, this is all what is required.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420632401", "createdAt": "2020-05-06T08:42:43Z", "author": {"login": "ctron"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -25,6 +27,10 @@\n  */\n public final class MongoDbDocumentBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY3ODE0Nw==", "bodyText": "The methods in this class to initialize the JsonObject (e.g.: forTenantId )query are already static.\nI think the main purpose of the class is to simplify the handling of jsonObject and property key constants.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420678147", "createdAt": "2020-05-06T10:05:56Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -25,6 +27,10 @@\n  */\n public final class MongoDbDocumentBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMjQwMQ=="}, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY4NzY3Nw==", "bodyText": "To me this makes it look more complicated. You have a static method, which creates and instance of an object, which fills a JSON object. Later on you ditch the object, and only use the JSON object.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420687677", "createdAt": "2020-05-06T10:24:59Z", "author": {"login": "ctron"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -25,6 +27,10 @@\n  */\n public final class MongoDbDocumentBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMjQwMQ=="}, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc0NDgyOA==", "bodyText": "When just a JsonObject is returned, we lose the abillty to make easy to read query creation chains:\nfinal JsonObject updateTenantQuery = MongoDbDocumentBuilder\n    .forVersion(resourceVersion)\n    .withTenantId(tenantId)\n    .document();\n\nwould change to e.g.:\nJsonObject updateTenantQuery = new JsonObject();\nif (resourceVersion.isPresent()) {\n    updateTenantQuery = MongoDbDocumentBuilder.withVersion(updateTenantQuery, tenantId);\n}\nupdateTenantQuery = MongoDbDocumentBuilder.withTenantId(updateTenantQuery, resourceVersion);", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420744828", "createdAt": "2020-05-06T12:18:06Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -25,6 +27,10 @@\n  */\n public final class MongoDbDocumentBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMjQwMQ=="}, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjgzMjYyNA==", "bodyText": "Yes, but you have withTenantId working on the instance, and a static forTenantId which only wraps around withTenantId. I would propose to remove one level of wrapping:\nfinal JsonObject updateTenantQuery = MongoDbDocumentBuilder\n    .builder()\n    .withVersion(resourceVersion)\n    .withTenantId(tenantId)\n    .document();\nThat would allow you drop all (duplicate) static wrapper methods, and still use chained method invocations.\nOr inline the with methods, and focus on the static for methods. Having both doesn't make sense to me.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r422832624", "createdAt": "2020-05-11T07:20:13Z", "author": {"login": "ctron"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -25,6 +27,10 @@\n  */\n public final class MongoDbDocumentBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMjQwMQ=="}, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg4MTY0MQ==", "bodyText": "To me it looks reasonable to have both the factory methods for creating the instance based on a resource version or tenant ID as well as the methods for adding additional properties. That way you only need .forTenantId(\"tenant\").withVersion(\"1\") instead of .builder().withTenantId(\"tenant\").withVersion(\"1\").\nI don't see a problem here.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r422881641", "createdAt": "2020-05-11T08:46:14Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -25,6 +27,10 @@\n  */\n public final class MongoDbDocumentBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMjQwMQ=="}, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI2NTAwMw==", "bodyText": "I see the arguments from @ctron, but I find the old implementation in the services is more readable.\nIMHO the problem is that an optional version can only be added conditionally withVersion(), which expands the code.\ndeleteDeviceQuery =\n  resourceVersion.map(v -> MongoDbDocumentBuilder.builder().withVersion(v))\n  .orElse(MongoDbDocumentBuilder.builder())\n    .withTenantId(tenantId)\n    .withDeviceId(deviceId)\n    .document();\n\nMy suggestion would be to remove the factory for* methods, as @ctron has suggested to simplify MongoDbDocumentBuilder.\nIn case of an optional version, I would introduce a new method withOptionalVersion().", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r424265003", "createdAt": "2020-05-13T08:32:03Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -25,6 +27,10 @@\n  */\n public final class MongoDbDocumentBuilder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMjQwMQ=="}, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxODUzODY5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQwODo0NTozMFrOGRJdlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwNzoyMjo0MVrOGTPu6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzNDAwNw==", "bodyText": "Sorry, but I don't know much about MongoDB. I think it would help documenting a little bit, what this is expected to do.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r420634007", "createdAt": "2020-05-06T08:45:30Z", "author": {"login": "ctron"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final MongoClient mongoClient;\n+    private final MongoDbCallExecutor mongoDbCallExecutor;\n+    private final MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Creates a new service for configuration properties.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param mongoClient The client for accessing the Mongo DB instance.\n+     * @param config The properties for configuring this service.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public MongoDbBasedTenantService(\n+            final Vertx vertx,\n+            final MongoClient mongoClient,\n+            final MongoDbBasedTenantsConfigProperties config) {\n+\n+        Objects.requireNonNull(vertx);\n+        Objects.requireNonNull(mongoClient);\n+        Objects.requireNonNull(config);\n+\n+        this.mongoClient = mongoClient;\n+        this.mongoDbCallExecutor = new MongoDbCallExecutor(vertx, mongoClient);\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjgzMzg5OA==", "bodyText": "I was thinking more about \"why\" you do things like that. Because I already assume that new IndexOptions().unique(true) will create a \"unique index\". So I do understand \"what\" you do, the question \"why\" and \"why this way\".", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r422833898", "createdAt": "2020-05-11T07:22:41Z", "author": {"login": "ctron"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final MongoClient mongoClient;\n+    private final MongoDbCallExecutor mongoDbCallExecutor;\n+    private final MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Creates a new service for configuration properties.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param mongoClient The client for accessing the Mongo DB instance.\n+     * @param config The properties for configuring this service.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public MongoDbBasedTenantService(\n+            final Vertx vertx,\n+            final MongoClient mongoClient,\n+            final MongoDbBasedTenantsConfigProperties config) {\n+\n+        Objects.requireNonNull(vertx);\n+        Objects.requireNonNull(mongoClient);\n+        Objects.requireNonNull(config);\n+\n+        this.mongoClient = mongoClient;\n+        this.mongoDbCallExecutor = new MongoDbCallExecutor(vertx, mongoClient);\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzNDAwNw=="}, "originalCommit": {"oid": "213fef328f68b1a01fa668ebac9ba4e049702b92"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzEwMTk1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/tenant/TenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTowNDoyN1rOGR1UEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDo1ODo0MVrOGR5T5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MjQ2Ng==", "bodyText": "This is a Java interface defining the behavior of implementations. The existence of required parameters passed in via a remoting protocol is the responsibility of the HTTP and/or AMQP endpoints that sit in front of the Java based implementation of this service interface. Thus it makes perfect sense that the methods of this interface require the passed in parameters to not be null. Please revert all corresponding changes.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r421352466", "createdAt": "2020-05-07T09:04:27Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/tenant/TenantService.java", "diffHunk": "@@ -86,9 +87,9 @@\n      *             <ul>\n      *             <li><em>200 OK</em> if a tenant with a matching trusted certificate authority exists.\n      *             The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *             <li><em>400 Bad Request</em> if the certificate authority is missing.</li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5c093df55df16e51e2e95fd10618406aa9a34c"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQxNzk1Nw==", "bodyText": "Okay, I had derived the response from the FileBasedTenantService#L320-L333.\nThanks for clarifying.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r421417957", "createdAt": "2020-05-07T10:58:41Z", "author": {"login": "ko-j"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/service/tenant/TenantService.java", "diffHunk": "@@ -86,9 +87,9 @@\n      *             <ul>\n      *             <li><em>200 OK</em> if a tenant with a matching trusted certificate authority exists.\n      *             The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *             <li><em>400 Bad Request</em> if the certificate authority is missing.</li>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MjQ2Ng=="}, "originalCommit": {"oid": "ce5c093df55df16e51e2e95fd10618406aa9a34c"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzEwNzYwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/ApplicationConfig.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTowNjowOFrOGR1X2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDo1ODo1NVrOGR5UXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MzQzNQ==", "bodyText": "please follow the approach taken for the RegistrationService and create a (private) instance in the TenantService implementation's constructor.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r421353435", "createdAt": "2020-05-07T09:06:08Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/ApplicationConfig.java", "diffHunk": "@@ -177,6 +184,17 @@ public MongoClient mongoClient() {\n         return MongoClient.createShared(vertx(), mongoDbConfigProperties().getMongoClientConfig());\n     }\n \n+    /**\n+     * Gets a {@link MongoDbCallExecutor} instance containing helper methods for mongodb interaction.\n+     *\n+     * @return An instance of the helper class {@link MongoDbCallExecutor}.\n+     */\n+    @Bean\n+    @Scope(\"prototype\")\n+    public MongoDbCallExecutor mongoDBCallExecutor() {\n+        return new MongoDbCallExecutor(vertx(), mongoClient());\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5c093df55df16e51e2e95fd10618406aa9a34c"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQxODA3OQ==", "bodyText": "removed", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r421418079", "createdAt": "2020-05-07T10:58:55Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/ApplicationConfig.java", "diffHunk": "@@ -177,6 +184,17 @@ public MongoClient mongoClient() {\n         return MongoClient.createShared(vertx(), mongoDbConfigProperties().getMongoClientConfig());\n     }\n \n+    /**\n+     * Gets a {@link MongoDbCallExecutor} instance containing helper methods for mongodb interaction.\n+     *\n+     * @return An instance of the helper class {@link MongoDbCallExecutor}.\n+     */\n+    @Bean\n+    @Scope(\"prototype\")\n+    public MongoDbCallExecutor mongoDBCallExecutor() {\n+        return new MongoDbCallExecutor(vertx(), mongoClient());\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1MzQzNQ=="}, "originalCommit": {"oid": "ce5c093df55df16e51e2e95fd10618406aa9a34c"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzEzOTc4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOToxNDoyNFrOGR1sIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMTowMzoyMFrOGR5dGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1ODYyNA==", "bodyText": "Objects.requireNonNull(subjectDn)", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r421358624", "createdAt": "2020-05-07T09:14:24Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final MongoClient mongoClient;\n+    private final MongoDbCallExecutor mongoDbCallExecutor;\n+    private final MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Creates a new service for configuration properties.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param mongoClient The client for accessing the Mongo DB instance.\n+     * @param config The properties for configuring this service.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public MongoDbBasedTenantService(\n+            final Vertx vertx,\n+            final MongoClient mongoClient,\n+            final MongoDbBasedTenantsConfigProperties config) {\n+\n+        Objects.requireNonNull(vertx);\n+        Objects.requireNonNull(mongoClient);\n+        Objects.requireNonNull(config);\n+\n+        this.mongoClient = mongoClient;\n+        this.mongoDbCallExecutor = new MongoDbCallExecutor(vertx, mongoClient);\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        // initialize indexes\n+        return CompositeFuture.all(\n+                // add unique index for the tenant id\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                // add unique index for subject-dn inside field of trusted-ca inside tenant object\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        // add unique index predicate for tenants with field of trusted-ca inside tenant object\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(\n+            final String tenantId,\n+            final Tenant tenantObj,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(\n+            final String tenantId,\n+            final Tenant newTenant,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject updateTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(\n+                                \"conflict updating tenant [{}]. An existing tenant uses a certificate authority with the same Subject DN\",\n+                                tenantId,\n+                                error);\n+                        TracingHelper.logError(span,\n+                                \"an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(span);\n+\n+        if (tenantId == null) {\n+            TracingHelper.logError(span, \"missing tenantId\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        }\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(span);\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5c093df55df16e51e2e95fd10618406aa9a34c"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQyMDMxNA==", "bodyText": "done.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r421420314", "createdAt": "2020-05-07T11:03:20Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final MongoClient mongoClient;\n+    private final MongoDbCallExecutor mongoDbCallExecutor;\n+    private final MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Creates a new service for configuration properties.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param mongoClient The client for accessing the Mongo DB instance.\n+     * @param config The properties for configuring this service.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public MongoDbBasedTenantService(\n+            final Vertx vertx,\n+            final MongoClient mongoClient,\n+            final MongoDbBasedTenantsConfigProperties config) {\n+\n+        Objects.requireNonNull(vertx);\n+        Objects.requireNonNull(mongoClient);\n+        Objects.requireNonNull(config);\n+\n+        this.mongoClient = mongoClient;\n+        this.mongoDbCallExecutor = new MongoDbCallExecutor(vertx, mongoClient);\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        // initialize indexes\n+        return CompositeFuture.all(\n+                // add unique index for the tenant id\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                // add unique index for subject-dn inside field of trusted-ca inside tenant object\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        // add unique index predicate for tenants with field of trusted-ca inside tenant object\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(\n+            final String tenantId,\n+            final Tenant tenantObj,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(\n+            final String tenantId,\n+            final Tenant newTenant,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject updateTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(\n+                                \"conflict updating tenant [{}]. An existing tenant uses a certificate authority with the same Subject DN\",\n+                                tenantId,\n+                                error);\n+                        TracingHelper.logError(span,\n+                                \"an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(span);\n+\n+        if (tenantId == null) {\n+            TracingHelper.logError(span, \"missing tenantId\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        }\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(span);\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1ODYyNA=="}, "originalCommit": {"oid": "ce5c093df55df16e51e2e95fd10618406aa9a34c"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMzE0MTgwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOToxNDo1OVrOGR1tgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMTowMzoyM1rOGR5dNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1ODk3Ng==", "bodyText": "Objects.requireNonNull(tenantId)", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r421358976", "createdAt": "2020-05-07T09:14:59Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final MongoClient mongoClient;\n+    private final MongoDbCallExecutor mongoDbCallExecutor;\n+    private final MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Creates a new service for configuration properties.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param mongoClient The client for accessing the Mongo DB instance.\n+     * @param config The properties for configuring this service.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public MongoDbBasedTenantService(\n+            final Vertx vertx,\n+            final MongoClient mongoClient,\n+            final MongoDbBasedTenantsConfigProperties config) {\n+\n+        Objects.requireNonNull(vertx);\n+        Objects.requireNonNull(mongoClient);\n+        Objects.requireNonNull(config);\n+\n+        this.mongoClient = mongoClient;\n+        this.mongoDbCallExecutor = new MongoDbCallExecutor(vertx, mongoClient);\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        // initialize indexes\n+        return CompositeFuture.all(\n+                // add unique index for the tenant id\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                // add unique index for subject-dn inside field of trusted-ca inside tenant object\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        // add unique index predicate for tenants with field of trusted-ca inside tenant object\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(\n+            final String tenantId,\n+            final Tenant tenantObj,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(\n+            final String tenantId,\n+            final Tenant newTenant,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject updateTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(\n+                                \"conflict updating tenant [{}]. An existing tenant uses a certificate authority with the same Subject DN\",\n+                                tenantId,\n+                                error);\n+                        TracingHelper.logError(span,\n+                                \"an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(span);\n+\n+        if (tenantId == null) {\n+            TracingHelper.logError(span, \"missing tenantId\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce5c093df55df16e51e2e95fd10618406aa9a34c"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQyMDM0MA==", "bodyText": "done.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r421420340", "createdAt": "2020-05-07T11:03:23Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final MongoClient mongoClient;\n+    private final MongoDbCallExecutor mongoDbCallExecutor;\n+    private final MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Creates a new service for configuration properties.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param mongoClient The client for accessing the Mongo DB instance.\n+     * @param config The properties for configuring this service.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public MongoDbBasedTenantService(\n+            final Vertx vertx,\n+            final MongoClient mongoClient,\n+            final MongoDbBasedTenantsConfigProperties config) {\n+\n+        Objects.requireNonNull(vertx);\n+        Objects.requireNonNull(mongoClient);\n+        Objects.requireNonNull(config);\n+\n+        this.mongoClient = mongoClient;\n+        this.mongoDbCallExecutor = new MongoDbCallExecutor(vertx, mongoClient);\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        // initialize indexes\n+        return CompositeFuture.all(\n+                // add unique index for the tenant id\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                // add unique index for subject-dn inside field of trusted-ca inside tenant object\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        // add unique index predicate for tenants with field of trusted-ca inside tenant object\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(\n+            final String tenantId,\n+            final Tenant tenantObj,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(\n+            final String tenantId,\n+            final Tenant newTenant,\n+            final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject updateTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(\n+                                \"conflict updating tenant [{}]. An existing tenant uses a certificate authority with the same Subject DN\",\n+                                tenantId,\n+                                error);\n+                        TracingHelper.logError(span,\n+                                \"an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isModificationEnabled(config)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = MongoDbDocumentBuilder.forVersion(resourceVersion)\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(span);\n+\n+        if (tenantId == null) {\n+            TracingHelper.logError(span, \"missing tenantId\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1ODk3Ng=="}, "originalCommit": {"oid": "ce5c093df55df16e51e2e95fd10618406aa9a34c"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NjM4NTI5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwODozODo0M1rOGVR4lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQwNzo1MjowMlrOGV6QRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk2NjI5Mg==", "bodyText": "This field is used only within this class and it should be private.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r424966292", "createdAt": "2020-05-14T08:38:43Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -27,6 +27,10 @@\n  */\n public final class MongoDbDocumentBuilder {\n \n+    public static final String TENANT_TRUSTED_CA_SUBJECT_PATH = String.format(\"%s.%s.%s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5c6e71440358a658be2a594e963e78618c8d155"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYyNzcxNg==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r425627716", "createdAt": "2020-05-15T07:52:02Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -27,6 +27,10 @@\n  */\n public final class MongoDbDocumentBuilder {\n \n+    public static final String TENANT_TRUSTED_CA_SUBJECT_PATH = String.format(\"%s.%s.%s\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk2NjI5Mg=="}, "originalCommit": {"oid": "a5c6e71440358a658be2a594e963e78618c8d155"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTY0MDg5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/Application.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwOTo1MToxMFrOF5NS8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODozNTozMVrOGALL5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzMDk5NQ==", "bodyText": "please put back annotation on their own line.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395530995", "createdAt": "2020-03-20T09:51:10Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/Application.java", "diffHunk": "@@ -68,8 +78,7 @@ public void setHealthCheckProviders(final List<HealthCheckProvider> healthCheckP\n \n         return super.deployVerticles().compose(ok -> {\n \n-            @SuppressWarnings(\"rawtypes\")\n-            final List<Future> futures = new LinkedList<>();\n+            @SuppressWarnings(\"rawtypes\") final List<Future> futures = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgzNjQ1Mw==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402836453", "createdAt": "2020-04-03T08:35:31Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/Application.java", "diffHunk": "@@ -68,8 +78,7 @@ public void setHealthCheckProviders(final List<HealthCheckProvider> healthCheckP\n \n         return super.deployVerticles().compose(ok -> {\n \n-            @SuppressWarnings(\"rawtypes\")\n-            final List<Future> futures = new LinkedList<>();\n+            @SuppressWarnings(\"rawtypes\") final List<Future> futures = new LinkedList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzMDk5NQ=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTY1MTIwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/ApplicationConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwOTo1NDozN1rOF5NZ8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODozNjo1OVrOGALQpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzMjc4Nw==", "bodyText": "Could you please make this javadoc in sync with the serviceProperties()?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395532787", "createdAt": "2020-03-20T09:54:37Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/ApplicationConfig.java", "diffHunk": "@@ -259,6 +259,17 @@ public MongoDbBasedRegistrationConfigProperties serviceProperties() {\n         return new MongoDbBasedRegistrationConfigProperties();\n     }\n \n+    /**\n+     * Gets properties for the hono tenant mongodb service.\n+     *\n+     * @return The properties.\n+     */\n+    @Bean\n+    @ConfigurationProperties(prefix = \"hono.tenant.svc\")\n+    public MongoDbBasedTenantsConfigProperties tenantsProperties() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgzNzY3MQ==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402837671", "createdAt": "2020-04-03T08:36:59Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/ApplicationConfig.java", "diffHunk": "@@ -259,6 +259,17 @@ public MongoDbBasedRegistrationConfigProperties serviceProperties() {\n         return new MongoDbBasedRegistrationConfigProperties();\n     }\n \n+    /**\n+     * Gets properties for the hono tenant mongodb service.\n+     *\n+     * @return The properties.\n+     */\n+    @Bean\n+    @ConfigurationProperties(prefix = \"hono.tenant.svc\")\n+    public MongoDbBasedTenantsConfigProperties tenantsProperties() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzMjc4Nw=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTY1MjQ2OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/MongoDbBasedTenantBackend.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwOTo1NTowM1rOF5Na0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMTo0MDozNlrOGAR2UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzMzAwOQ==", "bodyText": "This annotation could be removed. No need for it.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395533009", "createdAt": "2020-03-20T09:55:03Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/MongoDbBasedTenantBackend.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb;\n+\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.service.MongoDbBasedTenantService;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantBackend;\n+import org.eclipse.hono.util.TenantResult;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Repository;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Verticle;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A tenant backend for a mongodb based of device registry.\n+ */\n+@Repository\n+@Qualifier(\"backend\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\", matchIfMissing = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk0NTYxNw==", "bodyText": "done.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402945617", "createdAt": "2020-04-03T11:40:36Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/MongoDbBasedTenantBackend.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb;\n+\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.service.MongoDbBasedTenantService;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantBackend;\n+import org.eclipse.hono.util.TenantResult;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Repository;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Verticle;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A tenant backend for a mongodb based of device registry.\n+ */\n+@Repository\n+@Qualifier(\"backend\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\", matchIfMissing = true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzMzAwOQ=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTY1OTYwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/MongoDbBasedTenantBackend.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwOTo1NzoyNVrOF5NfbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMTo0MDo0NFrOGAR2hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzNDE4OA==", "bodyText": "Could you update the javadoc with more info? You could refer to the MongoDbBasedDeviceBackend", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395534188", "createdAt": "2020-03-20T09:57:25Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/MongoDbBasedTenantBackend.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb;\n+\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.service.MongoDbBasedTenantService;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantBackend;\n+import org.eclipse.hono.util.TenantResult;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Repository;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Verticle;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A tenant backend for a mongodb based of device registry.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk0NTY2OA==", "bodyText": "done.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402945668", "createdAt": "2020-04-03T11:40:44Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/MongoDbBasedTenantBackend.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb;\n+\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.service.MongoDbBasedTenantService;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantBackend;\n+import org.eclipse.hono.util.TenantResult;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Repository;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Verticle;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A tenant backend for a mongodb based of device registry.\n+ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzNDE4OA=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTY3ODQ3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/MongoDbConfigProperties.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMDowNDoyM1rOF5NsGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNToxMzoyMVrOGIZhBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzNzQzMg==", "bodyText": "There is already a MongoDbConfigProperties exists in org.eclipse.hono.deviceregistry.mongodb.config. You could remove this and make use of that.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395537432", "createdAt": "2020-03-20T10:04:23Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/MongoDbConfigProperties.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A POJO for configuring MongoDB properties used by the\n+ * MongoDbBasedRegistrationService.\n+ */\n+@SuppressWarnings(\"unused\")\n+public class MongoDbConfigProperties {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1OTcyMQ==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r411459721", "createdAt": "2020-04-20T15:13:13Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/MongoDbConfigProperties.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A POJO for configuring MongoDB properties used by the\n+ * MongoDbBasedRegistrationService.\n+ */\n+@SuppressWarnings(\"unused\")\n+public class MongoDbConfigProperties {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzNzQzMg=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1OTg0NA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r411459844", "createdAt": "2020-04-20T15:13:21Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/MongoDbConfigProperties.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A POJO for configuring MongoDB properties used by the\n+ * MongoDbBasedRegistrationService.\n+ */\n+@SuppressWarnings(\"unused\")\n+public class MongoDbConfigProperties {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUzNzQzMg=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTcwMzkyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/BaseDto.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMDoxMzo0MlrOF5N9DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMTo0MjoyN1rOGAR5mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0MTc3Mw==", "bodyText": "Is there any specific reason why you removed abstract?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395541773", "createdAt": "2020-03-20T10:13:42Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/BaseDto.java", "diffHunk": "@@ -27,7 +27,7 @@\n  */\n @JsonIgnoreProperties(ignoreUnknown = true)\n @JsonInclude(JsonInclude.Include.NON_NULL)\n-public abstract class BaseDto {\n+public class BaseDto {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU4ODAyMg==", "bodyText": "BaseDto is needed for the generalized use of getVersion in isVersionEqualCurrentVersionOrNotSet", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395588022", "createdAt": "2020-03-20T11:54:17Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/BaseDto.java", "diffHunk": "@@ -27,7 +27,7 @@\n  */\n @JsonIgnoreProperties(ignoreUnknown = true)\n @JsonInclude(JsonInclude.Include.NON_NULL)\n-public abstract class BaseDto {\n+public class BaseDto {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0MTc3Mw=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgzMjczNw==", "bodyText": "As this method doesn't exist anymore, this class can be made abstract again.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402832737", "createdAt": "2020-04-03T08:31:19Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/BaseDto.java", "diffHunk": "@@ -27,7 +27,7 @@\n  */\n @JsonIgnoreProperties(ignoreUnknown = true)\n @JsonInclude(JsonInclude.Include.NON_NULL)\n-public abstract class BaseDto {\n+public class BaseDto {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0MTc3Mw=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0NzkzOA==", "bodyText": "Now needed in successor function checkResourceVersion", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402847938", "createdAt": "2020-04-03T08:48:45Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/BaseDto.java", "diffHunk": "@@ -27,7 +27,7 @@\n  */\n @JsonIgnoreProperties(ignoreUnknown = true)\n @JsonInclude(JsonInclude.Include.NON_NULL)\n-public abstract class BaseDto {\n+public class BaseDto {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0MTc3Mw=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk0NjQ1Ng==", "bodyText": "Have removed the function to be more similar to registration services. Is now abstract again.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402946456", "createdAt": "2020-04-03T11:42:27Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/BaseDto.java", "diffHunk": "@@ -27,7 +27,7 @@\n  */\n @JsonIgnoreProperties(ignoreUnknown = true)\n @JsonInclude(JsonInclude.Include.NON_NULL)\n-public abstract class BaseDto {\n+public class BaseDto {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0MTc3Mw=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTczNjg0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/DeviceDto.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMDoyNDo1OFrOF5OSZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo0OTowN1rOGAL6Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0NzIzNw==", "bodyText": "Hono code style was used and the in my understanding the formatting was correct. Could you revert back all the changes in this javadoc?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395547237", "createdAt": "2020-03-20T10:24:58Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/DeviceDto.java", "diffHunk": "@@ -42,15 +42,15 @@ public DeviceDto() {\n     }\n \n     /**\n-     * @param tenantId The tenant identifier.\n-     * @param deviceId The device identifier.\n-     * @param device The device.\n-     * @param version The version of tenant to be sent as request header.\n+     * @param tenantId  The tenant identifier.\n+     * @param deviceId  The device identifier.\n+     * @param device    The device.\n+     * @param version   The version of tenant to be sent as request header.\n      * @param updatedOn The date and time of last update.\n      * @throws NullPointerException if any of the parameters except the device are {@code null}\n      */\n     public DeviceDto(final String tenantId, final String deviceId, final Device device, final String version,\n-            final Instant updatedOn) {\n+                     final Instant updatedOn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0ODMxNQ==", "bodyText": "reverted", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402848315", "createdAt": "2020-04-03T08:49:07Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/DeviceDto.java", "diffHunk": "@@ -42,15 +42,15 @@ public DeviceDto() {\n     }\n \n     /**\n-     * @param tenantId The tenant identifier.\n-     * @param deviceId The device identifier.\n-     * @param device The device.\n-     * @param version The version of tenant to be sent as request header.\n+     * @param tenantId  The tenant identifier.\n+     * @param deviceId  The device identifier.\n+     * @param device    The device.\n+     * @param version   The version of tenant to be sent as request header.\n      * @param updatedOn The date and time of last update.\n      * @throws NullPointerException if any of the parameters except the device are {@code null}\n      */\n     public DeviceDto(final String tenantId, final String deviceId, final Device device, final String version,\n-            final Instant updatedOn) {\n+                     final Instant updatedOn) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0NzIzNw=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTc0MTgxOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/TenantDto.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMDoyNjo1MFrOF5OV3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMToyNDoxN1rOGN6d4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0ODEyNg==", "bodyText": "How about ?\n    /**\n     * Default constructor for serialisation/deserialization.\n     */", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395548126", "createdAt": "2020-03-20T10:26:50Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/TenantDto.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.model;\n+\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * A versioned and dated wrapper class for {@link Tenant}.\n+ */\n+public final class TenantDto extends BaseDto {\n+\n+    @JsonProperty(value = RegistryManagementConstants.FIELD_PAYLOAD_TENANT_ID, required = true)\n+    private String tenantId;\n+    @JsonProperty(RegistryManagementConstants.FIELD_TENANT)\n+    private Tenant tenant;\n+\n+    /**\n+     * Creates a new empty tenant dto.\n+     */\n+    public TenantDto() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0ODQyMw==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402848423", "createdAt": "2020-04-03T08:49:15Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/TenantDto.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.model;\n+\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * A versioned and dated wrapper class for {@link Tenant}.\n+ */\n+public final class TenantDto extends BaseDto {\n+\n+    @JsonProperty(value = RegistryManagementConstants.FIELD_PAYLOAD_TENANT_ID, required = true)\n+    private String tenantId;\n+    @JsonProperty(RegistryManagementConstants.FIELD_TENANT)\n+    private Tenant tenant;\n+\n+    /**\n+     * Creates a new empty tenant dto.\n+     */\n+    public TenantDto() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0ODEyNg=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MjU5NA==", "bodyText": "what is this constructor good/required for?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417242594", "createdAt": "2020-04-29T11:24:17Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/TenantDto.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.model;\n+\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * A versioned and dated wrapper class for {@link Tenant}.\n+ */\n+public final class TenantDto extends BaseDto {\n+\n+    @JsonProperty(value = RegistryManagementConstants.FIELD_PAYLOAD_TENANT_ID, required = true)\n+    private String tenantId;\n+    @JsonProperty(RegistryManagementConstants.FIELD_TENANT)\n+    private Tenant tenant;\n+\n+    /**\n+     * Creates a new empty tenant dto.\n+     */\n+    public TenantDto() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0ODEyNg=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTc0MzAwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/TenantDto.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMDoyNzoxNlrOF5OWsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo0OTo0NlrOGAL8cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0ODMzOA==", "bodyText": "Missing description.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395548338", "createdAt": "2020-03-20T10:27:16Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/TenantDto.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.model;\n+\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * A versioned and dated wrapper class for {@link Tenant}.\n+ */\n+public final class TenantDto extends BaseDto {\n+\n+    @JsonProperty(value = RegistryManagementConstants.FIELD_PAYLOAD_TENANT_ID, required = true)\n+    private String tenantId;\n+    @JsonProperty(RegistryManagementConstants.FIELD_TENANT)\n+    private Tenant tenant;\n+\n+    /**\n+     * Creates a new empty tenant dto.\n+     */\n+    public TenantDto() {\n+        // Explicit default constructor.\n+    }\n+\n+    /**\n+     * @param tenantId  The tenant id.\n+     * @param version   The version of tenant to be sent as request header.\n+     * @param tenant    The tenant.\n+     * @param updatedOn The timestamp of creation.\n+     */\n+    public TenantDto(final String tenantId, final String version, final Tenant tenant, final Instant updatedOn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0ODg4Mg==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402848882", "createdAt": "2020-04-03T08:49:46Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/TenantDto.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.model;\n+\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * A versioned and dated wrapper class for {@link Tenant}.\n+ */\n+public final class TenantDto extends BaseDto {\n+\n+    @JsonProperty(value = RegistryManagementConstants.FIELD_PAYLOAD_TENANT_ID, required = true)\n+    private String tenantId;\n+    @JsonProperty(RegistryManagementConstants.FIELD_TENANT)\n+    private Tenant tenant;\n+\n+    /**\n+     * Creates a new empty tenant dto.\n+     */\n+    public TenantDto() {\n+        // Explicit default constructor.\n+    }\n+\n+    /**\n+     * @param tenantId  The tenant id.\n+     * @param version   The version of tenant to be sent as request header.\n+     * @param tenant    The tenant.\n+     * @param updatedOn The timestamp of creation.\n+     */\n+    public TenantDto(final String tenantId, final String version, final Tenant tenant, final Instant updatedOn) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0ODMzOA=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTc1NTcyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMDozMToxOVrOF5Oeww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1MDowMVrOGAL9Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1MDQwMw==", "bodyText": "Please remove this annotation.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395550403", "createdAt": "2020-03-20T10:31:19Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0OTEyMw==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402849123", "createdAt": "2020-04-03T08:50:01Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1MDQwMw=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTc1NzI0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMDozMTo1MVrOF5OfyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1MTozOFrOGAMC7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1MDY2NQ==", "bodyText": "Please make this javadoc in sync with that of the MongoDbBasedRegistrationService.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395550665", "createdAt": "2020-03-20T10:31:51Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MDU0MA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402850540", "createdAt": "2020-04-03T08:51:38Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1MDY2NQ=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTc2MjkzOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMDozMzo0N1rOF5Ojhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1MToyOFrOGAMCXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1MTYyMg==", "bodyText": "How about making it ins sync with MongoDbBasedRegistrationService?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395551622", "createdAt": "2020-03-20T10:33:47Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYxMTU3OQ==", "bodyText": "For Line 78: Since it sets both MongoDbCallExecutor and MongoClient I found the description more suitable to describe what the method does.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395611579", "createdAt": "2020-03-20T12:44:53Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1MTYyMg=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYxODc4OA==", "bodyText": "For Line 78: Since it sets both MongoDbCallExecutor and MongoClient I found the description more suitable to describe what the method does.\n\nIncluding the mongoClient is fine. Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection. IMHO it isn't grammatically correct. How about something thing like Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395618788", "createdAt": "2020-03-20T12:59:05Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1MTYyMg=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1MDM5Ng==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402850396", "createdAt": "2020-04-03T08:51:28Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1MTYyMg=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTc2OTg4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMDozNjowNlrOF5On_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMjo1ODozMVrOF5Sorg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1Mjc2Ng==", "bodyText": "It is bit misleading as it is not the tenant configuration. How about?\n/**\n  * Sets the configuration properties for this service.\n  *\n  * @param config The configuration properties.\n  * @throws NullPointerException if the configuration is {@code null}.\n  */", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395552766", "createdAt": "2020-03-20T10:36:06Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the tenant specific configuration.\n+     *\n+     * @param configuration The tenant configuration", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTYxODQ3OA==", "bodyText": "Actually it contains tenant specific configuration, but to make it consistent across services I will change it.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395618478", "createdAt": "2020-03-20T12:58:31Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the tenant specific configuration.\n+     *\n+     * @param configuration The tenant configuration", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1Mjc2Ng=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTgxNDgwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMDo1MTo1MlrOF5PExw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzo0NjowNFrOF5UTvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU2MDEzNQ==", "bodyText": "What are you trying to do here? You are checking for tenant collection and if it exists then you return succeeded future and thereby no index is created. If no tenant collection exists, then you are creating an index which will ultimately leads to error.\nAlso tere is a discussion regarding how to deal with is going on in another PR and you can follow it there. IMHO until then could you please make it in sync with that of the device registration.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395560135", "createdAt": "2020-03-20T10:51:52Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the tenant specific configuration.\n+     *\n+     * @param configuration The tenant configuration\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties configuration) {\n+        this.config = Objects.requireNonNull(configuration);\n+    }\n+\n+    /**\n+     * Starts the service.\n+     * <p>\n+     * Finishes if a tenant collection is found and creates an indexed collection else.\n+     * </P>\n+     *\n+     * @param startPromise the startup promise\n+     */\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        final Promise<List<String>> existingCollections = Promise.promise();\n+        mongoClient.getCollections(existingCollections);\n+        existingCollections.future()\n+                .compose(successExistingCollections -> {\n+                    if (successExistingCollections.contains(getConfig().getCollectionName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0NTg4Ng==", "bodyText": "As you point out in the #1842 discussion, the check if a collection exist can be removed.\nThe creation of collection is implicit if an index is created, so no error would be caused.\nI change it to the implementation of MongoDbBasedRegistrationService.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395645886", "createdAt": "2020-03-20T13:46:04Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the tenant specific configuration.\n+     *\n+     * @param configuration The tenant configuration\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties configuration) {\n+        this.config = Objects.requireNonNull(configuration);\n+    }\n+\n+    /**\n+     * Starts the service.\n+     * <p>\n+     * Finishes if a tenant collection is found and creates an indexed collection else.\n+     * </P>\n+     *\n+     * @param startPromise the startup promise\n+     */\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        final Promise<List<String>> existingCollections = Promise.promise();\n+        mongoClient.getCollections(existingCollections);\n+        existingCollections.future()\n+                .compose(successExistingCollections -> {\n+                    if (successExistingCollections.contains(getConfig().getCollectionName())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU2MDEzNQ=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTgyMjY0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMDo1NDoyMFrOF5PJgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMDo1NDoyMFrOF5PJgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU2MTM0NQ==", "bodyText": "You could remove this, as it is just being logged. Anyway its being already checked during write operations and appropriate response is being sent back.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395561345", "createdAt": "2020-03-20T10:54:20Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the tenant specific configuration.\n+     *\n+     * @param configuration The tenant configuration\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties configuration) {\n+        this.config = Objects.requireNonNull(configuration);\n+    }\n+\n+    /**\n+     * Starts the service.\n+     * <p>\n+     * Finishes if a tenant collection is found and creates an indexed collection else.\n+     * </P>\n+     *\n+     * @param startPromise the startup promise\n+     */\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        final Promise<List<String>> existingCollections = Promise.promise();\n+        mongoClient.getCollections(existingCollections);\n+        existingCollections.future()\n+                .compose(successExistingCollections -> {\n+                    if (successExistingCollections.contains(getConfig().getCollectionName())) {\n+                        return Future.succeededFuture();\n+                    } else {\n+                        // create index & implicit collection\n+                        return mongoDbCallExecutor.createCollectionIndex(getConfig().getCollectionName(),\n+                                new JsonObject().put(TenantConstants.FIELD_PAYLOAD_TENANT_ID, 1).put(TenantConstants.FIELD_PAYLOAD_DEVICE_ID, 1),\n+                                new IndexOptions().unique(true));\n+                    }\n+                })\n+                .compose(success -> {\n+                    if (getConfig().isModificationEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTgyNjY1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMDo1NTo1NFrOF5PMTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMDo1NTo1NFrOF5PMTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU2MjA2MQ==", "bodyText": "upper case P ?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395562061", "createdAt": "2020-03-20T10:55:54Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the tenant specific configuration.\n+     *\n+     * @param configuration The tenant configuration\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties configuration) {\n+        this.config = Objects.requireNonNull(configuration);\n+    }\n+\n+    /**\n+     * Starts the service.\n+     * <p>\n+     * Finishes if a tenant collection is found and creates an indexed collection else.\n+     * </P>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTgzOTY3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMTowMDozM1rOF5PUjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMTowMDozM1rOF5PUjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU2NDE3Mw==", "bodyText": "Could you please correct the above statement? You could also remove this javadoc  for this method, as it is a overridden method and the javadoc of the base class could be referred.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395564173", "createdAt": "2020-03-20T11:00:33Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the tenant specific configuration.\n+     *\n+     * @param configuration The tenant configuration\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties configuration) {\n+        this.config = Objects.requireNonNull(configuration);\n+    }\n+\n+    /**\n+     * Starts the service.\n+     * <p>\n+     * Finishes if a tenant collection is found and creates an indexed collection else.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTg0OTI1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMTowMzo1MVrOF5PatA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMTowMzo1MVrOF5PatA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU2NTc0OA==", "bodyText": "Please refer the above comment about the javadoc of the start(final Promise<Void> startPromise)", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395565748", "createdAt": "2020-03-20T11:03:51Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the tenant specific configuration.\n+     *\n+     * @param configuration The tenant configuration\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties configuration) {\n+        this.config = Objects.requireNonNull(configuration);\n+    }\n+\n+    /**\n+     * Starts the service.\n+     * <p>\n+     * Finishes if a tenant collection is found and creates an indexed collection else.\n+     * </P>\n+     *\n+     * @param startPromise the startup promise\n+     */\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        final Promise<List<String>> existingCollections = Promise.promise();\n+        mongoClient.getCollections(existingCollections);\n+        existingCollections.future()\n+                .compose(successExistingCollections -> {\n+                    if (successExistingCollections.contains(getConfig().getCollectionName())) {\n+                        return Future.succeededFuture();\n+                    } else {\n+                        // create index & implicit collection\n+                        return mongoDbCallExecutor.createCollectionIndex(getConfig().getCollectionName(),\n+                                new JsonObject().put(TenantConstants.FIELD_PAYLOAD_TENANT_ID, 1).put(TenantConstants.FIELD_PAYLOAD_DEVICE_ID, 1),\n+                                new IndexOptions().unique(true));\n+                    }\n+                })\n+                .compose(success -> {\n+                    if (getConfig().isModificationEnabled()) {\n+                        log.info(\"persistence is disabled, will not save tenant identities to mongoDB.\");\n+                    }\n+                    log.debug(\"startup complete\");\n+                    startPromise.complete();\n+                    return Future.succeededFuture();\n+                }).onFailure(reason -> {\n+            log.error(\"Index creation failed\", reason);\n+            startPromise.fail(reason.toString());\n+        });\n+    }\n+\n+    /**\n+     * Stops the service.\n+     *\n+     * @param stopPromise the shutdown promise\n+     */\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTg1ODY1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/MongoDbBasedTenantBackend.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMTowNzoxMlrOF5Pg2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMTowNzoxMlrOF5Pg2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU2NzMyMA==", "bodyText": "Could you pls place in an appropriate package? The device counterpart namely MongoDbBasedDeviceBackend resides under org.eclipse.hono.deviceregistry.mongodb.service.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395567320", "createdAt": "2020-03-20T11:07:12Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/MongoDbBasedTenantBackend.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb;\n+\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.service.MongoDbBasedTenantService;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantBackend;\n+import org.eclipse.hono.util.TenantResult;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Repository;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Verticle;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A tenant backend for a mongodb based of device registry.\n+ */\n+@Repository\n+@Qualifier(\"backend\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\", matchIfMissing = true)\n+public class MongoDbBasedTenantBackend extends AbstractVerticle", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTg3ODIyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMToxNDoyMVrOF5PtnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMToxNDoyMVrOF5PtnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU3MDU4OA==", "bodyText": "You could just remove this javadoc for this overridden method, as the interface TenantManagementService has a well documented one. If you still prefer to add one, you could any additional information that you have regarding this overridden method. If you add one, please follow the same style as of the TenantManagementService. Also please check the javadoc of the other methods too.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395570588", "createdAt": "2020-03-20T11:14:21Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the tenant specific configuration.\n+     *\n+     * @param configuration The tenant configuration\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties configuration) {\n+        this.config = Objects.requireNonNull(configuration);\n+    }\n+\n+    /**\n+     * Starts the service.\n+     * <p>\n+     * Finishes if a tenant collection is found and creates an indexed collection else.\n+     * </P>\n+     *\n+     * @param startPromise the startup promise\n+     */\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        final Promise<List<String>> existingCollections = Promise.promise();\n+        mongoClient.getCollections(existingCollections);\n+        existingCollections.future()\n+                .compose(successExistingCollections -> {\n+                    if (successExistingCollections.contains(getConfig().getCollectionName())) {\n+                        return Future.succeededFuture();\n+                    } else {\n+                        // create index & implicit collection\n+                        return mongoDbCallExecutor.createCollectionIndex(getConfig().getCollectionName(),\n+                                new JsonObject().put(TenantConstants.FIELD_PAYLOAD_TENANT_ID, 1).put(TenantConstants.FIELD_PAYLOAD_DEVICE_ID, 1),\n+                                new IndexOptions().unique(true));\n+                    }\n+                })\n+                .compose(success -> {\n+                    if (getConfig().isModificationEnabled()) {\n+                        log.info(\"persistence is disabled, will not save tenant identities to mongoDB.\");\n+                    }\n+                    log.debug(\"startup complete\");\n+                    startPromise.complete();\n+                    return Future.succeededFuture();\n+                }).onFailure(reason -> {\n+            log.error(\"Index creation failed\", reason);\n+            startPromise.fail(reason.toString());\n+        });\n+    }\n+\n+    /**\n+     * Stops the service.\n+     *\n+     * @param stopPromise the shutdown promise\n+     */\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates data of a present tenant.\n+     * <p>\n+     * Tenant modification have to be enabled in {@link MongoDbBasedTenantsConfigProperties} or exits with {@code HttpURLConnection.HTTP_FORBIDDEN}.\n+     * </p>\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * A provided <em>certificate authority</em> must not be set in other tenants.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param tenantObj       The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of update operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else. {@code HttpURLConnection.HTTP_FORBIDDEN} if modification is disabled.\n+     * @throws NullPointerException if {@code tenantId} or {@code tenantObj} are {@code null}.\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj, final Optional<String> resourceVersion, final Span span) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTg4NzYyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMToxNzo1M1rOF5Pz5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMToxNzo1M1rOF5Pz5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU3MjE5OQ==", "bodyText": "Please follow the hono javadoc style and you could use TenantManagementService as a reference.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395572199", "createdAt": "2020-03-20T11:17:53Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the tenant specific configuration.\n+     *\n+     * @param configuration The tenant configuration\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties configuration) {\n+        this.config = Objects.requireNonNull(configuration);\n+    }\n+\n+    /**\n+     * Starts the service.\n+     * <p>\n+     * Finishes if a tenant collection is found and creates an indexed collection else.\n+     * </P>\n+     *\n+     * @param startPromise the startup promise\n+     */\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        final Promise<List<String>> existingCollections = Promise.promise();\n+        mongoClient.getCollections(existingCollections);\n+        existingCollections.future()\n+                .compose(successExistingCollections -> {\n+                    if (successExistingCollections.contains(getConfig().getCollectionName())) {\n+                        return Future.succeededFuture();\n+                    } else {\n+                        // create index & implicit collection\n+                        return mongoDbCallExecutor.createCollectionIndex(getConfig().getCollectionName(),\n+                                new JsonObject().put(TenantConstants.FIELD_PAYLOAD_TENANT_ID, 1).put(TenantConstants.FIELD_PAYLOAD_DEVICE_ID, 1),\n+                                new IndexOptions().unique(true));\n+                    }\n+                })\n+                .compose(success -> {\n+                    if (getConfig().isModificationEnabled()) {\n+                        log.info(\"persistence is disabled, will not save tenant identities to mongoDB.\");\n+                    }\n+                    log.debug(\"startup complete\");\n+                    startPromise.complete();\n+                    return Future.succeededFuture();\n+                }).onFailure(reason -> {\n+            log.error(\"Index creation failed\", reason);\n+            startPromise.fail(reason.toString());\n+        });\n+    }\n+\n+    /**\n+     * Stops the service.\n+     *\n+     * @param stopPromise the shutdown promise\n+     */\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates data of a present tenant.\n+     * <p>\n+     * Tenant modification have to be enabled in {@link MongoDbBasedTenantsConfigProperties} or exits with {@code HttpURLConnection.HTTP_FORBIDDEN}.\n+     * </p>\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * A provided <em>certificate authority</em> must not be set in other tenants.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param tenantObj       The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of update operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else. {@code HttpURLConnection.HTTP_FORBIDDEN} if modification is disabled.\n+     * @throws NullPointerException if {@code tenantId} or {@code tenantObj} are {@code null}.\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj, final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        return executeIfModificationEnabled(\n+                () -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span),\n+                span\n+        );\n+    }\n+\n+    /**\n+     * Updates data of a present tenant.\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * A provided <em>certificate authority</em> must not be set in other tenants.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param tenantObj       The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of update operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else.\n+     * @throws NullPointerException if {@code tenantId} or {@code tenantObj} are {@code null}.\n+     */\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant tenantObj, final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        final JsonObject tenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return MongoDbServiceUtils.isVersionEqualCurrentVersionOrNotSet(mongoClient, getConfig().getCollectionName(), tenantQuery, resourceVersion)\n+                .compose(versionEqualsORNotSet -> {\n+                    if (!versionEqualsORNotSet) {\n+                        TracingHelper.logError(span, \"Resource Version mismatch.\");\n+                        return Future.<OperationResult<Void>>succeededFuture(OperationResult.<Void>empty(HttpURLConnection.HTTP_PRECON_FAILED));\n+                    }\n+                    final Versioned<Tenant> newTenant = new Versioned<>(tenantObj);\n+                    final TenantDto newTenantDto = new TenantDto(tenantId, newTenant.getVersion(), newTenant.getValue(), Instant.now());\n+                    final Future<Map.Entry<String, Versioned<Tenant>>> conflictingTenant = newTenantDto.getTenant()\n+                            .getTrustedCertificateAuthoritySubjectDNs()\n+                            .stream()\n+                            .map(this::getByCa)\n+                            .filter(Objects::nonNull)\n+                            .findFirst()\n+                            .orElseGet(() -> Future.succeededFuture(null));\n+                    return conflictingTenant.compose(conflictingTenantFound -> {\n+                        if (conflictingTenantFound != null && !tenantId.equals(conflictingTenantFound.getKey())) {\n+                            // Try to set the same CA as another tenant\n+                            TracingHelper.logError(span, \"Conflict : CA already used by an existing tenant.\");\n+                            return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                        }\n+                        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+                        final Promise<JsonObject> tenantUpdated = Promise.promise();\n+                        mongoClient.findOneAndReplace(getConfig().getCollectionName(), tenantQuery, newTenantDtoJson, tenantUpdated);\n+                        return tenantUpdated.future().compose(successTenantUpdated -> {\n+                            if (successTenantUpdated == null) {\n+                                throw new NullPointerException(\"Entity not found.\");\n+                            }\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(newTenantDto.getVersion())\n+                            ));\n+                        });\n+                    });\n+                })\n+                .recover(errorVersionEqualsORNotSet -> {\n+                    TracingHelper.logError(span, String.format(\"Tenant [%s] not found.\", tenantId));\n+                    return Future.<OperationResult<Void>>succeededFuture(OperationResult.<Void>empty(HttpURLConnection.HTTP_NOT_FOUND));\n+                });\n+\n+\n+    }\n+\n+    /**\n+     * Deletes a present tenant.\n+     * <p>\n+     * Tenant modification have to be enabled in {@link MongoDbBasedTenantsConfigProperties} or exits with {@code HttpURLConnection.HTTP_FORBIDDEN}.\n+     * </p>\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param resourceVersion The identifier of the resource version to delete.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of deletion operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else. {@code HttpURLConnection.HTTP_FORBIDDEN} if modification is disabled.\n+     * @throws NullPointerException if {@code tenantId} or resourceVersion are {@code null}.\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return executeIfModificationEnabled(\n+                () -> processDeleteTenant(tenantId, resourceVersion, span),\n+                span\n+        );\n+    }\n+\n+    /**\n+     * Deletes a present tenant.\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param resourceVersion The identifier of the resource version to delete.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of deletion operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else.\n+     * @throws NullPointerException if {@code tenantId} or resourceVersion are {@code null}.\n+     */\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion, final Span span) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 291}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTg4ODc4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMToxODoxN1rOF5P0sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMToxODoxN1rOF5P0sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU3MjQwMw==", "bodyText": "Please follow the hono javadoc style and you could use TenantManagementService as a reference.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395572403", "createdAt": "2020-03-20T11:18:17Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the tenant specific configuration.\n+     *\n+     * @param configuration The tenant configuration\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties configuration) {\n+        this.config = Objects.requireNonNull(configuration);\n+    }\n+\n+    /**\n+     * Starts the service.\n+     * <p>\n+     * Finishes if a tenant collection is found and creates an indexed collection else.\n+     * </P>\n+     *\n+     * @param startPromise the startup promise\n+     */\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        final Promise<List<String>> existingCollections = Promise.promise();\n+        mongoClient.getCollections(existingCollections);\n+        existingCollections.future()\n+                .compose(successExistingCollections -> {\n+                    if (successExistingCollections.contains(getConfig().getCollectionName())) {\n+                        return Future.succeededFuture();\n+                    } else {\n+                        // create index & implicit collection\n+                        return mongoDbCallExecutor.createCollectionIndex(getConfig().getCollectionName(),\n+                                new JsonObject().put(TenantConstants.FIELD_PAYLOAD_TENANT_ID, 1).put(TenantConstants.FIELD_PAYLOAD_DEVICE_ID, 1),\n+                                new IndexOptions().unique(true));\n+                    }\n+                })\n+                .compose(success -> {\n+                    if (getConfig().isModificationEnabled()) {\n+                        log.info(\"persistence is disabled, will not save tenant identities to mongoDB.\");\n+                    }\n+                    log.debug(\"startup complete\");\n+                    startPromise.complete();\n+                    return Future.succeededFuture();\n+                }).onFailure(reason -> {\n+            log.error(\"Index creation failed\", reason);\n+            startPromise.fail(reason.toString());\n+        });\n+    }\n+\n+    /**\n+     * Stops the service.\n+     *\n+     * @param stopPromise the shutdown promise\n+     */\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates data of a present tenant.\n+     * <p>\n+     * Tenant modification have to be enabled in {@link MongoDbBasedTenantsConfigProperties} or exits with {@code HttpURLConnection.HTTP_FORBIDDEN}.\n+     * </p>\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * A provided <em>certificate authority</em> must not be set in other tenants.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param tenantObj       The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of update operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else. {@code HttpURLConnection.HTTP_FORBIDDEN} if modification is disabled.\n+     * @throws NullPointerException if {@code tenantId} or {@code tenantObj} are {@code null}.\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj, final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        return executeIfModificationEnabled(\n+                () -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span),\n+                span\n+        );\n+    }\n+\n+    /**\n+     * Updates data of a present tenant.\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * A provided <em>certificate authority</em> must not be set in other tenants.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param tenantObj       The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of update operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else.\n+     * @throws NullPointerException if {@code tenantId} or {@code tenantObj} are {@code null}.\n+     */\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant tenantObj, final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        final JsonObject tenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return MongoDbServiceUtils.isVersionEqualCurrentVersionOrNotSet(mongoClient, getConfig().getCollectionName(), tenantQuery, resourceVersion)\n+                .compose(versionEqualsORNotSet -> {\n+                    if (!versionEqualsORNotSet) {\n+                        TracingHelper.logError(span, \"Resource Version mismatch.\");\n+                        return Future.<OperationResult<Void>>succeededFuture(OperationResult.<Void>empty(HttpURLConnection.HTTP_PRECON_FAILED));\n+                    }\n+                    final Versioned<Tenant> newTenant = new Versioned<>(tenantObj);\n+                    final TenantDto newTenantDto = new TenantDto(tenantId, newTenant.getVersion(), newTenant.getValue(), Instant.now());\n+                    final Future<Map.Entry<String, Versioned<Tenant>>> conflictingTenant = newTenantDto.getTenant()\n+                            .getTrustedCertificateAuthoritySubjectDNs()\n+                            .stream()\n+                            .map(this::getByCa)\n+                            .filter(Objects::nonNull)\n+                            .findFirst()\n+                            .orElseGet(() -> Future.succeededFuture(null));\n+                    return conflictingTenant.compose(conflictingTenantFound -> {\n+                        if (conflictingTenantFound != null && !tenantId.equals(conflictingTenantFound.getKey())) {\n+                            // Try to set the same CA as another tenant\n+                            TracingHelper.logError(span, \"Conflict : CA already used by an existing tenant.\");\n+                            return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                        }\n+                        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+                        final Promise<JsonObject> tenantUpdated = Promise.promise();\n+                        mongoClient.findOneAndReplace(getConfig().getCollectionName(), tenantQuery, newTenantDtoJson, tenantUpdated);\n+                        return tenantUpdated.future().compose(successTenantUpdated -> {\n+                            if (successTenantUpdated == null) {\n+                                throw new NullPointerException(\"Entity not found.\");\n+                            }\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(newTenantDto.getVersion())\n+                            ));\n+                        });\n+                    });\n+                })\n+                .recover(errorVersionEqualsORNotSet -> {\n+                    TracingHelper.logError(span, String.format(\"Tenant [%s] not found.\", tenantId));\n+                    return Future.<OperationResult<Void>>succeededFuture(OperationResult.<Void>empty(HttpURLConnection.HTTP_NOT_FOUND));\n+                });\n+\n+\n+    }\n+\n+    /**\n+     * Deletes a present tenant.\n+     * <p>\n+     * Tenant modification have to be enabled in {@link MongoDbBasedTenantsConfigProperties} or exits with {@code HttpURLConnection.HTTP_FORBIDDEN}.\n+     * </p>\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param resourceVersion The identifier of the resource version to delete.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of deletion operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else. {@code HttpURLConnection.HTTP_FORBIDDEN} if modification is disabled.\n+     * @throws NullPointerException if {@code tenantId} or resourceVersion are {@code null}.\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return executeIfModificationEnabled(\n+                () -> processDeleteTenant(tenantId, resourceVersion, span),\n+                span\n+        );\n+    }\n+\n+    /**\n+     * Deletes a present tenant.\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param resourceVersion The identifier of the resource version to delete.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of deletion operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else.\n+     * @throws NullPointerException if {@code tenantId} or resourceVersion are {@code null}.\n+     */\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        return MongoDbServiceUtils.isVersionEqualCurrentVersionOrNotSet(mongoClient, getConfig().getCollectionName(), tenantQuery, resourceVersion)\n+                .compose(versionEqualsORNotSet -> {\n+                    if (!versionEqualsORNotSet) {\n+                        TracingHelper.logError(span, \"Resource Version mismatch.\");\n+                        return Future.succeededFuture(Result.<Void>from(HttpURLConnection.HTTP_PRECON_FAILED));\n+                    }\n+                    final Promise<MongoClientDeleteResult> deleteTenant = Promise.promise();\n+                    mongoClient.removeDocument(getConfig().getCollectionName(), tenantQuery, deleteTenant);\n+                    return deleteTenant.future().compose(successDeleteTenant -> {\n+                        if (successDeleteTenant.getRemovedCount() == 0) {\n+                            throw new IllegalStateException(\"Entity not found.\");\n+                        } else if (successDeleteTenant.getRemovedCount() > 1) {\n+                            TracingHelper.logError(span, String.format(\"Multiple have been deleted.\"));\n+                            return Future.succeededFuture(Result.<Void>from(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                        }\n+                        // if successDeleteTenant.getRemovedCount() == 1\n+                        return Future.succeededFuture(Result.<Void>from(HttpURLConnection.HTTP_NO_CONTENT));\n+                    });\n+                })\n+                .recover(errorVersionEqualsORNotSet -> {\n+                    TracingHelper.logError(span, String.format(\"Tenant [%s] not found.\", tenantId));\n+                    return Future.succeededFuture(Result.<Void>from(HttpURLConnection.HTTP_NOT_FOUND));\n+                });\n+    }\n+\n+    /**\n+     * Fetches a tenant by tenant id.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @return Future TenantResult with {@code HttpURLConnection.HTTP_OK} if tenant found, {@code HttpURLConnection.HTTP_NOT_FOUND} else.\n+     * @throws NullPointerException if {@code tenantId} is {@code null}.\n+     */\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, null);\n+    }\n+\n+    /**\n+     * Fetches a tenant by tenant id.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param span     The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                 An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                 parent for any spans created in this method.\n+     * @return Future TenantResult with {@code HttpURLConnection.HTTP_OK} if tenant found, {@code HttpURLConnection.HTTP_NOT_FOUND} else.\n+     * @throws NullPointerException if {@code tenantId} is {@code null}.\n+     */\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return readTenant(tenantId, span)\n+                .compose(successTenantRead -> {\n+                    if (successTenantRead.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantId, successTenantRead.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())\n+                    ));\n+                });\n+    }\n+\n+    /**\n+     * Fetches a tenant by {@link X500Principal}.\n+     *\n+     * @param subjectDn The <em>subject DN</em> of the trusted CA certificate\n+     *                  that has been configured for the tenant.\n+     * @return Future TenantResult with {@code HttpURLConnection.HTTP_OK} if tenant found, {@code HttpURLConnection.HTTP_NOT_FOUND} else.\n+     * @throws NullPointerException if {@code subjectDn} is {@code null}.\n+     */\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, null);\n+    }\n+\n+    /**\n+     * Fetches a tenant by {@link X500Principal}.\n+     *\n+     * @param subjectDn The <em>subject DN</em> of the trusted CA certificate\n+     *                  that has been configured for the tenant.\n+     * @param span      The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                  An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                  parent for any spans created in this method.\n+     * @return Future TenantResult with {@code HttpURLConnection.HTTP_OK} if tenant found, {@code HttpURLConnection.HTTP_NOT_FOUND} else.\n+     * @throws NullPointerException if {@code subjectDn} is {@code null}.\n+     */\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span      The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                  An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                  parent for any spans created in this method.\n+     * @return Future TenantResult with {@code HttpURLConnection.HTTP_OK} if tenant found, {@code HttpURLConnection.HTTP_NOT_FOUND} else.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn, final Span span) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 409}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTkwNDE2OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMToyMzo1MlrOF5P-rQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMToyMzo1MlrOF5P-rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU3NDk1Nw==", "bodyText": "Please follow the hono javadoc style and you could use TenantManagementService as a reference. Please check the javadoc of other methods too.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395574957", "createdAt": "2020-03-20T11:23:52Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the tenant specific configuration.\n+     *\n+     * @param configuration The tenant configuration\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties configuration) {\n+        this.config = Objects.requireNonNull(configuration);\n+    }\n+\n+    /**\n+     * Starts the service.\n+     * <p>\n+     * Finishes if a tenant collection is found and creates an indexed collection else.\n+     * </P>\n+     *\n+     * @param startPromise the startup promise\n+     */\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        final Promise<List<String>> existingCollections = Promise.promise();\n+        mongoClient.getCollections(existingCollections);\n+        existingCollections.future()\n+                .compose(successExistingCollections -> {\n+                    if (successExistingCollections.contains(getConfig().getCollectionName())) {\n+                        return Future.succeededFuture();\n+                    } else {\n+                        // create index & implicit collection\n+                        return mongoDbCallExecutor.createCollectionIndex(getConfig().getCollectionName(),\n+                                new JsonObject().put(TenantConstants.FIELD_PAYLOAD_TENANT_ID, 1).put(TenantConstants.FIELD_PAYLOAD_DEVICE_ID, 1),\n+                                new IndexOptions().unique(true));\n+                    }\n+                })\n+                .compose(success -> {\n+                    if (getConfig().isModificationEnabled()) {\n+                        log.info(\"persistence is disabled, will not save tenant identities to mongoDB.\");\n+                    }\n+                    log.debug(\"startup complete\");\n+                    startPromise.complete();\n+                    return Future.succeededFuture();\n+                }).onFailure(reason -> {\n+            log.error(\"Index creation failed\", reason);\n+            startPromise.fail(reason.toString());\n+        });\n+    }\n+\n+    /**\n+     * Stops the service.\n+     *\n+     * @param stopPromise the shutdown promise\n+     */\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates data of a present tenant.\n+     * <p>\n+     * Tenant modification have to be enabled in {@link MongoDbBasedTenantsConfigProperties} or exits with {@code HttpURLConnection.HTTP_FORBIDDEN}.\n+     * </p>\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * A provided <em>certificate authority</em> must not be set in other tenants.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param tenantObj       The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of update operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else. {@code HttpURLConnection.HTTP_FORBIDDEN} if modification is disabled.\n+     * @throws NullPointerException if {@code tenantId} or {@code tenantObj} are {@code null}.\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj, final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        return executeIfModificationEnabled(\n+                () -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span),\n+                span\n+        );\n+    }\n+\n+    /**\n+     * Updates data of a present tenant.\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * A provided <em>certificate authority</em> must not be set in other tenants.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param tenantObj       The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of update operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else.\n+     * @throws NullPointerException if {@code tenantId} or {@code tenantObj} are {@code null}.\n+     */\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant tenantObj, final Optional<String> resourceVersion, final Span span) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTkzMjA3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMTozMzoyMlrOF5QP3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMTozMzoyMlrOF5QP3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU3OTM1Ng==", "bodyText": "Line too long. Please format it with the code formatter shipped with Hono. It is also applicable to several other places in this PR.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395579356", "createdAt": "2020-03-20T11:33:22Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the tenant specific configuration.\n+     *\n+     * @param configuration The tenant configuration\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties configuration) {\n+        this.config = Objects.requireNonNull(configuration);\n+    }\n+\n+    /**\n+     * Starts the service.\n+     * <p>\n+     * Finishes if a tenant collection is found and creates an indexed collection else.\n+     * </P>\n+     *\n+     * @param startPromise the startup promise\n+     */\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        final Promise<List<String>> existingCollections = Promise.promise();\n+        mongoClient.getCollections(existingCollections);\n+        existingCollections.future()\n+                .compose(successExistingCollections -> {\n+                    if (successExistingCollections.contains(getConfig().getCollectionName())) {\n+                        return Future.succeededFuture();\n+                    } else {\n+                        // create index & implicit collection\n+                        return mongoDbCallExecutor.createCollectionIndex(getConfig().getCollectionName(),\n+                                new JsonObject().put(TenantConstants.FIELD_PAYLOAD_TENANT_ID, 1).put(TenantConstants.FIELD_PAYLOAD_DEVICE_ID, 1),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Mjk0MzU5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNjoxNjowNFrOF5aVJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMTozMzoxNFrOF6Bbnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0NDU1MA==", "bodyText": "This method is also available in file based device registry. Duplication could be avoided by pulling up this method to DeviceRegistryUtils in base module.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395744550", "createdAt": "2020-03-20T16:16:04Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the tenant specific configuration.\n+     *\n+     * @param configuration The tenant configuration\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties configuration) {\n+        this.config = Objects.requireNonNull(configuration);\n+    }\n+\n+    /**\n+     * Starts the service.\n+     * <p>\n+     * Finishes if a tenant collection is found and creates an indexed collection else.\n+     * </P>\n+     *\n+     * @param startPromise the startup promise\n+     */\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        final Promise<List<String>> existingCollections = Promise.promise();\n+        mongoClient.getCollections(existingCollections);\n+        existingCollections.future()\n+                .compose(successExistingCollections -> {\n+                    if (successExistingCollections.contains(getConfig().getCollectionName())) {\n+                        return Future.succeededFuture();\n+                    } else {\n+                        // create index & implicit collection\n+                        return mongoDbCallExecutor.createCollectionIndex(getConfig().getCollectionName(),\n+                                new JsonObject().put(TenantConstants.FIELD_PAYLOAD_TENANT_ID, 1).put(TenantConstants.FIELD_PAYLOAD_DEVICE_ID, 1),\n+                                new IndexOptions().unique(true));\n+                    }\n+                })\n+                .compose(success -> {\n+                    if (getConfig().isModificationEnabled()) {\n+                        log.info(\"persistence is disabled, will not save tenant identities to mongoDB.\");\n+                    }\n+                    log.debug(\"startup complete\");\n+                    startPromise.complete();\n+                    return Future.succeededFuture();\n+                }).onFailure(reason -> {\n+            log.error(\"Index creation failed\", reason);\n+            startPromise.fail(reason.toString());\n+        });\n+    }\n+\n+    /**\n+     * Stops the service.\n+     *\n+     * @param stopPromise the shutdown promise\n+     */\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates data of a present tenant.\n+     * <p>\n+     * Tenant modification have to be enabled in {@link MongoDbBasedTenantsConfigProperties} or exits with {@code HttpURLConnection.HTTP_FORBIDDEN}.\n+     * </p>\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * A provided <em>certificate authority</em> must not be set in other tenants.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param tenantObj       The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of update operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else. {@code HttpURLConnection.HTTP_FORBIDDEN} if modification is disabled.\n+     * @throws NullPointerException if {@code tenantId} or {@code tenantObj} are {@code null}.\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj, final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        return executeIfModificationEnabled(\n+                () -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span),\n+                span\n+        );\n+    }\n+\n+    /**\n+     * Updates data of a present tenant.\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * A provided <em>certificate authority</em> must not be set in other tenants.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param tenantObj       The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of update operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else.\n+     * @throws NullPointerException if {@code tenantId} or {@code tenantObj} are {@code null}.\n+     */\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant tenantObj, final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        final JsonObject tenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return MongoDbServiceUtils.isVersionEqualCurrentVersionOrNotSet(mongoClient, getConfig().getCollectionName(), tenantQuery, resourceVersion)\n+                .compose(versionEqualsORNotSet -> {\n+                    if (!versionEqualsORNotSet) {\n+                        TracingHelper.logError(span, \"Resource Version mismatch.\");\n+                        return Future.<OperationResult<Void>>succeededFuture(OperationResult.<Void>empty(HttpURLConnection.HTTP_PRECON_FAILED));\n+                    }\n+                    final Versioned<Tenant> newTenant = new Versioned<>(tenantObj);\n+                    final TenantDto newTenantDto = new TenantDto(tenantId, newTenant.getVersion(), newTenant.getValue(), Instant.now());\n+                    final Future<Map.Entry<String, Versioned<Tenant>>> conflictingTenant = newTenantDto.getTenant()\n+                            .getTrustedCertificateAuthoritySubjectDNs()\n+                            .stream()\n+                            .map(this::getByCa)\n+                            .filter(Objects::nonNull)\n+                            .findFirst()\n+                            .orElseGet(() -> Future.succeededFuture(null));\n+                    return conflictingTenant.compose(conflictingTenantFound -> {\n+                        if (conflictingTenantFound != null && !tenantId.equals(conflictingTenantFound.getKey())) {\n+                            // Try to set the same CA as another tenant\n+                            TracingHelper.logError(span, \"Conflict : CA already used by an existing tenant.\");\n+                            return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                        }\n+                        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+                        final Promise<JsonObject> tenantUpdated = Promise.promise();\n+                        mongoClient.findOneAndReplace(getConfig().getCollectionName(), tenantQuery, newTenantDtoJson, tenantUpdated);\n+                        return tenantUpdated.future().compose(successTenantUpdated -> {\n+                            if (successTenantUpdated == null) {\n+                                throw new NullPointerException(\"Entity not found.\");\n+                            }\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(newTenantDto.getVersion())\n+                            ));\n+                        });\n+                    });\n+                })\n+                .recover(errorVersionEqualsORNotSet -> {\n+                    TracingHelper.logError(span, String.format(\"Tenant [%s] not found.\", tenantId));\n+                    return Future.<OperationResult<Void>>succeededFuture(OperationResult.<Void>empty(HttpURLConnection.HTTP_NOT_FOUND));\n+                });\n+\n+\n+    }\n+\n+    /**\n+     * Deletes a present tenant.\n+     * <p>\n+     * Tenant modification have to be enabled in {@link MongoDbBasedTenantsConfigProperties} or exits with {@code HttpURLConnection.HTTP_FORBIDDEN}.\n+     * </p>\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param resourceVersion The identifier of the resource version to delete.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of deletion operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else. {@code HttpURLConnection.HTTP_FORBIDDEN} if modification is disabled.\n+     * @throws NullPointerException if {@code tenantId} or resourceVersion are {@code null}.\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return executeIfModificationEnabled(\n+                () -> processDeleteTenant(tenantId, resourceVersion, span),\n+                span\n+        );\n+    }\n+\n+    /**\n+     * Deletes a present tenant.\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param resourceVersion The identifier of the resource version to delete.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of deletion operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else.\n+     * @throws NullPointerException if {@code tenantId} or resourceVersion are {@code null}.\n+     */\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        return MongoDbServiceUtils.isVersionEqualCurrentVersionOrNotSet(mongoClient, getConfig().getCollectionName(), tenantQuery, resourceVersion)\n+                .compose(versionEqualsORNotSet -> {\n+                    if (!versionEqualsORNotSet) {\n+                        TracingHelper.logError(span, \"Resource Version mismatch.\");\n+                        return Future.succeededFuture(Result.<Void>from(HttpURLConnection.HTTP_PRECON_FAILED));\n+                    }\n+                    final Promise<MongoClientDeleteResult> deleteTenant = Promise.promise();\n+                    mongoClient.removeDocument(getConfig().getCollectionName(), tenantQuery, deleteTenant);\n+                    return deleteTenant.future().compose(successDeleteTenant -> {\n+                        if (successDeleteTenant.getRemovedCount() == 0) {\n+                            throw new IllegalStateException(\"Entity not found.\");\n+                        } else if (successDeleteTenant.getRemovedCount() > 1) {\n+                            TracingHelper.logError(span, String.format(\"Multiple have been deleted.\"));\n+                            return Future.succeededFuture(Result.<Void>from(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                        }\n+                        // if successDeleteTenant.getRemovedCount() == 1\n+                        return Future.succeededFuture(Result.<Void>from(HttpURLConnection.HTTP_NO_CONTENT));\n+                    });\n+                })\n+                .recover(errorVersionEqualsORNotSet -> {\n+                    TracingHelper.logError(span, String.format(\"Tenant [%s] not found.\", tenantId));\n+                    return Future.succeededFuture(Result.<Void>from(HttpURLConnection.HTTP_NOT_FOUND));\n+                });\n+    }\n+\n+    /**\n+     * Fetches a tenant by tenant id.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @return Future TenantResult with {@code HttpURLConnection.HTTP_OK} if tenant found, {@code HttpURLConnection.HTTP_NOT_FOUND} else.\n+     * @throws NullPointerException if {@code tenantId} is {@code null}.\n+     */\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, null);\n+    }\n+\n+    /**\n+     * Fetches a tenant by tenant id.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param span     The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                 An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                 parent for any spans created in this method.\n+     * @return Future TenantResult with {@code HttpURLConnection.HTTP_OK} if tenant found, {@code HttpURLConnection.HTTP_NOT_FOUND} else.\n+     * @throws NullPointerException if {@code tenantId} is {@code null}.\n+     */\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return readTenant(tenantId, span)\n+                .compose(successTenantRead -> {\n+                    if (successTenantRead.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantId, successTenantRead.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())\n+                    ));\n+                });\n+    }\n+\n+    /**\n+     * Fetches a tenant by {@link X500Principal}.\n+     *\n+     * @param subjectDn The <em>subject DN</em> of the trusted CA certificate\n+     *                  that has been configured for the tenant.\n+     * @return Future TenantResult with {@code HttpURLConnection.HTTP_OK} if tenant found, {@code HttpURLConnection.HTTP_NOT_FOUND} else.\n+     * @throws NullPointerException if {@code subjectDn} is {@code null}.\n+     */\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, null);\n+    }\n+\n+    /**\n+     * Fetches a tenant by {@link X500Principal}.\n+     *\n+     * @param subjectDn The <em>subject DN</em> of the trusted CA certificate\n+     *                  that has been configured for the tenant.\n+     * @param span      The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                  An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                  parent for any spans created in this method.\n+     * @return Future TenantResult with {@code HttpURLConnection.HTTP_OK} if tenant found, {@code HttpURLConnection.HTTP_NOT_FOUND} else.\n+     * @throws NullPointerException if {@code subjectDn} is {@code null}.\n+     */\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span      The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                  An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                  parent for any spans created in this method.\n+     * @return Future TenantResult with {@code HttpURLConnection.HTTP_OK} if tenant found, {@code HttpURLConnection.HTTP_NOT_FOUND} else.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn, final Span span) {\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            final Future<Map.Entry<String, Versioned<Tenant>>> tenantsFound = getByCa(subjectDn);\n+            return tenantsFound.compose(successTenantRead -> {\n+                if (successTenantRead == null) {\n+                    TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                    return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                } else {\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(successTenantRead.getKey(), successTenantRead.getValue().getValue(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A Future Map consisting of pair of a tenant id and a versioned tenant.\n+     */\n+    private Future<Map.Entry<String, Versioned<Tenant>>> getByCa(final X500Principal subjectDn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 435}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM4NTE4Mw==", "bodyText": "The problem with this is that the method calls another local method and the extraction of the method becomes more complex.\nProposal: Extract this method along others in a refactor PR later.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r396385183", "createdAt": "2020-03-23T11:33:14Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,630 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Instant;\n+import java.util.AbstractMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbServiceUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ */\n+@SuppressWarnings(\"RedundantTypeArguments\")\n+@Component\n+@Qualifier(\"serviceImpl\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoClient mongoClient;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an the {@code MongoDbCallExecutor} and {@code MongoClient} for the mongodb connection.\n+     *\n+     * @param mongoDbCallExecutor An instance of the configured, connection ready mongodb executor singleton.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the tenant specific configuration.\n+     *\n+     * @param configuration The tenant configuration\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties configuration) {\n+        this.config = Objects.requireNonNull(configuration);\n+    }\n+\n+    /**\n+     * Starts the service.\n+     * <p>\n+     * Finishes if a tenant collection is found and creates an indexed collection else.\n+     * </P>\n+     *\n+     * @param startPromise the startup promise\n+     */\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        final Promise<List<String>> existingCollections = Promise.promise();\n+        mongoClient.getCollections(existingCollections);\n+        existingCollections.future()\n+                .compose(successExistingCollections -> {\n+                    if (successExistingCollections.contains(getConfig().getCollectionName())) {\n+                        return Future.succeededFuture();\n+                    } else {\n+                        // create index & implicit collection\n+                        return mongoDbCallExecutor.createCollectionIndex(getConfig().getCollectionName(),\n+                                new JsonObject().put(TenantConstants.FIELD_PAYLOAD_TENANT_ID, 1).put(TenantConstants.FIELD_PAYLOAD_DEVICE_ID, 1),\n+                                new IndexOptions().unique(true));\n+                    }\n+                })\n+                .compose(success -> {\n+                    if (getConfig().isModificationEnabled()) {\n+                        log.info(\"persistence is disabled, will not save tenant identities to mongoDB.\");\n+                    }\n+                    log.debug(\"startup complete\");\n+                    startPromise.complete();\n+                    return Future.succeededFuture();\n+                }).onFailure(reason -> {\n+            log.error(\"Index creation failed\", reason);\n+            startPromise.fail(reason.toString());\n+        });\n+    }\n+\n+    /**\n+     * Stops the service.\n+     *\n+     * @param stopPromise the shutdown promise\n+     */\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates data of a present tenant.\n+     * <p>\n+     * Tenant modification have to be enabled in {@link MongoDbBasedTenantsConfigProperties} or exits with {@code HttpURLConnection.HTTP_FORBIDDEN}.\n+     * </p>\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * A provided <em>certificate authority</em> must not be set in other tenants.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param tenantObj       The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of update operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else. {@code HttpURLConnection.HTTP_FORBIDDEN} if modification is disabled.\n+     * @throws NullPointerException if {@code tenantId} or {@code tenantObj} are {@code null}.\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj, final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        return executeIfModificationEnabled(\n+                () -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span),\n+                span\n+        );\n+    }\n+\n+    /**\n+     * Updates data of a present tenant.\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * A provided <em>certificate authority</em> must not be set in other tenants.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param tenantObj       The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of update operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else.\n+     * @throws NullPointerException if {@code tenantId} or {@code tenantObj} are {@code null}.\n+     */\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant tenantObj, final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        final JsonObject tenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return MongoDbServiceUtils.isVersionEqualCurrentVersionOrNotSet(mongoClient, getConfig().getCollectionName(), tenantQuery, resourceVersion)\n+                .compose(versionEqualsORNotSet -> {\n+                    if (!versionEqualsORNotSet) {\n+                        TracingHelper.logError(span, \"Resource Version mismatch.\");\n+                        return Future.<OperationResult<Void>>succeededFuture(OperationResult.<Void>empty(HttpURLConnection.HTTP_PRECON_FAILED));\n+                    }\n+                    final Versioned<Tenant> newTenant = new Versioned<>(tenantObj);\n+                    final TenantDto newTenantDto = new TenantDto(tenantId, newTenant.getVersion(), newTenant.getValue(), Instant.now());\n+                    final Future<Map.Entry<String, Versioned<Tenant>>> conflictingTenant = newTenantDto.getTenant()\n+                            .getTrustedCertificateAuthoritySubjectDNs()\n+                            .stream()\n+                            .map(this::getByCa)\n+                            .filter(Objects::nonNull)\n+                            .findFirst()\n+                            .orElseGet(() -> Future.succeededFuture(null));\n+                    return conflictingTenant.compose(conflictingTenantFound -> {\n+                        if (conflictingTenantFound != null && !tenantId.equals(conflictingTenantFound.getKey())) {\n+                            // Try to set the same CA as another tenant\n+                            TracingHelper.logError(span, \"Conflict : CA already used by an existing tenant.\");\n+                            return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                        }\n+                        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+                        final Promise<JsonObject> tenantUpdated = Promise.promise();\n+                        mongoClient.findOneAndReplace(getConfig().getCollectionName(), tenantQuery, newTenantDtoJson, tenantUpdated);\n+                        return tenantUpdated.future().compose(successTenantUpdated -> {\n+                            if (successTenantUpdated == null) {\n+                                throw new NullPointerException(\"Entity not found.\");\n+                            }\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(newTenantDto.getVersion())\n+                            ));\n+                        });\n+                    });\n+                })\n+                .recover(errorVersionEqualsORNotSet -> {\n+                    TracingHelper.logError(span, String.format(\"Tenant [%s] not found.\", tenantId));\n+                    return Future.<OperationResult<Void>>succeededFuture(OperationResult.<Void>empty(HttpURLConnection.HTTP_NOT_FOUND));\n+                });\n+\n+\n+    }\n+\n+    /**\n+     * Deletes a present tenant.\n+     * <p>\n+     * Tenant modification have to be enabled in {@link MongoDbBasedTenantsConfigProperties} or exits with {@code HttpURLConnection.HTTP_FORBIDDEN}.\n+     * </p>\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param resourceVersion The identifier of the resource version to delete.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of deletion operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else. {@code HttpURLConnection.HTTP_FORBIDDEN} if modification is disabled.\n+     * @throws NullPointerException if {@code tenantId} or resourceVersion are {@code null}.\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return executeIfModificationEnabled(\n+                () -> processDeleteTenant(tenantId, resourceVersion, span),\n+                span\n+        );\n+    }\n+\n+    /**\n+     * Deletes a present tenant.\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * </p>\n+     *\n+     * @param tenantId        The identifier of the tenant.\n+     * @param resourceVersion The identifier of the resource version to delete.\n+     * @param span            The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                        An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                        parent for any spans created in this method.\n+     * @return Result of deletion operation: On success {@code HttpURLConnection.HTTP_NO_CONTENT}, http error codes else.\n+     * @throws NullPointerException if {@code tenantId} or resourceVersion are {@code null}.\n+     */\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        return MongoDbServiceUtils.isVersionEqualCurrentVersionOrNotSet(mongoClient, getConfig().getCollectionName(), tenantQuery, resourceVersion)\n+                .compose(versionEqualsORNotSet -> {\n+                    if (!versionEqualsORNotSet) {\n+                        TracingHelper.logError(span, \"Resource Version mismatch.\");\n+                        return Future.succeededFuture(Result.<Void>from(HttpURLConnection.HTTP_PRECON_FAILED));\n+                    }\n+                    final Promise<MongoClientDeleteResult> deleteTenant = Promise.promise();\n+                    mongoClient.removeDocument(getConfig().getCollectionName(), tenantQuery, deleteTenant);\n+                    return deleteTenant.future().compose(successDeleteTenant -> {\n+                        if (successDeleteTenant.getRemovedCount() == 0) {\n+                            throw new IllegalStateException(\"Entity not found.\");\n+                        } else if (successDeleteTenant.getRemovedCount() > 1) {\n+                            TracingHelper.logError(span, String.format(\"Multiple have been deleted.\"));\n+                            return Future.succeededFuture(Result.<Void>from(HttpURLConnection.HTTP_INTERNAL_ERROR));\n+                        }\n+                        // if successDeleteTenant.getRemovedCount() == 1\n+                        return Future.succeededFuture(Result.<Void>from(HttpURLConnection.HTTP_NO_CONTENT));\n+                    });\n+                })\n+                .recover(errorVersionEqualsORNotSet -> {\n+                    TracingHelper.logError(span, String.format(\"Tenant [%s] not found.\", tenantId));\n+                    return Future.succeededFuture(Result.<Void>from(HttpURLConnection.HTTP_NOT_FOUND));\n+                });\n+    }\n+\n+    /**\n+     * Fetches a tenant by tenant id.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @return Future TenantResult with {@code HttpURLConnection.HTTP_OK} if tenant found, {@code HttpURLConnection.HTTP_NOT_FOUND} else.\n+     * @throws NullPointerException if {@code tenantId} is {@code null}.\n+     */\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, null);\n+    }\n+\n+    /**\n+     * Fetches a tenant by tenant id.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param span     The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                 An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                 parent for any spans created in this method.\n+     * @return Future TenantResult with {@code HttpURLConnection.HTTP_OK} if tenant found, {@code HttpURLConnection.HTTP_NOT_FOUND} else.\n+     * @throws NullPointerException if {@code tenantId} is {@code null}.\n+     */\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return readTenant(tenantId, span)\n+                .compose(successTenantRead -> {\n+                    if (successTenantRead.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantId, successTenantRead.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())\n+                    ));\n+                });\n+    }\n+\n+    /**\n+     * Fetches a tenant by {@link X500Principal}.\n+     *\n+     * @param subjectDn The <em>subject DN</em> of the trusted CA certificate\n+     *                  that has been configured for the tenant.\n+     * @return Future TenantResult with {@code HttpURLConnection.HTTP_OK} if tenant found, {@code HttpURLConnection.HTTP_NOT_FOUND} else.\n+     * @throws NullPointerException if {@code subjectDn} is {@code null}.\n+     */\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, null);\n+    }\n+\n+    /**\n+     * Fetches a tenant by {@link X500Principal}.\n+     *\n+     * @param subjectDn The <em>subject DN</em> of the trusted CA certificate\n+     *                  that has been configured for the tenant.\n+     * @param span      The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                  An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                  parent for any spans created in this method.\n+     * @return Future TenantResult with {@code HttpURLConnection.HTTP_OK} if tenant found, {@code HttpURLConnection.HTTP_NOT_FOUND} else.\n+     * @throws NullPointerException if {@code subjectDn} is {@code null}.\n+     */\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span      The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *                  An implementation should log (error) events on this span and it may set tags and use this span as the\n+     *                  parent for any spans created in this method.\n+     * @return Future TenantResult with {@code HttpURLConnection.HTTP_OK} if tenant found, {@code HttpURLConnection.HTTP_NOT_FOUND} else.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn, final Span span) {\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            final Future<Map.Entry<String, Versioned<Tenant>>> tenantsFound = getByCa(subjectDn);\n+            return tenantsFound.compose(successTenantRead -> {\n+                if (successTenantRead == null) {\n+                    TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                    return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                } else {\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(successTenantRead.getKey(), successTenantRead.getValue().getValue(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A Future Map consisting of pair of a tenant id and a versioned tenant.\n+     */\n+    private Future<Map.Entry<String, Versioned<Tenant>>> getByCa(final X500Principal subjectDn) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc0NDU1MA=="}, "originalCommit": {"oid": "df2ef34d0416f4747a06d4f3bf515f39cb56fecf"}, "originalPosition": 435}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzExODEyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbServiceUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzowMzo0OFrOF5cF8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNjowNDowNVrOF6MdYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc3MzQyNg==", "bodyText": "This is being used in only one place inside isVersionEqualCurrentVersionOrNotSet(..). FMPOV there is no need of a separate public static method for that. Also there is already a method isVersionMatch(...) doing the same in Versioned class. IMHO this can be removed.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r395773426", "createdAt": "2020-03-20T17:03:48Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbServiceUtils.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb.utils;\n+\n+import java.util.Optional;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.model.BaseDto;\n+\n+import com.mongodb.ErrorCategory;\n+import com.mongodb.MongoException;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.MongoClient;\n+\n+@SuppressWarnings( {\"checkstyle:MissingJavadocType\", \"checkstyle:HideUtilityClassConstructor\"})\n+/**\n+ * Utility class for common functions across device registry services.\n+ */\n+public final class MongoDbServiceUtils {\n+\n+    /**\n+     * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.\n+     *\n+     * @param throwable The exception to check. Other Throwables but {@link MongoException} return {@code false}.\n+     * @return {@code true} if exception is an {@link ErrorCategory#DUPLICATE_KEY} exception.\n+     */\n+    public static boolean ifDuplicateKeyError(final Throwable throwable) {\n+        if (throwable instanceof MongoException) {\n+            final MongoException mongoException = (MongoException) throwable;\n+            return ErrorCategory.fromErrorCode(mongoException.getCode()) == ErrorCategory.DUPLICATE_KEY;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a Version is different or not set.\n+     *\n+     * @param expectedVersion new version, can unset\n+     * @param actualValue     current version\n+     * @return {@code true}, if different version or {@code expectedVersion} is unset\n+     */\n+    public static boolean isVersionDifferent(@SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\") final Optional<String> expectedVersion, final String actualValue) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a27d13e7d3f7ca4ad5514c94d2eb34e82f2b377"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxMjM0OA==", "bodyText": "Are you working on the above too?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r396512348", "createdAt": "2020-03-23T14:55:15Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbServiceUtils.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb.utils;\n+\n+import java.util.Optional;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.model.BaseDto;\n+\n+import com.mongodb.ErrorCategory;\n+import com.mongodb.MongoException;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.MongoClient;\n+\n+@SuppressWarnings( {\"checkstyle:MissingJavadocType\", \"checkstyle:HideUtilityClassConstructor\"})\n+/**\n+ * Utility class for common functions across device registry services.\n+ */\n+public final class MongoDbServiceUtils {\n+\n+    /**\n+     * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.\n+     *\n+     * @param throwable The exception to check. Other Throwables but {@link MongoException} return {@code false}.\n+     * @return {@code true} if exception is an {@link ErrorCategory#DUPLICATE_KEY} exception.\n+     */\n+    public static boolean ifDuplicateKeyError(final Throwable throwable) {\n+        if (throwable instanceof MongoException) {\n+            final MongoException mongoException = (MongoException) throwable;\n+            return ErrorCategory.fromErrorCode(mongoException.getCode()) == ErrorCategory.DUPLICATE_KEY;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a Version is different or not set.\n+     *\n+     * @param expectedVersion new version, can unset\n+     * @param actualValue     current version\n+     * @return {@code true}, if different version or {@code expectedVersion} is unset\n+     */\n+    public static boolean isVersionDifferent(@SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\") final Optional<String> expectedVersion, final String actualValue) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc3MzQyNg=="}, "originalCommit": {"oid": "6a27d13e7d3f7ca4ad5514c94d2eb34e82f2b377"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2NTg1OA==", "bodyText": "This is being used in only one place inside isVersionEqualCurrentVersionOrNotSet(..). FMPOV there is no need of a separate public static method for that. Also there is already a method isVersionMatch(...) doing the same in Versioned class. IMHO this can be removed.\n\nYou're right. done.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r396565858", "createdAt": "2020-03-23T16:04:05Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbServiceUtils.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb.utils;\n+\n+import java.util.Optional;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.model.BaseDto;\n+\n+import com.mongodb.ErrorCategory;\n+import com.mongodb.MongoException;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.MongoClient;\n+\n+@SuppressWarnings( {\"checkstyle:MissingJavadocType\", \"checkstyle:HideUtilityClassConstructor\"})\n+/**\n+ * Utility class for common functions across device registry services.\n+ */\n+public final class MongoDbServiceUtils {\n+\n+    /**\n+     * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.\n+     *\n+     * @param throwable The exception to check. Other Throwables but {@link MongoException} return {@code false}.\n+     * @return {@code true} if exception is an {@link ErrorCategory#DUPLICATE_KEY} exception.\n+     */\n+    public static boolean ifDuplicateKeyError(final Throwable throwable) {\n+        if (throwable instanceof MongoException) {\n+            final MongoException mongoException = (MongoException) throwable;\n+            return ErrorCategory.fromErrorCode(mongoException.getCode()) == ErrorCategory.DUPLICATE_KEY;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Check if a Version is different or not set.\n+     *\n+     * @param expectedVersion new version, can unset\n+     * @param actualValue     current version\n+     * @return {@code true}, if different version or {@code expectedVersion} is unset\n+     */\n+    public static boolean isVersionDifferent(@SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\") final Optional<String> expectedVersion, final String actualValue) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc3MzQyNg=="}, "originalCommit": {"oid": "6a27d13e7d3f7ca4ad5514c94d2eb34e82f2b377"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODAwMTQ3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbServiceUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNDo1NDo0MVrOF6JKqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNjowNDoyNVrOF6MeZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxMTkxMw==", "bodyText": "Could you please move the @code part to the next line and  this change is also applicable to t other javadocs.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r396511913", "createdAt": "2020-03-23T14:54:41Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbServiceUtils.java", "diffHunk": "@@ -33,7 +33,8 @@\n     /**\n      * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.\n      *\n-     * @param throwable The exception to check. Other Throwables but {@link MongoException} return {@code false}.\n+     * @param throwable The exception to check. Other Throwables but {@link MongoException} return {@code", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fb580085452491f71b368dbb192361d92c0eded5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2NjExNg==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r396566116", "createdAt": "2020-03-23T16:04:25Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbServiceUtils.java", "diffHunk": "@@ -33,7 +33,8 @@\n     /**\n      * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.\n      *\n-     * @param throwable The exception to check. Other Throwables but {@link MongoException} return {@code false}.\n+     * @param throwable The exception to check. Other Throwables but {@link MongoException} return {@code", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxMTkxMw=="}, "originalCommit": {"oid": "fb580085452491f71b368dbb192361d92c0eded5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODM3MDA5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/ApplicationConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODoxOTo1NlrOGAKXIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMjo0MzoxNlrOGATzDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgyMjk0NQ==", "bodyText": "Is there a reason why several of the existing javadocs (several other places in this class) have been reformatted? If not could you please revert back to their original state and they were already formatted.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402822945", "createdAt": "2020-04-03T08:19:56Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/ApplicationConfig.java", "diffHunk": "@@ -60,9 +61,8 @@\n     /**\n      * Exposes a Vert.x instance as a Spring bean.\n      * <p>\n-     * This method creates new Vert.x default options and invokes\n-     * {@link VertxProperties#configureVertx(VertxOptions)} on the object returned\n-     * by {@link #vertxProperties()}.\n+     * This method creates new Vert.x default options and invokes {@link VertxProperties#configureVertx(VertxOptions)}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e8d5f0692db6b9b2acd865998d2c0c6e9bf57b5"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk3NzU1MQ==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402977551", "createdAt": "2020-04-03T12:43:16Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/ApplicationConfig.java", "diffHunk": "@@ -60,9 +61,8 @@\n     /**\n      * Exposes a Vert.x instance as a Spring bean.\n      * <p>\n-     * This method creates new Vert.x default options and invokes\n-     * {@link VertxProperties#configureVertx(VertxOptions)} on the object returned\n-     * by {@link #vertxProperties()}.\n+     * This method creates new Vert.x default options and invokes {@link VertxProperties#configureVertx(VertxOptions)}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgyMjk0NQ=="}, "originalCommit": {"oid": "4e8d5f0692db6b9b2acd865998d2c0c6e9bf57b5"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODQwNTA1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/config/MongoDbBasedTenantsConfigProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODoyNTo0M1rOGAKqUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMjo0MzoxMlrOGATy8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgyNzg1OQ==", "bodyText": "How above adding more specific information in the javadoc? Something like Configuration properties for Hono's tenant service and management APIs.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402827859", "createdAt": "2020-04-03T08:25:43Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/config/MongoDbBasedTenantsConfigProperties.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb.config;\n+\n+/**\n+ * Configuration properties for Hono's device registry device API.\n+ */\n+public final class MongoDbBasedTenantsConfigProperties extends AbstractMongoDbBasedRegistryConfigProperties {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e8d5f0692db6b9b2acd865998d2c0c6e9bf57b5"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk3NzUyMA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402977520", "createdAt": "2020-04-03T12:43:12Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/config/MongoDbBasedTenantsConfigProperties.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb.config;\n+\n+/**\n+ * Configuration properties for Hono's device registry device API.\n+ */\n+public final class MongoDbBasedTenantsConfigProperties extends AbstractMongoDbBasedRegistryConfigProperties {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgyNzg1OQ=="}, "originalCommit": {"oid": "4e8d5f0692db6b9b2acd865998d2c0c6e9bf57b5"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODQ4MjYwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/TenantDto.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODozODoxN1rOGALU_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMjo0MzowNlrOGATyvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgzODc4MQ==", "bodyText": "This information about the conflict is not needed here I guess. Could you please remove those 2 lines.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402838781", "createdAt": "2020-04-03T08:38:17Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/TenantDto.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.model;\n+\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * A versioned and dated wrapper class for {@link Tenant}.\n+ */\n+public final class TenantDto extends BaseDto {\n+\n+    @JsonProperty(value = RegistryManagementConstants.FIELD_PAYLOAD_TENANT_ID, required = true)\n+    private String tenantId;\n+    @JsonProperty(RegistryManagementConstants.FIELD_TENANT)\n+    private Tenant tenant;\n+\n+    /**\n+     * Default constructor for serialisation/deserialization.\n+     */\n+    public TenantDto() {\n+        // Explicit default constructor.\n+    }\n+\n+    /**\n+     * Creates a tenant DTO from tenant id, a version, an updated timestamp and a {@link Tenant}.\n+     * \n+     * @param tenantId The tenant id.\n+     * @param tenant The tenant.\n+     * @param version The version of tenant to be sent as request header.\n+     */\n+    public TenantDto(final String tenantId, final Tenant tenant, final String version) {\n+        setTenantId(tenantId);\n+        setVersion(version);\n+        setTenant(tenant);\n+        setUpdatedOn(Instant.now());\n+    }\n+\n+    /**\n+     * Gets the tenant id.\n+     *\n+     * @return the tenant id or {@code null} if none has been set.\n+     */\n+    public String getTenantId() {\n+        return tenantId;\n+    }\n+\n+    /**\n+     * Sets the tenant id.\n+     * <p>\n+     * Have to be conflict free with present tenants.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e8d5f0692db6b9b2acd865998d2c0c6e9bf57b5"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk3NzQ3MA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402977470", "createdAt": "2020-04-03T12:43:06Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/model/TenantDto.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.model;\n+\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * A versioned and dated wrapper class for {@link Tenant}.\n+ */\n+public final class TenantDto extends BaseDto {\n+\n+    @JsonProperty(value = RegistryManagementConstants.FIELD_PAYLOAD_TENANT_ID, required = true)\n+    private String tenantId;\n+    @JsonProperty(RegistryManagementConstants.FIELD_TENANT)\n+    private Tenant tenant;\n+\n+    /**\n+     * Default constructor for serialisation/deserialization.\n+     */\n+    public TenantDto() {\n+        // Explicit default constructor.\n+    }\n+\n+    /**\n+     * Creates a tenant DTO from tenant id, a version, an updated timestamp and a {@link Tenant}.\n+     * \n+     * @param tenantId The tenant id.\n+     * @param tenant The tenant.\n+     * @param version The version of tenant to be sent as request header.\n+     */\n+    public TenantDto(final String tenantId, final Tenant tenant, final String version) {\n+        setTenantId(tenantId);\n+        setVersion(version);\n+        setTenant(tenant);\n+        setUpdatedOn(Instant.now());\n+    }\n+\n+    /**\n+     * Gets the tenant id.\n+     *\n+     * @return the tenant id or {@code null} if none has been set.\n+     */\n+    public String getTenantId() {\n+        return tenantId;\n+    }\n+\n+    /**\n+     * Sets the tenant id.\n+     * <p>\n+     * Have to be conflict free with present tenants.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjgzODc4MQ=="}, "originalCommit": {"oid": "4e8d5f0692db6b9b2acd865998d2c0c6e9bf57b5"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODUwMDUyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantBackend.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo0MTowNlrOGALegQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMjo0MzowMlrOGATykQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0MTIxNw==", "bodyText": "This annotation ConditionalOnProperty is not any more needed.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402841217", "createdAt": "2020-04-03T08:41:06Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantBackend.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantBackend;\n+import org.eclipse.hono.util.TenantResult;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Repository;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Verticle;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A tenant backend that leverages {@link MongoDbBasedTenantService}.\n+ */\n+@Repository\n+@Qualifier(\"backend\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\", matchIfMissing = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e8d5f0692db6b9b2acd865998d2c0c6e9bf57b5"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk3NzQyNQ==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402977425", "createdAt": "2020-04-03T12:43:02Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantBackend.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantBackend;\n+import org.eclipse.hono.util.TenantResult;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Repository;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Verticle;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A tenant backend that leverages {@link MongoDbBasedTenantService}.\n+ */\n+@Repository\n+@Qualifier(\"backend\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\", matchIfMissing = true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0MTIxNw=="}, "originalCommit": {"oid": "4e8d5f0692db6b9b2acd865998d2c0c6e9bf57b5"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODUxMzk1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantBackend.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo0MzoxM1rOGALlXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMjo0MzowMFrOGATydQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0Mjk3NQ==", "bodyText": "This annotation regarding unused could be removed. IDE and static code analysis shows it as unused, as it doesn't recognises that it is autowired.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402842975", "createdAt": "2020-04-03T08:43:13Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantBackend.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantBackend;\n+import org.eclipse.hono.util.TenantResult;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Repository;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Verticle;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A tenant backend that leverages {@link MongoDbBasedTenantService}.\n+ */\n+@Repository\n+@Qualifier(\"backend\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\", matchIfMissing = true)\n+public class MongoDbBasedTenantBackend extends AbstractVerticle\n+        implements TenantBackend, Verticle {\n+\n+    private final MongoDbBasedTenantService tenantService;\n+\n+    /**\n+     * Create a new instance.\n+     *\n+     * @param tenantService an implementation of tenant service.\n+     */\n+    @SuppressWarnings(\"unused\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e8d5f0692db6b9b2acd865998d2c0c6e9bf57b5"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk3NzM5Nw==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402977397", "createdAt": "2020-04-03T12:43:00Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantBackend.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantBackend;\n+import org.eclipse.hono.util.TenantResult;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\n+import org.springframework.stereotype.Repository;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Verticle;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A tenant backend that leverages {@link MongoDbBasedTenantService}.\n+ */\n+@Repository\n+@Qualifier(\"backend\")\n+@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"mongodb\", matchIfMissing = true)\n+public class MongoDbBasedTenantBackend extends AbstractVerticle\n+        implements TenantBackend, Verticle {\n+\n+    private final MongoDbBasedTenantService tenantService;\n+\n+    /**\n+     * Create a new instance.\n+     *\n+     * @param tenantService an implementation of tenant service.\n+     */\n+    @SuppressWarnings(\"unused\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg0Mjk3NQ=="}, "originalCommit": {"oid": "4e8d5f0692db6b9b2acd865998d2c0c6e9bf57b5"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODYxMDU0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1Nzo0NFrOGAMYXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMjo0Mjo1NlrOGATyUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NjAzMQ==", "bodyText": "Wrong import order, please run check-style.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402856031", "createdAt": "2020-04-03T08:57:44Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk3NzM2MQ==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402977361", "createdAt": "2020-04-03T12:42:56Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NjAzMQ=="}, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODY4NjYwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxMDowOVrOGANCcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMjo0Mjo1M1rOGATyNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2NjgwMw==", "bodyText": "In general for the overridden methods, the JavaDoc of the original methods could be used and no need for another JavaDoc in the overridden methods. The additional information could be added using {@inheritdoc}. For example, please refer to VertxBasedCoapAdapter.getTypeName().\nIn this case, I see that you have added status codes which were missing in the TenantManagementService but specified in the swagger api. I would suggest that you go ahead and update the javdoc of the TenantManagementService and remove the JavaDoc  here.\nAlso please check the JavaDocs of the other overridden methods.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402866803", "createdAt": "2020-04-03T09:10:09Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates configuration information of a tenant.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param tenantObj The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/tenants/updateTenant\"> Device Registry\n+     *      Management API - Update Tenant</a>\n+     */\n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk3NzMzNA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402977334", "createdAt": "2020-04-03T12:42:53Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates configuration information of a tenant.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param tenantObj The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/tenants/updateTenant\"> Device Registry\n+     *      Management API - Update Tenant</a>\n+     */\n+    @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2NjgwMw=="}, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODY5Nzc1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxMjo1M1rOGANJTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMjo0Mjo0N1rOGATyCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2ODU1Ng==", "bodyText": "How about also adding null check for the span too? Please also check in the other methods too.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402868556", "createdAt": "2020-04-03T09:12:53Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates configuration information of a tenant.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param tenantObj The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/tenants/updateTenant\"> Device Registry\n+     *      Management API - Update Tenant</a>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk3NzI4OA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402977288", "createdAt": "2020-04-03T12:42:47Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates configuration information of a tenant.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param tenantObj The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/tenants/updateTenant\"> Device Registry\n+     *      Management API - Update Tenant</a>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2ODU1Ng=="}, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODc0NzM3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToyNjo1MVrOGANoYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMzo1MTo1OVrOGBYuiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3NjUxNQ==", "bodyText": "If tenant identifier is not provided then UUID (getUniqueIdentifier()) is to be used.\nAlso I see, that you have generated tenant Id later in the processCreateTenant(...). It is important that is generated here and then the same  generated id is used further. As the conflict should be checked with the id that has been already generated. After that, you could create a dto and pass it to the processCreateTenant(...) similar to the processCreateDevice(...)", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402876515", "createdAt": "2020-04-03T09:26:51Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates configuration information of a tenant.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param tenantObj The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/tenants/updateTenant\"> Device Registry\n+     *      Management API - Update Tenant</a>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantUpdateQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> tenantUpdated = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.updateCollection(config.getCollectionName(), tenantUpdateQuery,\n+                new JsonObject().put(\"$set\", JsonObject.mapFrom(newTenantDto)), tenantUpdated);\n+\n+        return tenantUpdated.future()\n+                .compose(tenantUpdateResult -> {\n+                    if (tenantUpdateResult.getDocMatched() == 0) {\n+\n+                        return getTenantNotFoundOrVersionMismatch(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(OperationResult.ok(\n+                                HttpURLConnection.HTTP_NO_CONTENT,\n+                                null,\n+                                Optional.empty(),\n+                                Optional.of(newTenantDto.getVersion())));\n+                    }\n+\n+                });\n+    }\n+\n+    /**\n+     * Checks if a tenant cannot be found or tenant mismatches provided version.\n+     *\n+     * @param tenantId The tenant id to be checked.\n+     * @param resourceVersion The version to be checked.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         <li><em>500 Internal Server Error</em> if the tenant under test does not generate any of the above errors.\n+     *         This means that none of the expected standard cases happened.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    private <T extends Result<Void>> Future<T> getTenantNotFoundOrVersionMismatch(final String tenantId,\n+            final Optional<String> resourceVersion) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDto -> MongoDbDeviceRegistryUtils.checkResourceVersion(tenantDto,\n+                        resourceVersion))\n+                .compose(t -> Future.<T> failedFuture(\n+                        new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                                \"Unknown error: Should be version mismatch or tenant not found.\")))\n+                .recover(Future::failedFuture);\n+    }\n+\n+    /**\n+     * Deletes a present tenant.\n+     *\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * </p>\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param resourceVersion The identifier of the resource version to delete.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantDeleteQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientDeleteResult> deleteTenantPromise = Promise.promise();\n+        mongoClient.removeDocument(config.getCollectionName(), tenantDeleteQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDeleteResult -> {\n+                    if (tenantDeleteResult.getRemovedCount() == 0) {\n+                        return getTenantNotFoundOrVersionMismatch(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(Result.from(HttpURLConnection.HTTP_NO_CONTENT));\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return readTenant(tenantId, span)\n+                .compose(successTenantRead -> {\n+                    if (successTenantRead.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, successTenantRead.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>404 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            final Future<Map.Entry<String, Versioned<Tenant>>> tenantsFound = getByCa(subjectDn);\n+            return tenantsFound.compose(successTenantRead -> {\n+                if (successTenantRead == null) {\n+                    TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                    return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                } else {\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(successTenantRead.getKey(),\n+                                    successTenantRead.getValue().getValue(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A Future Map consisting of pair of a tenant id and a versioned tenant.\n+     */\n+    private Future<Map.Entry<String, Versioned<Tenant>>> getByCa(final X500Principal subjectDn) {\n+\n+        if (subjectDn == null) {\n+            return Future.failedFuture(\"missing subject DN\");\n+        } else {\n+            final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                    .withCa(\"tenant\", subjectDn.getName())\n+                    .document();\n+\n+            final Promise<JsonObject> tenantsFound = Promise.promise();\n+            mongoClient.findOne(getConfig().getCollectionName(), findTenantQuery, new JsonObject(), tenantsFound);\n+            return tenantsFound.future().compose(successTenantsFound -> {\n+                if (successTenantsFound == null || successTenantsFound.size() == 0) {\n+                    return Future.succeededFuture(null);\n+                }\n+                final TenantDto tenantDtoFound = successTenantsFound.mapTo(TenantDto.class);\n+                return Future.succeededFuture(\n+                        new AbstractMap.SimpleEntry<>(tenantDtoFound.getTenantId(),\n+                                new Versioned<>(tenantDtoFound.getVersion(),\n+                                        tenantDtoFound.getTenant())));\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return processReadTenant(tenantId, span)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    /**\n+     * Retrieves a tenant by tenant id.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *             An implementation should log (error) events on this span and it may set tags\n+     *             and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given ID is registered. The <em>payload</em> will contain the\n+     *         tenant's configuration information.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         </ul>\n+     * @throws NullPointerException if {@code tenantId} is {@code null}.\n+     */\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDto -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDto.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDto.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameters is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        final Promise<JsonObject> didReadTenant = Promise.promise();\n+        mongoClient.findOne(getConfig().getCollectionName(), findTenantQuery, new JsonObject(), didReadTenant);\n+        return didReadTenant.future()\n+                .compose(successDidReadTenant -> Optional.ofNullable(successDidReadTenant)\n+                        .map(tenant -> tenant.mapTo(TenantDto.class))\n+                        .map(Future::succeededFuture)\n+                        .orElseGet(() -> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Tenant [%s] not found.\", tenantId)))));\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId.orElse(\"\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 464}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk2OTQ5Mg==", "bodyText": "isAllowedToModify only uses the tenantId for a error message, which is irrelevant if it is a generated one and then dropped.\ncheckConflictingCATenants needs a tenantDto only in updateTenant, since it should ignore this tenant do avoid conflict matches with itself. tenantId conflict checks are implicit with mongoClient.insert.\nNevertheless, getUniqueIdentifier be called there instead of in processCreateTenant to make it clearer.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402969492", "createdAt": "2020-04-03T12:28:37Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates configuration information of a tenant.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param tenantObj The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/tenants/updateTenant\"> Device Registry\n+     *      Management API - Update Tenant</a>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantUpdateQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> tenantUpdated = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.updateCollection(config.getCollectionName(), tenantUpdateQuery,\n+                new JsonObject().put(\"$set\", JsonObject.mapFrom(newTenantDto)), tenantUpdated);\n+\n+        return tenantUpdated.future()\n+                .compose(tenantUpdateResult -> {\n+                    if (tenantUpdateResult.getDocMatched() == 0) {\n+\n+                        return getTenantNotFoundOrVersionMismatch(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(OperationResult.ok(\n+                                HttpURLConnection.HTTP_NO_CONTENT,\n+                                null,\n+                                Optional.empty(),\n+                                Optional.of(newTenantDto.getVersion())));\n+                    }\n+\n+                });\n+    }\n+\n+    /**\n+     * Checks if a tenant cannot be found or tenant mismatches provided version.\n+     *\n+     * @param tenantId The tenant id to be checked.\n+     * @param resourceVersion The version to be checked.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         <li><em>500 Internal Server Error</em> if the tenant under test does not generate any of the above errors.\n+     *         This means that none of the expected standard cases happened.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    private <T extends Result<Void>> Future<T> getTenantNotFoundOrVersionMismatch(final String tenantId,\n+            final Optional<String> resourceVersion) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDto -> MongoDbDeviceRegistryUtils.checkResourceVersion(tenantDto,\n+                        resourceVersion))\n+                .compose(t -> Future.<T> failedFuture(\n+                        new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                                \"Unknown error: Should be version mismatch or tenant not found.\")))\n+                .recover(Future::failedFuture);\n+    }\n+\n+    /**\n+     * Deletes a present tenant.\n+     *\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * </p>\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param resourceVersion The identifier of the resource version to delete.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantDeleteQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientDeleteResult> deleteTenantPromise = Promise.promise();\n+        mongoClient.removeDocument(config.getCollectionName(), tenantDeleteQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDeleteResult -> {\n+                    if (tenantDeleteResult.getRemovedCount() == 0) {\n+                        return getTenantNotFoundOrVersionMismatch(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(Result.from(HttpURLConnection.HTTP_NO_CONTENT));\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return readTenant(tenantId, span)\n+                .compose(successTenantRead -> {\n+                    if (successTenantRead.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, successTenantRead.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>404 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            final Future<Map.Entry<String, Versioned<Tenant>>> tenantsFound = getByCa(subjectDn);\n+            return tenantsFound.compose(successTenantRead -> {\n+                if (successTenantRead == null) {\n+                    TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                    return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                } else {\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(successTenantRead.getKey(),\n+                                    successTenantRead.getValue().getValue(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A Future Map consisting of pair of a tenant id and a versioned tenant.\n+     */\n+    private Future<Map.Entry<String, Versioned<Tenant>>> getByCa(final X500Principal subjectDn) {\n+\n+        if (subjectDn == null) {\n+            return Future.failedFuture(\"missing subject DN\");\n+        } else {\n+            final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                    .withCa(\"tenant\", subjectDn.getName())\n+                    .document();\n+\n+            final Promise<JsonObject> tenantsFound = Promise.promise();\n+            mongoClient.findOne(getConfig().getCollectionName(), findTenantQuery, new JsonObject(), tenantsFound);\n+            return tenantsFound.future().compose(successTenantsFound -> {\n+                if (successTenantsFound == null || successTenantsFound.size() == 0) {\n+                    return Future.succeededFuture(null);\n+                }\n+                final TenantDto tenantDtoFound = successTenantsFound.mapTo(TenantDto.class);\n+                return Future.succeededFuture(\n+                        new AbstractMap.SimpleEntry<>(tenantDtoFound.getTenantId(),\n+                                new Versioned<>(tenantDtoFound.getVersion(),\n+                                        tenantDtoFound.getTenant())));\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return processReadTenant(tenantId, span)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    /**\n+     * Retrieves a tenant by tenant id.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *             An implementation should log (error) events on this span and it may set tags\n+     *             and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given ID is registered. The <em>payload</em> will contain the\n+     *         tenant's configuration information.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         </ul>\n+     * @throws NullPointerException if {@code tenantId} is {@code null}.\n+     */\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDto -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDto.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDto.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameters is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        final Promise<JsonObject> didReadTenant = Promise.promise();\n+        mongoClient.findOne(getConfig().getCollectionName(), findTenantQuery, new JsonObject(), didReadTenant);\n+        return didReadTenant.future()\n+                .compose(successDidReadTenant -> Optional.ofNullable(successDidReadTenant)\n+                        .map(tenant -> tenant.mapTo(TenantDto.class))\n+                        .map(Future::succeededFuture)\n+                        .orElseGet(() -> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Tenant [%s] not found.\", tenantId)))));\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId.orElse(\"\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3NjUxNQ=="}, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 464}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE2OTI0MA==", "bodyText": "isAllowedToModify only uses the tenantId for a error message, which is irrelevant if it is a generated one and then dropped.\n\nIn that case, instead of using an empty string as the tenant id, how about invoking isAllowedToModify only when tenant id exists else not.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r403169240", "createdAt": "2020-04-03T17:24:30Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates configuration information of a tenant.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param tenantObj The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/tenants/updateTenant\"> Device Registry\n+     *      Management API - Update Tenant</a>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantUpdateQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> tenantUpdated = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.updateCollection(config.getCollectionName(), tenantUpdateQuery,\n+                new JsonObject().put(\"$set\", JsonObject.mapFrom(newTenantDto)), tenantUpdated);\n+\n+        return tenantUpdated.future()\n+                .compose(tenantUpdateResult -> {\n+                    if (tenantUpdateResult.getDocMatched() == 0) {\n+\n+                        return getTenantNotFoundOrVersionMismatch(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(OperationResult.ok(\n+                                HttpURLConnection.HTTP_NO_CONTENT,\n+                                null,\n+                                Optional.empty(),\n+                                Optional.of(newTenantDto.getVersion())));\n+                    }\n+\n+                });\n+    }\n+\n+    /**\n+     * Checks if a tenant cannot be found or tenant mismatches provided version.\n+     *\n+     * @param tenantId The tenant id to be checked.\n+     * @param resourceVersion The version to be checked.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         <li><em>500 Internal Server Error</em> if the tenant under test does not generate any of the above errors.\n+     *         This means that none of the expected standard cases happened.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    private <T extends Result<Void>> Future<T> getTenantNotFoundOrVersionMismatch(final String tenantId,\n+            final Optional<String> resourceVersion) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDto -> MongoDbDeviceRegistryUtils.checkResourceVersion(tenantDto,\n+                        resourceVersion))\n+                .compose(t -> Future.<T> failedFuture(\n+                        new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                                \"Unknown error: Should be version mismatch or tenant not found.\")))\n+                .recover(Future::failedFuture);\n+    }\n+\n+    /**\n+     * Deletes a present tenant.\n+     *\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * </p>\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param resourceVersion The identifier of the resource version to delete.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantDeleteQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientDeleteResult> deleteTenantPromise = Promise.promise();\n+        mongoClient.removeDocument(config.getCollectionName(), tenantDeleteQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDeleteResult -> {\n+                    if (tenantDeleteResult.getRemovedCount() == 0) {\n+                        return getTenantNotFoundOrVersionMismatch(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(Result.from(HttpURLConnection.HTTP_NO_CONTENT));\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return readTenant(tenantId, span)\n+                .compose(successTenantRead -> {\n+                    if (successTenantRead.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, successTenantRead.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>404 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            final Future<Map.Entry<String, Versioned<Tenant>>> tenantsFound = getByCa(subjectDn);\n+            return tenantsFound.compose(successTenantRead -> {\n+                if (successTenantRead == null) {\n+                    TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                    return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                } else {\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(successTenantRead.getKey(),\n+                                    successTenantRead.getValue().getValue(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A Future Map consisting of pair of a tenant id and a versioned tenant.\n+     */\n+    private Future<Map.Entry<String, Versioned<Tenant>>> getByCa(final X500Principal subjectDn) {\n+\n+        if (subjectDn == null) {\n+            return Future.failedFuture(\"missing subject DN\");\n+        } else {\n+            final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                    .withCa(\"tenant\", subjectDn.getName())\n+                    .document();\n+\n+            final Promise<JsonObject> tenantsFound = Promise.promise();\n+            mongoClient.findOne(getConfig().getCollectionName(), findTenantQuery, new JsonObject(), tenantsFound);\n+            return tenantsFound.future().compose(successTenantsFound -> {\n+                if (successTenantsFound == null || successTenantsFound.size() == 0) {\n+                    return Future.succeededFuture(null);\n+                }\n+                final TenantDto tenantDtoFound = successTenantsFound.mapTo(TenantDto.class);\n+                return Future.succeededFuture(\n+                        new AbstractMap.SimpleEntry<>(tenantDtoFound.getTenantId(),\n+                                new Versioned<>(tenantDtoFound.getVersion(),\n+                                        tenantDtoFound.getTenant())));\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return processReadTenant(tenantId, span)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    /**\n+     * Retrieves a tenant by tenant id.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *             An implementation should log (error) events on this span and it may set tags\n+     *             and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given ID is registered. The <em>payload</em> will contain the\n+     *         tenant's configuration information.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         </ul>\n+     * @throws NullPointerException if {@code tenantId} is {@code null}.\n+     */\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDto -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDto.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDto.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameters is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        final Promise<JsonObject> didReadTenant = Promise.promise();\n+        mongoClient.findOne(getConfig().getCollectionName(), findTenantQuery, new JsonObject(), didReadTenant);\n+        return didReadTenant.future()\n+                .compose(successDidReadTenant -> Optional.ofNullable(successDidReadTenant)\n+                        .map(tenant -> tenant.mapTo(TenantDto.class))\n+                        .map(Future::succeededFuture)\n+                        .orElseGet(() -> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Tenant [%s] not found.\", tenantId)))));\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId.orElse(\"\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3NjUxNQ=="}, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 464}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwNjg4OA==", "bodyText": "That would be wrong, since the allowance does not depend on the tenantId.\ntenantId  is now generated in createTenant before the isAllowedToModify call.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r404106888", "createdAt": "2020-04-06T13:51:59Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates configuration information of a tenant.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param tenantObj The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/tenants/updateTenant\"> Device Registry\n+     *      Management API - Update Tenant</a>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantUpdateQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> tenantUpdated = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.updateCollection(config.getCollectionName(), tenantUpdateQuery,\n+                new JsonObject().put(\"$set\", JsonObject.mapFrom(newTenantDto)), tenantUpdated);\n+\n+        return tenantUpdated.future()\n+                .compose(tenantUpdateResult -> {\n+                    if (tenantUpdateResult.getDocMatched() == 0) {\n+\n+                        return getTenantNotFoundOrVersionMismatch(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(OperationResult.ok(\n+                                HttpURLConnection.HTTP_NO_CONTENT,\n+                                null,\n+                                Optional.empty(),\n+                                Optional.of(newTenantDto.getVersion())));\n+                    }\n+\n+                });\n+    }\n+\n+    /**\n+     * Checks if a tenant cannot be found or tenant mismatches provided version.\n+     *\n+     * @param tenantId The tenant id to be checked.\n+     * @param resourceVersion The version to be checked.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         <li><em>500 Internal Server Error</em> if the tenant under test does not generate any of the above errors.\n+     *         This means that none of the expected standard cases happened.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    private <T extends Result<Void>> Future<T> getTenantNotFoundOrVersionMismatch(final String tenantId,\n+            final Optional<String> resourceVersion) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDto -> MongoDbDeviceRegistryUtils.checkResourceVersion(tenantDto,\n+                        resourceVersion))\n+                .compose(t -> Future.<T> failedFuture(\n+                        new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                                \"Unknown error: Should be version mismatch or tenant not found.\")))\n+                .recover(Future::failedFuture);\n+    }\n+\n+    /**\n+     * Deletes a present tenant.\n+     *\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * </p>\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param resourceVersion The identifier of the resource version to delete.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantDeleteQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientDeleteResult> deleteTenantPromise = Promise.promise();\n+        mongoClient.removeDocument(config.getCollectionName(), tenantDeleteQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDeleteResult -> {\n+                    if (tenantDeleteResult.getRemovedCount() == 0) {\n+                        return getTenantNotFoundOrVersionMismatch(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(Result.from(HttpURLConnection.HTTP_NO_CONTENT));\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return readTenant(tenantId, span)\n+                .compose(successTenantRead -> {\n+                    if (successTenantRead.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, successTenantRead.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>404 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            final Future<Map.Entry<String, Versioned<Tenant>>> tenantsFound = getByCa(subjectDn);\n+            return tenantsFound.compose(successTenantRead -> {\n+                if (successTenantRead == null) {\n+                    TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                    return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                } else {\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(successTenantRead.getKey(),\n+                                    successTenantRead.getValue().getValue(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A Future Map consisting of pair of a tenant id and a versioned tenant.\n+     */\n+    private Future<Map.Entry<String, Versioned<Tenant>>> getByCa(final X500Principal subjectDn) {\n+\n+        if (subjectDn == null) {\n+            return Future.failedFuture(\"missing subject DN\");\n+        } else {\n+            final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                    .withCa(\"tenant\", subjectDn.getName())\n+                    .document();\n+\n+            final Promise<JsonObject> tenantsFound = Promise.promise();\n+            mongoClient.findOne(getConfig().getCollectionName(), findTenantQuery, new JsonObject(), tenantsFound);\n+            return tenantsFound.future().compose(successTenantsFound -> {\n+                if (successTenantsFound == null || successTenantsFound.size() == 0) {\n+                    return Future.succeededFuture(null);\n+                }\n+                final TenantDto tenantDtoFound = successTenantsFound.mapTo(TenantDto.class);\n+                return Future.succeededFuture(\n+                        new AbstractMap.SimpleEntry<>(tenantDtoFound.getTenantId(),\n+                                new Versioned<>(tenantDtoFound.getVersion(),\n+                                        tenantDtoFound.getTenant())));\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return processReadTenant(tenantId, span)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    /**\n+     * Retrieves a tenant by tenant id.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *             An implementation should log (error) events on this span and it may set tags\n+     *             and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given ID is registered. The <em>payload</em> will contain the\n+     *         tenant's configuration information.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         </ul>\n+     * @throws NullPointerException if {@code tenantId} is {@code null}.\n+     */\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDto -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDto.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDto.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameters is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        final Promise<JsonObject> didReadTenant = Promise.promise();\n+        mongoClient.findOne(getConfig().getCollectionName(), findTenantQuery, new JsonObject(), didReadTenant);\n+        return didReadTenant.future()\n+                .compose(successDidReadTenant -> Optional.ofNullable(successDidReadTenant)\n+                        .map(tenant -> tenant.mapTo(TenantDto.class))\n+                        .map(Future::succeededFuture)\n+                        .orElseGet(() -> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Tenant [%s] not found.\", tenantId)))));\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId.orElse(\"\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3NjUxNQ=="}, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 464}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODc2MTgxOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTozMDo0OFrOGANxUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMjo0Mjo0MFrOGATxwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3ODgwMQ==", "bodyText": "How about a more relevant variable name? Something like addTenantPromise or so?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402878801", "createdAt": "2020-04-03T09:30:48Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates configuration information of a tenant.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param tenantObj The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/tenants/updateTenant\"> Device Registry\n+     *      Management API - Update Tenant</a>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantUpdateQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> tenantUpdated = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.updateCollection(config.getCollectionName(), tenantUpdateQuery,\n+                new JsonObject().put(\"$set\", JsonObject.mapFrom(newTenantDto)), tenantUpdated);\n+\n+        return tenantUpdated.future()\n+                .compose(tenantUpdateResult -> {\n+                    if (tenantUpdateResult.getDocMatched() == 0) {\n+\n+                        return getTenantNotFoundOrVersionMismatch(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(OperationResult.ok(\n+                                HttpURLConnection.HTTP_NO_CONTENT,\n+                                null,\n+                                Optional.empty(),\n+                                Optional.of(newTenantDto.getVersion())));\n+                    }\n+\n+                });\n+    }\n+\n+    /**\n+     * Checks if a tenant cannot be found or tenant mismatches provided version.\n+     *\n+     * @param tenantId The tenant id to be checked.\n+     * @param resourceVersion The version to be checked.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         <li><em>500 Internal Server Error</em> if the tenant under test does not generate any of the above errors.\n+     *         This means that none of the expected standard cases happened.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    private <T extends Result<Void>> Future<T> getTenantNotFoundOrVersionMismatch(final String tenantId,\n+            final Optional<String> resourceVersion) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDto -> MongoDbDeviceRegistryUtils.checkResourceVersion(tenantDto,\n+                        resourceVersion))\n+                .compose(t -> Future.<T> failedFuture(\n+                        new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                                \"Unknown error: Should be version mismatch or tenant not found.\")))\n+                .recover(Future::failedFuture);\n+    }\n+\n+    /**\n+     * Deletes a present tenant.\n+     *\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * </p>\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param resourceVersion The identifier of the resource version to delete.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantDeleteQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientDeleteResult> deleteTenantPromise = Promise.promise();\n+        mongoClient.removeDocument(config.getCollectionName(), tenantDeleteQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDeleteResult -> {\n+                    if (tenantDeleteResult.getRemovedCount() == 0) {\n+                        return getTenantNotFoundOrVersionMismatch(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(Result.from(HttpURLConnection.HTTP_NO_CONTENT));\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return readTenant(tenantId, span)\n+                .compose(successTenantRead -> {\n+                    if (successTenantRead.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, successTenantRead.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>404 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            final Future<Map.Entry<String, Versioned<Tenant>>> tenantsFound = getByCa(subjectDn);\n+            return tenantsFound.compose(successTenantRead -> {\n+                if (successTenantRead == null) {\n+                    TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                    return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                } else {\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(successTenantRead.getKey(),\n+                                    successTenantRead.getValue().getValue(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A Future Map consisting of pair of a tenant id and a versioned tenant.\n+     */\n+    private Future<Map.Entry<String, Versioned<Tenant>>> getByCa(final X500Principal subjectDn) {\n+\n+        if (subjectDn == null) {\n+            return Future.failedFuture(\"missing subject DN\");\n+        } else {\n+            final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                    .withCa(\"tenant\", subjectDn.getName())\n+                    .document();\n+\n+            final Promise<JsonObject> tenantsFound = Promise.promise();\n+            mongoClient.findOne(getConfig().getCollectionName(), findTenantQuery, new JsonObject(), tenantsFound);\n+            return tenantsFound.future().compose(successTenantsFound -> {\n+                if (successTenantsFound == null || successTenantsFound.size() == 0) {\n+                    return Future.succeededFuture(null);\n+                }\n+                final TenantDto tenantDtoFound = successTenantsFound.mapTo(TenantDto.class);\n+                return Future.succeededFuture(\n+                        new AbstractMap.SimpleEntry<>(tenantDtoFound.getTenantId(),\n+                                new Versioned<>(tenantDtoFound.getVersion(),\n+                                        tenantDtoFound.getTenant())));\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return processReadTenant(tenantId, span)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    /**\n+     * Retrieves a tenant by tenant id.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *             An implementation should log (error) events on this span and it may set tags\n+     *             and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given ID is registered. The <em>payload</em> will contain the\n+     *         tenant's configuration information.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         </ul>\n+     * @throws NullPointerException if {@code tenantId} is {@code null}.\n+     */\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDto -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDto.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDto.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameters is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        final Promise<JsonObject> didReadTenant = Promise.promise();\n+        mongoClient.findOne(getConfig().getCollectionName(), findTenantQuery, new JsonObject(), didReadTenant);\n+        return didReadTenant.future()\n+                .compose(successDidReadTenant -> Optional.ofNullable(successDidReadTenant)\n+                        .map(tenant -> tenant.mapTo(TenantDto.class))\n+                        .map(Future::succeededFuture)\n+                        .orElseGet(() -> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Tenant [%s] not found.\", tenantId)))));\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId.orElse(\"\"))\n+                .compose(ok -> checkConflictingCATenants(Optional.empty(),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(ok -> processCreateTenant(tenantId, tenantObj, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    /**\n+     * Inserts a tenant into the device registry.\n+     * <p>\n+     * Optional: A tenant id can be provided. If none is set, a UUID will be created. A provided <em>certificate\n+     * authority</em> must not be set in other tenants.\n+     * </p>\n+     *\n+     * @param tenantId The identifier of the tenant to create.\n+     * @param tenantObj The configuration information to add for the tenant (may be {@code null}).\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *             An implementation should log (error) events on this span and it may set tags\n+     *             and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>201 Created</em> if the tenant has been added successfully.</li>\n+     *         <li><em>409 Conflict</em> if a tenant with the given\n+     *         identifier or certificate authority already exists.</li>\n+     *         <li><em>500 Internal Server Error</em> if tenants cannot be accessed.</li>\n+     *         </ul>\n+     * @throws NullPointerException if {@code tenantId} or {@code tenantObj} are {@code null}.\n+     */\n+    private Future<OperationResult<Id>> processCreateTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        final String tenantIdOrGenerated = tenantId.orElse(DeviceRegistryUtils.getUniqueIdentifier());\n+        final TenantDto newTenantDto = new TenantDto(tenantIdOrGenerated, tenantObj,\n+                new Versioned<>(tenantObj).getVersion());\n+\n+        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+        final Promise<String> getTenantInsertion = Promise.promise();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 503}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk3NzIxNw==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402977217", "createdAt": "2020-04-03T12:42:40Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates configuration information of a tenant.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param tenantObj The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/tenants/updateTenant\"> Device Registry\n+     *      Management API - Update Tenant</a>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantUpdateQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> tenantUpdated = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.updateCollection(config.getCollectionName(), tenantUpdateQuery,\n+                new JsonObject().put(\"$set\", JsonObject.mapFrom(newTenantDto)), tenantUpdated);\n+\n+        return tenantUpdated.future()\n+                .compose(tenantUpdateResult -> {\n+                    if (tenantUpdateResult.getDocMatched() == 0) {\n+\n+                        return getTenantNotFoundOrVersionMismatch(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(OperationResult.ok(\n+                                HttpURLConnection.HTTP_NO_CONTENT,\n+                                null,\n+                                Optional.empty(),\n+                                Optional.of(newTenantDto.getVersion())));\n+                    }\n+\n+                });\n+    }\n+\n+    /**\n+     * Checks if a tenant cannot be found or tenant mismatches provided version.\n+     *\n+     * @param tenantId The tenant id to be checked.\n+     * @param resourceVersion The version to be checked.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         <li><em>500 Internal Server Error</em> if the tenant under test does not generate any of the above errors.\n+     *         This means that none of the expected standard cases happened.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    private <T extends Result<Void>> Future<T> getTenantNotFoundOrVersionMismatch(final String tenantId,\n+            final Optional<String> resourceVersion) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDto -> MongoDbDeviceRegistryUtils.checkResourceVersion(tenantDto,\n+                        resourceVersion))\n+                .compose(t -> Future.<T> failedFuture(\n+                        new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                                \"Unknown error: Should be version mismatch or tenant not found.\")))\n+                .recover(Future::failedFuture);\n+    }\n+\n+    /**\n+     * Deletes a present tenant.\n+     *\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * </p>\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param resourceVersion The identifier of the resource version to delete.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantDeleteQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientDeleteResult> deleteTenantPromise = Promise.promise();\n+        mongoClient.removeDocument(config.getCollectionName(), tenantDeleteQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDeleteResult -> {\n+                    if (tenantDeleteResult.getRemovedCount() == 0) {\n+                        return getTenantNotFoundOrVersionMismatch(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(Result.from(HttpURLConnection.HTTP_NO_CONTENT));\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return readTenant(tenantId, span)\n+                .compose(successTenantRead -> {\n+                    if (successTenantRead.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, successTenantRead.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>404 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            final Future<Map.Entry<String, Versioned<Tenant>>> tenantsFound = getByCa(subjectDn);\n+            return tenantsFound.compose(successTenantRead -> {\n+                if (successTenantRead == null) {\n+                    TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                    return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                } else {\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(successTenantRead.getKey(),\n+                                    successTenantRead.getValue().getValue(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A Future Map consisting of pair of a tenant id and a versioned tenant.\n+     */\n+    private Future<Map.Entry<String, Versioned<Tenant>>> getByCa(final X500Principal subjectDn) {\n+\n+        if (subjectDn == null) {\n+            return Future.failedFuture(\"missing subject DN\");\n+        } else {\n+            final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                    .withCa(\"tenant\", subjectDn.getName())\n+                    .document();\n+\n+            final Promise<JsonObject> tenantsFound = Promise.promise();\n+            mongoClient.findOne(getConfig().getCollectionName(), findTenantQuery, new JsonObject(), tenantsFound);\n+            return tenantsFound.future().compose(successTenantsFound -> {\n+                if (successTenantsFound == null || successTenantsFound.size() == 0) {\n+                    return Future.succeededFuture(null);\n+                }\n+                final TenantDto tenantDtoFound = successTenantsFound.mapTo(TenantDto.class);\n+                return Future.succeededFuture(\n+                        new AbstractMap.SimpleEntry<>(tenantDtoFound.getTenantId(),\n+                                new Versioned<>(tenantDtoFound.getVersion(),\n+                                        tenantDtoFound.getTenant())));\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return processReadTenant(tenantId, span)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    /**\n+     * Retrieves a tenant by tenant id.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *             An implementation should log (error) events on this span and it may set tags\n+     *             and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given ID is registered. The <em>payload</em> will contain the\n+     *         tenant's configuration information.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         </ul>\n+     * @throws NullPointerException if {@code tenantId} is {@code null}.\n+     */\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDto -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDto.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDto.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameters is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        final Promise<JsonObject> didReadTenant = Promise.promise();\n+        mongoClient.findOne(getConfig().getCollectionName(), findTenantQuery, new JsonObject(), didReadTenant);\n+        return didReadTenant.future()\n+                .compose(successDidReadTenant -> Optional.ofNullable(successDidReadTenant)\n+                        .map(tenant -> tenant.mapTo(TenantDto.class))\n+                        .map(Future::succeededFuture)\n+                        .orElseGet(() -> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Tenant [%s] not found.\", tenantId)))));\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId.orElse(\"\"))\n+                .compose(ok -> checkConflictingCATenants(Optional.empty(),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(ok -> processCreateTenant(tenantId, tenantObj, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    /**\n+     * Inserts a tenant into the device registry.\n+     * <p>\n+     * Optional: A tenant id can be provided. If none is set, a UUID will be created. A provided <em>certificate\n+     * authority</em> must not be set in other tenants.\n+     * </p>\n+     *\n+     * @param tenantId The identifier of the tenant to create.\n+     * @param tenantObj The configuration information to add for the tenant (may be {@code null}).\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *             An implementation should log (error) events on this span and it may set tags\n+     *             and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>201 Created</em> if the tenant has been added successfully.</li>\n+     *         <li><em>409 Conflict</em> if a tenant with the given\n+     *         identifier or certificate authority already exists.</li>\n+     *         <li><em>500 Internal Server Error</em> if tenants cannot be accessed.</li>\n+     *         </ul>\n+     * @throws NullPointerException if {@code tenantId} or {@code tenantObj} are {@code null}.\n+     */\n+    private Future<OperationResult<Id>> processCreateTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+\n+        final String tenantIdOrGenerated = tenantId.orElse(DeviceRegistryUtils.getUniqueIdentifier());\n+        final TenantDto newTenantDto = new TenantDto(tenantIdOrGenerated, tenantObj,\n+                new Versioned<>(tenantObj).getVersion());\n+\n+        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+        final Promise<String> getTenantInsertion = Promise.promise();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3ODgwMQ=="}, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 503}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODgyODI1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTo0OTowOFrOGAOZfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMjo0MjozN1rOGATxqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg4OTA4Ng==", "bodyText": "Please use NoopSpan.INSTANCE instead of null.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402889086", "createdAt": "2020-04-03T09:49:08Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates configuration information of a tenant.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param tenantObj The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/tenants/updateTenant\"> Device Registry\n+     *      Management API - Update Tenant</a>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantUpdateQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> tenantUpdated = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.updateCollection(config.getCollectionName(), tenantUpdateQuery,\n+                new JsonObject().put(\"$set\", JsonObject.mapFrom(newTenantDto)), tenantUpdated);\n+\n+        return tenantUpdated.future()\n+                .compose(tenantUpdateResult -> {\n+                    if (tenantUpdateResult.getDocMatched() == 0) {\n+\n+                        return getTenantNotFoundOrVersionMismatch(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(OperationResult.ok(\n+                                HttpURLConnection.HTTP_NO_CONTENT,\n+                                null,\n+                                Optional.empty(),\n+                                Optional.of(newTenantDto.getVersion())));\n+                    }\n+\n+                });\n+    }\n+\n+    /**\n+     * Checks if a tenant cannot be found or tenant mismatches provided version.\n+     *\n+     * @param tenantId The tenant id to be checked.\n+     * @param resourceVersion The version to be checked.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         <li><em>500 Internal Server Error</em> if the tenant under test does not generate any of the above errors.\n+     *         This means that none of the expected standard cases happened.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    private <T extends Result<Void>> Future<T> getTenantNotFoundOrVersionMismatch(final String tenantId,\n+            final Optional<String> resourceVersion) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDto -> MongoDbDeviceRegistryUtils.checkResourceVersion(tenantDto,\n+                        resourceVersion))\n+                .compose(t -> Future.<T> failedFuture(\n+                        new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                                \"Unknown error: Should be version mismatch or tenant not found.\")))\n+                .recover(Future::failedFuture);\n+    }\n+\n+    /**\n+     * Deletes a present tenant.\n+     *\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * </p>\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param resourceVersion The identifier of the resource version to delete.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantDeleteQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientDeleteResult> deleteTenantPromise = Promise.promise();\n+        mongoClient.removeDocument(config.getCollectionName(), tenantDeleteQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDeleteResult -> {\n+                    if (tenantDeleteResult.getRemovedCount() == 0) {\n+                        return getTenantNotFoundOrVersionMismatch(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(Result.from(HttpURLConnection.HTTP_NO_CONTENT));\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return readTenant(tenantId, span)\n+                .compose(successTenantRead -> {\n+                    if (successTenantRead.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, successTenantRead.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk3NzE5NA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402977194", "createdAt": "2020-04-03T12:42:37Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * Updates configuration information of a tenant.\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param tenantObj The updated configuration information for the tenant (may be {@code null}).\n+     * @param resourceVersion The identifier of the resource version to update.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/tenants/updateTenant\"> Device Registry\n+     *      Management API - Update Tenant</a>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantUpdateQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> tenantUpdated = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.updateCollection(config.getCollectionName(), tenantUpdateQuery,\n+                new JsonObject().put(\"$set\", JsonObject.mapFrom(newTenantDto)), tenantUpdated);\n+\n+        return tenantUpdated.future()\n+                .compose(tenantUpdateResult -> {\n+                    if (tenantUpdateResult.getDocMatched() == 0) {\n+\n+                        return getTenantNotFoundOrVersionMismatch(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(OperationResult.ok(\n+                                HttpURLConnection.HTTP_NO_CONTENT,\n+                                null,\n+                                Optional.empty(),\n+                                Optional.of(newTenantDto.getVersion())));\n+                    }\n+\n+                });\n+    }\n+\n+    /**\n+     * Checks if a tenant cannot be found or tenant mismatches provided version.\n+     *\n+     * @param tenantId The tenant id to be checked.\n+     * @param resourceVersion The version to be checked.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         <li><em>500 Internal Server Error</em> if the tenant under test does not generate any of the above errors.\n+     *         This means that none of the expected standard cases happened.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    private <T extends Result<Void>> Future<T> getTenantNotFoundOrVersionMismatch(final String tenantId,\n+            final Optional<String> resourceVersion) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDto -> MongoDbDeviceRegistryUtils.checkResourceVersion(tenantDto,\n+                        resourceVersion))\n+                .compose(t -> Future.<T> failedFuture(\n+                        new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                                \"Unknown error: Should be version mismatch or tenant not found.\")))\n+                .recover(Future::failedFuture);\n+    }\n+\n+    /**\n+     * Deletes a present tenant.\n+     *\n+     * <p>\n+     * Provided version {@code resourceVersion} have to be empty or equal to the version of present tenant.\n+     * </p>\n+     *\n+     * @param tenantId The identifier of the tenant.\n+     * @param resourceVersion The identifier of the resource version to delete.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantDeleteQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientDeleteResult> deleteTenantPromise = Promise.promise();\n+        mongoClient.removeDocument(config.getCollectionName(), tenantDeleteQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDeleteResult -> {\n+                    if (tenantDeleteResult.getRemovedCount() == 0) {\n+                        return getTenantNotFoundOrVersionMismatch(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(Result.from(HttpURLConnection.HTTP_NO_CONTENT));\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return readTenant(tenantId, span)\n+                .compose(successTenantRead -> {\n+                    if (successTenantRead.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, successTenantRead.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg4OTA4Ng=="}, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 317}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODg0NjI2OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTo1NDowNlrOGAOkvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMjo0MjozNFrOGATxkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5MTk2Nw==", "bodyText": "Wrong import order, please run check-style.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402891967", "createdAt": "2020-04-03T09:54:06Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "diffHunk": "@@ -26,6 +28,9 @@\n import io.opentracing.Span;\n import io.vertx.core.Future;\n \n+import com.mongodb.ErrorCategory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk3NzE2OA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402977168", "createdAt": "2020-04-03T12:42:34Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "diffHunk": "@@ -26,6 +28,9 @@\n import io.opentracing.Span;\n import io.vertx.core.Future;\n \n+import com.mongodb.ErrorCategory;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5MTk2Nw=="}, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODg1NTIzOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTo1NjozOFrOGAOqeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMjo0MjozMVrOGATxdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5MzQzNA==", "bodyText": "How about more meaningful variable name like error? Missing null check Objects.requireNonNull(error);.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402893434", "createdAt": "2020-04-03T09:56:38Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "diffHunk": "@@ -97,4 +102,43 @@ private MongoDbDeviceRegistryUtils() {\n         }\n         return OperationResult.empty(HttpURLConnection.HTTP_INTERNAL_ERROR);\n     }\n+\n+    /**\n+     * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.\n+     *\n+     * @param throwable The exception to check. Other Throwables but {@link MongoException} return {@code false}.\n+     * @return {@code true} if exception is an {@link ErrorCategory#DUPLICATE_KEY} exception.\n+     */\n+    public static boolean ifDuplicateKeyError(final Throwable throwable) {\n+        if (throwable instanceof MongoException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk3NzE0MQ==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402977141", "createdAt": "2020-04-03T12:42:31Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "diffHunk": "@@ -97,4 +102,43 @@ private MongoDbDeviceRegistryUtils() {\n         }\n         return OperationResult.empty(HttpURLConnection.HTTP_INTERNAL_ERROR);\n     }\n+\n+    /**\n+     * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.\n+     *\n+     * @param throwable The exception to check. Other Throwables but {@link MongoException} return {@code false}.\n+     * @return {@code true} if exception is an {@link ErrorCategory#DUPLICATE_KEY} exception.\n+     */\n+    public static boolean ifDuplicateKeyError(final Throwable throwable) {\n+        if (throwable instanceof MongoException) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg5MzQzNA=="}, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODkwMzgyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMDoxMDo1M1rOGAPJYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMzo1MjoyMlrOGBYvjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwMTM0NA==", "bodyText": "It is being used only in one place inside MongoDbBasedTenantService.getTenantNotFoundOrVersionMismatch(...) and hence it can be removed from here. Also my suggestion is to remove this method and move the version check inside the getTenantNotFoundOrVersionMismatch(...) as in the MongoDbBasedRegistrationService.checkForVersionMismatchAndFail(...). Meanwhile I will check how this method checkForVersionMismatchAndFail(...) could be pulled up to util class so that it can be used also for tenant and credentials services.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402901344", "createdAt": "2020-04-03T10:10:53Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "diffHunk": "@@ -97,4 +102,43 @@ private MongoDbDeviceRegistryUtils() {\n         }\n         return OperationResult.empty(HttpURLConnection.HTTP_INTERNAL_ERROR);\n     }\n+\n+    /**\n+     * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.\n+     *\n+     * @param throwable The exception to check. Other Throwables but {@link MongoException} return {@code false}.\n+     * @return {@code true} if exception is an {@link ErrorCategory#DUPLICATE_KEY} exception.\n+     */\n+    public static boolean ifDuplicateKeyError(final Throwable throwable) {\n+        if (throwable instanceof MongoException) {\n+            final MongoException mongoException = (MongoException) throwable;\n+            return ErrorCategory.fromErrorCode(mongoException.getCode()) == ErrorCategory.DUPLICATE_KEY;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks if this version matches the provided version.\n+     *\n+     * @param <T> The type of the resource.\n+     * @param resourceDto The data transfer object of the resource.\n+     * @param resourceVersion The version of the resource to be matched with that of the existing one.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future will succeed if the version matches. Otherwise the future will fail with a\n+     *         {@link ServiceInvocationException}.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    public static <T extends BaseDto> Future<T> checkResourceVersion(final T resourceDto,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk3Njk5Mg==", "bodyText": "done and adapted to the method MongoDbBasedRegistrationService.checkForVersionMismatchAndFail.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402976992", "createdAt": "2020-04-03T12:42:13Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "diffHunk": "@@ -97,4 +102,43 @@ private MongoDbDeviceRegistryUtils() {\n         }\n         return OperationResult.empty(HttpURLConnection.HTTP_INTERNAL_ERROR);\n     }\n+\n+    /**\n+     * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.\n+     *\n+     * @param throwable The exception to check. Other Throwables but {@link MongoException} return {@code false}.\n+     * @return {@code true} if exception is an {@link ErrorCategory#DUPLICATE_KEY} exception.\n+     */\n+    public static boolean ifDuplicateKeyError(final Throwable throwable) {\n+        if (throwable instanceof MongoException) {\n+            final MongoException mongoException = (MongoException) throwable;\n+            return ErrorCategory.fromErrorCode(mongoException.getCode()) == ErrorCategory.DUPLICATE_KEY;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks if this version matches the provided version.\n+     *\n+     * @param <T> The type of the resource.\n+     * @param resourceDto The data transfer object of the resource.\n+     * @param resourceVersion The version of the resource to be matched with that of the existing one.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future will succeed if the version matches. Otherwise the future will fail with a\n+     *         {@link ServiceInvocationException}.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    public static <T extends BaseDto> Future<T> checkResourceVersion(final T resourceDto,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwMTM0NA=="}, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkxNTQxNw==", "bodyText": "Meanwhile I will check how this method checkForVersionMismatchAndFail(...) could be pulled up to util class so that it can be used also for tenant and credentials services.\n\nThis method has been pulled up now to MongoDbDeviceRegistryUtils. You could use that and remove the method definition from MongoDbBasedRegistrationService.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r403915417", "createdAt": "2020-04-06T08:30:43Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "diffHunk": "@@ -97,4 +102,43 @@ private MongoDbDeviceRegistryUtils() {\n         }\n         return OperationResult.empty(HttpURLConnection.HTTP_INTERNAL_ERROR);\n     }\n+\n+    /**\n+     * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.\n+     *\n+     * @param throwable The exception to check. Other Throwables but {@link MongoException} return {@code false}.\n+     * @return {@code true} if exception is an {@link ErrorCategory#DUPLICATE_KEY} exception.\n+     */\n+    public static boolean ifDuplicateKeyError(final Throwable throwable) {\n+        if (throwable instanceof MongoException) {\n+            final MongoException mongoException = (MongoException) throwable;\n+            return ErrorCategory.fromErrorCode(mongoException.getCode()) == ErrorCategory.DUPLICATE_KEY;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks if this version matches the provided version.\n+     *\n+     * @param <T> The type of the resource.\n+     * @param resourceDto The data transfer object of the resource.\n+     * @param resourceVersion The version of the resource to be matched with that of the existing one.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future will succeed if the version matches. Otherwise the future will fail with a\n+     *         {@link ServiceInvocationException}.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    public static <T extends BaseDto> Future<T> checkResourceVersion(final T resourceDto,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwMTM0NA=="}, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwNzE1MQ==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r404107151", "createdAt": "2020-04-06T13:52:22Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "diffHunk": "@@ -97,4 +102,43 @@ private MongoDbDeviceRegistryUtils() {\n         }\n         return OperationResult.empty(HttpURLConnection.HTTP_INTERNAL_ERROR);\n     }\n+\n+    /**\n+     * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.\n+     *\n+     * @param throwable The exception to check. Other Throwables but {@link MongoException} return {@code false}.\n+     * @return {@code true} if exception is an {@link ErrorCategory#DUPLICATE_KEY} exception.\n+     */\n+    public static boolean ifDuplicateKeyError(final Throwable throwable) {\n+        if (throwable instanceof MongoException) {\n+            final MongoException mongoException = (MongoException) throwable;\n+            return ErrorCategory.fromErrorCode(mongoException.getCode()) == ErrorCategory.DUPLICATE_KEY;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks if this version matches the provided version.\n+     *\n+     * @param <T> The type of the resource.\n+     * @param resourceDto The data transfer object of the resource.\n+     * @param resourceVersion The version of the resource to be matched with that of the existing one.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future will succeed if the version matches. Otherwise the future will fail with a\n+     *         {@link ServiceInvocationException}.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    public static <T extends BaseDto> Future<T> checkResourceVersion(final T resourceDto,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwMTM0NA=="}, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODkyNTc5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMDoxODowM1rOGAPXOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxMjo0MjoyMlrOGATxIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwNDg5MQ==", "bodyText": "This method could be removed and we could use directly use the instance variable config.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402904891", "createdAt": "2020-04-03T10:18:03Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk3NzA1Nw==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r402977057", "createdAt": "2020-04-03T12:42:22Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,572 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientDeleteResult;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjkwNDg5MQ=="}, "originalCommit": {"oid": "3e4b8a9f2f631ab3e7e08e1487a61c10206d712e"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMDM4Mjk4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNjozNzo1NVrOGAdWtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTowNjo1N1rOGDUHEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEzNDEzNA==", "bodyText": "How about updateTenantPromise as you used deleteTenantPromise for the delete tenant?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r403134134", "createdAt": "2020-04-03T16:37:55Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantUpdateQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> tenantUpdated = Promise.promise();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3da0f844033ba080016174458b62f4c1932cffd"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyODQwMA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406128400", "createdAt": "2020-04-09T11:06:57Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantUpdateQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> tenantUpdated = Promise.promise();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEzNDEzNA=="}, "originalCommit": {"oid": "d3da0f844033ba080016174458b62f4c1932cffd"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMDQ0OTgxOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNjo1NjoyMVrOGAeADA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTowNzowMFrOGDUHMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0NDcxNg==", "bodyText": "I think it could be simplified by using findTenant(final String tenantId) and also I didn't understand why Future<Map.Entry<String, Versioned<Tenant>>> is being returned. Simply a Future<TenantDto> should work.\nAfter simplifying as above, the two methods getForCertificateAuthority and getByCa could be merged into a method like getTenantByCA.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r403144716", "createdAt": "2020-04-03T16:56:21Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantUpdateQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> tenantUpdated = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.updateCollection(config.getCollectionName(), tenantUpdateQuery,\n+                new JsonObject().put(\"$set\", JsonObject.mapFrom(newTenantDto)), tenantUpdated);\n+\n+        return tenantUpdated.future()\n+                .compose(tenantUpdateResult -> {\n+                    if (tenantUpdateResult.getDocMatched() == 0) {\n+\n+                        return checkForVersionMismatchAndFail(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(OperationResult.ok(\n+                                HttpURLConnection.HTTP_NO_CONTENT,\n+                                null,\n+                                Optional.empty(),\n+                                Optional.of(newTenantDto.getVersion())));\n+                    }\n+\n+                });\n+    }\n+\n+    /**\n+     * Checks if a tenant cannot be found or tenant mismatches provided version.\n+     *\n+     * @param tenantId The tenant id to be checked.\n+     * @param versionFromRequest The version to be checked.\n+     * @return A future indicating the outcome of the operation. The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         <li><em>500 Internal Server Error</em> if the tenant under test does not generate any of the above\n+     *         errors. This means that none of the expected standard cases happened.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    private <T extends Result<Void>> Future<T> checkForVersionMismatchAndFail(final String tenantId,\n+            final Optional<String> versionFromRequest) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(versionFromRequest);\n+\n+        if (versionFromRequest.isPresent()) {\n+            return findTenant(tenantId)\n+                    .compose(tenantDto -> {\n+                        if (!versionFromRequest.get().equals(\n+                                tenantDto.getVersion())) {\n+                            return Future.failedFuture(\n+                                    new ClientErrorException(HttpURLConnection.HTTP_PRECON_FAILED,\n+                                            \"Resource version mismatch\"));\n+                        }\n+                        return Future.failedFuture(\n+                                new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                                        \"Unknown error: Should be version mismatch or tenant not found.\"));\n+\n+                    });\n+        } else {\n+            return Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                    String.format(\"Tenant [%s] not found.\", tenantId)));\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantDeleteQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), tenantDeleteQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(result -> Optional.ofNullable(result)\n+                        .map(deleted -> {\n+                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> checkForVersionMismatchAndFail(tenantId, resourceVersion)));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return readTenant(tenantId, span)\n+                .compose(successTenantRead -> {\n+                    if (successTenantRead.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, successTenantRead.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            final Future<Map.Entry<String, Versioned<Tenant>>> tenantsFound = getByCa(subjectDn);\n+            return tenantsFound.compose(successTenantRead -> {\n+                if (successTenantRead == null) {\n+                    TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                    return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                } else {\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(successTenantRead.getKey(),\n+                                    successTenantRead.getValue().getValue(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A Future Map consisting of pair of a tenant id and a versioned tenant.\n+     */\n+    private Future<Map.Entry<String, Versioned<Tenant>>> getByCa(final X500Principal subjectDn) {\n+\n+        if (subjectDn == null) {\n+            return Future.failedFuture(\"missing subject DN\");\n+        } else {\n+            final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                    .withCa(\"tenant\", subjectDn.getName())\n+                    .document();\n+\n+            final Promise<JsonObject> tenantsFound = Promise.promise();\n+            mongoClient.findOne(getConfig().getCollectionName(), findTenantQuery, new JsonObject(), tenantsFound);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3da0f844033ba080016174458b62f4c1932cffd"}, "originalPosition": 367}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyODQzMg==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406128432", "createdAt": "2020-04-09T11:07:00Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantUpdateQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> tenantUpdated = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.updateCollection(config.getCollectionName(), tenantUpdateQuery,\n+                new JsonObject().put(\"$set\", JsonObject.mapFrom(newTenantDto)), tenantUpdated);\n+\n+        return tenantUpdated.future()\n+                .compose(tenantUpdateResult -> {\n+                    if (tenantUpdateResult.getDocMatched() == 0) {\n+\n+                        return checkForVersionMismatchAndFail(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(OperationResult.ok(\n+                                HttpURLConnection.HTTP_NO_CONTENT,\n+                                null,\n+                                Optional.empty(),\n+                                Optional.of(newTenantDto.getVersion())));\n+                    }\n+\n+                });\n+    }\n+\n+    /**\n+     * Checks if a tenant cannot be found or tenant mismatches provided version.\n+     *\n+     * @param tenantId The tenant id to be checked.\n+     * @param versionFromRequest The version to be checked.\n+     * @return A future indicating the outcome of the operation. The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         <li><em>500 Internal Server Error</em> if the tenant under test does not generate any of the above\n+     *         errors. This means that none of the expected standard cases happened.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    private <T extends Result<Void>> Future<T> checkForVersionMismatchAndFail(final String tenantId,\n+            final Optional<String> versionFromRequest) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(versionFromRequest);\n+\n+        if (versionFromRequest.isPresent()) {\n+            return findTenant(tenantId)\n+                    .compose(tenantDto -> {\n+                        if (!versionFromRequest.get().equals(\n+                                tenantDto.getVersion())) {\n+                            return Future.failedFuture(\n+                                    new ClientErrorException(HttpURLConnection.HTTP_PRECON_FAILED,\n+                                            \"Resource version mismatch\"));\n+                        }\n+                        return Future.failedFuture(\n+                                new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                                        \"Unknown error: Should be version mismatch or tenant not found.\"));\n+\n+                    });\n+        } else {\n+            return Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                    String.format(\"Tenant [%s] not found.\", tenantId)));\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantDeleteQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), tenantDeleteQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(result -> Optional.ofNullable(result)\n+                        .map(deleted -> {\n+                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> checkForVersionMismatchAndFail(tenantId, resourceVersion)));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return readTenant(tenantId, span)\n+                .compose(successTenantRead -> {\n+                    if (successTenantRead.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, successTenantRead.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            final Future<Map.Entry<String, Versioned<Tenant>>> tenantsFound = getByCa(subjectDn);\n+            return tenantsFound.compose(successTenantRead -> {\n+                if (successTenantRead == null) {\n+                    TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                    return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                } else {\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(successTenantRead.getKey(),\n+                                    successTenantRead.getValue().getValue(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A Future Map consisting of pair of a tenant id and a versioned tenant.\n+     */\n+    private Future<Map.Entry<String, Versioned<Tenant>>> getByCa(final X500Principal subjectDn) {\n+\n+        if (subjectDn == null) {\n+            return Future.failedFuture(\"missing subject DN\");\n+        } else {\n+            final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                    .withCa(\"tenant\", subjectDn.getName())\n+                    .document();\n+\n+            final Promise<JsonObject> tenantsFound = Promise.promise();\n+            mongoClient.findOne(getConfig().getCollectionName(), findTenantQuery, new JsonObject(), tenantsFound);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE0NDcxNg=="}, "originalCommit": {"oid": "d3da0f844033ba080016174458b62f4c1932cffd"}, "originalPosition": 367}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMDQ5MTUyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNzowMjo1MVrOGAeW4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTowNzowOVrOGDUHfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE1MDU2MQ==", "bodyText": "As I noticed in several places, please use a suitable name for variables of type Promise. Here I think findTenantPromisesuits more than the tenantsFound. Also please take a look and make changes in other places too.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r403150561", "createdAt": "2020-04-03T17:02:51Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantUpdateQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> tenantUpdated = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.updateCollection(config.getCollectionName(), tenantUpdateQuery,\n+                new JsonObject().put(\"$set\", JsonObject.mapFrom(newTenantDto)), tenantUpdated);\n+\n+        return tenantUpdated.future()\n+                .compose(tenantUpdateResult -> {\n+                    if (tenantUpdateResult.getDocMatched() == 0) {\n+\n+                        return checkForVersionMismatchAndFail(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(OperationResult.ok(\n+                                HttpURLConnection.HTTP_NO_CONTENT,\n+                                null,\n+                                Optional.empty(),\n+                                Optional.of(newTenantDto.getVersion())));\n+                    }\n+\n+                });\n+    }\n+\n+    /**\n+     * Checks if a tenant cannot be found or tenant mismatches provided version.\n+     *\n+     * @param tenantId The tenant id to be checked.\n+     * @param versionFromRequest The version to be checked.\n+     * @return A future indicating the outcome of the operation. The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         <li><em>500 Internal Server Error</em> if the tenant under test does not generate any of the above\n+     *         errors. This means that none of the expected standard cases happened.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    private <T extends Result<Void>> Future<T> checkForVersionMismatchAndFail(final String tenantId,\n+            final Optional<String> versionFromRequest) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(versionFromRequest);\n+\n+        if (versionFromRequest.isPresent()) {\n+            return findTenant(tenantId)\n+                    .compose(tenantDto -> {\n+                        if (!versionFromRequest.get().equals(\n+                                tenantDto.getVersion())) {\n+                            return Future.failedFuture(\n+                                    new ClientErrorException(HttpURLConnection.HTTP_PRECON_FAILED,\n+                                            \"Resource version mismatch\"));\n+                        }\n+                        return Future.failedFuture(\n+                                new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                                        \"Unknown error: Should be version mismatch or tenant not found.\"));\n+\n+                    });\n+        } else {\n+            return Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                    String.format(\"Tenant [%s] not found.\", tenantId)));\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantDeleteQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), tenantDeleteQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(result -> Optional.ofNullable(result)\n+                        .map(deleted -> {\n+                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> checkForVersionMismatchAndFail(tenantId, resourceVersion)));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return readTenant(tenantId, span)\n+                .compose(successTenantRead -> {\n+                    if (successTenantRead.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, successTenantRead.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            final Future<Map.Entry<String, Versioned<Tenant>>> tenantsFound = getByCa(subjectDn);\n+            return tenantsFound.compose(successTenantRead -> {\n+                if (successTenantRead == null) {\n+                    TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                    return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                } else {\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(successTenantRead.getKey(),\n+                                    successTenantRead.getValue().getValue(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A Future Map consisting of pair of a tenant id and a versioned tenant.\n+     */\n+    private Future<Map.Entry<String, Versioned<Tenant>>> getByCa(final X500Principal subjectDn) {\n+\n+        if (subjectDn == null) {\n+            return Future.failedFuture(\"missing subject DN\");\n+        } else {\n+            final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                    .withCa(\"tenant\", subjectDn.getName())\n+                    .document();\n+\n+            final Promise<JsonObject> tenantsFound = Promise.promise();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3da0f844033ba080016174458b62f4c1932cffd"}, "originalPosition": 366}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyODUxMQ==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406128511", "createdAt": "2020-04-09T11:07:09Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantUpdateQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> tenantUpdated = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.updateCollection(config.getCollectionName(), tenantUpdateQuery,\n+                new JsonObject().put(\"$set\", JsonObject.mapFrom(newTenantDto)), tenantUpdated);\n+\n+        return tenantUpdated.future()\n+                .compose(tenantUpdateResult -> {\n+                    if (tenantUpdateResult.getDocMatched() == 0) {\n+\n+                        return checkForVersionMismatchAndFail(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(OperationResult.ok(\n+                                HttpURLConnection.HTTP_NO_CONTENT,\n+                                null,\n+                                Optional.empty(),\n+                                Optional.of(newTenantDto.getVersion())));\n+                    }\n+\n+                });\n+    }\n+\n+    /**\n+     * Checks if a tenant cannot be found or tenant mismatches provided version.\n+     *\n+     * @param tenantId The tenant id to be checked.\n+     * @param versionFromRequest The version to be checked.\n+     * @return A future indicating the outcome of the operation. The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         <li><em>500 Internal Server Error</em> if the tenant under test does not generate any of the above\n+     *         errors. This means that none of the expected standard cases happened.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    private <T extends Result<Void>> Future<T> checkForVersionMismatchAndFail(final String tenantId,\n+            final Optional<String> versionFromRequest) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(versionFromRequest);\n+\n+        if (versionFromRequest.isPresent()) {\n+            return findTenant(tenantId)\n+                    .compose(tenantDto -> {\n+                        if (!versionFromRequest.get().equals(\n+                                tenantDto.getVersion())) {\n+                            return Future.failedFuture(\n+                                    new ClientErrorException(HttpURLConnection.HTTP_PRECON_FAILED,\n+                                            \"Resource version mismatch\"));\n+                        }\n+                        return Future.failedFuture(\n+                                new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                                        \"Unknown error: Should be version mismatch or tenant not found.\"));\n+\n+                    });\n+        } else {\n+            return Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                    String.format(\"Tenant [%s] not found.\", tenantId)));\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantDeleteQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), tenantDeleteQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(result -> Optional.ofNullable(result)\n+                        .map(deleted -> {\n+                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> checkForVersionMismatchAndFail(tenantId, resourceVersion)));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return readTenant(tenantId, span)\n+                .compose(successTenantRead -> {\n+                    if (successTenantRead.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, successTenantRead.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            final Future<Map.Entry<String, Versioned<Tenant>>> tenantsFound = getByCa(subjectDn);\n+            return tenantsFound.compose(successTenantRead -> {\n+                if (successTenantRead == null) {\n+                    TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                    return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                } else {\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(successTenantRead.getKey(),\n+                                    successTenantRead.getValue().getValue(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A Future Map consisting of pair of a tenant id and a versioned tenant.\n+     */\n+    private Future<Map.Entry<String, Versioned<Tenant>>> getByCa(final X500Principal subjectDn) {\n+\n+        if (subjectDn == null) {\n+            return Future.failedFuture(\"missing subject DN\");\n+        } else {\n+            final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                    .withCa(\"tenant\", subjectDn.getName())\n+                    .document();\n+\n+            final Promise<JsonObject> tenantsFound = Promise.promise();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE1MDU2MQ=="}, "originalCommit": {"oid": "d3da0f844033ba080016174458b62f4c1932cffd"}, "originalPosition": 366}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMDUwNDQxOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNzowNDo1NFrOGAedkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNzowNDo1NFrOGAedkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE1MjI3Mg==", "bodyText": "There is only one parameter, how about changing to parameter instead of parameters.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r403152272", "createdAt": "2020-04-03T17:04:54Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantUpdateQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> tenantUpdated = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.updateCollection(config.getCollectionName(), tenantUpdateQuery,\n+                new JsonObject().put(\"$set\", JsonObject.mapFrom(newTenantDto)), tenantUpdated);\n+\n+        return tenantUpdated.future()\n+                .compose(tenantUpdateResult -> {\n+                    if (tenantUpdateResult.getDocMatched() == 0) {\n+\n+                        return checkForVersionMismatchAndFail(tenantId, resourceVersion);\n+                    } else {\n+                        span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(OperationResult.ok(\n+                                HttpURLConnection.HTTP_NO_CONTENT,\n+                                null,\n+                                Optional.empty(),\n+                                Optional.of(newTenantDto.getVersion())));\n+                    }\n+\n+                });\n+    }\n+\n+    /**\n+     * Checks if a tenant cannot be found or tenant mismatches provided version.\n+     *\n+     * @param tenantId The tenant id to be checked.\n+     * @param versionFromRequest The version to be checked.\n+     * @return A future indicating the outcome of the operation. The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         <li><em>500 Internal Server Error</em> if the tenant under test does not generate any of the above\n+     *         errors. This means that none of the expected standard cases happened.</li>\n+     *         </ul>\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    private <T extends Result<Void>> Future<T> checkForVersionMismatchAndFail(final String tenantId,\n+            final Optional<String> versionFromRequest) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(versionFromRequest);\n+\n+        if (versionFromRequest.isPresent()) {\n+            return findTenant(tenantId)\n+                    .compose(tenantDto -> {\n+                        if (!versionFromRequest.get().equals(\n+                                tenantDto.getVersion())) {\n+                            return Future.failedFuture(\n+                                    new ClientErrorException(HttpURLConnection.HTTP_PRECON_FAILED,\n+                                            \"Resource version mismatch\"));\n+                        }\n+                        return Future.failedFuture(\n+                                new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                                        \"Unknown error: Should be version mismatch or tenant not found.\"));\n+\n+                    });\n+        } else {\n+            return Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                    String.format(\"Tenant [%s] not found.\", tenantId)));\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+\n+        final JsonObject tenantDeleteQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), tenantDeleteQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(result -> Optional.ofNullable(result)\n+                        .map(deleted -> {\n+                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> checkForVersionMismatchAndFail(tenantId, resourceVersion)));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return readTenant(tenantId, span)\n+                .compose(successTenantRead -> {\n+                    if (successTenantRead.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, successTenantRead.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, null);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            final Future<Map.Entry<String, Versioned<Tenant>>> tenantsFound = getByCa(subjectDn);\n+            return tenantsFound.compose(successTenantRead -> {\n+                if (successTenantRead == null) {\n+                    TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                    return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                } else {\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(successTenantRead.getKey(),\n+                                    successTenantRead.getValue().getValue(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A Future Map consisting of pair of a tenant id and a versioned tenant.\n+     */\n+    private Future<Map.Entry<String, Versioned<Tenant>>> getByCa(final X500Principal subjectDn) {\n+\n+        if (subjectDn == null) {\n+            return Future.failedFuture(\"missing subject DN\");\n+        } else {\n+            final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                    .withCa(\"tenant\", subjectDn.getName())\n+                    .document();\n+\n+            final Promise<JsonObject> tenantsFound = Promise.promise();\n+            mongoClient.findOne(getConfig().getCollectionName(), findTenantQuery, new JsonObject(), tenantsFound);\n+            return tenantsFound.future().compose(successTenantsFound -> {\n+                if (successTenantsFound == null || successTenantsFound.size() == 0) {\n+                    return Future.succeededFuture(null);\n+                }\n+                final TenantDto tenantDtoFound = successTenantsFound.mapTo(TenantDto.class);\n+                return Future.succeededFuture(\n+                        new AbstractMap.SimpleEntry<>(tenantDtoFound.getTenantId(),\n+                                new Versioned<>(tenantDtoFound.getVersion(),\n+                                        tenantDtoFound.getTenant())));\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return processReadTenant(tenantId, span)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDto -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDto.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDto.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameters is {@code null}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3da0f844033ba080016174458b62f4c1932cffd"}, "originalPosition": 410}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjM2MDI3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODo0MDoyNVrOGBNZUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMzo1Mjo0OVrOGBYw2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkyMTIzNA==", "bodyText": "It is repetitive as the error is being already logged in createCollectionIndex(...). IMHO it could be removed and simply leave it as .onFailure(startPromise::fail);", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r403921234", "createdAt": "2020-04-06T08:40:25Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3da0f844033ba080016174458b62f4c1932cffd"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwNzQ4Mw==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r404107483", "createdAt": "2020-04-06T13:52:49Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkyMTIzNA=="}, "originalCommit": {"oid": "d3da0f844033ba080016174458b62f4c1932cffd"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNjM2NzY3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwODo0MjoxNlrOGBNdzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMzo1Mjo0NVrOGBYwpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkyMjM4MA==", "bodyText": "removed? Isn't it updated?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r403922380", "createdAt": "2020-04-06T08:42:16Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3da0f844033ba080016174458b62f4c1932cffd"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwNzQyOA==", "bodyText": "fixed", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r404107428", "createdAt": "2020-04-06T13:52:45Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,531 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    public MongoDbBasedTenantsConfigProperties getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(error -> {\n+                    log.error(\"Index creation failed\", error);\n+                    startPromise.fail(error);\n+                });\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkyMjM4MA=="}, "originalCommit": {"oid": "d3da0f844033ba080016174458b62f4c1932cffd"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNzc1MTkyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDozNTowNlrOGBazZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMTo1NTo0MlrOGCAAsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0MDkwMA==", "bodyText": "Here we assume based on the number of records that the update has been successful and hence we send the newTenantDto.getVersion(). IMHO it would have been even better, if we are able to get the version of that  document after update. For that findOneAndReplaceWithOptions(...) would be more suited. Device registration service uses it too.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r404140900", "createdAt": "2020-04-06T14:35:06Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,517 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.updateCollection(config.getCollectionName(), updateTenantQuery,\n+                new JsonObject().put(\"$set\", JsonObject.mapFrom(newTenantDto)), updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> {\n+                    if (updateResult.getDocMatched() == 0) {\n+                        return MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId, resourceVersion,\n+                                findTenant(tenantId));\n+                    } else {\n+                        span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(OperationResult.ok(\n+                                HttpURLConnection.HTTP_NO_CONTENT,\n+                                null,\n+                                Optional.empty(),\n+                                Optional.of(newTenantDto.getVersion())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22bce087cbd3eb6d38b04cbf5f087a211b6c09b2"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc1MDUxMw==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r404750513", "createdAt": "2020-04-07T11:55:42Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,517 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.MongoClientUpdateResult;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<MongoClientUpdateResult> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.updateCollection(config.getCollectionName(), updateTenantQuery,\n+                new JsonObject().put(\"$set\", JsonObject.mapFrom(newTenantDto)), updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> {\n+                    if (updateResult.getDocMatched() == 0) {\n+                        return MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId, resourceVersion,\n+                                findTenant(tenantId));\n+                    } else {\n+                        span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                        return Future.succeededFuture(OperationResult.ok(\n+                                HttpURLConnection.HTTP_NO_CONTENT,\n+                                null,\n+                                Optional.empty(),\n+                                Optional.of(newTenantDto.getVersion())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE0MDkwMA=="}, "originalCommit": {"oid": "22bce087cbd3eb6d38b04cbf5f087a211b6c09b2"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTA1NzU4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwOToxOToxM1rOGB6nTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTowODoyNVrOGDUJrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2MjA5NQ==", "bodyText": "Finding a tenant, checking for conflict CAs and then updating that tenant are not atomic. After checking and before update some other request could have inserted a tenant with the same SubjectDN. So it is better if we these operations atomic.\nwe could created an index as below. That ensures no conflicting CAs are updated and the code regarding conflicting CAs could be removed.\ndb.getCollection('tenants')\n.createIndex(\n{\"tenant.trusted-ca.subject-dn\": 1}, \n{unique: true, partialFilterExpression: { \"tenant.trusted-ca\": { $exists: true } } })", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r404662095", "createdAt": "2020-04-07T09:19:13Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,514 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e69de9d1afb1a67eea4f69a1209d15120989ea9"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyOTA3MA==", "bodyText": "Good idea. Done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406129070", "createdAt": "2020-04-09T11:08:25Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,514 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2MjA5NQ=="}, "originalCommit": {"oid": "4e69de9d1afb1a67eea4f69a1209d15120989ea9"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTA4MDYzOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwOToyNToxMVrOGB61nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTowODozNFrOGDUJ-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2NTc1Ng==", "bodyText": "Checking for conflict CAs and creating a tenant should be atomic. Please refer the same comment as that of the update tenant and the same index should also solve the problem here. In case of create tenant, a duplicate key error could due to two reasons which are tenant id duplication or conflicting CAs. IMHO the log messages could be also adapted to say that the error could be due to two reasons.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r404665756", "createdAt": "2020-04-07T09:25:11Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,514 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated device [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>>succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> result(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> result(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        Objects.requireNonNull(span);\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+            .recover(error -> {\n+                TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId, span)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(\"tenant\", subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new NullPointerException()))\n+                        .recover(error -> {\n+                            if (findQuery.containsKey(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID)) {\n+                                return Future.failedFuture(\n+                                        new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                                String.format(\"Tenant [%s] not found.\",\n+                                                        findQuery.getString(\n+                                                                RegistrationConstants.FIELD_PAYLOAD_TENANT_ID))));\n+                            }\n+                            return Future.failedFuture(\n+                                    new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND, \"Tenant not found\"));\n+                        }));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>201 Created</em> if the tenant has been added successfully.</li>\n+     *         <li><em>409 Conflict</em> if a tenant with the given\n+     *         identifier or certificate authority already exists.</li>\n+     *         <li><em>500 Internal Server Error</em> if tenants cannot be accessed.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(span);\n+\n+        final String tenantIdOrGenerated = tenantId.orElse(DeviceRegistryUtils.getUniqueIdentifier());\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantIdOrGenerated)\n+                .compose(ok -> checkConflictingCATenants(Optional.empty(),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e69de9d1afb1a67eea4f69a1209d15120989ea9"}, "originalPosition": 428}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyOTE0NA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406129144", "createdAt": "2020-04-09T11:08:34Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,514 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated device [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>>succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> result(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> result(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        Objects.requireNonNull(span);\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+            .recover(error -> {\n+                TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId, span)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(\"tenant\", subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new NullPointerException()))\n+                        .recover(error -> {\n+                            if (findQuery.containsKey(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID)) {\n+                                return Future.failedFuture(\n+                                        new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                                String.format(\"Tenant [%s] not found.\",\n+                                                        findQuery.getString(\n+                                                                RegistrationConstants.FIELD_PAYLOAD_TENANT_ID))));\n+                            }\n+                            return Future.failedFuture(\n+                                    new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND, \"Tenant not found\"));\n+                        }));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>201 Created</em> if the tenant has been added successfully.</li>\n+     *         <li><em>409 Conflict</em> if a tenant with the given\n+     *         identifier or certificate authority already exists.</li>\n+     *         <li><em>500 Internal Server Error</em> if tenants cannot be accessed.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(span);\n+\n+        final String tenantIdOrGenerated = tenantId.orElse(DeviceRegistryUtils.getUniqueIdentifier());\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantIdOrGenerated)\n+                .compose(ok -> checkConflictingCATenants(Optional.empty(),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2NTc1Ng=="}, "originalCommit": {"oid": "4e69de9d1afb1a67eea4f69a1209d15120989ea9"}, "originalPosition": 428}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTA4OTIxOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwOToyNzoyMlrOGB668w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTowODo1MFrOGDUKeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2NzEyMw==", "bodyText": "One more index for the subjectDN is optimal, so that it helps with the querying based on the subjectDNs. Please refer my comment on the update Tenant part and the same index should work.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r404667123", "createdAt": "2020-04-07T09:27:22Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,514 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e69de9d1afb1a67eea4f69a1209d15120989ea9"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyOTI3Mg==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406129272", "createdAt": "2020-04-09T11:08:50Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,514 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2NzEyMw=="}, "originalCommit": {"oid": "4e69de9d1afb1a67eea4f69a1209d15120989ea9"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTY3MjU4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMjoxMjoyMlrOGCAjAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTowODo1NlrOGDUKsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc1OTI5OQ==", "bodyText": "Please change it to successfully updated tenant not device.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r404759299", "createdAt": "2020-04-07T12:12:22Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,514 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated device [%s]\", tenantId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1272e6d349e86e413ac73ceeff5a4c5064203aa3"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyOTMzMA==", "bodyText": "fixed", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406129330", "createdAt": "2020-04-09T11:08:56Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,514 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID,\n+                        1),\n+                new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES)\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> findTenant(tenantId))\n+                .compose(tenantDto -> checkConflictingCATenants(Optional.of(tenantDto),\n+                        tenantObj.getTrustedCertificateAuthoritySubjectDNs(), span))\n+                .compose(tenantDto -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated device [%s]\", tenantId));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc1OTI5OQ=="}, "originalCommit": {"oid": "1272e6d349e86e413ac73ceeff5a4c5064203aa3"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjA2NzI1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTozMToyMlrOGCq_Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTowOTowN1rOGDULEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1NDYxNA==", "bodyText": "Check style error due to static import. Static imports are not allowed except the tests.\n[ERROR] src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java:[16] (imports) AvoidStaticImport: Using a static member import should be avoided - io.vertx.core.impl.CompositeFutureImpl.all.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r405454614", "createdAt": "2020-04-08T11:31:22Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyOTQyNQ==", "bodyText": "fixed", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406129425", "createdAt": "2020-04-09T11:09:07Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1NDYxNA=="}, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjA4MzMyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTozNjoxNlrOGCrI8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTowOToxMlrOGDULPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1NzEzOA==", "bodyText": "I guess its by mistake and pls remove it.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r405457138", "createdAt": "2020-04-08T11:36:16Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                                .map(success -> {\n+                                    startPromise.complete();\n+                                    return null;\n+                                })\n+                                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyOTQ2OQ==", "bodyText": "fixed", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406129469", "createdAt": "2020-04-09T11:09:12Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                                .map(success -> {\n+                                    startPromise.complete();\n+                                    return null;\n+                                })\n+                                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ1NzEzOA=="}, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjEwMjI1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMTo0MjowMFrOGCrUew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTowOToxN1rOGDULYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2MDA5MQ==", "bodyText": "We could now remove the JavaDoc of all overridden methods. With the PR  #1879, JavaDoc of the API interfaces have been updated asking to refer to the API documentation for status codes.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r405460091", "createdAt": "2020-04-08T11:42:00Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                                .map(success -> {\n+                                    startPromise.complete();\n+                                    return null;\n+                                })\n+                                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyOTUwNQ==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406129505", "createdAt": "2020-04-09T11:09:17Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                                .map(success -> {\n+                                    startPromise.complete();\n+                                    return null;\n+                                })\n+                                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ2MDA5MQ=="}, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjQwNTc4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzowNDo0MFrOGCuP7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNTo0ODo0M1rOGC1h4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwODA3OQ==", "bodyText": "How about naming it in sync with the other methods with a more meaningful method name than result(...)?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r405508079", "createdAt": "2020-04-08T13:04:40Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                                .map(success -> {\n+                                    startPromise.complete();\n+                                    return null;\n+                                })\n+                                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> result(tenantId, resourceVersion, span))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYyNzM2Mg==", "bodyText": "Was a typo. Fixed", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r405627362", "createdAt": "2020-04-08T15:48:43Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                                .map(success -> {\n+                                    startPromise.complete();\n+                                    return null;\n+                                })\n+                                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> result(tenantId, resourceVersion, span))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwODA3OQ=="}, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjQxODI3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzowNzo1M1rOGCuX8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTowOToyM1rOGDULjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxMDEyOA==", "bodyText": "Redundant null checks in the private methods could be removed for those parameters that have been already checked.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r405510128", "createdAt": "2020-04-08T13:07:53Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                                .map(success -> {\n+                                    startPromise.complete();\n+                                    return null;\n+                                })\n+                                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> result(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> result(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyOTU1MA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406129550", "createdAt": "2020-04-09T11:09:23Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                                .map(success -> {\n+                                    startPromise.complete();\n+                                    return null;\n+                                })\n+                                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> result(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> result(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxMDEyOA=="}, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjQ4Mzg2OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzoyMjo0M1rOGCu_9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTowNjozOVrOGDUGdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyMDM3NQ==", "bodyText": "Why this NullPointerException instead directly a ClientErrorException could be returned as in the MongoDbBasedRegistrationService?\nAlso I didn't get why it is being checked if findQuery contains FIELD_PAYLOAD_TENANT_ID and then same HTTP_NOT_FOUND status is returned even if it is available or not.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r405520375", "createdAt": "2020-04-08T13:22:43Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                                .map(success -> {\n+                                    startPromise.complete();\n+                                    return null;\n+                                })\n+                                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> result(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> result(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        Objects.requireNonNull(span);\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId, span)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(\"tenant\", subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new NullPointerException()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 422}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyODI0Nw==", "bodyText": "The check was necessary due to optional tenantId.\nFunction is simplified now.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406128247", "createdAt": "2020-04-09T11:06:39Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                                .map(success -> {\n+                                    startPromise.complete();\n+                                    return null;\n+                                })\n+                                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> result(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> result(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        Objects.requireNonNull(span);\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId, span)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(\"tenant\", subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new NullPointerException()))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyMDM3NQ=="}, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 422}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjUyMDMzOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzozMDo0NlrOGCvWXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTowMzo0M1rOGDUBLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyNjExMA==", "bodyText": "As we discussed, there is no need of checking here, if the duplication key error is due to tenantId or  subjectDN. In case of update, there the duplicate error can happen only due to subjectDN. Hence I would suggest to remove this part and use MongoDbDeviceRegistryUtils.isDuplicateKeyError() as you check in the processCreateTenant(...)", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r405526110", "createdAt": "2020-04-08T13:30:46Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                                .map(success -> {\n+                                    startPromise.complete();\n+                                    return null;\n+                                })\n+                                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyNjg5NQ==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406126895", "createdAt": "2020-04-09T11:03:43Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                                .map(success -> {\n+                                    startPromise.complete();\n+                                    return null;\n+                                })\n+                                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUyNjExMA=="}, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjY1Mjk5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDowMDowNVrOGCwp2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDoyMzowNlrOGDSy6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU0NzQ4MA==", "bodyText": "We could also remove logging of the tenant ID using span (in other places too) as the span should already be tagged with the tenant ID.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r405547480", "createdAt": "2020-04-08T14:00:05Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                                .map(success -> {\n+                                    startPromise.complete();\n+                                    return null;\n+                                })\n+                                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> result(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> result(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        Objects.requireNonNull(span);\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId, span)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(\"tenant\", subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new NullPointerException()))\n+                        .recover(error -> {\n+                            if (findQuery.containsKey(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID)) {\n+                                return Future.failedFuture(\n+                                        new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                                String.format(\"Tenant [%s] not found.\",\n+                                                        findQuery.getString(\n+                                                                RegistrationConstants.FIELD_PAYLOAD_TENANT_ID))));\n+                            }\n+                            return Future.failedFuture(\n+                                    new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND, \"Tenant not found\"));\n+                        }));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>201 Created</em> if the tenant has been added successfully.</li>\n+     *         <li><em>409 Conflict</em> if a tenant with the given\n+     *         identifier or certificate authority already exists.</li>\n+     *         <li><em>500 Internal Server Error</em> if tenants cannot be accessed.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(span);\n+\n+        final String tenantIdOrGenerated = tenantId.orElse(DeviceRegistryUtils.getUniqueIdentifier());\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantIdOrGenerated)\n+                .compose(ok -> processCreateTenant(tenantIdOrGenerated, tenantObj, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Id>> processCreateTenant(final String tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(span);\n+\n+        final TenantDto newTenantDto = new TenantDto(tenantId, tenantObj,\n+                new Versioned<>(tenantObj).getVersion());\n+\n+        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+        final Promise<String> createTenantPromise = Promise.promise();\n+        mongoClient.insert(config.getCollectionName(), newTenantDtoJson, createTenantPromise);\n+        return createTenantPromise.future()\n+                .compose(tenantObjectIdResult -> {\n+                    span.log(String.format(\"successfully created tenant [%s]\", tenantId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 476}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA4NjI1OA==", "bodyText": "Are you working on it?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406086258", "createdAt": "2020-04-09T09:46:37Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                                .map(success -> {\n+                                    startPromise.complete();\n+                                    return null;\n+                                })\n+                                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> result(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> result(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        Objects.requireNonNull(span);\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId, span)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(\"tenant\", subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new NullPointerException()))\n+                        .recover(error -> {\n+                            if (findQuery.containsKey(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID)) {\n+                                return Future.failedFuture(\n+                                        new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                                String.format(\"Tenant [%s] not found.\",\n+                                                        findQuery.getString(\n+                                                                RegistrationConstants.FIELD_PAYLOAD_TENANT_ID))));\n+                            }\n+                            return Future.failedFuture(\n+                                    new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND, \"Tenant not found\"));\n+                        }));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>201 Created</em> if the tenant has been added successfully.</li>\n+     *         <li><em>409 Conflict</em> if a tenant with the given\n+     *         identifier or certificate authority already exists.</li>\n+     *         <li><em>500 Internal Server Error</em> if tenants cannot be accessed.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(span);\n+\n+        final String tenantIdOrGenerated = tenantId.orElse(DeviceRegistryUtils.getUniqueIdentifier());\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantIdOrGenerated)\n+                .compose(ok -> processCreateTenant(tenantIdOrGenerated, tenantObj, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Id>> processCreateTenant(final String tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(span);\n+\n+        final TenantDto newTenantDto = new TenantDto(tenantId, tenantObj,\n+                new Versioned<>(tenantObj).getVersion());\n+\n+        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+        final Promise<String> createTenantPromise = Promise.promise();\n+        mongoClient.insert(config.getCollectionName(), newTenantDtoJson, createTenantPromise);\n+        return createTenantPromise.future()\n+                .compose(tenantObjectIdResult -> {\n+                    span.log(String.format(\"successfully created tenant [%s]\", tenantId));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU0NzQ4MA=="}, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 476}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwNjg1Nw==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406106857", "createdAt": "2020-04-09T10:23:06Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                                .map(success -> {\n+                                    startPromise.complete();\n+                                    return null;\n+                                })\n+                                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> result(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> result(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        Objects.requireNonNull(span);\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId, span)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(\"tenant\", subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new NullPointerException()))\n+                        .recover(error -> {\n+                            if (findQuery.containsKey(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID)) {\n+                                return Future.failedFuture(\n+                                        new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                                String.format(\"Tenant [%s] not found.\",\n+                                                        findQuery.getString(\n+                                                                RegistrationConstants.FIELD_PAYLOAD_TENANT_ID))));\n+                            }\n+                            return Future.failedFuture(\n+                                    new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND, \"Tenant not found\"));\n+                        }));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>201 Created</em> if the tenant has been added successfully.</li>\n+     *         <li><em>409 Conflict</em> if a tenant with the given\n+     *         identifier or certificate authority already exists.</li>\n+     *         <li><em>500 Internal Server Error</em> if tenants cannot be accessed.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(span);\n+\n+        final String tenantIdOrGenerated = tenantId.orElse(DeviceRegistryUtils.getUniqueIdentifier());\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantIdOrGenerated)\n+                .compose(ok -> processCreateTenant(tenantIdOrGenerated, tenantObj, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Id>> processCreateTenant(final String tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(span);\n+\n+        final TenantDto newTenantDto = new TenantDto(tenantId, tenantObj,\n+                new Versioned<>(tenantObj).getVersion());\n+\n+        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+        final Promise<String> createTenantPromise = Promise.promise();\n+        mongoClient.insert(config.getCollectionName(), newTenantDtoJson, createTenantPromise);\n+        return createTenantPromise.future()\n+                .compose(tenantObjectIdResult -> {\n+                    span.log(String.format(\"successfully created tenant [%s]\", tenantId));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU0NzQ4MA=="}, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 476}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjcwNjc5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDoxMjowOVrOGCxLZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDoyMzoxNlrOGDSzMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1NjA3MQ==", "bodyText": "IMHO I wouldn't rely on parsing the error message and make a decision based on that. As we discussed, in case of duplicate tenant ID or subjectDN HTTP_CONFLICT is returned. In that case I would simply customise the log message to The tenant with the given identifier already exists or an existing tenant uses a certificate authority with the same Subject DN as given in the API docs. WDYT?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r405556071", "createdAt": "2020-04-08T14:12:09Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwNjkyOQ==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406106929", "createdAt": "2020-04-09T10:23:16Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static io.vertx.core.impl.CompositeFutureImpl.all;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1NjA3MQ=="}, "originalCommit": {"oid": "2385b40881ec275095ae77328ef7ca4c972e7fc1"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxOTY5Nzg4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODowMToyNlrOGDNzTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDoyMzoyM1rOGDSzaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAyNTAzOA==", "bodyText": "It is better to pass the error as another argument in the log.debug(...) and TracingHelper.logError(...).", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406025038", "createdAt": "2020-04-09T08:01:26Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -482,47 +412,15 @@ public void stop(final Promise<Void> stopPromise) {\n                 })\n                 .recover(error -> {\n                     if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n-                        logDuplicationError(error.getMessage(), tenantId, span);\n+                        log.debug(String.format(\"The tenant [%s] already exists or an existing tenant uses a certificate authority with the same Subject DN\", tenantId));\n+                        TracingHelper.logError(span, \"The tenant with the given identifier already exists or an existing tenant uses a certificate authority with the same Subject DN\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "243d3f325eb85ba0b318b34c3bb44e19989a4353"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwNjk4NQ==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406106985", "createdAt": "2020-04-09T10:23:23Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -482,47 +412,15 @@ public void stop(final Promise<Void> stopPromise) {\n                 })\n                 .recover(error -> {\n                     if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n-                        logDuplicationError(error.getMessage(), tenantId, span);\n+                        log.debug(String.format(\"The tenant [%s] already exists or an existing tenant uses a certificate authority with the same Subject DN\", tenantId));\n+                        TracingHelper.logError(span, \"The tenant with the given identifier already exists or an existing tenant uses a certificate authority with the same Subject DN\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAyNTAzOA=="}, "originalCommit": {"oid": "243d3f325eb85ba0b318b34c3bb44e19989a4353"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxOTY5OTc0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODowMTo1OVrOGDN0fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODowMTo1OVrOGDN0fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAyNTM0MA==", "bodyText": "Same as the above comment to pass the error as another argument.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406025340", "createdAt": "2020-04-09T08:01:59Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -482,47 +412,15 @@ public void stop(final Promise<Void> stopPromise) {\n                 })\n                 .recover(error -> {\n                     if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n-                        logDuplicationError(error.getMessage(), tenantId, span);\n+                        log.debug(String.format(\"The tenant [%s] already exists or an existing tenant uses a certificate authority with the same Subject DN\", tenantId));\n+                        TracingHelper.logError(span, \"The tenant with the given identifier already exists or an existing tenant uses a certificate authority with the same Subject DN\");\n                         return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n                     } else {\n-                        final var errorMsg = String.format(\"Error adding Tenant [%s].\",\n-                                tenantId);\n-                        log.error(errorMsg);\n-                        TracingHelper.logError(span, errorMsg);\n+                        log.error(String.format(\"Error adding Tenant [%s].\",\n+                                                tenantId));\n+                        TracingHelper.logError(span, \"Error adding Tenant.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "243d3f325eb85ba0b318b34c3bb44e19989a4353"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxOTcwNzk1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODowNDoxMlrOGDN5Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDoyMzozMFrOGDSztA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAyNjU3MA==", "bodyText": "Since it is a failed future, how about also adding String.format(\"Tenant [%s] not found.\", tenantId) as a next argument to the ClientErrorException?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406026570", "createdAt": "2020-04-09T08:04:12Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -419,32 +375,9 @@ public void stop(final Promise<Void> stopPromise) {\n         return findTenantPromise.future()\n                 .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n                         .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n-                        .orElse(Future.failedFuture(new NullPointerException()))\n-                        .recover(error -> {\n-                            if (findQuery.containsKey(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID)) {\n-                                return Future.failedFuture(\n-                                        new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n-                                                String.format(\"Tenant [%s] not found.\",\n-                                                        findQuery.getString(\n-                                                                RegistrationConstants.FIELD_PAYLOAD_TENANT_ID))));\n-                            }\n-                            return Future.failedFuture(\n-                                    new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND, \"Tenant not found\"));\n-                        }));\n+                        .orElse(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "243d3f325eb85ba0b318b34c3bb44e19989a4353"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwNzA2MA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406107060", "createdAt": "2020-04-09T10:23:30Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -419,32 +375,9 @@ public void stop(final Promise<Void> stopPromise) {\n         return findTenantPromise.future()\n                 .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n                         .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n-                        .orElse(Future.failedFuture(new NullPointerException()))\n-                        .recover(error -> {\n-                            if (findQuery.containsKey(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID)) {\n-                                return Future.failedFuture(\n-                                        new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n-                                                String.format(\"Tenant [%s] not found.\",\n-                                                        findQuery.getString(\n-                                                                RegistrationConstants.FIELD_PAYLOAD_TENANT_ID))));\n-                            }\n-                            return Future.failedFuture(\n-                                    new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND, \"Tenant not found\"));\n-                        }));\n+                        .orElse(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAyNjU3MA=="}, "originalCommit": {"oid": "243d3f325eb85ba0b318b34c3bb44e19989a4353"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxOTc3NDA5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODoyMTozMlrOGDOhOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDoyMzo0MVrOGDS0DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzNjc5Mg==", "bodyText": "How about explaining the purpose of the method in the description? Something like Checks if the given error is caused due to duplicate keys.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406036792", "createdAt": "2020-04-09T08:21:32Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "diffHunk": "@@ -139,4 +142,21 @@ private MongoDbDeviceRegistryUtils() {\n                     String.format(\"Resource [%s] not found.\", resourceId)));\n         }\n     }\n+\n+    /**\n+     * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwNzE0OQ==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406107149", "createdAt": "2020-04-09T10:23:41Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "diffHunk": "@@ -139,4 +142,21 @@ private MongoDbDeviceRegistryUtils() {\n                     String.format(\"Resource [%s] not found.\", resourceId)));\n         }\n     }\n+\n+    /**\n+     * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzNjc5Mg=="}, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxOTc3NDY0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODoyMTo0M1rOGDOhpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDoyMzo0NFrOGDS0Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzNjkwMQ==", "bodyText": "Something like @param The error to check.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406036901", "createdAt": "2020-04-09T08:21:43Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "diffHunk": "@@ -139,4 +142,21 @@ private MongoDbDeviceRegistryUtils() {\n                     String.format(\"Resource [%s] not found.\", resourceId)));\n         }\n     }\n+\n+    /**\n+     * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.\n+     *\n+     * @param error The exception to check. Other Throwables but {@link MongoException} return {@code false}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwNzIwNw==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406107207", "createdAt": "2020-04-09T10:23:44Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "diffHunk": "@@ -139,4 +142,21 @@ private MongoDbDeviceRegistryUtils() {\n                     String.format(\"Resource [%s] not found.\", resourceId)));\n         }\n     }\n+\n+    /**\n+     * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.\n+     *\n+     * @param error The exception to check. Other Throwables but {@link MongoException} return {@code false}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzNjkwMQ=="}, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxOTc3NDk3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODoyMTo0NlrOGDOh1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzozNTo1MFrOGDinfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzNjk0OQ==", "bodyText": "Something like @return {@code true} if the given error is caused by duplicate keys.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406036949", "createdAt": "2020-04-09T08:21:46Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "diffHunk": "@@ -139,4 +142,21 @@ private MongoDbDeviceRegistryUtils() {\n                     String.format(\"Resource [%s] not found.\", resourceId)));\n         }\n     }\n+\n+    /**\n+     * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.\n+     *\n+     * @param error The exception to check. Other Throwables but {@link MongoException} return {@code false}.\n+     * @return {@code true} if exception is an {@link ErrorCategory#DUPLICATE_KEY} exception.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM2NjA3Ng==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406366076", "createdAt": "2020-04-09T17:35:50Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "diffHunk": "@@ -139,4 +142,21 @@ private MongoDbDeviceRegistryUtils() {\n                     String.format(\"Resource [%s] not found.\", resourceId)));\n         }\n     }\n+\n+    /**\n+     * Checks if a provided error is {@link MongoException} with error category {@link ErrorCategory#DUPLICATE_KEY}.\n+     *\n+     * @param error The exception to check. Other Throwables but {@link MongoException} return {@code false}.\n+     * @return {@code true} if exception is an {@link ErrorCategory#DUPLICATE_KEY} exception.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzNjk0OQ=="}, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxOTc5NjkwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODoyODowNFrOGDOv3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDoyMzo0OVrOGDS0cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA0MDU0MA==", "bodyText": "TheentityPropKey is always a constant and probably you could remove this parameter. Within the method withCa RegistryManagementConstants.FIELD_TENANT  could be used instead of string literal \"tenant\".", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406040540", "createdAt": "2020-04-09T08:28:04Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -46,6 +48,22 @@ public MongoDbDocumentBuilder withDeviceId(final String deviceId) {\n         return this;\n     }\n \n+    /**\n+     * Adds nested CA subjectDn property.\n+     *\n+     * @param entityPropKey key where entity properties are stored. e.g.: \"tenant\" for\n+     *                      the {@link org.eclipse.hono.service.management.tenant.Tenant}\n+     * @param caSubjectDn certificate Authority subjectDn\n+     * @return a reference to this for fluent use.\n+     */\n+    public MongoDbDocumentBuilder withCa(final String entityPropKey, final String caSubjectDn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwNzI0OA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406107248", "createdAt": "2020-04-09T10:23:49Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -46,6 +48,22 @@ public MongoDbDocumentBuilder withDeviceId(final String deviceId) {\n         return this;\n     }\n \n+    /**\n+     * Adds nested CA subjectDn property.\n+     *\n+     * @param entityPropKey key where entity properties are stored. e.g.: \"tenant\" for\n+     *                      the {@link org.eclipse.hono.service.management.tenant.Tenant}\n+     * @param caSubjectDn certificate Authority subjectDn\n+     * @return a reference to this for fluent use.\n+     */\n+    public MongoDbDocumentBuilder withCa(final String entityPropKey, final String caSubjectDn) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA0MDU0MA=="}, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxOTgxODQ3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODozMzozOFrOGDO9LQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNTozNTo0MVrOGDeLjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA0Mzk0OQ==", "bodyText": "How about renaming the parameter to subjectDN instead of caSubjectDn?\nAlso @param The subject DN.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406043949", "createdAt": "2020-04-09T08:33:38Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -46,6 +48,22 @@ public MongoDbDocumentBuilder withDeviceId(final String deviceId) {\n         return this;\n     }\n \n+    /**\n+     * Adds nested CA subjectDn property.\n+     *\n+     * @param entityPropKey key where entity properties are stored. e.g.: \"tenant\" for\n+     *                      the {@link org.eclipse.hono.service.management.tenant.Tenant}\n+     * @param caSubjectDn certificate Authority subjectDn", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwNzI5NQ==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406107295", "createdAt": "2020-04-09T10:23:54Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -46,6 +48,22 @@ public MongoDbDocumentBuilder withDeviceId(final String deviceId) {\n         return this;\n     }\n \n+    /**\n+     * Adds nested CA subjectDn property.\n+     *\n+     * @param entityPropKey key where entity properties are stored. e.g.: \"tenant\" for\n+     *                      the {@link org.eclipse.hono.service.management.tenant.Tenant}\n+     * @param caSubjectDn certificate Authority subjectDn", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA0Mzk0OQ=="}, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwOTkyMA==", "bodyText": "How about also updating to@param The subject DN as in the above comment.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406109920", "createdAt": "2020-04-09T10:28:52Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -46,6 +48,22 @@ public MongoDbDocumentBuilder withDeviceId(final String deviceId) {\n         return this;\n     }\n \n+    /**\n+     * Adds nested CA subjectDn property.\n+     *\n+     * @param entityPropKey key where entity properties are stored. e.g.: \"tenant\" for\n+     *                      the {@link org.eclipse.hono.service.management.tenant.Tenant}\n+     * @param caSubjectDn certificate Authority subjectDn", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA0Mzk0OQ=="}, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE1ODI1Mg==", "bodyText": "Any update on this?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406158252", "createdAt": "2020-04-09T12:09:06Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -46,6 +48,22 @@ public MongoDbDocumentBuilder withDeviceId(final String deviceId) {\n         return this;\n     }\n \n+    /**\n+     * Adds nested CA subjectDn property.\n+     *\n+     * @param entityPropKey key where entity properties are stored. e.g.: \"tenant\" for\n+     *                      the {@link org.eclipse.hono.service.management.tenant.Tenant}\n+     * @param caSubjectDn certificate Authority subjectDn", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA0Mzk0OQ=="}, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5MzM4OA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406293388", "createdAt": "2020-04-09T15:35:41Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -46,6 +48,22 @@ public MongoDbDocumentBuilder withDeviceId(final String deviceId) {\n         return this;\n     }\n \n+    /**\n+     * Adds nested CA subjectDn property.\n+     *\n+     * @param entityPropKey key where entity properties are stored. e.g.: \"tenant\" for\n+     *                      the {@link org.eclipse.hono.service.management.tenant.Tenant}\n+     * @param caSubjectDn certificate Authority subjectDn", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA0Mzk0OQ=="}, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxOTgzOTMzOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwODozOToxNFrOGDPJ0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDoyNDowMFrOGDS00w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA0NzE4NA==", "bodyText": "The span here remains unused, in that case it could be removed.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406047184", "createdAt": "2020-04-09T08:39:14Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> result(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> result(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        Objects.requireNonNull(span);\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId, span)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId, final Span span) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 349}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwNzM0Nw==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406107347", "createdAt": "2020-04-09T10:24:00Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> result(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> result(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        Objects.requireNonNull(span);\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId, span)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId, final Span span) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA0NzE4NA=="}, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 349}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDA3MTY5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwOTo0MzoxM1rOGDRa4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTowMzoxN1rOGDUATA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA4NDMyMg==", "bodyText": "Already the span is being checked for null and hence this could be removed and also the @throws part in the JavaDoc.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406084322", "createdAt": "2020-04-09T09:43:13Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> result(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> result(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        Objects.requireNonNull(span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 321}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyNjY2OA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406126668", "createdAt": "2020-04-09T11:03:17Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"\n+            + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\"\n+            + AuthenticationConstants.FIELD_SUBJECT_DN;\n+    private final String DUPLICATE_ERROR_MONGODB_REGEX = \"^\\\\w+\\\\sduplicate key error collection:\\\\s.+\\\\sindex:\\\\s.+\\\\sdup\\\\skey:\\\\s\\\\{\\\\s(?<key>.+):\\\\s(?<val>.+)\\\\s}$\";\n+    private final Pattern duplicateErrorMongodbPattern = Pattern.compile(DUPLICATE_ERROR_MONGODB_REGEX);\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        FIELD_PAYLOAD_TENANT + \".\"\n+                                                + RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been updated successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>409 Conflict</em> if provided trusted certificate authority is already present in another\n+     *         tenant.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(newTenant);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(String.format(\"successfully updated tenant [%s]\", tenantId));\n+                            return Future.<OperationResult<Void>> succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId))))\n+                .recover((error) -> {\n+                    if (error instanceof MongoCommandException) {\n+                        logDuplicationError(((MongoCommandException) error).getErrorMessage(), tenantId, span);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else if (error instanceof ServiceInvocationException) {\n+                        return Future.failedFuture(((ServiceInvocationException) error));\n+                    }\n+                    return Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                            String.format(\"Error modifying tenant [%s].\", tenantId)));\n+                });\n+    }\n+\n+//\n+    /**\n+     * {@inheritDoc}\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>204 No Content</em> if the tenant has been removed successfully.</li>\n+     *         <li><em>403 forbidden</em> if tenant modification is forbidden due to configuration settings.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier and version exists.</li>\n+     *         <li><em>412 Precondition Failed</em> if the version exists but mismatch the current tenants version.</li>\n+     *         </ul>\n+     */\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> result(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> result(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, String.format(\"tenant [%s] not found.\", tenantId));\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+        Objects.requireNonNull(span);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA4NDMyMg=="}, "originalCommit": {"oid": "2c3d299d926a701a0710964540c6701dee6fedc3"}, "originalPosition": 321}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDE2OTUxOnYy", "diffSide": "RIGHT", "path": "service-base/src/test/java/org/eclipse/hono/service/registration/RegistrationServiceTests.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDowOTo1NFrOGDSXkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTowMzowNVrOGDT__Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA5OTg1Ng==", "bodyText": "I guess that you by mistake included the changes related to tests in this PR instead of the other PR for tests. The changes in this class could be removed.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406099856", "createdAt": "2020-04-09T10:09:54Z", "author": {"login": "kaniyan"}, "path": "service-base/src/test/java/org/eclipse/hono/service/registration/RegistrationServiceTests.java", "diffHunk": "@@ -61,6 +61,10 @@\n      * The gateway identifier used in the tests.\n      */\n     protected static final String GW = \"gw-1\";\n+    /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8eff8fa86c857310878196da2da2ab49e927a56"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyNjU4OQ==", "bodyText": "Yes, indeed. Removed", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406126589", "createdAt": "2020-04-09T11:03:05Z", "author": {"login": "ko-j"}, "path": "service-base/src/test/java/org/eclipse/hono/service/registration/RegistrationServiceTests.java", "diffHunk": "@@ -61,6 +61,10 @@\n      * The gateway identifier used in the tests.\n      */\n     protected static final String GW = \"gw-1\";\n+    /**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA5OTg1Ng=="}, "originalCommit": {"oid": "f8eff8fa86c857310878196da2da2ab49e927a56"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDE4Mjg3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDoxMzo0NFrOGDSfyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMTowMzoxMVrOGDUAKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwMTk2Mw==", "bodyText": "Since FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN is being used only once during startup, it could be moved there instead of declaring it as a field variable.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406101963", "createdAt": "2020-04-09T10:13:44Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8eff8fa86c857310878196da2da2ab49e927a56"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEyNjYzMw==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406126633", "createdAt": "2020-04-09T11:03:11Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import com.mongodb.MongoCommandException;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private final String FIELD_PAYLOAD_TENANT = \"tenant\";\n+    private final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN = FIELD_PAYLOAD_TENANT + \".\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwMTk2Mw=="}, "originalCommit": {"oid": "f8eff8fa86c857310878196da2da2ab49e927a56"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDI0NjU4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDozMjo0MVrOGDTGcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMToyMDoxN1rOGDUfeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjExMTg1Nw==", "bodyText": "How about adding a description in sync with the other methods in this class? Something like Sets the json object with the given subject DN.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406111857", "createdAt": "2020-04-09T10:32:41Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -51,16 +51,16 @@ public MongoDbDocumentBuilder withDeviceId(final String deviceId) {\n     /**\n      * Adds nested CA subjectDn property.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aac69b67941a1cba4759ca8b7ed59492b9900825"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEzNDY1MA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406134650", "createdAt": "2020-04-09T11:20:17Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDocumentBuilder.java", "diffHunk": "@@ -51,16 +51,16 @@ public MongoDbDocumentBuilder withDeviceId(final String deviceId) {\n     /**\n      * Adds nested CA subjectDn property.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjExMTg1Nw=="}, "originalCommit": {"oid": "aac69b67941a1cba4759ca8b7ed59492b9900825"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDU1MzA4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/test/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedRegistrationServiceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjoxMTo0OFrOGDWBMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNTozNjoxNVrOGDeM3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE1OTY2Nw==", "bodyText": "I think, this class is in this PR by mistake.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406159667", "createdAt": "2020-04-09T12:11:48Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/test/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedRegistrationServiceTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedRegistrationConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.registration.RegistrationService;\n+import org.eclipse.hono.service.registration.RegistrationServiceTests;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import io.vertx.core.Context;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.junit5.Timeout;\n+import io.vertx.junit5.VertxExtension;\n+\n+@ExtendWith(VertxExtension.class)\n+@Timeout(timeUnit = TimeUnit.SECONDS, value = 3)\n+class MongoDbBasedRegistrationServiceTest extends RegistrationServiceTests {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46e62fce6ff2b499760a037f30c29a0d6fad3d14"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5MzcyNA==", "bodyText": "that's right.\ndone", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406293724", "createdAt": "2020-04-09T15:36:15Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/test/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedRegistrationServiceTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import static org.mockito.Mockito.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedRegistrationConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.service.management.device.DeviceManagementService;\n+import org.eclipse.hono.service.registration.RegistrationService;\n+import org.eclipse.hono.service.registration.RegistrationServiceTests;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import io.vertx.core.Context;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.junit5.Timeout;\n+import io.vertx.junit5.VertxExtension;\n+\n+@ExtendWith(VertxExtension.class)\n+@Timeout(timeUnit = TimeUnit.SECONDS, value = 3)\n+class MongoDbBasedRegistrationServiceTest extends RegistrationServiceTests {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE1OTY2Nw=="}, "originalCommit": {"oid": "46e62fce6ff2b499760a037f30c29a0d6fad3d14"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDU1ODI4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjoxMzoyMlrOGDWEcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNTozNjoyMFrOGDeNFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE2MDQ5OA==", "bodyText": "No need of String.format(...).", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406160498", "createdAt": "2020-04-09T12:13:22Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -209,7 +209,7 @@ public void stop(final Promise<Void> stopPromise) {\n         return deleteTenantPromise.future()\n                 .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n                         .map(deleted -> {\n-                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            span.log(String.format(\"successfully deleted tenant\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df6379bc49b2347e8a6aea4089b99e90cbdc3d23"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5Mzc4MA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406293780", "createdAt": "2020-04-09T15:36:20Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -209,7 +209,7 @@ public void stop(final Promise<Void> stopPromise) {\n         return deleteTenantPromise.future()\n                 .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n                         .map(deleted -> {\n-                            span.log(String.format(\"successfully deleted tenant [%s]\", tenantId));\n+                            span.log(String.format(\"successfully deleted tenant\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE2MDQ5OA=="}, "originalCommit": {"oid": "df6379bc49b2347e8a6aea4089b99e90cbdc3d23"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMDU3OTkwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjoyMDowNVrOGDWSHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNTozNjozMlrOGDeNlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE2Mzk5Ng==", "bodyText": "Since this variable is being used at only one place, could you please inline that reference and remove this variable.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406163996", "createdAt": "2020-04-09T12:20:05Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -106,6 +102,11 @@ public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n \n     @Override\n     public void start(final Promise<Void> startPromise) {\n+        final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bca53e52c00ea2f68db6fcb679cc4cf257ff5b20"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5MzkwOA==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r406293908", "createdAt": "2020-04-09T15:36:32Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -106,6 +102,11 @@ public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n \n     @Override\n     public void start(final Promise<Void> startPromise) {\n+        final String FIELD_PAYLOAD_TRUSTED_CA_WITH_SUBJECT_DN =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE2Mzk5Ng=="}, "originalCommit": {"oid": "bca53e52c00ea2f68db6fcb679cc4cf257ff5b20"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDQ3ODU0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwODo0MDozNVrOGIJlTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMDo0OTozNVrOGIOinw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE5ODc5Nw==", "bodyText": "As per the naming conventions, we could change this static final variable to upper case (LOG).", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r411198797", "createdAt": "2020-04-20T08:40:35Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,424 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8323612c9358f3652ed2baf0325ac45a434bccd"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI4MDAzMQ==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r411280031", "createdAt": "2020-04-20T10:49:35Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,424 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE5ODc5Nw=="}, "originalCommit": {"oid": "f8323612c9358f3652ed2baf0325ac45a434bccd"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDUwNjU5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwODo0NzowN1rOGIJ1zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowNjo0NFrOGIKojA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwMzAyMg==", "bodyText": "log.debug(...) please.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r411203022", "createdAt": "2020-04-20T08:47:07Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,424 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                        RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        log.error(String.format(\"conflict updating tenant [%s]. An existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8323612c9358f3652ed2baf0325ac45a434bccd"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNjAxMg==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r411216012", "createdAt": "2020-04-20T09:06:44Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,424 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                        RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        log.error(String.format(\"conflict updating tenant [%s]. An existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwMzAyMg=="}, "originalCommit": {"oid": "f8323612c9358f3652ed2baf0325ac45a434bccd"}, "originalPosition": 176}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDUxNjA4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwODo0OToxNVrOGIJ7Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwOTowNjo0N1rOGIKovw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwNDQzNQ==", "bodyText": "log.debug(...) please.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r411204435", "createdAt": "2020-04-20T08:49:15Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,424 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                        RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        log.error(String.format(\"conflict updating tenant [%s]. An existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);\n+                        TracingHelper.logError(span, \"An existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found.\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId) {\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Tenant [%s] not found.\",\n+                                        findQuery.getString(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID))))));\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(span);\n+\n+        final String tenantIdOrGenerated = tenantId.orElse(DeviceRegistryUtils.getUniqueIdentifier());\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantIdOrGenerated)\n+                .compose(ok -> processCreateTenant(tenantIdOrGenerated, tenantObj, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Id>> processCreateTenant(final String tenantId, final Tenant tenantObj,\n+            final Span span) {\n+\n+        final TenantDto newTenantDto = new TenantDto(tenantId, tenantObj,\n+                new Versioned<>(tenantObj).getVersion());\n+\n+        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+        final Promise<String> createTenantPromise = Promise.promise();\n+        mongoClient.insert(config.getCollectionName(), newTenantDtoJson, createTenantPromise);\n+        return createTenantPromise.future()\n+                .compose(tenantObjectIdResult -> {\n+                    span.log(\"successfully created tenant.\");\n+                    return Future.succeededFuture(OperationResult.ok(\n+                            HttpURLConnection.HTTP_CREATED,\n+                            Id.of(tenantId),\n+                            Optional.empty(),\n+                            Optional.of(newTenantDto.getVersion())));\n+                })\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        log.error(String.format(\"The tenant [%s] already exists or an existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8323612c9358f3652ed2baf0325ac45a434bccd"}, "originalPosition": 414}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNjA2Mw==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r411216063", "createdAt": "2020-04-20T09:06:47Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,424 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {\n+\n+    private static final Logger log = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public void start(final Promise<Void> startPromise) {\n+        CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                        RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(success -> {\n+                    startPromise.complete();\n+                    return null;\n+                })\n+                .onFailure(startPromise::fail);\n+    }\n+\n+    @Override\n+    public void stop(final Promise<Void> stopPromise) {\n+        this.mongoClient.close();\n+        stopPromise.complete();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        log.error(String.format(\"conflict updating tenant [%s]. An existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);\n+                        TracingHelper.logError(span, \"An existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found.\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId) {\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Tenant [%s] not found.\",\n+                                        findQuery.getString(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID))))));\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(span);\n+\n+        final String tenantIdOrGenerated = tenantId.orElse(DeviceRegistryUtils.getUniqueIdentifier());\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantIdOrGenerated)\n+                .compose(ok -> processCreateTenant(tenantIdOrGenerated, tenantObj, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Id>> processCreateTenant(final String tenantId, final Tenant tenantObj,\n+            final Span span) {\n+\n+        final TenantDto newTenantDto = new TenantDto(tenantId, tenantObj,\n+                new Versioned<>(tenantObj).getVersion());\n+\n+        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+        final Promise<String> createTenantPromise = Promise.promise();\n+        mongoClient.insert(config.getCollectionName(), newTenantDtoJson, createTenantPromise);\n+        return createTenantPromise.future()\n+                .compose(tenantObjectIdResult -> {\n+                    span.log(\"successfully created tenant.\");\n+                    return Future.succeededFuture(OperationResult.ok(\n+                            HttpURLConnection.HTTP_CREATED,\n+                            Id.of(tenantId),\n+                            Optional.empty(),\n+                            Optional.of(newTenantDto.getVersion())));\n+                })\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        log.error(String.format(\"The tenant [%s] already exists or an existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwNDQzNQ=="}, "originalCommit": {"oid": "f8323612c9358f3652ed2baf0325ac45a434bccd"}, "originalPosition": 414}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDg5MzE3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/ApplicationConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMDoxNzozOFrOGINa3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMDo0NzoyNVrOGIOd1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI2MTY2MA==", "bodyText": "Tenant service and not registration service. Could you please update it?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r411261660", "createdAt": "2020-04-20T10:17:38Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/ApplicationConfig.java", "diffHunk": "@@ -255,6 +275,17 @@ public MongoDbBasedCredentialsService credentialsService() {\n         return new MongoDbBasedCredentialsService();\n     }\n \n+    /**\n+     * Exposes the MongoDB tenant service as a Spring bean.\n+     *\n+     * @return The MongoDB registration service.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06fdb2007c2f58263f899b96208c3e89fc1ed49"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI3ODgwNw==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r411278807", "createdAt": "2020-04-20T10:47:25Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/ApplicationConfig.java", "diffHunk": "@@ -255,6 +275,17 @@ public MongoDbBasedCredentialsService credentialsService() {\n         return new MongoDbBasedCredentialsService();\n     }\n \n+    /**\n+     * Exposes the MongoDB tenant service as a Spring bean.\n+     *\n+     * @return The MongoDB registration service.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI2MTY2MA=="}, "originalCommit": {"oid": "e06fdb2007c2f58263f899b96208c3e89fc1ed49"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDg5Njg2OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/ApplicationConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMDoxODoyOFrOGINdBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMDo0NzozNFrOGIOeHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI2MjIxMg==", "bodyText": "Could you please revert it back to the original version? The previous formatting was fine.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r411262212", "createdAt": "2020-04-20T10:18:28Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/ApplicationConfig.java", "diffHunk": "@@ -335,7 +377,7 @@ public HttpEndpoint deviceHttpEndpoint() {\n         // need to use backend service because creating a device implicitly\n         // creates (empty) credentials as well for the device\n         final MongoDbBasedDeviceBackend service = new MongoDbBasedDeviceBackend(registrationService(),\n-                credentialsService());\n+                                                                                credentialsService());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06fdb2007c2f58263f899b96208c3e89fc1ed49"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI3ODg3OA==", "bodyText": "reverted", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r411278878", "createdAt": "2020-04-20T10:47:34Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/ApplicationConfig.java", "diffHunk": "@@ -335,7 +377,7 @@ public HttpEndpoint deviceHttpEndpoint() {\n         // need to use backend service because creating a device implicitly\n         // creates (empty) credentials as well for the device\n         final MongoDbBasedDeviceBackend service = new MongoDbBasedDeviceBackend(registrationService(),\n-                credentialsService());\n+                                                                                credentialsService());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI2MjIxMg=="}, "originalCommit": {"oid": "e06fdb2007c2f58263f899b96208c3e89fc1ed49"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDg5NzU1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/ApplicationConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMDoxODozOFrOGINdZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMDo0NzozNlrOGIOeMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI2MjMwOQ==", "bodyText": "Could you please revert it back to the original version? The previous formatting was fine.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r411262309", "createdAt": "2020-04-20T10:18:38Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/ApplicationConfig.java", "diffHunk": "@@ -277,10 +308,21 @@ public AmqpEndpoint credentialsAmqpEndpoint() {\n         // need to use backend service because the Credentials service's \"get\" operation\n         // supports auto-provisioning and thus needs to be able to create a device on the fly\n         final MongoDbBasedDeviceBackend service = new MongoDbBasedDeviceBackend(registrationService(),\n-                credentialsService());\n+                                                                                credentialsService());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06fdb2007c2f58263f899b96208c3e89fc1ed49"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI3ODg5OQ==", "bodyText": "reverted", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r411278899", "createdAt": "2020-04-20T10:47:36Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/ApplicationConfig.java", "diffHunk": "@@ -277,10 +308,21 @@ public AmqpEndpoint credentialsAmqpEndpoint() {\n         // need to use backend service because the Credentials service's \"get\" operation\n         // supports auto-provisioning and thus needs to be able to create a device on the fly\n         final MongoDbBasedDeviceBackend service = new MongoDbBasedDeviceBackend(registrationService(),\n-                credentialsService());\n+                                                                                credentialsService());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI2MjMwOQ=="}, "originalCommit": {"oid": "e06fdb2007c2f58263f899b96208c3e89fc1ed49"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NDg5OTEyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/ApplicationConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMDoxODo1NlrOGINePg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMDo0Nzo0M1rOGIOecQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI2MjUyNg==", "bodyText": "Could you please revert it back to the original version? The previous formatting was fine.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r411262526", "createdAt": "2020-04-20T10:18:56Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/ApplicationConfig.java", "diffHunk": "@@ -349,6 +391,19 @@ public HttpEndpoint deviceHttpEndpoint() {\n     @Scope(\"prototype\")\n     public HttpEndpoint credentialsHttpEndpoint() {\n         return new DelegatingCredentialsManagementHttpEndpoint<CredentialsManagementService>(vertx(),\n-                credentialsService());\n+                                                                                             credentialsService());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e06fdb2007c2f58263f899b96208c3e89fc1ed49"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI3ODk2MQ==", "bodyText": "reverted", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r411278961", "createdAt": "2020-04-20T10:47:43Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/ApplicationConfig.java", "diffHunk": "@@ -349,6 +391,19 @@ public HttpEndpoint deviceHttpEndpoint() {\n     @Scope(\"prototype\")\n     public HttpEndpoint credentialsHttpEndpoint() {\n         return new DelegatingCredentialsManagementHttpEndpoint<CredentialsManagementService>(vertx(),\n-                credentialsService());\n+                                                                                             credentialsService());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI2MjUyNg=="}, "originalCommit": {"oid": "e06fdb2007c2f58263f899b96208c3e89fc1ed49"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzM5MDY5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjoyMToyNVrOGJ_LPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwODoxMzozM1rOGKckNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEyNTQzOA==", "bodyText": "Extending AbstractVerticle could be removed and implement LifeCycle. Please refer to the MongoDbBasedRegistrationService.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r413125438", "createdAt": "2020-04-22T16:21:25Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,424 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b7e780da92fe3d0457dd27b172ee35660a555b9"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYwNjk2Ng==", "bodyText": "updated.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r413606966", "createdAt": "2020-04-23T08:13:33Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,424 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService extends AbstractVerticle\n+        implements TenantService, TenantManagementService {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEyNTQzOA=="}, "originalCommit": {"oid": "6b7e780da92fe3d0457dd27b172ee35660a555b9"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDY1NTgwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwODoxNzo0NFrOGKcvhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwOTowOTozMVrOGKfBDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYwOTg2MQ==", "bodyText": "This promise could be removed and the CompositeFuture could be mapped to return a Future.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r413609861", "createdAt": "2020-04-23T08:17:44Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        final Promise<Void> startPromise = Promise.promise();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b653ca48575896a410becf5f3c3b2e26cbcf99c"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0NzExNw==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r413647117", "createdAt": "2020-04-23T09:09:31Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        final Promise<Void> startPromise = Promise.promise();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzYwOTg2MQ=="}, "originalCommit": {"oid": "1b653ca48575896a410becf5f3c3b2e26cbcf99c"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDg4OTQ0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwOTowNzoyOFrOGKe7PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwOToxMTozN1rOGKfG0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0NTYyOA==", "bodyText": "This unused variable startPromise could be removed.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r413645628", "createdAt": "2020-04-23T09:07:28Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,420 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        final Promise<Void> startPromise = Promise.promise();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2bd2d4cffe17ea02fe1591d73e8c1e65f02ab7f"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0ODU5Mw==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r413648593", "createdAt": "2020-04-23T09:11:37Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,420 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        final Promise<Void> startPromise = Promise.promise();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0NTYyOA=="}, "originalCommit": {"oid": "d2bd2d4cffe17ea02fe1591d73e8c1e65f02ab7f"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjEwMjQxOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantBackend.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMToyNTo1OFrOGN6gzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNDo0ODo1NVrOGOCmWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MzM0Mg==", "bodyText": "what is this class good for?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417243342", "createdAt": "2020-04-29T11:25:58Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantBackend.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantBackend;\n+import org.eclipse.hono.util.TenantResult;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Repository;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Verticle;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A tenant backend that leverages {@link MongoDbBasedTenantService}.\n+ */\n+@Repository\n+@Qualifier(\"backend\")\n+public class MongoDbBasedTenantBackend extends AbstractVerticle", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM3NTgzMg==", "bodyText": "The legacy of former implementations. Will be removed.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417375832", "createdAt": "2020-04-29T14:48:55Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantBackend.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantBackend;\n+import org.eclipse.hono.util.TenantResult;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Repository;\n+\n+import io.opentracing.Span;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Verticle;\n+import io.vertx.core.json.JsonObject;\n+\n+/**\n+ * A tenant backend that leverages {@link MongoDbBasedTenantService}.\n+ */\n+@Repository\n+@Qualifier(\"backend\")\n+public class MongoDbBasedTenantBackend extends AbstractVerticle", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MzM0Mg=="}, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjEwNTU4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMToyNjo1NFrOGN6iug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNDo0ODo1NlrOGOCmdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MzgzNA==", "bodyText": "please remove these annotations, we are no longer using Spring Boot's component scan", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417243834", "createdAt": "2020-04-29T11:26:54Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM3NTg2Mg==", "bodyText": "Done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417375862", "createdAt": "2020-04-29T14:48:56Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0MzgzNA=="}, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjExMTE3OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMToyODo0OFrOGN6mHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNDo0ODo0OVrOGOCmGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NDcwMQ==", "bodyText": "there is no need to explicitly enumerate the types of the params. This information can be seen from the @param tags. This method also doesn't seem to accept a MongoClient, does it? FMPOV it would be more helpful if the description would, well, describe what the executor is used for ...", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417244701", "createdAt": "2020-04-29T11:28:48Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM3NTc2OQ==", "bodyText": "The documentation is similar to the method of MongoDbBasedRegistrationService.\nMongoClient is not a parameter, but is set implicitly by the setter and therefore mentioned.\nHow about the following change:\nSets an instance of a utility class that allows creation of indices and accessing a shared {@code MongoClient}.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417375769", "createdAt": "2020-04-29T14:48:49Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NDcwMQ=="}, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjExODIzOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMTozMDo1OVrOGN6qJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNDo0ODo0M1rOGOClxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NTczNQ==", "bodyText": "what if config is null?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417245735", "createdAt": "2020-04-29T11:30:59Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM3NTY4NQ==", "bodyText": "That is checked in setConfig.\nIf no MongoDbBasedTenantsConfigProperties exists to be passed, a NPE would occur.\nShould a null check happen in this method?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417375685", "createdAt": "2020-04-29T14:48:43Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NTczNQ=="}, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjEyMjk4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMTozMjoxNlrOGN6syw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDozNDoxMVrOGR4jkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NjQxMQ==", "bodyText": "sure that this is RegistrationConstants and not RegistryManagementConstants?", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417246411", "createdAt": "2020-04-29T11:32:16Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM4MDc3OA==", "bodyText": "RegistrationConstants contains \"tenant-id\" that is used in various classes in the registry and is needed to distinguish it from other ids e.g. device-id.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417380778", "createdAt": "2020-04-29T14:55:11Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NjQxMQ=="}, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM1NzY4MA==", "bodyText": "my point is that the data model used in the Mongo DB collections is based on the Device Registry Management API's types. Thus, the field names used when accessing the collections should be referred to by means of RegistryManagementConstants. The RegistrationConstants contain constants defined by the Tenant API ...", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r421357680", "createdAt": "2020-05-07T09:12:57Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NjQxMQ=="}, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwNTU4Nw==", "bodyText": "I missed that RegistryManagementConstants inherits a constant with \"tenant-id\" too.\nChanged it.\nBut then the section in MongoDbBasedRegistrationService#L107-L108 should be changed as well.\nI would provide a PR for MongoDbBasedRegistrationService when it is completed.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r421405587", "createdAt": "2020-05-07T10:34:11Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NjQxMQ=="}, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjEzMDY5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMTozNDozOVrOGN6xkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTowNTo0OVrOGODZVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NzYzMw==", "bodyText": "I wonder why we need to be aware of the inner workings of the executor by keeping a reference to one of its properties ...\nIf this class needs a MongoClient, then it should be passed in as a separate parameter here.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417247633", "createdAt": "2020-04-29T11:34:39Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM4ODg4Nw==", "bodyText": "Good idea, but the mongoDbCallExecutor is currently used to handle more complex functions like createCollectionIndex and to return a shared MongoClient on which most db operations of the service classes happen.\nThe usage is similar to the usage of class MongoDbBasedRegistrationService. So I would suggest to change this in a later PR in all classes.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417388887", "createdAt": "2020-04-29T15:05:49Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI0NzYzMw=="}, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjE2Mzk4OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMTo0NDo0MlrOGN7Fhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDozNDo1MVrOGR4lKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1Mjc0Mw==", "bodyText": "please remove the . at the end", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417252743", "createdAt": "2020-04-29T11:44:42Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwNTk5Mg==", "bodyText": "done", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r421405992", "createdAt": "2020-05-07T10:34:51Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1Mjc0Mw=="}, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjE3MDk0OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMTo0NjozOFrOGN7Jmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo0Mjo0M1rOGOFGmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1Mzc4Ng==", "bodyText": "no need to use String.format in a log statement ...", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417253786", "createdAt": "2020-04-29T11:46:38Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(String.format(\"conflict updating tenant [%s]. An existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQxNjg1Ng==", "bodyText": "updated.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417416856", "createdAt": "2020-04-29T15:42:43Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(String.format(\"conflict updating tenant [%s]. An existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1Mzc4Ng=="}, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjIxMTMwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMTo1ODo1NFrOGN7iBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNToyMzozNlrOGOENzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI2MDAzNg==", "bodyText": "this makes an assumption about the structure of the findQuery which is not obvious to the user of this method. If the tenant ID is required for implementing this method, then it should be passed in as a parameter explicitly.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417260036", "createdAt": "2020-04-29T11:58:54Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(String.format(\"conflict updating tenant [%s]. An existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);\n+                        TracingHelper.logError(span, \"An existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found.\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId) {\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Tenant [%s] not found.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 371}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwMjMxOA==", "bodyText": "The tenantId is not required, since it's only used in the error message.\nI suggest to display the error message conditionally with the tenantId.", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417402318", "createdAt": "2020-04-29T15:23:36Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(String.format(\"conflict updating tenant [%s]. An existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);\n+                        TracingHelper.logError(span, \"An existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found.\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId) {\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Tenant [%s] not found.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI2MDAzNg=="}, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 371}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjIxMjMzOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMTo1OToxNFrOGN7irQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTozMjowNVrOGOEn0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI2MDIwNQ==", "bodyText": "this is not true if I understand the code correctly", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417260205", "createdAt": "2020-04-29T11:59:14Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(String.format(\"conflict updating tenant [%s]. An existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);\n+                        TracingHelper.logError(span, \"An existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found.\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId) {\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwODk3OQ==", "bodyText": "Updated", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417408979", "createdAt": "2020-04-29T15:32:05Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(String.format(\"conflict updating tenant [%s]. An existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);\n+                        TracingHelper.logError(span, \"An existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found.\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId) {\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI2MDIwNQ=="}, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 352}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjIyODQwOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMjowNDoxMlrOGN7slQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTozMjowM1rOGOEnuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI2Mjc0MQ==", "bodyText": "please remove . at the end", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417262741", "createdAt": "2020-04-29T12:04:12Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(String.format(\"conflict updating tenant [%s]. An existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);\n+                        TracingHelper.logError(span, \"An existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found.\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId) {\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Tenant [%s] not found.\",\n+                                        findQuery.getString(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID))))));\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(span);\n+\n+        final String tenantIdOrGenerated = tenantId.orElse(DeviceRegistryUtils.getUniqueIdentifier());\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantIdOrGenerated)\n+                .compose(ok -> processCreateTenant(tenantIdOrGenerated, tenantObj, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Id>> processCreateTenant(final String tenantId, final Tenant tenantObj,\n+            final Span span) {\n+\n+        final TenantDto newTenantDto = new TenantDto(tenantId, tenantObj,\n+                new Versioned<>(tenantObj).getVersion());\n+\n+        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+        final Promise<String> createTenantPromise = Promise.promise();\n+        mongoClient.insert(config.getCollectionName(), newTenantDtoJson, createTenantPromise);\n+        return createTenantPromise.future()\n+                .compose(tenantObjectIdResult -> {\n+                    span.log(\"successfully created tenant.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 400}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwODk1Mw==", "bodyText": "removed from all log strings", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417408953", "createdAt": "2020-04-29T15:32:03Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(String.format(\"conflict updating tenant [%s]. An existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);\n+                        TracingHelper.logError(span, \"An existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found.\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId) {\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Tenant [%s] not found.\",\n+                                        findQuery.getString(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID))))));\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(span);\n+\n+        final String tenantIdOrGenerated = tenantId.orElse(DeviceRegistryUtils.getUniqueIdentifier());\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantIdOrGenerated)\n+                .compose(ok -> processCreateTenant(tenantIdOrGenerated, tenantObj, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Id>> processCreateTenant(final String tenantId, final Tenant tenantObj,\n+            final Span span) {\n+\n+        final TenantDto newTenantDto = new TenantDto(tenantId, tenantObj,\n+                new Versioned<>(tenantObj).getVersion());\n+\n+        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+        final Promise<String> createTenantPromise = Promise.promise();\n+        mongoClient.insert(config.getCollectionName(), newTenantDtoJson, createTenantPromise);\n+        return createTenantPromise.future()\n+                .compose(tenantObjectIdResult -> {\n+                    span.log(\"successfully created tenant.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI2Mjc0MQ=="}, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 400}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NjIyOTU5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxMjowNDozNlrOGN7tUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTozMTo1OFrOGOEngA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI2MjkzMA==", "bodyText": "no need to use String.format in a log statement", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417262930", "createdAt": "2020-04-29T12:04:36Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(String.format(\"conflict updating tenant [%s]. An existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);\n+                        TracingHelper.logError(span, \"An existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found.\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId) {\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Tenant [%s] not found.\",\n+                                        findQuery.getString(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID))))));\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(span);\n+\n+        final String tenantIdOrGenerated = tenantId.orElse(DeviceRegistryUtils.getUniqueIdentifier());\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantIdOrGenerated)\n+                .compose(ok -> processCreateTenant(tenantIdOrGenerated, tenantObj, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Id>> processCreateTenant(final String tenantId, final Tenant tenantObj,\n+            final Span span) {\n+\n+        final TenantDto newTenantDto = new TenantDto(tenantId, tenantObj,\n+                new Versioned<>(tenantObj).getVersion());\n+\n+        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+        final Promise<String> createTenantPromise = Promise.promise();\n+        mongoClient.insert(config.getCollectionName(), newTenantDtoJson, createTenantPromise);\n+        return createTenantPromise.future()\n+                .compose(tenantObjectIdResult -> {\n+                    span.log(\"successfully created tenant.\");\n+                    return Future.succeededFuture(OperationResult.ok(\n+                            HttpURLConnection.HTTP_CREATED,\n+                            Id.of(tenantId),\n+                            Optional.empty(),\n+                            Optional.of(newTenantDto.getVersion())));\n+                })\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(String.format(\"The tenant [%s] already exists or an existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);\n+                        TracingHelper.logError(span, \"The tenant with the given identifier already exists or an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else {\n+                        LOG.error(String.format(\"Error adding Tenant [%s].\", tenantId), error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 413}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwODg5Ng==", "bodyText": "Updated", "url": "https://github.com/eclipse/hono/pull/1845#discussion_r417408896", "createdAt": "2020-04-29T15:31:58Z", "author": {"login": "ko-j"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedTenantService.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.deviceregistry.mongodb.service;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import javax.security.auth.x500.X500Principal;\n+\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.deviceregistry.mongodb.config.MongoDbBasedTenantsConfigProperties;\n+import org.eclipse.hono.deviceregistry.mongodb.model.TenantDto;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbCallExecutor;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.mongodb.utils.MongoDbDocumentBuilder;\n+import org.eclipse.hono.deviceregistry.util.DeviceRegistryUtils;\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.Lifecycle;\n+import org.eclipse.hono.service.management.Id;\n+import org.eclipse.hono.service.management.OperationResult;\n+import org.eclipse.hono.service.management.Result;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.service.management.tenant.TenantManagementService;\n+import org.eclipse.hono.service.tenant.TenantService;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.AuthenticationConstants;\n+import org.eclipse.hono.util.RegistrationConstants;\n+import org.eclipse.hono.util.RegistryManagementConstants;\n+import org.eclipse.hono.util.TenantResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.stereotype.Component;\n+\n+import io.opentracing.Span;\n+import io.opentracing.noop.NoopSpan;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.mongo.FindOptions;\n+import io.vertx.ext.mongo.IndexOptions;\n+import io.vertx.ext.mongo.MongoClient;\n+import io.vertx.ext.mongo.UpdateOptions;\n+\n+/**\n+ * An implementation of the tenant service and the tenant management service\n+ * that uses a mongodb database to store tenants.\n+ * <p>\n+ * On startup this adapter tries to find the tenant collection, if not found, it gets created.\n+ *\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/tenant/\">Tenant API</a>\n+ * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/\">Device Registry Management API</a>\n+ */\n+@Component\n+@Qualifier(\"serviceImpl\")\n+public final class MongoDbBasedTenantService implements TenantService, TenantManagementService, Lifecycle {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MongoDbBasedTenantService.class);\n+\n+    private static final int INDEX_CREATION_MAX_RETRIES = 3;\n+    private MongoClient mongoClient;\n+    private MongoDbCallExecutor mongoDbCallExecutor;\n+    private MongoDbBasedTenantsConfigProperties config;\n+\n+    /**\n+     * Sets an instance of the {@code MongoDbCallExecutor} and {@code MongoClient}.\n+     *\n+     * @param mongoDbCallExecutor An instance of the mongoDbCallExecutor.\n+     * @throws NullPointerException if the mongoDbCallExecutor is {@code null}.\n+     */\n+    @Autowired\n+    public void setExecutor(final MongoDbCallExecutor mongoDbCallExecutor) {\n+        this.mongoDbCallExecutor = Objects.requireNonNull(mongoDbCallExecutor);\n+        this.mongoClient = Objects.requireNonNull(this.mongoDbCallExecutor.getMongoClient());\n+    }\n+\n+    /**\n+     * Sets the configuration properties for this service.\n+     *\n+     * @param config The configuration properties.\n+     * @throws NullPointerException if the configuration is {@code null}.\n+     */\n+    @Autowired\n+    public void setConfig(final MongoDbBasedTenantsConfigProperties config) {\n+        this.config = Objects.requireNonNull(config);\n+    }\n+\n+    @Override\n+    public Future<Void> start() {\n+        return CompositeFuture.all(\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID, 1),\n+                        new IndexOptions().unique(true), INDEX_CREATION_MAX_RETRIES),\n+                mongoDbCallExecutor.createCollectionIndex(config.getCollectionName(),\n+                        new JsonObject().put(RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA + \".\" +\n+                                AuthenticationConstants.FIELD_SUBJECT_DN, 1),\n+                        new IndexOptions().unique(true)\n+                                .partialFilterExpression(new JsonObject().put(\n+                                        RegistryManagementConstants.FIELD_TENANT + \".\" +\n+                                                RegistryManagementConstants.FIELD_PAYLOAD_TRUSTED_CA,\n+                                        new JsonObject().put(\"$exists\", true))),\n+                        INDEX_CREATION_MAX_RETRIES))\n+                .map(ok -> null);\n+    }\n+\n+    @Override\n+    public Future<Void>  stop() {\n+        this.mongoClient.close();\n+        return Future.succeededFuture();\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Void>> updateTenant(final String tenantId, final Tenant tenantObj,\n+            final Optional<String> resourceVersion, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processUpdateTenant(tenantId, tenantObj, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Void>> processUpdateTenant(final String tenantId, final Tenant newTenant,\n+            final Optional<String> resourceVersion, final Span span) {\n+\n+        final JsonObject updateTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> updateTenantPromise = Promise.promise();\n+        final TenantDto newTenantDto = new TenantDto(tenantId, newTenant,\n+                new Versioned<>(newTenant).getVersion());\n+        mongoClient.findOneAndReplaceWithOptions(config.getCollectionName(), updateTenantQuery,\n+                JsonObject.mapFrom(newTenantDto), new FindOptions(), new UpdateOptions().setReturningNewDocument(true),\n+                updateTenantPromise);\n+\n+        return updateTenantPromise.future()\n+                .compose(updateResult -> Optional.ofNullable(updateResult)\n+                        .map(updated -> {\n+                            span.log(\"successfully updated tenant.\");\n+                            return Future.succeededFuture(OperationResult.ok(\n+                                    HttpURLConnection.HTTP_NO_CONTENT,\n+                                    (Void) null,\n+                                    Optional.empty(),\n+                                    Optional.of(updateResult.getString(MongoDbDeviceRegistryUtils.FIELD_VERSION))));\n+                        })\n+                        .orElse(MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(\n+                                tenantId, resourceVersion, findTenant(tenantId)))\n+                )\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(String.format(\"conflict updating tenant [%s]. An existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);\n+                        TracingHelper.logError(span, \"An existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    }\n+                    return Future.failedFuture(error);\n+                });\n+    }\n+\n+    @Override\n+    public Future<Result<Void>> deleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(resourceVersion);\n+        Objects.requireNonNull(span);\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantId)\n+                .compose(ok -> processDeleteTenant(tenantId, resourceVersion, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<Result<Void>> processDeleteTenant(final String tenantId, final Optional<String> resourceVersion,\n+            final Span span) {\n+\n+        final JsonObject deleteTenantQuery = resourceVersion\n+                .map(version -> new MongoDbDocumentBuilder().withVersion(version))\n+                .orElse(new MongoDbDocumentBuilder())\n+                .withTenantId(tenantId)\n+                .document();\n+\n+        final Promise<JsonObject> deleteTenantPromise = Promise.promise();\n+        mongoClient.findOneAndDelete(config.getCollectionName(), deleteTenantQuery, deleteTenantPromise);\n+        return deleteTenantPromise.future()\n+                .compose(tenantDtoResult -> Optional.ofNullable(tenantDtoResult)\n+                        .map(deleted -> {\n+                            span.log(\"successfully deleted tenant\");\n+                            return Future.succeededFuture(Result.<Void> from(HttpURLConnection.HTTP_NO_CONTENT));\n+                        })\n+                        .orElseGet(() -> MongoDbDeviceRegistryUtils.checkForVersionMismatchAndFail(tenantId,\n+                                resourceVersion, findTenant(tenantId))));\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        return get(tenantId, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return readTenant(tenantId, span)\n+                .compose(tenantDtoResult -> {\n+                    if (tenantDtoResult.getStatus() != HttpURLConnection.HTTP_OK) {\n+                        TracingHelper.logError(span, \"tenant not found.\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    }\n+                    return Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils\n+                                    .convertTenant(tenantId, tenantDtoResult.getPayload(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())));\n+                });\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        return get(subjectDn, NoopSpan.INSTANCE);\n+    }\n+\n+    @Override\n+    public Future<TenantResult<JsonObject>> get(final X500Principal subjectDn, final Span span) {\n+        Objects.requireNonNull(subjectDn);\n+        Objects.requireNonNull(span);\n+\n+        return getForCertificateAuthority(subjectDn, span);\n+    }\n+\n+    /**\n+     * Finds an existing tenant by the subject DN of its configured certificate authority.\n+     *\n+     * @param subjectDn the subject DN to find the tenant with.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method!\n+     *            An implementation should log (error) events on this span and it may set tags\n+     *            and use this span as the parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be\n+     *         <ul>\n+     *         <li><em>200 OK</em> if a tenant with the given certificate authority is registered.\n+     *         The <em>payload</em> will contain the tenant's configuration information.</li>\n+     *         <li><em>400 Bad Request</em> if the certificate authority is missing.</li>\n+     *         <li><em>404 Not Found</em> if no tenant with the given identifier.</li>\n+     *         </ul>\n+     * @throws NullPointerException if the parameters are {@code null}.\n+     */\n+    private Future<TenantResult<JsonObject>> getForCertificateAuthority(final X500Principal subjectDn,\n+            final Span span) {\n+\n+        if (subjectDn == null) {\n+            TracingHelper.logError(span, \"missing subject DN\");\n+            return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_BAD_REQUEST));\n+        } else {\n+            return findTenant(subjectDn)\n+                    .compose(tenantDtoResult -> Future.succeededFuture(TenantResult.from(\n+                            HttpURLConnection.HTTP_OK,\n+                            DeviceRegistryUtils.convertTenant(tenantDtoResult.getTenantId(),\n+                                    tenantDtoResult.getTenant(), true),\n+                            DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge()))))\n+                    .recover(error -> {\n+                        TracingHelper.logError(span, \"no tenant found for subject DN\");\n+                        return Future.succeededFuture(TenantResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Tenant>> readTenant(final String tenantId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(span);\n+\n+        return processReadTenant(tenantId)\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Tenant>> processReadTenant(final String tenantId) {\n+\n+        return findTenant(tenantId)\n+                .compose(tenantDtoResult -> Future.succeededFuture(OperationResult.ok(\n+                        HttpURLConnection.HTTP_OK,\n+                        tenantDtoResult.getTenant(),\n+                        Optional.ofNullable(DeviceRegistryUtils.getCacheDirective(config.getCacheMaxAge())),\n+                        Optional.ofNullable(tenantDtoResult.getVersion()))));\n+\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param tenantId the tenant id.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final String tenantId) {\n+        Objects.requireNonNull(tenantId);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withTenantId(tenantId)\n+                .document();\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Fetches tenant by subject DN.\n+     *\n+     * @param subjectDn the subject DN.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final X500Principal subjectDn) {\n+        Objects.requireNonNull(subjectDn);\n+\n+        final JsonObject findTenantQuery = new MongoDbDocumentBuilder()\n+                .withCa(subjectDn.getName())\n+                .document();\n+\n+        return findTenant(findTenantQuery);\n+    }\n+\n+    /**\n+     * Gets a tenant dto by tenant id.\n+     *\n+     * @param findQuery the tenant query.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future with a {@link TenantDto} be provided if found.\n+     *         Otherwise the future will fail with\n+     *         a {@link ClientErrorException} with {@link HttpURLConnection#HTTP_NOT_FOUND}.\n+     * @throws NullPointerException if the parameter is {@code null}.\n+     */\n+    private Future<TenantDto> findTenant(final JsonObject findQuery) {\n+        Objects.requireNonNull(findQuery);\n+\n+        final Promise<JsonObject> findTenantPromise = Promise.promise();\n+        mongoClient.findOne(config.getCollectionName(), findQuery, new JsonObject(), findTenantPromise);\n+        return findTenantPromise.future()\n+                .compose(tenantJsonResult -> Optional.ofNullable(tenantJsonResult)\n+                        .map(tenantJson -> Future.succeededFuture(tenantJson.mapTo(TenantDto.class)))\n+                        .orElse(Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Tenant [%s] not found.\",\n+                                        findQuery.getString(RegistrationConstants.FIELD_PAYLOAD_TENANT_ID))))));\n+    }\n+\n+    @Override\n+    public Future<OperationResult<Id>> createTenant(final Optional<String> tenantId, final Tenant tenantObj,\n+            final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(tenantObj);\n+        Objects.requireNonNull(span);\n+\n+        final String tenantIdOrGenerated = tenantId.orElse(DeviceRegistryUtils.getUniqueIdentifier());\n+\n+        return MongoDbDeviceRegistryUtils.isAllowedToModify(config, tenantIdOrGenerated)\n+                .compose(ok -> processCreateTenant(tenantIdOrGenerated, tenantObj, span))\n+                .recover(error -> Future.succeededFuture(MongoDbDeviceRegistryUtils.mapErrorToResult(error, span)));\n+    }\n+\n+    private Future<OperationResult<Id>> processCreateTenant(final String tenantId, final Tenant tenantObj,\n+            final Span span) {\n+\n+        final TenantDto newTenantDto = new TenantDto(tenantId, tenantObj,\n+                new Versioned<>(tenantObj).getVersion());\n+\n+        final JsonObject newTenantDtoJson = JsonObject.mapFrom(newTenantDto);\n+        final Promise<String> createTenantPromise = Promise.promise();\n+        mongoClient.insert(config.getCollectionName(), newTenantDtoJson, createTenantPromise);\n+        return createTenantPromise.future()\n+                .compose(tenantObjectIdResult -> {\n+                    span.log(\"successfully created tenant.\");\n+                    return Future.succeededFuture(OperationResult.ok(\n+                            HttpURLConnection.HTTP_CREATED,\n+                            Id.of(tenantId),\n+                            Optional.empty(),\n+                            Optional.of(newTenantDto.getVersion())));\n+                })\n+                .recover(error -> {\n+                    if (MongoDbDeviceRegistryUtils.isDuplicateKeyError(error)) {\n+                        LOG.debug(String.format(\"The tenant [%s] already exists or an existing tenant uses a certificate authority with the same Subject DN\", tenantId), error);\n+                        TracingHelper.logError(span, \"The tenant with the given identifier already exists or an existing tenant uses a certificate authority with the same Subject DN\", error);\n+                        return Future.succeededFuture(OperationResult.empty(HttpURLConnection.HTTP_CONFLICT));\n+                    } else {\n+                        LOG.error(String.format(\"Error adding Tenant [%s].\", tenantId), error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI2MjkzMA=="}, "originalCommit": {"oid": "fc2ab3aa5e8cb199ef787dd11d649c67bb3a38f9"}, "originalPosition": 413}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3290, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}