{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0ODEyNzY3", "number": 2138, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzozMjowMVrOEexXhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDowNTozOVrOEgAciQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwNzAxNTczOnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/DeviceRegistryHttpClient.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNzozMjowMVrOHKpE2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNTozNzo1NFrOHK8a6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkyMDc5NQ==", "bodyText": "can we use the simple parameter types? I do not see why we need to use Optionals here. There is certainly no problem with providing a page size and an offset and empty lists, if no filters nor sort options are used, right?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r480920795", "createdAt": "2020-09-01T07:32:01Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/DeviceRegistryHttpClient.java", "diffHunk": "@@ -532,6 +542,45 @@ private static String registrationWithoutIdUri(final String tenant) {\n         return httpClient.delete(requestUri, status -> status == HttpURLConnection.HTTP_NO_CONTENT);\n     }\n \n+    /**\n+     * Finds devices belonging to the given tenant with optional filters, paging and sorting options.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param pageSize The maximum number of results to include in a response.\n+     * @param pageOffset The offset into the result set from which to include objects in the response.\n+     * @param filters The filters are predicates that objects in the result set must match.\n+     * @param sortOptions A list of sort options.\n+     * @param expectedStatus The status code indicating a successful outcome.\n+     * @return A future indicating the outcome of the operation. The future will contain the response payload\n+     *         if the request succeeded. Otherwise the future will fail with a \n+     *         {@link org.eclipse.hono.client.ServiceInvocationException}.\n+     * @throws NullPointerException if the tenant is {@code null}.\n+     */\n+    public Future<Buffer> searchDevices(\n+            final String tenantId,\n+            final Optional<Integer> pageSize,\n+            final Optional<Integer> pageOffset,\n+            final Optional<List<String>> filters,\n+            final Optional<List<String>> sortOptions,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "845fc62c799551ebb4e7e83b308ac0c800c840a3"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk4NjAzOA==", "bodyText": "The page size and offset are not mandatory fields. I thought its better to test some cases without page size or offset. Hence I defined them as Optional parameters.", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r480986038", "createdAt": "2020-09-01T09:04:57Z", "author": {"login": "kaniyan"}, "path": "tests/src/test/java/org/eclipse/hono/tests/DeviceRegistryHttpClient.java", "diffHunk": "@@ -532,6 +542,45 @@ private static String registrationWithoutIdUri(final String tenant) {\n         return httpClient.delete(requestUri, status -> status == HttpURLConnection.HTTP_NO_CONTENT);\n     }\n \n+    /**\n+     * Finds devices belonging to the given tenant with optional filters, paging and sorting options.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param pageSize The maximum number of results to include in a response.\n+     * @param pageOffset The offset into the result set from which to include objects in the response.\n+     * @param filters The filters are predicates that objects in the result set must match.\n+     * @param sortOptions A list of sort options.\n+     * @param expectedStatus The status code indicating a successful outcome.\n+     * @return A future indicating the outcome of the operation. The future will contain the response payload\n+     *         if the request succeeded. Otherwise the future will fail with a \n+     *         {@link org.eclipse.hono.client.ServiceInvocationException}.\n+     * @throws NullPointerException if the tenant is {@code null}.\n+     */\n+    public Future<Buffer> searchDevices(\n+            final String tenantId,\n+            final Optional<Integer> pageSize,\n+            final Optional<Integer> pageOffset,\n+            final Optional<List<String>> filters,\n+            final Optional<List<String>> sortOptions,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkyMDc5NQ=="}, "originalCommit": {"oid": "845fc62c799551ebb4e7e83b308ac0c800c840a3"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE1MDcyMg==", "bodyText": "So, we remove the Optionals for the Lists but keep them for the Integer params?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481150722", "createdAt": "2020-09-01T13:47:57Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/DeviceRegistryHttpClient.java", "diffHunk": "@@ -532,6 +542,45 @@ private static String registrationWithoutIdUri(final String tenant) {\n         return httpClient.delete(requestUri, status -> status == HttpURLConnection.HTTP_NO_CONTENT);\n     }\n \n+    /**\n+     * Finds devices belonging to the given tenant with optional filters, paging and sorting options.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param pageSize The maximum number of results to include in a response.\n+     * @param pageOffset The offset into the result set from which to include objects in the response.\n+     * @param filters The filters are predicates that objects in the result set must match.\n+     * @param sortOptions A list of sort options.\n+     * @param expectedStatus The status code indicating a successful outcome.\n+     * @return A future indicating the outcome of the operation. The future will contain the response payload\n+     *         if the request succeeded. Otherwise the future will fail with a \n+     *         {@link org.eclipse.hono.client.ServiceInvocationException}.\n+     * @throws NullPointerException if the tenant is {@code null}.\n+     */\n+    public Future<Buffer> searchDevices(\n+            final String tenantId,\n+            final Optional<Integer> pageSize,\n+            final Optional<Integer> pageOffset,\n+            final Optional<List<String>> filters,\n+            final Optional<List<String>> sortOptions,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkyMDc5NQ=="}, "originalCommit": {"oid": "845fc62c799551ebb4e7e83b308ac0c800c840a3"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIzNzczNw==", "bodyText": "I have removed the Optionals for the Lists and also rebased the code for PR#2412. Would you mind taking a look again?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481237737", "createdAt": "2020-09-01T15:37:54Z", "author": {"login": "kaniyan"}, "path": "tests/src/test/java/org/eclipse/hono/tests/DeviceRegistryHttpClient.java", "diffHunk": "@@ -532,6 +542,45 @@ private static String registrationWithoutIdUri(final String tenant) {\n         return httpClient.delete(requestUri, status -> status == HttpURLConnection.HTTP_NO_CONTENT);\n     }\n \n+    /**\n+     * Finds devices belonging to the given tenant with optional filters, paging and sorting options.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param pageSize The maximum number of results to include in a response.\n+     * @param pageOffset The offset into the result set from which to include objects in the response.\n+     * @param filters The filters are predicates that objects in the result set must match.\n+     * @param sortOptions A list of sort options.\n+     * @param expectedStatus The status code indicating a successful outcome.\n+     * @return A future indicating the outcome of the operation. The future will contain the response payload\n+     *         if the request succeeded. Otherwise the future will fail with a \n+     *         {@link org.eclipse.hono.client.ServiceInvocationException}.\n+     * @throws NullPointerException if the tenant is {@code null}.\n+     */\n+    public Future<Buffer> searchDevices(\n+            final String tenantId,\n+            final Optional<Integer> pageSize,\n+            final Optional<Integer> pageOffset,\n+            final Optional<List<String>> filters,\n+            final Optional<List<String>> sortOptions,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkyMDc5NQ=="}, "originalCommit": {"oid": "845fc62c799551ebb4e7e83b308ac0c800c840a3"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjY4NjkzOnYy", "diffSide": "RIGHT", "path": "tests/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzoyOToxNVrOHLgozw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzoyOToxNVrOHLgozw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzMTExOQ==", "bodyText": "maybe we can keep the name of this feature flag in line with the other two flags that we already use?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481831119", "createdAt": "2020-09-02T07:29:15Z", "author": {"login": "sophokles73"}, "path": "tests/pom.xml", "diffHunk": "@@ -43,6 +43,8 @@ Test cases are run against Docker images of Hono server + (Apache Qpid Dispatch\n     <!-- should be set to false if testing against a registry that doesn't support GW mode -->\n     <deviceregistry.supportsGatewayMode>true</deviceregistry.supportsGatewayMode>\n     <deviceregistry.credentials.supportsClientContext>true</deviceregistry.credentials.supportsClientContext>\n+    <!-- should be set to true if testing against a registry that supports search devices operation -->\n+    <hono.deviceregistry.supportsSearchDevices>false</hono.deviceregistry.supportsSearchDevices>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjcwNDg2OnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/DeviceRegistryHttpClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzozMjo0MlrOHLg0fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzozMjo0MlrOHLg0fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNDExMQ==", "bodyText": "well, the idea here is to make all parameters mandatory, right?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481834111", "createdAt": "2020-09-02T07:32:42Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/DeviceRegistryHttpClient.java", "diffHunk": "@@ -577,6 +587,49 @@ private static String registrationWithoutIdUri(final String tenant) {\n                 ResponsePredicate.status(expectedStatus));\n     }\n \n+    /**\n+     * Finds devices belonging to the given tenant with optional filters, paging and sorting options.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param pageSize The maximum number of results to include in a response.\n+     * @param pageOffset The offset into the result set from which to include objects in the response.\n+     * @param filters The filters are predicates that objects in the result set must match.\n+     * @param sortOptions A list of sort options.\n+     * @param expectedStatusCode The status code indicating a successful outcome.\n+     * @return A future indicating the outcome of the operation. The future will contain the response if the\n+     *         response contained the expected status code. Otherwise the future will fail.\n+     * @throws NullPointerException if the tenant is {@code null}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjcwNjY5OnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/DeviceRegistryHttpClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzozMzowNVrOHLg1zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzozMzowNVrOHLg1zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNDQ0NA==", "bodyText": "missing null checks", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481834444", "createdAt": "2020-09-02T07:33:05Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/DeviceRegistryHttpClient.java", "diffHunk": "@@ -577,6 +587,49 @@ private static String registrationWithoutIdUri(final String tenant) {\n                 ResponsePredicate.status(expectedStatus));\n     }\n \n+    /**\n+     * Finds devices belonging to the given tenant with optional filters, paging and sorting options.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param pageSize The maximum number of results to include in a response.\n+     * @param pageOffset The offset into the result set from which to include objects in the response.\n+     * @param filters The filters are predicates that objects in the result set must match.\n+     * @param sortOptions A list of sort options.\n+     * @param expectedStatusCode The status code indicating a successful outcome.\n+     * @return A future indicating the outcome of the operation. The future will contain the response if the\n+     *         response contained the expected status code. Otherwise the future will fail.\n+     * @throws NullPointerException if the tenant is {@code null}.\n+     */\n+    public Future<HttpResponse<Buffer>> searchDevices(\n+            final String tenantId,\n+            final Optional<Integer> pageSize,\n+            final Optional<Integer> pageOffset,\n+            final List<String> filters,\n+            final List<String> sortOptions,\n+            final int expectedStatusCode) {\n+\n+        Objects.requireNonNull(tenantId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjcxODI2OnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzozNToyOFrOHLg9iQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzozNToyOFrOHLg9iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNjQyNQ==", "bodyText": "does what?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481836425", "createdAt": "2020-09-02T07:35:28Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjcyMDQ0OnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzozNTo1MlrOHLg_BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzozNTo1MlrOHLg_BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNjgwNA==", "bodyText": "...WithValidPageSizeSucceeds?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481836804", "createdAt": "2020-09-02T07:35:52Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjcyNTUzOnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzozNjo1MFrOHLhCOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxMzo0Mzo1NlrOHMnQQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzYyNw==", "bodyText": "how about also asserting the overall result set size?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481837627", "createdAt": "2020-09-02T07:36:50Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg3MTY3Ng==", "bodyText": "Here the result set size is being asserted to the page size. I didn't get it what do you mean by overall result set size?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481871676", "createdAt": "2020-09-02T08:15:53Z", "author": {"login": "kaniyan"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzYyNw=="}, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk5Nzg5Mg==", "bodyText": "well, you have registered two devices and the first page of the search result contains the first match (page size = 1). However, the overall result set size should be 2 because you haven't specified any search criteria, right? So we could also check the total property in the response body. But wait a second, it looks like the response body currently doesn't contain the total and result properties but instead only contains the result set as a JSON array. IMHO this is currently not compliant with the spec ...", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481997892", "createdAt": "2020-09-02T11:29:29Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzYyNw=="}, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA5NTI2Mw==", "bodyText": "I see what do you mean now. My bad I failed to notice the change in the result structure of the search devices operation and I followed the old one. I will create a separate PR to comply with the spec and then continue with the integration tests here.", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r482095263", "createdAt": "2020-09-02T14:04:52Z", "author": {"login": "kaniyan"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzYyNw=="}, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwMTk1Ng==", "bodyText": "sounds good. No worries, I missed it too while reviewing the MongoDB registry implementation ...", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r482101956", "createdAt": "2020-09-02T14:13:39Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzYyNw=="}, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg0NTI0MQ==", "bodyText": "I have created  a PR #2150 to make the search devices result in compliant with the spec.", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r482845241", "createdAt": "2020-09-03T09:36:54Z", "author": {"login": "kaniyan"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzYyNw=="}, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4ODA5Nw==", "bodyText": "The overall size value is now being asserted and changes are made in accordance with the PR #2150 (Fix search devices result). I have pushed a separate commit for that.", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r482988097", "createdAt": "2020-09-03T13:43:56Z", "author": {"login": "kaniyan"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzYyNw=="}, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjcyNzI2OnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzozNzoxMlrOHLhDVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzozNzoxMlrOHLhDVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzkwOQ==", "bodyText": "does what?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481837909", "createdAt": "2020-09-02T07:37:12Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageOffset(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page offset.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjczNDM2OnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzozODo0MFrOHLhH7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzozODo0MFrOHLhH7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzOTA4Ng==", "bodyText": "Multiple", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481839086", "createdAt": "2020-09-02T07:38:40Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageOffset(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageOffset(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            null, List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+\n+                            final JsonObject deviceObject = response.getJsonObject(0);\n+                            assertThat(deviceObject.getString(\"id\")).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when filterJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidFilterJson(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(\"Invalid filterJson\"), null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with multiple filters succeeds and matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithMutlipleFilters(final VertxTestContext ctx) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjc0MDA3OnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzozOTo0OVrOHLhLhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzozOTo0OVrOHLhLhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg0MDAwNw==", "bodyText": "how about adding a step verifying that a combination of other filters actually yields a result?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481840007", "createdAt": "2020-09-02T07:39:49Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageOffset(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageOffset(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            null, List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+\n+                            final JsonObject deviceObject = response.getJsonObject(0);\n+                            assertThat(deviceObject.getString(\"id\")).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when filterJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidFilterJson(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(\"Invalid filterJson\"), null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with multiple filters succeeds and matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithMutlipleFilters(final VertxTestContext ctx) {\n+            final Device device1 = new Device().setEnabled(false).setExtensions(Map.of(\"id\", \"1\"));\n+            final Device device2 = new Device().setEnabled(true).setExtensions(Map.of(\"id\", \"2\"));\n+            final String filterJson1 = getFilterJson(\"/ext/id\", \"1\", \"eq\");\n+            final String filterJson2 = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, device1), registry.registerDevice(tenantId, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson2), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMjc0OTk5OnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzo0MTo0MFrOHLhSAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNzo0MTo0MFrOHLhSAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg0MTY2Ng==", "bodyText": "how about also checking position 1?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481841666", "createdAt": "2020-09-02T07:41:40Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageOffset(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageOffset(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            null, List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+\n+                            final JsonObject deviceObject = response.getJsonObject(0);\n+                            assertThat(deviceObject.getString(\"id\")).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when filterJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidFilterJson(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(\"Invalid filterJson\"), null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with multiple filters succeeds and matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithMutlipleFilters(final VertxTestContext ctx) {\n+            final Device device1 = new Device().setEnabled(false).setExtensions(Map.of(\"id\", \"1\"));\n+            final Device device2 = new Device().setEnabled(true).setExtensions(Map.of(\"id\", \"2\"));\n+            final String filterJson1 = getFilterJson(\"/ext/id\", \"1\", \"eq\");\n+            final String filterJson2 = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, device1), registry.registerDevice(tenantId, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson2), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when sortJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidSortJson(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(), null,\n+                            List.of(\"Invalid sortJson\"), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid sort option succeeds and the result is sorted accordingly.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithSortOption(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(), null,\n+                            List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(2);\n+\n+                            final JsonObject deviceObject = response.getJsonObject(0);\n+                            assertThat(deviceObject.getString(\"id\")).isEqualTo(deviceId2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTk2NTQwOnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDowNDoyNFrOHMoMOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDoyNzo1NVrOHMpQQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwMzQ1MA==", "bodyText": "httpResponse.bodyAsJson(SearchDeviceResult.class)?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r483003450", "createdAt": "2020-09-03T14:04:24Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -420,6 +427,243 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageSizeFails(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with pageSize succeeds and the result is in accordance\n+         * with the specified page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageSizeSucceeds(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), List.of(),\n+                            List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00692ee0f93fbfc8ba22625f80914de1f6229f5a"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwNjgxOA==", "bodyText": "\ud83d\udc4d I am not aware of that method. I will update it.", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r483006818", "createdAt": "2020-09-03T14:08:57Z", "author": {"login": "kaniyan"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -420,6 +427,243 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageSizeFails(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with pageSize succeeds and the result is in accordance\n+         * with the specified page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageSizeSucceeds(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), List.of(),\n+                            List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwMzQ1MA=="}, "originalCommit": {"oid": "00692ee0f93fbfc8ba22625f80914de1f6229f5a"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAyMDg2Ng==", "bodyText": "I have updated to use httpResponse.bodyAsJson(SearchDeviceResult.class) and pushed a commit for that.", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r483020866", "createdAt": "2020-09-03T14:27:55Z", "author": {"login": "kaniyan"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -420,6 +427,243 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageSizeFails(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with pageSize succeeds and the result is in accordance\n+         * with the specified page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageSizeSucceeds(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), List.of(),\n+                            List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwMzQ1MA=="}, "originalCommit": {"oid": "00692ee0f93fbfc8ba22625f80914de1f6229f5a"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTk2OTQ2OnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDowNToxM1rOHMoOxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDowNToxM1rOHMoOxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwNDEwMA==", "bodyText": "httpResponse.bodyAsJson(SearchDeviceResult.class)?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r483004100", "createdAt": "2020-09-03T14:05:13Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -420,6 +427,243 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageSizeFails(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with pageSize succeeds and the result is in accordance\n+         * with the specified page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageSizeSucceeds(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), List.of(),\n+                            List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(2);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageOffsetFails(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with page offset succeeds and the result is in accordance with\n+         * the specified page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageOffsetSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            List.of(), List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00692ee0f93fbfc8ba22625f80914de1f6229f5a"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTk3MDc2OnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDowNToyN1rOHMoPgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDowNToyN1rOHMoPgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwNDI4OQ==", "bodyText": "httpResponse.bodyAsJson(SearchDeviceResult.class)?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r483004289", "createdAt": "2020-09-03T14:05:27Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -420,6 +427,243 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageSizeFails(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with pageSize succeeds and the result is in accordance\n+         * with the specified page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageSizeSucceeds(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), List.of(),\n+                            List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(2);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageOffsetFails(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with page offset succeeds and the result is in accordance with\n+         * the specified page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageOffsetSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            List.of(), List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(2);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                            assertThat(searchDevicesResult.getResult().get(0).getId()).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when filterJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidFilterJsonFails(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(\"Invalid filterJson\"), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with multiple filters succeeds and matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidMultipleFiltersSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setEnabled(false).setExtensions(Map.of(\"id\", \"1\"));\n+            final Device device2 = new Device().setEnabled(true).setExtensions(Map.of(\"id\", \"2\"));\n+            final String filterJson1 = getFilterJson(\"/ext/id\", \"1\", \"eq\");\n+            final String filterJson2 = getFilterJson(\"/enabled\", true, \"eq\");\n+            final String filterJson3 = getFilterJson(\"/enabled\", false, \"eq\");\n+\n+            CompositeFuture\n+                    .all(registry.registerDevice(tenantId, deviceId1, device1),\n+                            registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson2), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson3), List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00692ee0f93fbfc8ba22625f80914de1f6229f5a"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxOTk3MTkzOnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDowNTozOVrOHMoQJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNDowNTozOVrOHMoQJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwNDQ1NQ==", "bodyText": "httpResponse.bodyAsJson(SearchDeviceResult.class)?", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r483004455", "createdAt": "2020-09-03T14:05:39Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -420,6 +427,243 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageSizeFails(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with pageSize succeeds and the result is in accordance\n+         * with the specified page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageSizeSucceeds(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), List.of(),\n+                            List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(2);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageOffsetFails(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with page offset succeeds and the result is in accordance with\n+         * the specified page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageOffsetSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            List.of(), List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(2);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                            assertThat(searchDevicesResult.getResult().get(0).getId()).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when filterJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidFilterJsonFails(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(\"Invalid filterJson\"), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with multiple filters succeeds and matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidMultipleFiltersSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setEnabled(false).setExtensions(Map.of(\"id\", \"1\"));\n+            final Device device2 = new Device().setEnabled(true).setExtensions(Map.of(\"id\", \"2\"));\n+            final String filterJson1 = getFilterJson(\"/ext/id\", \"1\", \"eq\");\n+            final String filterJson2 = getFilterJson(\"/enabled\", true, \"eq\");\n+            final String filterJson3 = getFilterJson(\"/enabled\", false, \"eq\");\n+\n+            CompositeFuture\n+                    .all(registry.registerDevice(tenantId, deviceId1, device1),\n+                            registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson2), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson3), List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(1);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                            assertThat(searchDevicesResult.getResult().get(0).getId()).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when sortJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidSortJsonFails(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(), List.of(),\n+                            List.of(\"Invalid sortJson\"), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid sort option succeeds and the result is sorted\n+         * accordingly.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidSortOptionSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(), List.of(),\n+                            List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00692ee0f93fbfc8ba22625f80914de1f6229f5a"}, "originalPosition": 241}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3004, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}