{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxMzExNzE5", "number": 1699, "title": "[#1691] Add isConnected(timeout); use it in client factories", "bodyText": "This fixes #1691.", "createdAt": "2020-01-10T07:22:57Z", "url": "https://github.com/eclipse/hono/pull/1699", "merged": true, "mergeCommit": {"oid": "9193dfc04015cbc1d51c4cb926249b4c0407eee7"}, "closed": true, "closedAt": "2020-01-14T07:49:37Z", "author": {"login": "calohmn"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb46UglgFqTM0MTAwNDk5OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABb5-59ZAFqTM0MTk2ODYyOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxMDA0OTk4", "url": "https://github.com/eclipse/hono/pull/1699#pullrequestreview-341004998", "createdAt": "2020-01-10T08:12:01Z", "commit": {"oid": "e28cb5ad4f824ead00e270591c42751b94439343"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwODoxMjowMVrOFcMvbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwODozMTozMVrOFcNGcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExMzE5OQ==", "bodyText": "shouldn't this be connection.isConnected(waitForCurrentConnectionAttemptTimeout)?", "url": "https://github.com/eclipse/hono/pull/1699#discussion_r365113199", "createdAt": "2020-01-10T08:12:01Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/AbstractHonoClientFactory.java", "diffHunk": "@@ -95,6 +95,26 @@ public void addReconnectListener(final ReconnectListener<HonoConnection> listene\n         return connection.isConnected();\n     }\n \n+    /**\n+     * Checks whether this client is connected to the service.\n+     * <p>\n+     * If a connection attempt is currently in progress, the returned future is completed\n+     * with the outcome of the connection attempt. If the connection attempt (including\n+     * potential reconnect attempts) isn't finished after the given timeout, the returned\n+     * future is failed.\n+     * <p>\n+     * Simply delegates to {@link HonoConnection#isConnected(long)}.\n+     * \n+     * @param waitForCurrentConnectAttemptTimeout The maximum number of milliseconds to wait for\n+     *                                            on ongoing connection attempt to finish.\n+     * @return A succeeded future if this factory is connected.\n+     *         Otherwise, the future will be failed with a {@link ServerErrorException}.\n+     */\n+    @Override\n+    public final Future<Void> isConnected(final long waitForCurrentConnectAttemptTimeout) {\n+        return connection.isConnected();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28cb5ad4f824ead00e270591c42751b94439343"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExNzQwNg==", "bodyText": "shouldn't this better be encapsulated in CheckConnectPromise (which might be renamed to ExpiringPromise according to its purpose)?", "url": "https://github.com/eclipse/hono/pull/1699#discussion_r365117406", "createdAt": "2020-01-10T08:25:57Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java", "diffHunk": "@@ -291,44 +286,82 @@ public final void addReconnectListener(final ReconnectListener<HonoConnection> l\n     private void checkConnected(final Handler<AsyncResult<Void>> resultHandler) {\n         if (isConnectedInternal()) {\n             resultHandler.handle(Future.succeededFuture());\n-        } else if (connecting.get()) {\n+        } else {\n+            resultHandler.handle(Future.failedFuture(\n+                    new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, \"not connected\")));\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public final Future<Void> isConnected(final long waitForCurrentConnectAttemptTimeout) {\n+        return executeOnContext(result -> checkConnected(result, waitForCurrentConnectAttemptTimeout));\n+    }\n+\n+    private void checkConnected(final Handler<AsyncResult<Void>> resultHandler, final long waitForCurrentConnectAttemptTimeout) {\n+        if (isConnectedInternal()) {\n+            resultHandler.handle(Future.succeededFuture());\n+        } else if (waitForCurrentConnectAttemptTimeout > 0 && checkConnectedPromises.get() != null) {\n             // connect attempt in progress - let its completion complete the resultHandler here\n             log.debug(\"connection attempt to server [{}:{}] in progress, connection check will be completed with its result\",\n                     connectionFactory.getHost(), connectionFactory.getPort());\n-            final Promise<Void> promiseToAdd = Promise.promise();\n-            promiseToAdd.future().setHandler(resultHandler);\n-            // atomically add the promise to checkConnectedPromises - but only if checkConnectedPromises hasn't been cleared already\n-            final List<Promise<Void>> newCheckConnectedPromises = checkConnectedPromises\n-                    .accumulateAndGet(Collections.singletonList(promiseToAdd), (existing, toAdd) -> {\n-                        // no modification of the existing list done here, keeping the accumulatorFunction function side-effect free as required\n-                        if (existing == null) {\n-                            return null;\n-                        }\n-                        final List<Promise<Void>> promises = new ArrayList<>(existing.size() + 1);\n-                        promises.addAll(existing);\n-                        promises.add(toAdd.get(0));\n-                        return promises;\n-                    });\n-            if (newCheckConnectedPromises == null) {\n-                // checkConnectedPromises wasn't updated with our promiseToAdd because the checkConnectedPromises were cleared in between\n-                resultHandler.handle(Future.failedFuture(\n-                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, \"not connected\")));\n+            final CheckConnectedPromise promiseToAdd = new CheckConnectedPromise(resultHandler);\n+            if (!addToCheckConnectedPromises(promiseToAdd)) {\n+                // checkConnectedPromises has been cleared in between\n+                checkConnected(resultHandler);\n+            } else {\n+                // promise added to list, now use a timer to ensure that we wait no more than the given timeout\n+                promiseToAdd.setTimerId(vertx.setTimer(waitForCurrentConnectAttemptTimeout, id -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28cb5ad4f824ead00e270591c42751b94439343"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExNzgzMQ==", "bodyText": "how about moving all of this into a separate class?", "url": "https://github.com/eclipse/hono/pull/1699#discussion_r365117831", "createdAt": "2020-01-10T08:27:25Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/HonoConnectionImpl.java", "diffHunk": "@@ -291,44 +286,82 @@ public final void addReconnectListener(final ReconnectListener<HonoConnection> l\n     private void checkConnected(final Handler<AsyncResult<Void>> resultHandler) {\n         if (isConnectedInternal()) {\n             resultHandler.handle(Future.succeededFuture());\n-        } else if (connecting.get()) {\n+        } else {\n+            resultHandler.handle(Future.failedFuture(\n+                    new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, \"not connected\")));\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public final Future<Void> isConnected(final long waitForCurrentConnectAttemptTimeout) {\n+        return executeOnContext(result -> checkConnected(result, waitForCurrentConnectAttemptTimeout));\n+    }\n+\n+    private void checkConnected(final Handler<AsyncResult<Void>> resultHandler, final long waitForCurrentConnectAttemptTimeout) {\n+        if (isConnectedInternal()) {\n+            resultHandler.handle(Future.succeededFuture());\n+        } else if (waitForCurrentConnectAttemptTimeout > 0 && checkConnectedPromises.get() != null) {\n             // connect attempt in progress - let its completion complete the resultHandler here\n             log.debug(\"connection attempt to server [{}:{}] in progress, connection check will be completed with its result\",\n                     connectionFactory.getHost(), connectionFactory.getPort());\n-            final Promise<Void> promiseToAdd = Promise.promise();\n-            promiseToAdd.future().setHandler(resultHandler);\n-            // atomically add the promise to checkConnectedPromises - but only if checkConnectedPromises hasn't been cleared already\n-            final List<Promise<Void>> newCheckConnectedPromises = checkConnectedPromises\n-                    .accumulateAndGet(Collections.singletonList(promiseToAdd), (existing, toAdd) -> {\n-                        // no modification of the existing list done here, keeping the accumulatorFunction function side-effect free as required\n-                        if (existing == null) {\n-                            return null;\n-                        }\n-                        final List<Promise<Void>> promises = new ArrayList<>(existing.size() + 1);\n-                        promises.addAll(existing);\n-                        promises.add(toAdd.get(0));\n-                        return promises;\n-                    });\n-            if (newCheckConnectedPromises == null) {\n-                // checkConnectedPromises wasn't updated with our promiseToAdd because the checkConnectedPromises were cleared in between\n-                resultHandler.handle(Future.failedFuture(\n-                        new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, \"not connected\")));\n+            final CheckConnectedPromise promiseToAdd = new CheckConnectedPromise(resultHandler);\n+            if (!addToCheckConnectedPromises(promiseToAdd)) {\n+                // checkConnectedPromises has been cleared in between\n+                checkConnected(resultHandler);\n+            } else {\n+                // promise added to list, now use a timer to ensure that we wait no more than the given timeout\n+                promiseToAdd.setTimerId(vertx.setTimer(waitForCurrentConnectAttemptTimeout, id -> {\n+                    log.debug(\"canceling connection check after {}ms\", waitForCurrentConnectAttemptTimeout);\n+                    promiseToAdd.setTimerId(null);\n+                    promiseToAdd.tryCompleteAndCancelTimer(Future.failedFuture(\n+                            new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, \"not connected\")));\n+                    removeFromCheckConnectedPromises(promiseToAdd); // not strictly necessary but keeps the list from growing if connection attempts keep on failing\n+                }));\n             }\n         } else {\n             resultHandler.handle(Future.failedFuture(\n                     new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE, \"not connected\")));\n         }\n     }\n \n+    private boolean addToCheckConnectedPromises(final CheckConnectedPromise promiseToAdd) {\n+        // atomically add to checkConnectedPromises - but only if checkConnectedPromises hasn't been set to null\n+        final List<CheckConnectedPromise> newPromises = checkConnectedPromises\n+                .accumulateAndGet(Collections.singletonList(promiseToAdd), (existing, toAdd) -> {\n+                    // no modification of the existing list done here, keeping the accumulatorFunction function side-effect free as required\n+                    if (existing == null) {\n+                        return null;\n+                    }\n+                    final List<CheckConnectedPromise> promises = new ArrayList<>(existing.size() + 1);\n+                    promises.addAll(existing);\n+                    promises.add(toAdd.get(0));\n+                    return promises;\n+                });\n+        return newPromises != null;\n+    }\n+\n+    private void removeFromCheckConnectedPromises(final CheckConnectedPromise promiseToRemove) {\n+        checkConnectedPromises\n+                .accumulateAndGet(Collections.singletonList(promiseToRemove), (existing, toRemove) -> {\n+                    // no modification of the existing list done here, keeping the accumulatorFunction function side-effect free as required\n+                    if (existing == null) {\n+                        return null;\n+                    }\n+                    final List<CheckConnectedPromise> promises = new ArrayList<>(existing);\n+                    promises.remove(toRemove.get(0));\n+                    return promises;\n+                });\n+    }\n+\n     private void removeAndCompleteCheckConnectedPromises(final AsyncResult<HonoConnection> connectionResult) {\n-        final List<Promise<Void>> promises = checkConnectedPromises.getAndSet(null);\n-        if (promises != null) {\n+        final List<CheckConnectedPromise> promises = checkConnectedPromises.getAndSet(null);\n+        if (promises != null && !promises.isEmpty()) {\n+            log.trace(\"completing {} accumulated connection checks\", promises.size());\n             final Context ctx = vertx.getOrCreateContext();\n-            if (connectionResult.succeeded()) {\n-                promises.forEach(promise -> ctx.runOnContext(v -> promise.complete()));\n-            } else {\n-                promises.forEach(promise -> ctx.runOnContext(v -> promise.fail(connectionResult.cause())));\n-            }\n+            promises.forEach(promise -> ctx.runOnContext(v -> promise.tryCompleteAndCancelTimer(connectionResult)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28cb5ad4f824ead00e270591c42751b94439343"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExOTA5MA==", "bodyText": "in all the other places we use the request timeout for limiting the time to wait for the processing of a request over an already established connection, don't we? So, in order to improve chances that the request, that his method invocation is part of, succeeds, we might want to slightly reduce the time to wait a little so that there is some time left to establish the link and send the request message?", "url": "https://github.com/eclipse/hono/pull/1699#discussion_r365119090", "createdAt": "2020-01-10T08:31:31Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/CredentialsClientFactoryImpl.java", "diffHunk": "@@ -67,17 +67,18 @@ protected void onDisconnect() {\n             final String tenantId) {\n \n         Objects.requireNonNull(tenantId);\n-        return connection.executeOnContext(result -> {\n-            credentialsClientFactory.getOrCreateClient(\n-                    CredentialsClientImpl.getTargetAddress(tenantId),\n-                    () -> CredentialsClientImpl.create(\n-                            cacheProvider,\n-                            connection,\n-                            tenantId,\n-                            this::removeCredentialsClient,\n-                            this::removeCredentialsClient),\n-                    result);\n-        });\n+        return connection.isConnected(connection.getConfig().getRequestTimeout())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e28cb5ad4f824ead00e270591c42751b94439343"}, "originalPosition": 22}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e28cb5ad4f824ead00e270591c42751b94439343", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/e28cb5ad4f824ead00e270591c42751b94439343", "committedDate": "2020-01-10T07:21:31Z", "message": "[#1691] Add isConnected(timeout); use it in client factories.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch-si.com>"}, "afterCommit": {"oid": "720c061f1f62eb39c4b24699681bd6be7177bb7b", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/720c061f1f62eb39c4b24699681bd6be7177bb7b", "committedDate": "2020-01-10T09:09:20Z", "message": "[#1691] Add isConnected(timeout); use it in client factories.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch-si.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "720c061f1f62eb39c4b24699681bd6be7177bb7b", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/720c061f1f62eb39c4b24699681bd6be7177bb7b", "committedDate": "2020-01-10T09:09:20Z", "message": "[#1691] Add isConnected(timeout); use it in client factories.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch-si.com>"}, "afterCommit": {"oid": "b5dc0b24a6783aaee1703cc95136f336f8bafb76", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/b5dc0b24a6783aaee1703cc95136f336f8bafb76", "committedDate": "2020-01-10T14:10:29Z", "message": "[#1691] Add isConnected(timeout); use it in client factories.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch-si.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b5dc0b24a6783aaee1703cc95136f336f8bafb76", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/b5dc0b24a6783aaee1703cc95136f336f8bafb76", "committedDate": "2020-01-10T14:10:29Z", "message": "[#1691] Add isConnected(timeout); use it in client factories.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch-si.com>"}, "afterCommit": {"oid": "e26172b56fb22d82b460a223df4ed6c91952b161", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/e26172b56fb22d82b460a223df4ed6c91952b161", "committedDate": "2020-01-13T09:47:35Z", "message": "[#1691] Add isConnected(timeout); use it in client factories.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch-si.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNzg5Njg4", "url": "https://github.com/eclipse/hono/pull/1699#pullrequestreview-341789688", "createdAt": "2020-01-13T11:47:38Z", "commit": {"oid": "e26172b56fb22d82b460a223df4ed6c91952b161"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMTo0NzozOFrOFc0Zjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMTo0NzozOFrOFc0Zjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2Mjk1OQ==", "bodyText": "final ?", "url": "https://github.com/eclipse/hono/pull/1699#discussion_r365762959", "createdAt": "2020-01-13T11:47:38Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/impl/DeferredConnectionCheckHandler.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.client.impl;\n+\n+import java.net.HttpURLConnection;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Context;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+\n+/**\n+ * Handles connection checks that should be completed only when a concurrent connection attempt has finished\n+ * (or when a timeout period has elapsed).\n+ */\n+public class DeferredConnectionCheckHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e26172b56fb22d82b460a223df4ed6c91952b161"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2173d4ecefa2b92ccdd539605914d4b38e0ad0ea", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/2173d4ecefa2b92ccdd539605914d4b38e0ad0ea", "committedDate": "2020-01-13T16:11:45Z", "message": "[#1691] Add isConnected(timeout); use it in client factories.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch-si.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e26172b56fb22d82b460a223df4ed6c91952b161", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/e26172b56fb22d82b460a223df4ed6c91952b161", "committedDate": "2020-01-13T09:47:35Z", "message": "[#1691] Add isConnected(timeout); use it in client factories.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch-si.com>"}, "afterCommit": {"oid": "2173d4ecefa2b92ccdd539605914d4b38e0ad0ea", "author": {"user": {"login": "calohmn", "name": "Carsten Lohmann"}}, "url": "https://github.com/eclipse/hono/commit/2173d4ecefa2b92ccdd539605914d4b38e0ad0ea", "committedDate": "2020-01-13T16:11:45Z", "message": "[#1691] Add isConnected(timeout); use it in client factories.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch-si.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxOTY4NjI4", "url": "https://github.com/eclipse/hono/pull/1699#pullrequestreview-341968628", "createdAt": "2020-01-13T16:26:02Z", "commit": {"oid": "2173d4ecefa2b92ccdd539605914d4b38e0ad0ea"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 915, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}