{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwMjQ3NTk3", "number": 1883, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwOToyMDoyNlrODv6E0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToxMjozNlrODwCcMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNTYxMTcwOnYy", "diffSide": "RIGHT", "path": "client-device-connection-infinispan/src/main/java/org/eclipse/hono/deviceconnection/infinispan/client/EmbeddedCache.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwOToyMDoyNlrOGCmg5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzo0NToxMVrOGCv-Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM4MTM1MA==", "bodyText": "Typo", "url": "https://github.com/eclipse/hono/pull/1883#discussion_r405381350", "createdAt": "2020-04-08T09:20:26Z", "author": {"login": "calohmn"}, "path": "client-device-connection-infinispan/src/main/java/org/eclipse/hono/deviceconnection/infinispan/client/EmbeddedCache.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.eclipse.hono.deviceconnection.infinispan.client;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.infinispan.lifecycle.ComponentStatus;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+\n+/**\n+ * An embedded cache.\n+ *\n+ * @param <K> The type of keys used by the cache.\n+ * @param <V> The type of values stored in the cache.\n+ */\n+public class EmbeddedCache<K, V> extends BasicCache<K, V> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(EmbeddedCache.class);\n+\n+    private final AtomicBoolean connecting = new AtomicBoolean(false);\n+\n+    private final EmbeddedCacheManager cacheManager;\n+    private final String cacheName;\n+\n+    /**\n+     * Create a new embedded cache instance.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param cacheManager The connection to the remote cache.\n+     * @param cacheName The name of the (remote) cache.\n+     * @param connectionCheckKey The key to use for checking the connection\n+     *        to the data grid.\n+     * @param connectionCheckValue The value to use for checking the connection\n+     *        to the data grid.\n+     */\n+    public EmbeddedCache(\n+            final Vertx vertx,\n+            final EmbeddedCacheManager cacheManager,\n+            final String cacheName,\n+            final K connectionCheckKey,\n+            final V connectionCheckValue) {\n+        super(vertx, cacheManager, connectionCheckKey, connectionCheckValue);\n+        this.cacheManager = Objects.requireNonNull(cacheManager);\n+        this.cacheName = Objects.requireNonNull(cacheName);\n+    }\n+\n+    @Override\n+    protected boolean isStarted() {\n+        return cacheManager.getStatus() == ComponentStatus.RUNNING && getCache() != null;\n+    }\n+\n+    @Override\n+    protected Future<Void> connectToGrid() {\n+\n+        final Promise<Void> result = Promise.promise();\n+\n+        if (connecting.compareAndSet(false, true)) {\n+\n+            vertx.executeBlocking(r -> {\n+                try {\n+                    final var status = cacheManager.getStatus();\n+                    if (status != ComponentStatus.RUNNING) {\n+                        LOG.debug(\"trying to start cache manager, current state: {}\", status);\n+                        cacheManager.start();\n+                        LOG.info(\"started cache manager, now connecting to remote cache\");\n+                    }\n+                    LOG.debug(\"trying to get cache\");\n+                    setCache(cacheManager.getCache(cacheName));\n+                    if (getCache() == null) {\n+                        r.fail(new IllegalStateException(\"cache [\" + cacheName + \"] is not configured exist\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3254f6a059d27870a3368874885436bb8fc1e357"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUzNjM0Mg==", "bodyText": "Fixed.", "url": "https://github.com/eclipse/hono/pull/1883#discussion_r405536342", "createdAt": "2020-04-08T13:45:11Z", "author": {"login": "ctron"}, "path": "client-device-connection-infinispan/src/main/java/org/eclipse/hono/deviceconnection/infinispan/client/EmbeddedCache.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.eclipse.hono.deviceconnection.infinispan.client;\n+\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.infinispan.lifecycle.ComponentStatus;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+import io.vertx.core.Vertx;\n+\n+/**\n+ * An embedded cache.\n+ *\n+ * @param <K> The type of keys used by the cache.\n+ * @param <V> The type of values stored in the cache.\n+ */\n+public class EmbeddedCache<K, V> extends BasicCache<K, V> {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(EmbeddedCache.class);\n+\n+    private final AtomicBoolean connecting = new AtomicBoolean(false);\n+\n+    private final EmbeddedCacheManager cacheManager;\n+    private final String cacheName;\n+\n+    /**\n+     * Create a new embedded cache instance.\n+     *\n+     * @param vertx The vert.x instance to run on.\n+     * @param cacheManager The connection to the remote cache.\n+     * @param cacheName The name of the (remote) cache.\n+     * @param connectionCheckKey The key to use for checking the connection\n+     *        to the data grid.\n+     * @param connectionCheckValue The value to use for checking the connection\n+     *        to the data grid.\n+     */\n+    public EmbeddedCache(\n+            final Vertx vertx,\n+            final EmbeddedCacheManager cacheManager,\n+            final String cacheName,\n+            final K connectionCheckKey,\n+            final V connectionCheckValue) {\n+        super(vertx, cacheManager, connectionCheckKey, connectionCheckValue);\n+        this.cacheManager = Objects.requireNonNull(cacheManager);\n+        this.cacheName = Objects.requireNonNull(cacheName);\n+    }\n+\n+    @Override\n+    protected boolean isStarted() {\n+        return cacheManager.getStatus() == ComponentStatus.RUNNING && getCache() != null;\n+    }\n+\n+    @Override\n+    protected Future<Void> connectToGrid() {\n+\n+        final Promise<Void> result = Promise.promise();\n+\n+        if (connecting.compareAndSet(false, true)) {\n+\n+            vertx.executeBlocking(r -> {\n+                try {\n+                    final var status = cacheManager.getStatus();\n+                    if (status != ComponentStatus.RUNNING) {\n+                        LOG.debug(\"trying to start cache manager, current state: {}\", status);\n+                        cacheManager.start();\n+                        LOG.info(\"started cache manager, now connecting to remote cache\");\n+                    }\n+                    LOG.debug(\"trying to get cache\");\n+                    setCache(cacheManager.getCache(cacheName));\n+                    if (getCache() == null) {\n+                        r.fail(new IllegalStateException(\"cache [\" + cacheName + \"] is not configured exist\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM4MTM1MA=="}, "originalCommit": {"oid": "3254f6a059d27870a3368874885436bb8fc1e357"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjI0ODY4OnYy", "diffSide": "RIGHT", "path": "client-device-connection-infinispan/src/main/java/org/eclipse/hono/deviceconnection/infinispan/client/CacheBasedDeviceConnectionInfo.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjoyMzo1NFrOGCsu-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzo0NToxOVrOGCv-qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4MzI1OQ==", "bodyText": "The content of the log message doesn't fit here any more.", "url": "https://github.com/eclipse/hono/pull/1883#discussion_r405483259", "createdAt": "2020-04-08T12:23:54Z", "author": {"login": "calohmn"}, "path": "client-device-connection-infinispan/src/main/java/org/eclipse/hono/deviceconnection/infinispan/client/CacheBasedDeviceConnectionInfo.java", "diffHunk": "@@ -167,39 +164,26 @@ public HotrodBasedDeviceConnectionInfo(final RemoteCache<String, String> cache,\n         Objects.requireNonNull(adapterInstanceId);\n \n         final String key = getAdapterInstanceEntryKey(tenantId, deviceId);\n-        return cache.getWithVersion(key)\n-               .recover(t -> {\n+\n+        return cache\n+                .remove(key, adapterInstanceId)\n+                .recover(t -> {\n                     LOG.debug(\"failed to get cache entry when trying to remove command handling adapter instance [tenant: {}, device-id: {}, adapter-instance: {}]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3254f6a059d27870a3368874885436bb8fc1e357"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUzNjQyNg==", "bodyText": "Fixed.", "url": "https://github.com/eclipse/hono/pull/1883#discussion_r405536426", "createdAt": "2020-04-08T13:45:19Z", "author": {"login": "ctron"}, "path": "client-device-connection-infinispan/src/main/java/org/eclipse/hono/deviceconnection/infinispan/client/CacheBasedDeviceConnectionInfo.java", "diffHunk": "@@ -167,39 +164,26 @@ public HotrodBasedDeviceConnectionInfo(final RemoteCache<String, String> cache,\n         Objects.requireNonNull(adapterInstanceId);\n \n         final String key = getAdapterInstanceEntryKey(tenantId, deviceId);\n-        return cache.getWithVersion(key)\n-               .recover(t -> {\n+\n+        return cache\n+                .remove(key, adapterInstanceId)\n+                .recover(t -> {\n                     LOG.debug(\"failed to get cache entry when trying to remove command handling adapter instance [tenant: {}, device-id: {}, adapter-instance: {}]\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4MzI1OQ=="}, "originalCommit": {"oid": "3254f6a059d27870a3368874885436bb8fc1e357"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjI2MjAwOnYy", "diffSide": "RIGHT", "path": "client-device-connection-infinispan/src/main/java/org/eclipse/hono/deviceconnection/infinispan/client/Cache.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMjoyNzozOFrOGCs3RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMzo0NToyNVrOGCv_Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NTM4MA==", "bodyText": "I would prefix the @return sentence with \"A succeeded future containing\".\nI think it would be good to also mention the possibility that a failed future is returned here.", "url": "https://github.com/eclipse/hono/pull/1883#discussion_r405485380", "createdAt": "2020-04-08T12:27:38Z", "author": {"login": "calohmn"}, "path": "client-device-connection-infinispan/src/main/java/org/eclipse/hono/deviceconnection/infinispan/client/Cache.java", "diffHunk": "@@ -67,14 +57,14 @@\n     Future<V> get(K key);\n \n     /**\n-     * Gets a value from the cache.\n+     * Remove a key/value mapping from the cache.\n      *\n      * @param key The key.\n-     * @return A succeeded future containing the value or {@code null} if the\n-     *         cache didn't contain the key yet.\n-     *         A failed future if the value could not be read from the cache.\n+     * @param value The value.\n+     * @return {@code true} if the key was mapped to the value, {@code false}\n+     *         otherwise.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3254f6a059d27870a3368874885436bb8fc1e357"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUzNjUxOQ==", "bodyText": "Changed.", "url": "https://github.com/eclipse/hono/pull/1883#discussion_r405536519", "createdAt": "2020-04-08T13:45:25Z", "author": {"login": "ctron"}, "path": "client-device-connection-infinispan/src/main/java/org/eclipse/hono/deviceconnection/infinispan/client/Cache.java", "diffHunk": "@@ -67,14 +57,14 @@\n     Future<V> get(K key);\n \n     /**\n-     * Gets a value from the cache.\n+     * Remove a key/value mapping from the cache.\n      *\n      * @param key The key.\n-     * @return A succeeded future containing the value or {@code null} if the\n-     *         cache didn't contain the key yet.\n-     *         A failed future if the value could not be read from the cache.\n+     * @param value The value.\n+     * @return {@code true} if the key was mapped to the value, {@code false}\n+     *         otherwise.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQ4NTM4MA=="}, "originalCommit": {"oid": "3254f6a059d27870a3368874885436bb8fc1e357"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjk4MjI0OnYy", "diffSide": "RIGHT", "path": "client-device-connection-infinispan/pom.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToxMjozNlrOGCz5gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNToxOTo0N1rOGC0ObQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwMDY0MA==", "bodyText": "For actually using the embedded cache mode in a kubernetes cluster, we would also need the jgroups-kubernetes dependency, wouldn't we? Or do you want to add that later, along with maybe an example config?", "url": "https://github.com/eclipse/hono/pull/1883#discussion_r405600640", "createdAt": "2020-04-08T15:12:36Z", "author": {"login": "calohmn"}, "path": "client-device-connection-infinispan/pom.xml", "diffHunk": "@@ -22,6 +22,10 @@\n       <groupId>org.infinispan</groupId>\n       <artifactId>infinispan-client-hotrod</artifactId>\n     </dependency>\n+    <dependency>\n+      <groupId>org.infinispan</groupId>\n+      <artifactId>infinispan-core</artifactId>\n+    </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "404f2bfb8f18715ab023944ce8024cca6cef7edf"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwNTk5Nw==", "bodyText": "I would do that outside of the scope of this PR.", "url": "https://github.com/eclipse/hono/pull/1883#discussion_r405605997", "createdAt": "2020-04-08T15:19:47Z", "author": {"login": "ctron"}, "path": "client-device-connection-infinispan/pom.xml", "diffHunk": "@@ -22,6 +22,10 @@\n       <groupId>org.infinispan</groupId>\n       <artifactId>infinispan-client-hotrod</artifactId>\n     </dependency>\n+    <dependency>\n+      <groupId>org.infinispan</groupId>\n+      <artifactId>infinispan-core</artifactId>\n+    </dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYwMDY0MA=="}, "originalCommit": {"oid": "404f2bfb8f18715ab023944ce8024cca6cef7edf"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3328, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}