{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5Nzg5MjM2", "number": 2335, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNzozNjoxNVrOE---vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNzo0NDoxMVrOE-_Hsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDc5MDM4OnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNzozNjoxNVrOH8bY0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzo0MDowOFrOH8s_AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNTMyOQ==", "bodyText": "\"... receive this event message\"", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533125329", "createdAt": "2020-12-01T07:36:15Z", "author": {"login": "calohmn"}, "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQxMzYzMg==", "bodyText": "It has been corrected.", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533413632", "createdAt": "2020-12-01T13:40:08Z", "author": {"login": "kaniyan"}, "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNTMyOQ=="}, "originalCommit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDc5OTMxOnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNzozOToyMVrOH8beXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNzozOToyMVrOH8beXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNjc1MA==", "bodyText": "Is it necessary to wait 4s here? I would have guessed at most 200ms should be enough here, if waiting at all.", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533126750", "createdAt": "2020-12-01T07:39:21Z", "author": {"login": "calohmn"}, "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDgwMTI3OnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNzo0MDowNVrOH8bfmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNzo0MDowNVrOH8bfmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNzA2NA==", "bodyText": "how about using a checkpoint here instead and simply relying on the test timeout instead of setting another vert.x timer to wait for the message to arrive?", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533127064", "createdAt": "2020-12-01T07:40:05Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {\n+                        log.info(\"opening event consumer for tenant [{}]\", tenantId);\n+                        createConsumer(tenantId, msg -> receivedMessageCount.incrementAndGet())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDgwMzAyOnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNzo0MDozNVrOH8bgmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzo0MDo0MlrOH8tAbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNzMyMg==", "bodyText": "why do you need to set a timer here?", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533127322", "createdAt": "2020-12-01T07:40:35Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQxMzk5Nw==", "bodyText": "I have removed the timer approach and rewritten the tests.", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533413997", "createdAt": "2020-12-01T13:40:42Z", "author": {"login": "kaniyan"}, "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNzMyMg=="}, "originalCommit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDgwNjcxOnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNzo0MTo1MVrOH8bi3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMzo0MTo1OVrOH8tDtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNzkwMg==", "bodyText": "instead of verifying the number of messages here I'd rather assert a particular property of the message that has been sent in the consumer itself, before flagging the checkpoint ...", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533127902", "createdAt": "2020-12-01T07:41:51Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {\n+                        log.info(\"opening event consumer for tenant [{}]\", tenantId);\n+                        createConsumer(tenantId, msg -> receivedMessageCount.incrementAndGet())\n+                                .onComplete(consumerCreated);\n+                    });\n+                    return consumerCreated.future();\n+                })\n+                .compose(consumer -> {\n+                    final Promise<Void> done = Promise.promise();\n+                    vertx.setTimer(1000, tid -> {\n+                        //THEN verify if the message is received by the consumer\n+                        assertThat(receivedMessageCount.get()).isEqualTo(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQxNDgzOQ==", "bodyText": "I have made use of a random UUID as a payload message. The event consumer verifies the payload content with that of the random UUID value.", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533414839", "createdAt": "2020-12-01T13:41:59Z", "author": {"login": "kaniyan"}, "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {\n+                        log.info(\"opening event consumer for tenant [{}]\", tenantId);\n+                        createConsumer(tenantId, msg -> receivedMessageCount.incrementAndGet())\n+                                .onComplete(consumerCreated);\n+                    });\n+                    return consumerCreated.future();\n+                })\n+                .compose(consumer -> {\n+                    final Promise<Void> done = Promise.promise();\n+                    vertx.setTimer(1000, tid -> {\n+                        //THEN verify if the message is received by the consumer\n+                        assertThat(receivedMessageCount.get()).isEqualTo(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNzkwMg=="}, "originalCommit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDgxMzMwOnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNzo0NDoxMVrOH8bnAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNzo0NDoxMVrOH8bnAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyODk2Mw==", "bodyText": "Instead of waiting a second, how about finishing the test in the consumer message handler, and making sure there is a timeout for the whole test method execution?", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533128963", "createdAt": "2020-12-01T07:44:11Z", "author": {"login": "calohmn"}, "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {\n+                        log.info(\"opening event consumer for tenant [{}]\", tenantId);\n+                        createConsumer(tenantId, msg -> receivedMessageCount.incrementAndGet())\n+                                .onComplete(consumerCreated);\n+                    });\n+                    return consumerCreated.future();\n+                })\n+                .compose(consumer -> {\n+                    final Promise<Void> done = Promise.promise();\n+                    vertx.setTimer(1000, tid -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "originalPosition": 90}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2918, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}