{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyNDY2Nzk2", "number": 1800, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzo1OTo1NVrODm-DNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwODoyNjowMFrODm-eZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTg5MTExOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzo1OTo1NVrOF0sU5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzo1OTo1NVrOF0sU5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5NjUxOA==", "bodyText": "IMHO we should simply refer to the Device Connection API here in order to prevent duplication and diverging documentation. WDYT?", "url": "https://github.com/eclipse/hono/pull/1800#discussion_r390796518", "createdAt": "2020-03-11T07:59:55Z", "author": {"login": "sophokles73"}, "path": "client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java", "diffHunk": "@@ -64,4 +66,93 @@\n      * @throws NullPointerException if device id is {@code null}.\n      */\n     Future<JsonObject> getLastKnownGatewayForDevice(String deviceId, SpanContext context);\n+\n+    /**\n+     * Sets the protocol adapter instance that handles commands for the given device.\n+     *\n+     * @param deviceId The device id.\n+     * @param adapterInstanceId The protocol adapter instance id.\n+     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.\n+     *            An implementation should use this as the parent for any span it creates for tracing\n+     *            the execution of this operation.\n+     * @return A future indicating whether the operation succeeded or not.\n+     * @throws NullPointerException if device id or adapter instance id is {@code null}.\n+     */\n+    Future<Void> setCommandHandlingAdapterInstance(String deviceId, String adapterInstanceId, SpanContext context);\n+\n+    /**\n+     * Removes the mapping information that associates the given device with the given protocol adapter instance\n+     * that handles commands for the given device. The mapping entry is only deleted if its value\n+     * contains the given protocol adapter instance id.\n+     *\n+     * @param deviceId The device id.\n+     * @param adapterInstanceId The protocol adapter instance id that the entry to be removed has to contain.\n+     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.\n+     *            An implementation should use this as the parent for any span it creates for tracing\n+     *            the execution of this operation.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future will be succeeded if the entry was successfully removed.\n+     *         Otherwise the future will be failed with a {@link org.eclipse.hono.client.ServiceInvocationException}.\n+     * @throws NullPointerException if device id or adapter instance id is {@code null}.\n+     */\n+    Future<Void> removeCommandHandlingAdapterInstance(String deviceId, String adapterInstanceId, SpanContext context);\n+\n+    /**\n+     * Gets information about the adapter instances that can handle a command for the given device.\n+     * <p>\n+     * For a device that may communicate via a gateway, the list of all these gateways configured for the device\n+     * has to be given in the <em>viaGateways</em> parameter.\n+     * <p>\n+     * The resulting JSON object contains a list of entries associating device id and adapter instance id. This device\n+     * id may not necessarily be the <em>deviceId</em> given in the method parameter, it may be the ID of one of the\n+     * gateways acting on behalf of the device.\n+     * Example result JSON:\n+     * <pre>\n+     *  {\n+     *   \"adapter-instances\": [\n+     *     {\n+     *       \"adapter-instance-id\": \"adapter-1\",\n+     *       \"device-id\": \"4711\"\n+     *     }\n+     *   ]\n+     * }\n+     * </pre>\n+     * A JSON object with a single <em>adapter-instances</em> entry is returned if (in order of precedence)\n+     * <ol>\n+     *     <li>an adapter instance is registered for the given device</li>\n+     *     <li>or there is an adapter instance registered for the last known gateway associated with the given device.\n+     *     (That gateway also has to be contained in the given list of <em>viaGateways</em>.)</li>\n+     * </ol>\n+     * If both conditions are <i>not</i> met, all registered adapter instances for the given gateway ids (<em>viaGateways</em>)\n+     * are returned in the JSON object. Example:\n+     * <pre>\n+     *  {\n+     *   \"adapter-instances\": [\n+     *     {\n+     *       \"adapter-instance-id\": \"adapter-1\",\n+     *       \"device-id\": \"gw-1\"\n+     *     },\n+     *     {\n+     *       \"adapter-instance-id\": \"adapter-1\",\n+     *       \"device-id\": \"gw-2\"\n+     *     }\n+     *   ]\n+     * }\n+     * </pre>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50cee3621ab8b1f250bc76726113677d59dc6579"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTkwNjQ5OnYy", "diffSide": "RIGHT", "path": "service-base/src/main/java/org/eclipse/hono/service/deviceconnection/DeviceConnectionService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwODowNTo1NFrOF0seGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwODowNTo1NFrOF0seGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5ODg3NA==", "bodyText": "refer to API docs?", "url": "https://github.com/eclipse/hono/pull/1800#discussion_r390798874", "createdAt": "2020-03-11T08:05:54Z", "author": {"login": "sophokles73"}, "path": "service-base/src/main/java/org/eclipse/hono/service/deviceconnection/DeviceConnectionService.java", "diffHunk": "@@ -70,4 +72,98 @@\n      * @throws NullPointerException if any of the parameters is {@code null}.\n      */\n     Future<DeviceConnectionResult> getLastKnownGatewayForDevice(String tenantId, String deviceId, Span span);\n+\n+    /**\n+     * Sets the protocol adapter instance that handles commands for the given device or gateway.\n+     *\n+     * @param tenantId The tenant id.\n+     * @param deviceId The device id.\n+     * @param adapterInstanceId The protocol adapter instance id.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be <em>204 No Content</em> if the operation completed successfully.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    Future<DeviceConnectionResult> setCommandHandlingAdapterInstance(String tenantId, String deviceId, String adapterInstanceId, Span span);\n+\n+    /**\n+     * Removes the mapping information that associates the given device with the given protocol adapter instance\n+     * that handles commands for the given device. The mapping entry is only deleted if its value\n+     * contains the given protocol adapter instance id.\n+     *\n+     * @param tenantId The tenant id.\n+     * @param deviceId The device id.\n+     * @param adapterInstanceId The protocol adapter instance id that the entry to be removed has to contain.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be <em>204 No Content</em> if the entry was successfully removed.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    Future<DeviceConnectionResult> removeCommandHandlingAdapterInstance(String tenantId, String deviceId, String adapterInstanceId, Span span);\n+\n+    /**\n+     * Gets information about the adapter instances that can handle a command for the given device.\n+     * <p>\n+     * For a device that may communicate via a gateway, the list of all these gateways configured for the device\n+     * has to be given in the <em>viaGateways</em> parameter.\n+     * <p>\n+     * The resulting JSON object contains a list of entries associating device id and adapter instance id. This device\n+     * id may not necessarily be the <em>deviceId</em> given in the method parameter, it may be the ID of one of the\n+     * gateways acting on behalf of the device.\n+     * Example result JSON:\n+     * <pre>\n+     *  {\n+     *   \"adapter-instances\": [\n+     *     {\n+     *       \"adapter-instance-id\": \"adapter-1\",\n+     *       \"device-id\": \"4711\"\n+     *     }\n+     *   ]\n+     * }\n+     * </pre>\n+     * A JSON object with a single <em>adapter-instances</em> entry is returned if (in order of precedence)\n+     * <ol>\n+     *     <li>an adapter instance is registered for the given device</li>\n+     *     <li>or there is an adapter instance registered for the last known gateway associated with the given device.\n+     *     (That gateway also has to be contained in the given list of <em>viaGateways</em>.)</li>\n+     * </ol>\n+     * If both conditions are <i>not</i> met, all registered adapter instances for the given gateway ids (<em>viaGateways</em>)\n+     * are returned in the JSON object. Example:\n+     * <pre>\n+     *  {\n+     *   \"adapter-instances\": [\n+     *     {\n+     *       \"adapter-instance-id\": \"adapter-1\",\n+     *       \"device-id\": \"gw-1\"\n+     *     },\n+     *     {\n+     *       \"adapter-instance-id\": \"adapter-1\",\n+     *       \"device-id\": \"gw-2\"\n+     *     }\n+     *   ]\n+     * }\n+     * </pre>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50cee3621ab8b1f250bc76726113677d59dc6579"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTk0MzU5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/deviceconnection/MapBasedDeviceConnectionService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwODoyMDoyMlrOF0s1Tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwODo0NjoxM1rOF0tncA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgwNDgxNA==", "bodyText": "IMHO this should simply be\nfinal JsonArray adapterInstancesArray = new JsonArray();", "url": "https://github.com/eclipse/hono/pull/1800#discussion_r390804814", "createdAt": "2020-03-11T08:20:22Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/deviceconnection/MapBasedDeviceConnectionService.java", "diffHunk": "@@ -105,17 +111,151 @@ public MapBasedDeviceConnectionsConfigProperties getConfig() {\n         return Future.succeededFuture(result);\n     }\n \n+    @Override\n+    public Future<DeviceConnectionResult> setCommandHandlingAdapterInstance(final String tenantId, final String deviceId,\n+            final String protocolAdapterInstanceId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(protocolAdapterInstanceId);\n+\n+        final Map<String, JsonObject> adapterInstancesForTenantMap = commandHandlingAdapterInstancesMap.computeIfAbsent(tenantId,\n+                k -> new ConcurrentHashMap<>());\n+        final DeviceConnectionResult result;\n+        final int currentMapSize = adapterInstancesForTenantMap.size();\n+        if (currentMapSize < getConfig().getMaxDevicesPerTenant()\n+                || (currentMapSize == getConfig().getMaxDevicesPerTenant() && adapterInstancesForTenantMap.containsKey(deviceId))) {\n+            adapterInstancesForTenantMap.put(deviceId, createAdapterInstanceIdJson(protocolAdapterInstanceId));\n+            result = DeviceConnectionResult.from(HttpURLConnection.HTTP_NO_CONTENT);\n+        } else {\n+            log.debug(\"cannot set protocol adapter instance for handling commands of device [{}], tenant [{}]: max number of entries per tenant reached ({})\",\n+                    deviceId, tenantId, getConfig().getMaxDevicesPerTenant());\n+            result = DeviceConnectionResult.from(HttpURLConnection.HTTP_FORBIDDEN);\n+        }\n+        return Future.succeededFuture(result);\n+    }\n+\n+    @Override\n+    public Future<DeviceConnectionResult> removeCommandHandlingAdapterInstance(final String tenantId, final String deviceId,\n+            final String adapterInstanceId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(adapterInstanceId);\n+\n+        final Map<String, JsonObject> adapterInstancesForTenantMap = commandHandlingAdapterInstancesMap.computeIfAbsent(tenantId,\n+                k -> new ConcurrentHashMap<>());\n+\n+        final JsonObject adapterInstanceIdJson = adapterInstancesForTenantMap.get(deviceId);\n+        final Future<DeviceConnectionResult> resultFuture;\n+        if (adapterInstanceIdJson != null) {\n+            // remove entry only if existing value contains matching adapterInstanceId\n+            final boolean removed = adapterInstanceId.equals(getAdapterInstanceIdFromJson(adapterInstanceIdJson))\n+                    && adapterInstancesForTenantMap.remove(deviceId, adapterInstanceIdJson);\n+            if (removed) {\n+                resultFuture = Future.succeededFuture(DeviceConnectionResult.from(HttpURLConnection.HTTP_NO_CONTENT));\n+            } else {\n+                log.debug(\"cannot remove command handling adapter instance for device [{}], tenant [{}] - given value does not match current\",\n+                        deviceId, tenantId);\n+                resultFuture = Future.succeededFuture(DeviceConnectionResult.from(HttpURLConnection.HTTP_PRECON_FAILED));\n+            }\n+        } else {\n+            resultFuture = Future.succeededFuture(DeviceConnectionResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+        }\n+        return resultFuture;\n+    }\n+\n+    @Override\n+    public Future<DeviceConnectionResult> getCommandHandlingAdapterInstances(final String tenantId,\n+            final String deviceId, final List<String> viaGateways, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+\n+        final Map<String, JsonObject> commandHandlersForTenantMap = commandHandlingAdapterInstancesMap.get(tenantId);\n+        final DeviceConnectionResult result;\n+        if (commandHandlersForTenantMap != null) {\n+            // resultMap has device id as key and adapter instance id as value\n+            final Map<String, String> resultMap = new HashMap<>();\n+            final JsonObject deviceAdapterInstanceIdJson = commandHandlersForTenantMap.get(deviceId);\n+            if (deviceAdapterInstanceIdJson != null) {\n+                // found mapping for given device id\n+                resultMap.put(deviceId, getAdapterInstanceIdFromJson(deviceAdapterInstanceIdJson));\n+            } else if (!viaGateways.isEmpty()) {\n+                // no mapping found for given device; check last known gateway of device\n+                final Map<String, JsonObject> lastKnownGatewaysForTenantMap = lastKnownGatewaysMap.get(tenantId);\n+                if (lastKnownGatewaysForTenantMap != null) {\n+                    final JsonObject lastKnownGatewayJson = lastKnownGatewaysForTenantMap.get(deviceId);\n+                    if (lastKnownGatewayJson != null) {\n+                        final String gatewayId = getGatewayIdFromLastKnownGatewayJson(lastKnownGatewayJson);\n+                        if (viaGateways.contains(gatewayId)) {\n+                            // get command handler for found gateway device\n+                            final JsonObject gwAdapterInstanceIdJson = commandHandlersForTenantMap.get(gatewayId);\n+                            if (gwAdapterInstanceIdJson != null) {\n+                                resultMap.put(gatewayId, getAdapterInstanceIdFromJson(gwAdapterInstanceIdJson));\n+                            }\n+                        } else {\n+                            log.trace(\"ignoring found last known gateway [{}]; gateway is not in given via list\", gatewayId);\n+                        }\n+                    }\n+                }\n+            }\n+            if (resultMap.isEmpty() && !viaGateways.isEmpty()) {\n+                log.trace(\"no command handling adapter instance found for given device or last known gateway; getting instances for all via gateways\");\n+                for (final String viaGateway : viaGateways) {\n+                    final JsonObject gwAdapterInstanceIdJson = commandHandlersForTenantMap.get(viaGateway);\n+                    if (gwAdapterInstanceIdJson != null) {\n+                        resultMap.put(viaGateway, getAdapterInstanceIdFromJson(gwAdapterInstanceIdJson));\n+                    }\n+                }\n+            }\n+            if (!resultMap.isEmpty()) {\n+                result = DeviceConnectionResult.from(HttpURLConnection.HTTP_OK, getResultJson(resultMap));\n+            } else {\n+                result = DeviceConnectionResult.from(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+        } else {\n+            result = DeviceConnectionResult.from(HttpURLConnection.HTTP_NOT_FOUND);\n+        }\n+        return Future.succeededFuture(result);\n+    }\n+\n+    private JsonObject getResultJson(final Map<String, String> deviceToAdapterInstanceMap) {\n+        final JsonObject jsonObject = new JsonObject();\n+        final JsonArray adapterInstancesArray = new JsonArray(new ArrayList<>(deviceToAdapterInstanceMap.size()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50cee3621ab8b1f250bc76726113677d59dc6579"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgxNzY0OA==", "bodyText": "Since the array size is fixed here, I want to initialize the JsonArray with that size like that (for lack of a corresponding JsonArray constructor).", "url": "https://github.com/eclipse/hono/pull/1800#discussion_r390817648", "createdAt": "2020-03-11T08:46:13Z", "author": {"login": "calohmn"}, "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/deviceconnection/MapBasedDeviceConnectionService.java", "diffHunk": "@@ -105,17 +111,151 @@ public MapBasedDeviceConnectionsConfigProperties getConfig() {\n         return Future.succeededFuture(result);\n     }\n \n+    @Override\n+    public Future<DeviceConnectionResult> setCommandHandlingAdapterInstance(final String tenantId, final String deviceId,\n+            final String protocolAdapterInstanceId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(protocolAdapterInstanceId);\n+\n+        final Map<String, JsonObject> adapterInstancesForTenantMap = commandHandlingAdapterInstancesMap.computeIfAbsent(tenantId,\n+                k -> new ConcurrentHashMap<>());\n+        final DeviceConnectionResult result;\n+        final int currentMapSize = adapterInstancesForTenantMap.size();\n+        if (currentMapSize < getConfig().getMaxDevicesPerTenant()\n+                || (currentMapSize == getConfig().getMaxDevicesPerTenant() && adapterInstancesForTenantMap.containsKey(deviceId))) {\n+            adapterInstancesForTenantMap.put(deviceId, createAdapterInstanceIdJson(protocolAdapterInstanceId));\n+            result = DeviceConnectionResult.from(HttpURLConnection.HTTP_NO_CONTENT);\n+        } else {\n+            log.debug(\"cannot set protocol adapter instance for handling commands of device [{}], tenant [{}]: max number of entries per tenant reached ({})\",\n+                    deviceId, tenantId, getConfig().getMaxDevicesPerTenant());\n+            result = DeviceConnectionResult.from(HttpURLConnection.HTTP_FORBIDDEN);\n+        }\n+        return Future.succeededFuture(result);\n+    }\n+\n+    @Override\n+    public Future<DeviceConnectionResult> removeCommandHandlingAdapterInstance(final String tenantId, final String deviceId,\n+            final String adapterInstanceId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(adapterInstanceId);\n+\n+        final Map<String, JsonObject> adapterInstancesForTenantMap = commandHandlingAdapterInstancesMap.computeIfAbsent(tenantId,\n+                k -> new ConcurrentHashMap<>());\n+\n+        final JsonObject adapterInstanceIdJson = adapterInstancesForTenantMap.get(deviceId);\n+        final Future<DeviceConnectionResult> resultFuture;\n+        if (adapterInstanceIdJson != null) {\n+            // remove entry only if existing value contains matching adapterInstanceId\n+            final boolean removed = adapterInstanceId.equals(getAdapterInstanceIdFromJson(adapterInstanceIdJson))\n+                    && adapterInstancesForTenantMap.remove(deviceId, adapterInstanceIdJson);\n+            if (removed) {\n+                resultFuture = Future.succeededFuture(DeviceConnectionResult.from(HttpURLConnection.HTTP_NO_CONTENT));\n+            } else {\n+                log.debug(\"cannot remove command handling adapter instance for device [{}], tenant [{}] - given value does not match current\",\n+                        deviceId, tenantId);\n+                resultFuture = Future.succeededFuture(DeviceConnectionResult.from(HttpURLConnection.HTTP_PRECON_FAILED));\n+            }\n+        } else {\n+            resultFuture = Future.succeededFuture(DeviceConnectionResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+        }\n+        return resultFuture;\n+    }\n+\n+    @Override\n+    public Future<DeviceConnectionResult> getCommandHandlingAdapterInstances(final String tenantId,\n+            final String deviceId, final List<String> viaGateways, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+\n+        final Map<String, JsonObject> commandHandlersForTenantMap = commandHandlingAdapterInstancesMap.get(tenantId);\n+        final DeviceConnectionResult result;\n+        if (commandHandlersForTenantMap != null) {\n+            // resultMap has device id as key and adapter instance id as value\n+            final Map<String, String> resultMap = new HashMap<>();\n+            final JsonObject deviceAdapterInstanceIdJson = commandHandlersForTenantMap.get(deviceId);\n+            if (deviceAdapterInstanceIdJson != null) {\n+                // found mapping for given device id\n+                resultMap.put(deviceId, getAdapterInstanceIdFromJson(deviceAdapterInstanceIdJson));\n+            } else if (!viaGateways.isEmpty()) {\n+                // no mapping found for given device; check last known gateway of device\n+                final Map<String, JsonObject> lastKnownGatewaysForTenantMap = lastKnownGatewaysMap.get(tenantId);\n+                if (lastKnownGatewaysForTenantMap != null) {\n+                    final JsonObject lastKnownGatewayJson = lastKnownGatewaysForTenantMap.get(deviceId);\n+                    if (lastKnownGatewayJson != null) {\n+                        final String gatewayId = getGatewayIdFromLastKnownGatewayJson(lastKnownGatewayJson);\n+                        if (viaGateways.contains(gatewayId)) {\n+                            // get command handler for found gateway device\n+                            final JsonObject gwAdapterInstanceIdJson = commandHandlersForTenantMap.get(gatewayId);\n+                            if (gwAdapterInstanceIdJson != null) {\n+                                resultMap.put(gatewayId, getAdapterInstanceIdFromJson(gwAdapterInstanceIdJson));\n+                            }\n+                        } else {\n+                            log.trace(\"ignoring found last known gateway [{}]; gateway is not in given via list\", gatewayId);\n+                        }\n+                    }\n+                }\n+            }\n+            if (resultMap.isEmpty() && !viaGateways.isEmpty()) {\n+                log.trace(\"no command handling adapter instance found for given device or last known gateway; getting instances for all via gateways\");\n+                for (final String viaGateway : viaGateways) {\n+                    final JsonObject gwAdapterInstanceIdJson = commandHandlersForTenantMap.get(viaGateway);\n+                    if (gwAdapterInstanceIdJson != null) {\n+                        resultMap.put(viaGateway, getAdapterInstanceIdFromJson(gwAdapterInstanceIdJson));\n+                    }\n+                }\n+            }\n+            if (!resultMap.isEmpty()) {\n+                result = DeviceConnectionResult.from(HttpURLConnection.HTTP_OK, getResultJson(resultMap));\n+            } else {\n+                result = DeviceConnectionResult.from(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+        } else {\n+            result = DeviceConnectionResult.from(HttpURLConnection.HTTP_NOT_FOUND);\n+        }\n+        return Future.succeededFuture(result);\n+    }\n+\n+    private JsonObject getResultJson(final Map<String, String> deviceToAdapterInstanceMap) {\n+        final JsonObject jsonObject = new JsonObject();\n+        final JsonArray adapterInstancesArray = new JsonArray(new ArrayList<>(deviceToAdapterInstanceMap.size()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgwNDgxNA=="}, "originalCommit": {"oid": "50cee3621ab8b1f250bc76726113677d59dc6579"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTk2MDY4OnYy", "diffSide": "RIGHT", "path": "client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwODoyNjowMFrOF0s_tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwODoyNjowMFrOF0s_tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgwNzQ3Ng==", "bodyText": "this seems to be repeated over and over again, maybe you can extract it into a helper method?", "url": "https://github.com/eclipse/hono/pull/1800#discussion_r390807476", "createdAt": "2020-03-11T08:26:00Z", "author": {"login": "sophokles73"}, "path": "client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java", "diffHunk": "@@ -136,9 +143,73 @@ public void testSetLastKnownGatewayForDeviceSuccess(final VertxTestContext ctx)\n         // WHEN setting the last known gateway\n         client.setLastKnownGatewayForDevice(\"deviceId\", \"gatewayId\", span.context())\n                 .setHandler(ctx.succeeding(r -> {\n-                    // THEN the response for setting the last known gateway has been handled by the service\n-                    // and the span is finished\n-                    verify(span).finish();\n+                    ctx.verify(() -> {\n+                        // THEN the response for setting the last known gateway has been handled by the service\n+                        // and the span is finished\n+                        verify(span).finish();\n+                    });\n+                    ctx.completeNow();\n+                }));\n+\n+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);\n+        verify(sender).send(messageCaptor.capture(), any(Handler.class));\n+        final Message response = ProtonHelper.message();\n+        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_NO_CONTENT);\n+        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));\n+        response.setCorrelationId(messageCaptor.getValue().getMessageId());\n+        final ProtonDelivery delivery = mock(ProtonDelivery.class);\n+        client.handleResponse(delivery, response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50cee3621ab8b1f250bc76726113677d59dc6579"}, "originalPosition": 78}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3231, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}