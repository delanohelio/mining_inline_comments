{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwNzk1ODA2", "number": 2123, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMjozNjo0N1rOEaghKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMDowOTo0NlrOEasG1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MjMxMjExOnYy", "diffSide": "RIGHT", "path": "service-base/src/test/java/org/eclipse/hono/service/resourcelimits/PrometheusBasedResourceLimitChecksTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMjozNjo0N1rOHD-zKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMjozNjo0N1rOHD-zKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzNjY4Mg==", "bodyText": "typo: Septemer", "url": "https://github.com/eclipse/hono/pull/2123#discussion_r473936682", "createdAt": "2020-08-20T12:36:47Z", "author": {"login": "calohmn"}, "path": "service-base/src/test/java/org/eclipse/hono/service/resourcelimits/PrometheusBasedResourceLimitChecksTest.java", "diffHunk": "@@ -402,80 +427,110 @@ public void testMessageLimitNotExceededForMissingMetrics(final VertxTestContext\n      */\n     @Test\n     public void verifyEffectiveResourceLimitCalculation() {\n+\n         final long maxBytes = 9300;\n \n         // Monthly mode\n-        // The case where the effectiveSince lies on the past months of the target date.\n-        assertEquals(maxBytes,\n+        // target date lies within the initial accounting period.\n+        final long numberOfMinutesInSeptemer = 24 * 60 * 30;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "130bd9904c06dac41245f8667c98980c2d66333f"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MjMzMzc0OnYy", "diffSide": "RIGHT", "path": "service-base/src/test/java/org/eclipse/hono/service/resourcelimits/PrometheusBasedResourceLimitChecksTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMjo0MzowNlrOHD_Afg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMzoyMjoyMlrOHEAlOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MDA5NA==", "bodyText": "Using Math.floor() looks superfluous here since the division result is truncated anyway.", "url": "https://github.com/eclipse/hono/pull/2123#discussion_r473940094", "createdAt": "2020-08-20T12:43:06Z", "author": {"login": "calohmn"}, "path": "service-base/src/test/java/org/eclipse/hono/service/resourcelimits/PrometheusBasedResourceLimitChecksTest.java", "diffHunk": "@@ -402,80 +427,110 @@ public void testMessageLimitNotExceededForMissingMetrics(final VertxTestContext\n      */\n     @Test\n     public void verifyEffectiveResourceLimitCalculation() {\n+\n         final long maxBytes = 9300;\n \n         // Monthly mode\n-        // The case where the effectiveSince lies on the past months of the target date.\n-        assertEquals(maxBytes,\n+        // target date lies within the initial accounting period.\n+        final long numberOfMinutesInSeptemer = 24 * 60 * 30;\n+        // next accounting period starts Oct 1st 12 AM UTC\n+        final long remainingMinutesTillStartOfNextAccountingPeriod = 24 * 60 * 28 + 9 * 60 + 30;\n+        final long expectedEffectiveLimit = (long) Math.floor(remainingMinutesTillStartOfNextAccountingPeriod * maxBytes / numberOfMinutesInSeptemer );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "130bd9904c06dac41245f8667c98980c2d66333f"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk2NTg4MQ==", "bodyText": "floor() is the wrong one anyway ;-)", "url": "https://github.com/eclipse/hono/pull/2123#discussion_r473965881", "createdAt": "2020-08-20T13:22:22Z", "author": {"login": "sophokles73"}, "path": "service-base/src/test/java/org/eclipse/hono/service/resourcelimits/PrometheusBasedResourceLimitChecksTest.java", "diffHunk": "@@ -402,80 +427,110 @@ public void testMessageLimitNotExceededForMissingMetrics(final VertxTestContext\n      */\n     @Test\n     public void verifyEffectiveResourceLimitCalculation() {\n+\n         final long maxBytes = 9300;\n \n         // Monthly mode\n-        // The case where the effectiveSince lies on the past months of the target date.\n-        assertEquals(maxBytes,\n+        // target date lies within the initial accounting period.\n+        final long numberOfMinutesInSeptemer = 24 * 60 * 30;\n+        // next accounting period starts Oct 1st 12 AM UTC\n+        final long remainingMinutesTillStartOfNextAccountingPeriod = 24 * 60 * 28 + 9 * 60 + 30;\n+        final long expectedEffectiveLimit = (long) Math.floor(remainingMinutesTillStartOfNextAccountingPeriod * maxBytes / numberOfMinutesInSeptemer );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MDA5NA=="}, "originalCommit": {"oid": "130bd9904c06dac41245f8667c98980c2d66333f"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MjM5NTExOnYy", "diffSide": "RIGHT", "path": "service-base/src/main/java/org/eclipse/hono/service/resourcelimits/PrometheusBasedResourceLimitChecks.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMjo1OToxN1rOHD_mTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMzoyMDowOFrOHEAb9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0OTc3NQ==", "bodyText": "FMPOV we should also allow to set a future date as an effectiveSince date. For example, I would like to start a plan from the next month. In this case, I should be able to set it now and not wait until 12 AM UTC on the first day of the next month. IMHO if the effective date is in the future, we can simply ignore and no need to calculate any limits.\nIf we don't want to allow any future date as an effectiveSince, then I think a corresponding validation should be  there while adding/updating tenant information. WDYT?", "url": "https://github.com/eclipse/hono/pull/2123#discussion_r473949775", "createdAt": "2020-08-20T12:59:17Z", "author": {"login": "kaniyan"}, "path": "service-base/src/main/java/org/eclipse/hono/service/resourcelimits/PrometheusBasedResourceLimitChecks.java", "diffHunk": "@@ -627,76 +647,146 @@ private Long extractLongValue(final JsonObject response, final Span span) {\n     }\n \n     /**\n-     * Calculates the effective resource limit for a tenant for the given period from the configured values.\n+     * Calculates the effective resource limit for a tenant for the current accounting period.\n      * <p>\n-     * In the <em>monthly</em> mode, if the effectiveSince date doesn't fall on the \n-     * first day of the month then the effective resource limit for the tenant is \n-     * calculated as below.\n+     * For the initial accounting period of a monthly plan the effective resource limit is\n+     * calculated as follows:\n      * <pre>\n      *             configured limit \n-     *   ---------------------------------- x No. of days from effectiveSince till lastDay of the targetDateMonth.\n-     *    No. of days in the current month\n+     *   ----------------------------------- x No. of minutes until start of next accounting period.\n+     *   No. of minutes in the current month\n      * </pre>\n      * <p>\n-     * For rest of the months and the <em>days</em> mode, the configured limit is used directly.\n+     * In all other cases the configured limit is used directly.\n      *\n-     * @param effectiveSince The point of time on which the given resource limit came into effect.\n-     * @param targetDateTime The target date and time.\n-     * @param mode The mode of the period. \n-     * @param configuredLimit The configured limit. \n-     * @return The effective resource limit that has been calculated.\n+     * @param effectiveSince The point of time (UTC) at which the resource limit became effective.\n+     * @param targetDateTime The point in time (UTC) to calculate the limit for.\n+     * @param periodType The type of accounting periods that the resource limit is based on.\n+     * @param configuredLimit The maximum amount of resources to be used per accounting period.\n+     * @return The resource limit for the current accounting period.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     * @throws IllegalArgumentException if target date-time is before effective since date-time.\n      */\n     long calculateEffectiveLimit(\n-            final OffsetDateTime effectiveSince,\n-            final OffsetDateTime targetDateTime,\n-            final PeriodMode mode,\n+            final Instant effectiveSince,\n+            final Instant targetDateTime,\n+            final PeriodMode periodType,\n             final long configuredLimit) {\n-        if (PeriodMode.MONTHLY.equals(mode)\n-                && configuredLimit > 0\n-                && !targetDateTime.isBefore(effectiveSince)\n-                && YearMonth.from(targetDateTime).equals(YearMonth.from(effectiveSince))\n-                && effectiveSince.getDayOfMonth() != 1) {\n-            final OffsetDateTime lastDayOfMonth = effectiveSince.with(TemporalAdjusters.lastDayOfMonth());\n-            final long daysBetween = ChronoUnit.DAYS\n-                    .between(effectiveSince, lastDayOfMonth) + 1;\n-            return Double.valueOf(Math.ceil(daysBetween * configuredLimit / lastDayOfMonth.getDayOfMonth()))\n-                    .longValue();\n+\n+        Objects.requireNonNull(effectiveSince, \"effective since\");\n+        Objects.requireNonNull(targetDateTime, \"target date-time\");\n+        Objects.requireNonNull(periodType, \"period mode\");\n+\n+        if (targetDateTime.isBefore(effectiveSince)) {\n+            throw new IllegalArgumentException(\"target date-time must not be before effective since\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "130bd9904c06dac41245f8667c98980c2d66333f"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk2MzUxMA==", "bodyText": "very good point \ud83d\udc4d  I will change it accordingly", "url": "https://github.com/eclipse/hono/pull/2123#discussion_r473963510", "createdAt": "2020-08-20T13:20:08Z", "author": {"login": "sophokles73"}, "path": "service-base/src/main/java/org/eclipse/hono/service/resourcelimits/PrometheusBasedResourceLimitChecks.java", "diffHunk": "@@ -627,76 +647,146 @@ private Long extractLongValue(final JsonObject response, final Span span) {\n     }\n \n     /**\n-     * Calculates the effective resource limit for a tenant for the given period from the configured values.\n+     * Calculates the effective resource limit for a tenant for the current accounting period.\n      * <p>\n-     * In the <em>monthly</em> mode, if the effectiveSince date doesn't fall on the \n-     * first day of the month then the effective resource limit for the tenant is \n-     * calculated as below.\n+     * For the initial accounting period of a monthly plan the effective resource limit is\n+     * calculated as follows:\n      * <pre>\n      *             configured limit \n-     *   ---------------------------------- x No. of days from effectiveSince till lastDay of the targetDateMonth.\n-     *    No. of days in the current month\n+     *   ----------------------------------- x No. of minutes until start of next accounting period.\n+     *   No. of minutes in the current month\n      * </pre>\n      * <p>\n-     * For rest of the months and the <em>days</em> mode, the configured limit is used directly.\n+     * In all other cases the configured limit is used directly.\n      *\n-     * @param effectiveSince The point of time on which the given resource limit came into effect.\n-     * @param targetDateTime The target date and time.\n-     * @param mode The mode of the period. \n-     * @param configuredLimit The configured limit. \n-     * @return The effective resource limit that has been calculated.\n+     * @param effectiveSince The point of time (UTC) at which the resource limit became effective.\n+     * @param targetDateTime The point in time (UTC) to calculate the limit for.\n+     * @param periodType The type of accounting periods that the resource limit is based on.\n+     * @param configuredLimit The maximum amount of resources to be used per accounting period.\n+     * @return The resource limit for the current accounting period.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     * @throws IllegalArgumentException if target date-time is before effective since date-time.\n      */\n     long calculateEffectiveLimit(\n-            final OffsetDateTime effectiveSince,\n-            final OffsetDateTime targetDateTime,\n-            final PeriodMode mode,\n+            final Instant effectiveSince,\n+            final Instant targetDateTime,\n+            final PeriodMode periodType,\n             final long configuredLimit) {\n-        if (PeriodMode.MONTHLY.equals(mode)\n-                && configuredLimit > 0\n-                && !targetDateTime.isBefore(effectiveSince)\n-                && YearMonth.from(targetDateTime).equals(YearMonth.from(effectiveSince))\n-                && effectiveSince.getDayOfMonth() != 1) {\n-            final OffsetDateTime lastDayOfMonth = effectiveSince.with(TemporalAdjusters.lastDayOfMonth());\n-            final long daysBetween = ChronoUnit.DAYS\n-                    .between(effectiveSince, lastDayOfMonth) + 1;\n-            return Double.valueOf(Math.ceil(daysBetween * configuredLimit / lastDayOfMonth.getDayOfMonth()))\n-                    .longValue();\n+\n+        Objects.requireNonNull(effectiveSince, \"effective since\");\n+        Objects.requireNonNull(targetDateTime, \"target date-time\");\n+        Objects.requireNonNull(periodType, \"period mode\");\n+\n+        if (targetDateTime.isBefore(effectiveSince)) {\n+            throw new IllegalArgumentException(\"target date-time must not be before effective since\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0OTc3NQ=="}, "originalCommit": {"oid": "130bd9904c06dac41245f8667c98980c2d66333f"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MjQxMTE4OnYy", "diffSide": "RIGHT", "path": "service-base/src/main/java/org/eclipse/hono/service/resourcelimits/PrometheusBasedResourceLimitChecks.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMzowMzoyN1rOHD_wSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNTowMTo0MVrOHEFycw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MjMyOQ==", "bodyText": "The result won't be the rounded up division result here because the division is done in an integer context and so the division result is truncated before it gets used in Math.ceil().", "url": "https://github.com/eclipse/hono/pull/2123#discussion_r473952329", "createdAt": "2020-08-20T13:03:27Z", "author": {"login": "calohmn"}, "path": "service-base/src/main/java/org/eclipse/hono/service/resourcelimits/PrometheusBasedResourceLimitChecks.java", "diffHunk": "@@ -627,76 +647,146 @@ private Long extractLongValue(final JsonObject response, final Span span) {\n     }\n \n     /**\n-     * Calculates the effective resource limit for a tenant for the given period from the configured values.\n+     * Calculates the effective resource limit for a tenant for the current accounting period.\n      * <p>\n-     * In the <em>monthly</em> mode, if the effectiveSince date doesn't fall on the \n-     * first day of the month then the effective resource limit for the tenant is \n-     * calculated as below.\n+     * For the initial accounting period of a monthly plan the effective resource limit is\n+     * calculated as follows:\n      * <pre>\n      *             configured limit \n-     *   ---------------------------------- x No. of days from effectiveSince till lastDay of the targetDateMonth.\n-     *    No. of days in the current month\n+     *   ----------------------------------- x No. of minutes until start of next accounting period.\n+     *   No. of minutes in the current month\n      * </pre>\n      * <p>\n-     * For rest of the months and the <em>days</em> mode, the configured limit is used directly.\n+     * In all other cases the configured limit is used directly.\n      *\n-     * @param effectiveSince The point of time on which the given resource limit came into effect.\n-     * @param targetDateTime The target date and time.\n-     * @param mode The mode of the period. \n-     * @param configuredLimit The configured limit. \n-     * @return The effective resource limit that has been calculated.\n+     * @param effectiveSince The point of time (UTC) at which the resource limit became effective.\n+     * @param targetDateTime The point in time (UTC) to calculate the limit for.\n+     * @param periodType The type of accounting periods that the resource limit is based on.\n+     * @param configuredLimit The maximum amount of resources to be used per accounting period.\n+     * @return The resource limit for the current accounting period.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     * @throws IllegalArgumentException if target date-time is before effective since date-time.\n      */\n     long calculateEffectiveLimit(\n-            final OffsetDateTime effectiveSince,\n-            final OffsetDateTime targetDateTime,\n-            final PeriodMode mode,\n+            final Instant effectiveSince,\n+            final Instant targetDateTime,\n+            final PeriodMode periodType,\n             final long configuredLimit) {\n-        if (PeriodMode.MONTHLY.equals(mode)\n-                && configuredLimit > 0\n-                && !targetDateTime.isBefore(effectiveSince)\n-                && YearMonth.from(targetDateTime).equals(YearMonth.from(effectiveSince))\n-                && effectiveSince.getDayOfMonth() != 1) {\n-            final OffsetDateTime lastDayOfMonth = effectiveSince.with(TemporalAdjusters.lastDayOfMonth());\n-            final long daysBetween = ChronoUnit.DAYS\n-                    .between(effectiveSince, lastDayOfMonth) + 1;\n-            return Double.valueOf(Math.ceil(daysBetween * configuredLimit / lastDayOfMonth.getDayOfMonth()))\n-                    .longValue();\n+\n+        Objects.requireNonNull(effectiveSince, \"effective since\");\n+        Objects.requireNonNull(targetDateTime, \"target date-time\");\n+        Objects.requireNonNull(periodType, \"period mode\");\n+\n+        if (targetDateTime.isBefore(effectiveSince)) {\n+            throw new IllegalArgumentException(\"target date-time must not be before effective since\");\n+        }\n+\n+        // we only need to calculate the effective limit if we are in the initial accounting period\n+        // of a monthly plan\n+        if (PeriodMode.MONTHLY.equals(periodType) && configuredLimit > 0) {\n+\n+            final ZonedDateTime effectiveSinceZonedDateTime = ZonedDateTime.ofInstant(effectiveSince, ZoneOffset.UTC);\n+            final ZonedDateTime targetZonedDateTime = ZonedDateTime.ofInstant(targetDateTime, ZoneOffset.UTC);\n+\n+            if (YearMonth.from(targetZonedDateTime).equals(YearMonth.from(effectiveSinceZonedDateTime))) {\n+\n+                final ZonedDateTime startOfNextAccountingPeriod = effectiveSinceZonedDateTime\n+                        .with(TemporalAdjusters.firstDayOfNextMonth())\n+                        .withHour(0)\n+                        .withMinute(0)\n+                        .withSecond(0)\n+                        .withNano(0);\n+                final long minutesTillStartOfNextAccountingPeriod = Math.max(1, Duration\n+                        .between(effectiveSinceZonedDateTime, startOfNextAccountingPeriod)\n+                        .toMinutes());\n+                final long lengthOfCurrentMonthInMinutes = 60 * 24 * effectiveSinceZonedDateTime\n+                        .range(ChronoField.DAY_OF_MONTH).getMaximum();\n+                return Double.valueOf(Math.ceil(minutesTillStartOfNextAccountingPeriod * configuredLimit / lengthOfCurrentMonthInMinutes))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b5511fe54615764955e5aab014436fa7c850c88"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA1MTE4Nw==", "bodyText": "true, I have changed that", "url": "https://github.com/eclipse/hono/pull/2123#discussion_r474051187", "createdAt": "2020-08-20T15:01:41Z", "author": {"login": "sophokles73"}, "path": "service-base/src/main/java/org/eclipse/hono/service/resourcelimits/PrometheusBasedResourceLimitChecks.java", "diffHunk": "@@ -627,76 +647,146 @@ private Long extractLongValue(final JsonObject response, final Span span) {\n     }\n \n     /**\n-     * Calculates the effective resource limit for a tenant for the given period from the configured values.\n+     * Calculates the effective resource limit for a tenant for the current accounting period.\n      * <p>\n-     * In the <em>monthly</em> mode, if the effectiveSince date doesn't fall on the \n-     * first day of the month then the effective resource limit for the tenant is \n-     * calculated as below.\n+     * For the initial accounting period of a monthly plan the effective resource limit is\n+     * calculated as follows:\n      * <pre>\n      *             configured limit \n-     *   ---------------------------------- x No. of days from effectiveSince till lastDay of the targetDateMonth.\n-     *    No. of days in the current month\n+     *   ----------------------------------- x No. of minutes until start of next accounting period.\n+     *   No. of minutes in the current month\n      * </pre>\n      * <p>\n-     * For rest of the months and the <em>days</em> mode, the configured limit is used directly.\n+     * In all other cases the configured limit is used directly.\n      *\n-     * @param effectiveSince The point of time on which the given resource limit came into effect.\n-     * @param targetDateTime The target date and time.\n-     * @param mode The mode of the period. \n-     * @param configuredLimit The configured limit. \n-     * @return The effective resource limit that has been calculated.\n+     * @param effectiveSince The point of time (UTC) at which the resource limit became effective.\n+     * @param targetDateTime The point in time (UTC) to calculate the limit for.\n+     * @param periodType The type of accounting periods that the resource limit is based on.\n+     * @param configuredLimit The maximum amount of resources to be used per accounting period.\n+     * @return The resource limit for the current accounting period.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     * @throws IllegalArgumentException if target date-time is before effective since date-time.\n      */\n     long calculateEffectiveLimit(\n-            final OffsetDateTime effectiveSince,\n-            final OffsetDateTime targetDateTime,\n-            final PeriodMode mode,\n+            final Instant effectiveSince,\n+            final Instant targetDateTime,\n+            final PeriodMode periodType,\n             final long configuredLimit) {\n-        if (PeriodMode.MONTHLY.equals(mode)\n-                && configuredLimit > 0\n-                && !targetDateTime.isBefore(effectiveSince)\n-                && YearMonth.from(targetDateTime).equals(YearMonth.from(effectiveSince))\n-                && effectiveSince.getDayOfMonth() != 1) {\n-            final OffsetDateTime lastDayOfMonth = effectiveSince.with(TemporalAdjusters.lastDayOfMonth());\n-            final long daysBetween = ChronoUnit.DAYS\n-                    .between(effectiveSince, lastDayOfMonth) + 1;\n-            return Double.valueOf(Math.ceil(daysBetween * configuredLimit / lastDayOfMonth.getDayOfMonth()))\n-                    .longValue();\n+\n+        Objects.requireNonNull(effectiveSince, \"effective since\");\n+        Objects.requireNonNull(targetDateTime, \"target date-time\");\n+        Objects.requireNonNull(periodType, \"period mode\");\n+\n+        if (targetDateTime.isBefore(effectiveSince)) {\n+            throw new IllegalArgumentException(\"target date-time must not be before effective since\");\n+        }\n+\n+        // we only need to calculate the effective limit if we are in the initial accounting period\n+        // of a monthly plan\n+        if (PeriodMode.MONTHLY.equals(periodType) && configuredLimit > 0) {\n+\n+            final ZonedDateTime effectiveSinceZonedDateTime = ZonedDateTime.ofInstant(effectiveSince, ZoneOffset.UTC);\n+            final ZonedDateTime targetZonedDateTime = ZonedDateTime.ofInstant(targetDateTime, ZoneOffset.UTC);\n+\n+            if (YearMonth.from(targetZonedDateTime).equals(YearMonth.from(effectiveSinceZonedDateTime))) {\n+\n+                final ZonedDateTime startOfNextAccountingPeriod = effectiveSinceZonedDateTime\n+                        .with(TemporalAdjusters.firstDayOfNextMonth())\n+                        .withHour(0)\n+                        .withMinute(0)\n+                        .withSecond(0)\n+                        .withNano(0);\n+                final long minutesTillStartOfNextAccountingPeriod = Math.max(1, Duration\n+                        .between(effectiveSinceZonedDateTime, startOfNextAccountingPeriod)\n+                        .toMinutes());\n+                final long lengthOfCurrentMonthInMinutes = 60 * 24 * effectiveSinceZonedDateTime\n+                        .range(ChronoField.DAY_OF_MONTH).getMaximum();\n+                return Double.valueOf(Math.ceil(minutesTillStartOfNextAccountingPeriod * configuredLimit / lengthOfCurrentMonthInMinutes))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MjMyOQ=="}, "originalCommit": {"oid": "5b5511fe54615764955e5aab014436fa7c850c88"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MjQxOTM2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/eclipse/hono/util/ResourceLimitsPeriod.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMzowNTozNVrOHD_1VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxMzowNTozNVrOHD_1VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MzYyMA==", "bodyText": "double whitespace used here", "url": "https://github.com/eclipse/hono/pull/2123#discussion_r473953620", "createdAt": "2020-08-20T13:05:35Z", "author": {"login": "calohmn"}, "path": "core/src/main/java/org/eclipse/hono/util/ResourceLimitsPeriod.java", "diffHunk": "@@ -64,11 +64,11 @@ public final int getNoOfDays() {\n      *\n      * @param noOfDays The number of days for which resource usage is calculated.\n      * @return  a reference to this for fluent use.\n-     * @throws IllegalArgumentException if the number of days is negative.\n+     * @throws IllegalArgumentException if the number of days is &lt;= 0.\n      */\n     public final ResourceLimitsPeriod setNoOfDays(final int noOfDays) {\n-        if (noOfDays < 0) {\n-            throw new IllegalArgumentException(\"Number of days property must be  set to value >= 0\");\n+        if (noOfDays <= 0) {\n+            throw new IllegalArgumentException(\"Number of days property must be  set to value > 0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b5511fe54615764955e5aab014436fa7c850c88"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzMwOTQ5OnYy", "diffSide": "RIGHT", "path": "service-base/src/main/java/org/eclipse/hono/service/resourcelimits/PrometheusBasedResourceLimitChecks.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjowNTo1MlrOHEIuJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjowNzo0NFrOHEIypQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5OTIzOQ==", "bodyText": "As per the master branch, the configured maxBytes value is returned when the effectiveSince date lies in the future. Now by returning zero, it means that no messages are accepted for this tenant (as the allowedMaxBytes is zero bytes) until the plan actually starts as per the effectiveSince date. I think it makes more sense not to allow any messages until the plan actually starts.", "url": "https://github.com/eclipse/hono/pull/2123#discussion_r474099239", "createdAt": "2020-08-20T16:05:52Z", "author": {"login": "kaniyan"}, "path": "service-base/src/main/java/org/eclipse/hono/service/resourcelimits/PrometheusBasedResourceLimitChecks.java", "diffHunk": "@@ -678,7 +678,7 @@ long calculateEffectiveLimit(\n         Objects.requireNonNull(periodType, \"period mode\");\n \n         if (targetDateTime.isBefore(effectiveSince)) {\n-            throw new IllegalArgumentException(\"target date-time must not be before effective since\");\n+            return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6287c65d75ea67e5e9d9d908a9b36b40a8f36117"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEwMDM4OQ==", "bodyText": "I agree. That's why I made that change ;-)", "url": "https://github.com/eclipse/hono/pull/2123#discussion_r474100389", "createdAt": "2020-08-20T16:07:44Z", "author": {"login": "sophokles73"}, "path": "service-base/src/main/java/org/eclipse/hono/service/resourcelimits/PrometheusBasedResourceLimitChecks.java", "diffHunk": "@@ -678,7 +678,7 @@ long calculateEffectiveLimit(\n         Objects.requireNonNull(periodType, \"period mode\");\n \n         if (targetDateTime.isBefore(effectiveSince)) {\n-            throw new IllegalArgumentException(\"target date-time must not be before effective since\");\n+            return 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5OTIzOQ=="}, "originalCommit": {"oid": "6287c65d75ea67e5e9d9d908a9b36b40a8f36117"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NDEzMzkzOnYy", "diffSide": "RIGHT", "path": "site/documentation/content/api/management/device-registry-v1.yaml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxOTo0NDo0MVrOHEQ0vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxOTo0NDo0MVrOHEQ0vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIzMTk5Nw==", "bodyText": "Looks like this should be \"if mode is set to value days\" (instead of monthly).", "url": "https://github.com/eclipse/hono/pull/2123#discussion_r474231997", "createdAt": "2020-08-20T19:44:41Z", "author": {"login": "calohmn"}, "path": "site/documentation/content/api/management/device-registry-v1.yaml", "diffHunk": "@@ -930,13 +931,19 @@ components:\n          properties:\n             \"mode\":\n                type: string\n-               description: The mode of the data usage caluclation. The supported modes by\n-                            the default resource limit checks implementation are \"days\"\n-                            and \"monthly\".\n+               description: |\n+                 The accounting period mode of recurrence. The following modes are defined:\n+                 * `monthly`: Accounting periods start at 12 AM UTC on the 1st day of each month.\n+                 * `days`: Accounting periods start at the time of the initial accounting period every *N* days where\n+                           *N* is the value of the *no-of-days* property.\n+\n+                 The initial accounting period always starts at the point in time that the plan was put in effect at.\n+                 Implementations MUST support the *monthly* and *days* modes and MAY support additional custom modes.\n             \"no-of-days\":\n                type: integer\n-               description: The number of days for which the data usage is to be calculated\n-                            if mode is set to \"days\". Otherwise, this property is ignored.\n+               minimum: 1\n+               description: The accounting period length in days. This property is only used if *mode* is set to value\n+                            `monthly`. Otherwise, this property is ignored.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6287c65d75ea67e5e9d9d908a9b36b40a8f36117"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NDE0NTIwOnYy", "diffSide": "RIGHT", "path": "site/documentation/content/api/management/device-registry-v1.yaml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxOTo0ODoyM1rOHEQ75w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxOTo0ODoyM1rOHEQ75w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIzMzgzMQ==", "bodyText": "\"came or will come into effect.\"  - since it could be in the future.", "url": "https://github.com/eclipse/hono/pull/2123#discussion_r474233831", "createdAt": "2020-08-20T19:48:23Z", "author": {"login": "calohmn"}, "path": "site/documentation/content/api/management/device-registry-v1.yaml", "diffHunk": "@@ -893,13 +893,13 @@ components:\n             \"effective-since\":\n                type: string\n                format: date-time\n-               description: The date-time on which the data volume limit came into effect.\n+               description: The point in time at which the data volume limit came into effect.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6287c65d75ea67e5e9d9d908a9b36b40a8f36117"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NDE0NTkwOnYy", "diffSide": "RIGHT", "path": "site/documentation/content/api/management/device-registry-v1.yaml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxOTo0ODozNlrOHEQ8VA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxOTo0ODozNlrOHEQ8VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIzMzk0MA==", "bodyText": "\"came or will come into effect.\"  - since it could be in the future.", "url": "https://github.com/eclipse/hono/pull/2123#discussion_r474233940", "createdAt": "2020-08-20T19:48:36Z", "author": {"login": "calohmn"}, "path": "site/documentation/content/api/management/device-registry-v1.yaml", "diffHunk": "@@ -912,13 +912,14 @@ components:\n             \"effective-since\":\n                type: string\n                format: date-time\n-               description: The date-time on which the connection duration limit came into effect.\n+               description: The point in time at which the connection duration limit came into effect.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6287c65d75ea67e5e9d9d908a9b36b40a8f36117"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NDIxMDc3OnYy", "diffSide": "RIGHT", "path": "site/documentation/content/api/management/device-registry-v1.yaml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMDowOTo0NlrOHERlfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNjoxNToxM1rOHEc5GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI0NDQ3Nw==", "bodyText": "Using midnight (start of day) UTC instead of 12 AM UTC would be clearer and easier to understand here, IMHO. There might be some confusion otherwise.", "url": "https://github.com/eclipse/hono/pull/2123#discussion_r474244477", "createdAt": "2020-08-20T20:09:46Z", "author": {"login": "calohmn"}, "path": "site/documentation/content/api/management/device-registry-v1.yaml", "diffHunk": "@@ -930,13 +931,19 @@ components:\n          properties:\n             \"mode\":\n                type: string\n-               description: The mode of the data usage caluclation. The supported modes by\n-                            the default resource limit checks implementation are \"days\"\n-                            and \"monthly\".\n+               description: |\n+                 The accounting period mode of recurrence. The following modes are defined:\n+                 * `monthly`: Accounting periods start at 12 AM UTC on the 1st day of each month.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6287c65d75ea67e5e9d9d908a9b36b40a8f36117"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyOTcyMQ==", "bodyText": "Yes, I guess that will make it easier to understand for people from Europe ...", "url": "https://github.com/eclipse/hono/pull/2123#discussion_r474429721", "createdAt": "2020-08-21T06:15:13Z", "author": {"login": "sophokles73"}, "path": "site/documentation/content/api/management/device-registry-v1.yaml", "diffHunk": "@@ -930,13 +931,19 @@ components:\n          properties:\n             \"mode\":\n                type: string\n-               description: The mode of the data usage caluclation. The supported modes by\n-                            the default resource limit checks implementation are \"days\"\n-                            and \"monthly\".\n+               description: |\n+                 The accounting period mode of recurrence. The following modes are defined:\n+                 * `monthly`: Accounting periods start at 12 AM UTC on the 1st day of each month.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDI0NDQ3Nw=="}, "originalCommit": {"oid": "6287c65d75ea67e5e9d9d908a9b36b40a8f36117"}, "originalPosition": 55}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2986, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}