{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5Nzg5MjM2", "number": 2335, "title": "[#2333] Add integration tests", "bodyText": "When no north bound application is connected, the Event messages, which have been sent, are supposed to be queued by the Artemis broker. Once the north bound application connects those queued messages should be delivered. This was not working as\nexpected due to a bug described in the issue #2333. Integration tests are added to test the expected behavior.\nThese newly added tests will fail until the PR #2334 has been merged.", "createdAt": "2020-11-30T20:22:31Z", "url": "https://github.com/eclipse/hono/pull/2335", "merged": true, "mergeCommit": {"oid": "dc8011677f8e7d7861b21628f6553ac8a951f1d1"}, "closed": true, "closedAt": "2020-12-01T15:29:39Z", "author": {"login": "kaniyan"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdh1BDHgFqTU0MTU1NDQ1Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdh7K8GgFqTU0MTk3ODU5NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNTU0NDU3", "url": "https://github.com/eclipse/hono/pull/2335#pullrequestreview-541554457", "createdAt": "2020-12-01T07:40:05Z", "commit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNzo0MDowNVrOH8bfmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNzo0MTo1MVrOH8bi3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNzA2NA==", "bodyText": "how about using a checkpoint here instead and simply relying on the test timeout instead of setting another vert.x timer to wait for the message to arrive?", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533127064", "createdAt": "2020-12-01T07:40:05Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {\n+                        log.info(\"opening event consumer for tenant [{}]\", tenantId);\n+                        createConsumer(tenantId, msg -> receivedMessageCount.incrementAndGet())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNzMyMg==", "bodyText": "why do you need to set a timer here?", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533127322", "createdAt": "2020-12-01T07:40:35Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNzkwMg==", "bodyText": "instead of verifying the number of messages here I'd rather assert a particular property of the message that has been sent in the consumer itself, before flagging the checkpoint ...", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533127902", "createdAt": "2020-12-01T07:41:51Z", "author": {"login": "sophokles73"}, "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {\n+                        log.info(\"opening event consumer for tenant [{}]\", tenantId);\n+                        createConsumer(tenantId, msg -> receivedMessageCount.incrementAndGet())\n+                                .onComplete(consumerCreated);\n+                    });\n+                    return consumerCreated.future();\n+                })\n+                .compose(consumer -> {\n+                    final Promise<Void> done = Promise.promise();\n+                    vertx.setTimer(1000, tid -> {\n+                        //THEN verify if the message is received by the consumer\n+                        assertThat(receivedMessageCount.get()).isEqualTo(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNTUyMjgx", "url": "https://github.com/eclipse/hono/pull/2335#pullrequestreview-541552281", "createdAt": "2020-12-01T07:36:14Z", "commit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNzozNjoxNVrOH8bY0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNzo0NDoxMVrOH8bnAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNTMyOQ==", "bodyText": "\"... receive this event message\"", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533125329", "createdAt": "2020-12-01T07:36:15Z", "author": {"login": "calohmn"}, "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyNjc1MA==", "bodyText": "Is it necessary to wait 4s here? I would have guessed at most 200ms should be enough here, if waiting at all.", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533126750", "createdAt": "2020-12-01T07:39:21Z", "author": {"login": "calohmn"}, "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzEyODk2Mw==", "bodyText": "Instead of waiting a second, how about finishing the test in the consumer message handler, and making sure there is a timeout for the whole test method execution?", "url": "https://github.com/eclipse/hono/pull/2335#discussion_r533128963", "createdAt": "2020-12-01T07:44:11Z", "author": {"login": "calohmn"}, "path": "tests/src/test/java/org/eclipse/hono/tests/amqp/EventAmqpIT.java", "diffHunk": "@@ -56,4 +65,65 @@ protected void assertAdditionalMessageProperties(final VertxTestContext ctx, fin\n             assertThat(msg.isDurable()).isTrue();\n         });\n     }\n+\n+    /**\n+     * Verifies that an event message from a device has been successfully sent and a north bound application, \n+     * which connects after the event has been sent, can successfully receive those event message.\n+     *\n+     * @param ctx The vert.x test context.\n+     * @throws InterruptedException if test execution gets interrupted.\n+     */\n+    @Test\n+    public void testEventMessageAlreadySentIsDeliveredWhenConsumerConnects(final VertxTestContext ctx)\n+            throws InterruptedException {\n+        final VertxTestContext setup = new VertxTestContext();\n+        final String tenantId = helper.getRandomTenantId();\n+        final String deviceId = helper.getRandomDeviceId(tenantId);\n+\n+        setupProtocolAdapter(tenantId, deviceId, ProtonQoS.AT_LEAST_ONCE, false)\n+                .map(s -> sender = s)\n+                .onComplete(setup.completing());\n+\n+        assertThat(setup.awaitCompletion(5, TimeUnit.SECONDS)).isTrue();\n+        if (setup.failed()) {\n+            ctx.failNow(setup.causeOfFailure());\n+            return;\n+        }\n+\n+        // WHEN a device that belongs to the tenant publishes an event\n+        final AtomicInteger receivedMessageCount = new AtomicInteger(0);\n+        final Message event = ProtonHelper.message();\n+        MessageHelper.setPayload(event, \"opaque/binary\", Buffer.buffer(\"hello\"));\n+        event.setAddress(getEndpointName());\n+        final Promise<?> sendingComplete = Promise.promise();\n+        sender.send(event, delivery -> {\n+            if (Accepted.class.isInstance(delivery.getRemoteState())) {\n+                sendingComplete.complete();\n+            } else {\n+                sendingComplete.fail(AmqpErrorException.from(delivery.getRemoteState()));\n+            }\n+        });\n+\n+        sendingComplete\n+                .future()\n+                .compose(eventSent -> {\n+                    //THEN create a consumer once the event message has been successfully sent\n+                    final Promise<MessageConsumer> consumerCreated = Promise.promise();\n+                    vertx.setTimer(4000, tid -> {\n+                        log.info(\"opening event consumer for tenant [{}]\", tenantId);\n+                        createConsumer(tenantId, msg -> receivedMessageCount.incrementAndGet())\n+                                .onComplete(consumerCreated);\n+                    });\n+                    return consumerCreated.future();\n+                })\n+                .compose(consumer -> {\n+                    final Promise<Void> done = Promise.promise();\n+                    vertx.setTimer(1000, tid -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb"}, "originalPosition": 90}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64314766a60bab68c540e74aa57b7eb57eb8d794", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/64314766a60bab68c540e74aa57b7eb57eb8d794", "committedDate": "2020-12-01T13:38:48Z", "message": "[#2333] Add integration tests\n\n Event messages are supposed to be queued by the Artemis broker when no north bound application is connected.\n Once the north bound application connects those queued messages should be delivered. This was not working as\n expected due to a bug described in the issue #2333. Integration tests are added to test the expected behavior.\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cb2dd41e92e53d6d54e3d73a62a8f403a1cd2fe", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/9cb2dd41e92e53d6d54e3d73a62a8f403a1cd2fe", "committedDate": "2020-12-01T13:38:48Z", "message": "Rewrite tests and incorporate review comments\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a61856a68e92bc5dab99d98d52a5b9f65d9f45fb", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/a61856a68e92bc5dab99d98d52a5b9f65d9f45fb", "committedDate": "2020-11-30T20:20:14Z", "message": "[#2333] Add integration tests\n\n Event messages are supposed to be queued by the Artemis broker when no north bound application is connected.\n Once the north bound application connects those queued messages should be delivered. This was not working as\n expected due to a bug described in the issue #2333. Integration tests are added to test the expected behavior.\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}, "afterCommit": {"oid": "9cb2dd41e92e53d6d54e3d73a62a8f403a1cd2fe", "author": {"user": {"login": "kaniyan", "name": "Karthees Kalidass"}}, "url": "https://github.com/eclipse/hono/commit/9cb2dd41e92e53d6d54e3d73a62a8f403a1cd2fe", "committedDate": "2020-12-01T13:38:48Z", "message": "Rewrite tests and incorporate review comments\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxOTY3MDA5", "url": "https://github.com/eclipse/hono/pull/2335#pullrequestreview-541967009", "createdAt": "2020-12-01T14:42:05Z", "commit": {"oid": "9cb2dd41e92e53d6d54e3d73a62a8f403a1cd2fe"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxOTc4NTk1", "url": "https://github.com/eclipse/hono/pull/2335#pullrequestreview-541978595", "createdAt": "2020-12-01T14:53:05Z", "commit": {"oid": "9cb2dd41e92e53d6d54e3d73a62a8f403a1cd2fe"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 466, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}