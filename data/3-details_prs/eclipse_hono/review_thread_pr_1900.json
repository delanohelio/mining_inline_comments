{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMjEzNDAy", "number": 1900, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzowMDowN1rODx8HIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoyMzowM1rODx8inA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjkxNjgyOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedRegistrationService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzowMDowN1rOGFsR5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwODoyODo0MlrOGFvNyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyMTU0MQ==", "bodyText": "why not fail the promise with a ClientErrorException(404) here instead of checking for a null result everywhere else?", "url": "https://github.com/eclipse/hono/pull/1900#discussion_r408621541", "createdAt": "2020-04-15T07:00:07Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedRegistrationService.java", "diffHunk": "@@ -196,32 +198,32 @@ public void setConfig(final MongoDbBasedRegistrationConfigProperties config) {\n         return processResolveGroupMembers(tenantId, viaGroups, span);\n     }\n \n-    private JsonObject convertDevice(final String deviceId, final Device payload) {\n-\n-        if (payload == null) {\n-            return null;\n-        }\n-\n-        final JsonObject data = JsonObject.mapFrom(payload);\n-\n-        return new JsonObject()\n-                .put(RegistryManagementConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId)\n-                .put(\"data\", data);\n+    private Future<DeviceDto> findDevice(final String tenantId, final String deviceId) {\n+        return findDeviceDocument(tenantId, deviceId)\n+                .compose(result -> Optional.ofNullable(result)\n+                        .map(ok -> result.mapTo(DeviceDto.class))\n+                        .map(Future::succeededFuture)\n+                        .orElseGet(() -> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Device [%s] not found.\", deviceId)))));\n     }\n \n-    private Future<DeviceDto> findDevice(final String tenantId, final String deviceId) {\n+    private Future<JsonObject> findDeviceDocument(final String tenantId, final String deviceId) {\n         final JsonObject findDeviceQuery = new MongoDbDocumentBuilder()\n                 .withTenantId(tenantId)\n                 .withDeviceId(deviceId)\n                 .document();\n         final Promise<JsonObject> readDevicePromise = Promise.promise();\n         mongoClient.findOne(config.getCollectionName(), findDeviceQuery, null, readDevicePromise);\n-        return readDevicePromise.future()\n-                .compose(result -> Optional.ofNullable(result)\n-                        .map(ok -> result.mapTo(DeviceDto.class))\n-                        .map(Future::succeededFuture)\n-                        .orElseGet(() -> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n-                                String.format(\"Device [%s] not found.\", deviceId)))));\n+        return readDevicePromise.future();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d1df8b3e8d6cfabbb4c7516c059470f7651908c"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2NDk5OA==", "bodyText": "Initially I implemented as in the comment (as below), then I changed it. In this case a recover block is needed and there it need to be checked for the ClientErrorException and create a RegistrationResult based on the status code. I thought in the other approach, by checking for null we could directly create a RegistrationResult with HTTP_NOT_FOUND and this extra check for ClientErrorException could be avoided. That's why I chose the other one. We discuss here about the error case and supposedly it's not the often occurring case, I am fine with both the approaches. I will replace it with the below code.\nreturn findDeviceDocument(deviceKey.getTenantId(), deviceKey.getDeviceId())\n\t\t.map(result -> getRegistrationResult(deviceKey.getDeviceId(),\n\t\t\t\tresult.getJsonObject(MongoDbDeviceRegistryUtils.FIELD_DEVICE)))\n\t\t.recover(error -> {\n\t\t\tlog.error(error.getMessage(), error);\n\t\t\tTracingHelper.logError(span, error.getMessage(), error);\n\t\t\tif (error instanceof ClientErrorException) {\n\t\t\t\treturn Future.succeededFuture(\n\t\t\t\t\t\tRegistrationResult.from(((ClientErrorException) error).getErrorCode()));\n\t\t\t}\n\t\t\treturn Future.succeededFuture(RegistrationResult.from(HttpURLConnection.HTTP_INTERNAL_ERROR));\n\t\t});", "url": "https://github.com/eclipse/hono/pull/1900#discussion_r408664998", "createdAt": "2020-04-15T08:20:54Z", "author": {"login": "kaniyan"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedRegistrationService.java", "diffHunk": "@@ -196,32 +198,32 @@ public void setConfig(final MongoDbBasedRegistrationConfigProperties config) {\n         return processResolveGroupMembers(tenantId, viaGroups, span);\n     }\n \n-    private JsonObject convertDevice(final String deviceId, final Device payload) {\n-\n-        if (payload == null) {\n-            return null;\n-        }\n-\n-        final JsonObject data = JsonObject.mapFrom(payload);\n-\n-        return new JsonObject()\n-                .put(RegistryManagementConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId)\n-                .put(\"data\", data);\n+    private Future<DeviceDto> findDevice(final String tenantId, final String deviceId) {\n+        return findDeviceDocument(tenantId, deviceId)\n+                .compose(result -> Optional.ofNullable(result)\n+                        .map(ok -> result.mapTo(DeviceDto.class))\n+                        .map(Future::succeededFuture)\n+                        .orElseGet(() -> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Device [%s] not found.\", deviceId)))));\n     }\n \n-    private Future<DeviceDto> findDevice(final String tenantId, final String deviceId) {\n+    private Future<JsonObject> findDeviceDocument(final String tenantId, final String deviceId) {\n         final JsonObject findDeviceQuery = new MongoDbDocumentBuilder()\n                 .withTenantId(tenantId)\n                 .withDeviceId(deviceId)\n                 .document();\n         final Promise<JsonObject> readDevicePromise = Promise.promise();\n         mongoClient.findOne(config.getCollectionName(), findDeviceQuery, null, readDevicePromise);\n-        return readDevicePromise.future()\n-                .compose(result -> Optional.ofNullable(result)\n-                        .map(ok -> result.mapTo(DeviceDto.class))\n-                        .map(Future::succeededFuture)\n-                        .orElseGet(() -> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n-                                String.format(\"Device [%s] not found.\", deviceId)))));\n+        return readDevicePromise.future();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyMTU0MQ=="}, "originalCommit": {"oid": "8d1df8b3e8d6cfabbb4c7516c059470f7651908c"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY2OTY0MA==", "bodyText": "No, please keep your code. You seem to have a good reason for doing it the way you do :-)", "url": "https://github.com/eclipse/hono/pull/1900#discussion_r408669640", "createdAt": "2020-04-15T08:28:42Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedRegistrationService.java", "diffHunk": "@@ -196,32 +198,32 @@ public void setConfig(final MongoDbBasedRegistrationConfigProperties config) {\n         return processResolveGroupMembers(tenantId, viaGroups, span);\n     }\n \n-    private JsonObject convertDevice(final String deviceId, final Device payload) {\n-\n-        if (payload == null) {\n-            return null;\n-        }\n-\n-        final JsonObject data = JsonObject.mapFrom(payload);\n-\n-        return new JsonObject()\n-                .put(RegistryManagementConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId)\n-                .put(\"data\", data);\n+    private Future<DeviceDto> findDevice(final String tenantId, final String deviceId) {\n+        return findDeviceDocument(tenantId, deviceId)\n+                .compose(result -> Optional.ofNullable(result)\n+                        .map(ok -> result.mapTo(DeviceDto.class))\n+                        .map(Future::succeededFuture)\n+                        .orElseGet(() -> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Device [%s] not found.\", deviceId)))));\n     }\n \n-    private Future<DeviceDto> findDevice(final String tenantId, final String deviceId) {\n+    private Future<JsonObject> findDeviceDocument(final String tenantId, final String deviceId) {\n         final JsonObject findDeviceQuery = new MongoDbDocumentBuilder()\n                 .withTenantId(tenantId)\n                 .withDeviceId(deviceId)\n                 .document();\n         final Promise<JsonObject> readDevicePromise = Promise.promise();\n         mongoClient.findOne(config.getCollectionName(), findDeviceQuery, null, readDevicePromise);\n-        return readDevicePromise.future()\n-                .compose(result -> Optional.ofNullable(result)\n-                        .map(ok -> result.mapTo(DeviceDto.class))\n-                        .map(Future::succeededFuture)\n-                        .orElseGet(() -> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n-                                String.format(\"Device [%s] not found.\", deviceId)))));\n+        return readDevicePromise.future();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyMTU0MQ=="}, "originalCommit": {"oid": "8d1df8b3e8d6cfabbb4c7516c059470f7651908c"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjkyNjgxOnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzowMzozNlrOGFsX3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzowMzozNlrOGFsX3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyMzA3MA==", "bodyText": "IMHO we don't need this as it seems to be a re-declaration of RegistrationConstants.FIELD_DATA, isn't it?", "url": "https://github.com/eclipse/hono/pull/1900#discussion_r408623070", "createdAt": "2020-04-15T07:03:36Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "diffHunk": "@@ -35,6 +35,14 @@\n  */\n public final class MongoDbDeviceRegistryUtils {\n \n+    /**\n+     * The name of the JSON property containing the device identifier.\n+     */\n+    public static final String FIELD_DEVICE = \"device\";\n+    /**\n+     * The name of the JSON property containing the data.\n+     */\n+    public static final String FIELD_DATA = \"data\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d1df8b3e8d6cfabbb4c7516c059470f7651908c"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjk2MDM5OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedRegistrationService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoxNDozM1rOGFssXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoxNDozM1rOGFssXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyODMxOQ==", "bodyText": "IMHO this should be RegistrationConstants.FIELD_DATA", "url": "https://github.com/eclipse/hono/pull/1900#discussion_r408628319", "createdAt": "2020-04-15T07:14:33Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedRegistrationService.java", "diffHunk": "@@ -196,32 +198,32 @@ public void setConfig(final MongoDbBasedRegistrationConfigProperties config) {\n         return processResolveGroupMembers(tenantId, viaGroups, span);\n     }\n \n-    private JsonObject convertDevice(final String deviceId, final Device payload) {\n-\n-        if (payload == null) {\n-            return null;\n-        }\n-\n-        final JsonObject data = JsonObject.mapFrom(payload);\n-\n-        return new JsonObject()\n-                .put(RegistryManagementConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId)\n-                .put(\"data\", data);\n+    private Future<DeviceDto> findDevice(final String tenantId, final String deviceId) {\n+        return findDeviceDocument(tenantId, deviceId)\n+                .compose(result -> Optional.ofNullable(result)\n+                        .map(ok -> result.mapTo(DeviceDto.class))\n+                        .map(Future::succeededFuture)\n+                        .orElseGet(() -> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Device [%s] not found.\", deviceId)))));\n     }\n \n-    private Future<DeviceDto> findDevice(final String tenantId, final String deviceId) {\n+    private Future<JsonObject> findDeviceDocument(final String tenantId, final String deviceId) {\n         final JsonObject findDeviceQuery = new MongoDbDocumentBuilder()\n                 .withTenantId(tenantId)\n                 .withDeviceId(deviceId)\n                 .document();\n         final Promise<JsonObject> readDevicePromise = Promise.promise();\n         mongoClient.findOne(config.getCollectionName(), findDeviceQuery, null, readDevicePromise);\n-        return readDevicePromise.future()\n-                .compose(result -> Optional.ofNullable(result)\n-                        .map(ok -> result.mapTo(DeviceDto.class))\n-                        .map(Future::succeededFuture)\n-                        .orElseGet(() -> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n-                                String.format(\"Device [%s] not found.\", deviceId)))));\n+        return readDevicePromise.future();\n+    }\n+\n+    private RegistrationResult getRegistrationResult(final String deviceId, final JsonObject devicePayload) {\n+        return RegistrationResult.from(HttpURLConnection.HTTP_OK,\n+                Optional.ofNullable(devicePayload)\n+                        .map(ok -> new JsonObject()\n+                                .put(RegistryManagementConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId)\n+                                .put(MongoDbDeviceRegistryUtils.FIELD_DATA, devicePayload))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d1df8b3e8d6cfabbb4c7516c059470f7651908c"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjk2Mzc1OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoxNTo0MlrOGFsucQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoxNTo0MlrOGFsucQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyODg0OQ==", "bodyText": "is this field really used for the device identifier? Or is it used for the device data itself?", "url": "https://github.com/eclipse/hono/pull/1900#discussion_r408628849", "createdAt": "2020-04-15T07:15:42Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/utils/MongoDbDeviceRegistryUtils.java", "diffHunk": "@@ -35,6 +35,14 @@\n  */\n public final class MongoDbDeviceRegistryUtils {\n \n+    /**\n+     * The name of the JSON property containing the device identifier.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d1df8b3e8d6cfabbb4c7516c059470f7651908c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjk4NzE2OnYy", "diffSide": "RIGHT", "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedRegistrationService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoyMzowM1rOGFs9MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNzoyMzowM1rOGFs9MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzMjYyNQ==", "bodyText": "IMHO this should be RegistrationConstants.FIELD_PAYLOAD_DEVICE_ID as the result being prepared here is defined by the Device Registration API", "url": "https://github.com/eclipse/hono/pull/1900#discussion_r408632625", "createdAt": "2020-04-15T07:23:03Z", "author": {"login": "sophokles73"}, "path": "services/device-registry-mongodb/src/main/java/org/eclipse/hono/deviceregistry/mongodb/service/MongoDbBasedRegistrationService.java", "diffHunk": "@@ -196,32 +198,32 @@ public void setConfig(final MongoDbBasedRegistrationConfigProperties config) {\n         return processResolveGroupMembers(tenantId, viaGroups, span);\n     }\n \n-    private JsonObject convertDevice(final String deviceId, final Device payload) {\n-\n-        if (payload == null) {\n-            return null;\n-        }\n-\n-        final JsonObject data = JsonObject.mapFrom(payload);\n-\n-        return new JsonObject()\n-                .put(RegistryManagementConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId)\n-                .put(\"data\", data);\n+    private Future<DeviceDto> findDevice(final String tenantId, final String deviceId) {\n+        return findDeviceDocument(tenantId, deviceId)\n+                .compose(result -> Optional.ofNullable(result)\n+                        .map(ok -> result.mapTo(DeviceDto.class))\n+                        .map(Future::succeededFuture)\n+                        .orElseGet(() -> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n+                                String.format(\"Device [%s] not found.\", deviceId)))));\n     }\n \n-    private Future<DeviceDto> findDevice(final String tenantId, final String deviceId) {\n+    private Future<JsonObject> findDeviceDocument(final String tenantId, final String deviceId) {\n         final JsonObject findDeviceQuery = new MongoDbDocumentBuilder()\n                 .withTenantId(tenantId)\n                 .withDeviceId(deviceId)\n                 .document();\n         final Promise<JsonObject> readDevicePromise = Promise.promise();\n         mongoClient.findOne(config.getCollectionName(), findDeviceQuery, null, readDevicePromise);\n-        return readDevicePromise.future()\n-                .compose(result -> Optional.ofNullable(result)\n-                        .map(ok -> result.mapTo(DeviceDto.class))\n-                        .map(Future::succeededFuture)\n-                        .orElseGet(() -> Future.failedFuture(new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND,\n-                                String.format(\"Device [%s] not found.\", deviceId)))));\n+        return readDevicePromise.future();\n+    }\n+\n+    private RegistrationResult getRegistrationResult(final String deviceId, final JsonObject devicePayload) {\n+        return RegistrationResult.from(HttpURLConnection.HTTP_OK,\n+                Optional.ofNullable(devicePayload)\n+                        .map(ok -> new JsonObject()\n+                                .put(RegistryManagementConstants.FIELD_PAYLOAD_DEVICE_ID, deviceId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d1df8b3e8d6cfabbb4c7516c059470f7651908c"}, "originalPosition": 60}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3346, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}