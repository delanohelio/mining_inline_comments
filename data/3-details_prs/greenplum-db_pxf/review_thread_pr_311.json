{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzNzM1NDc5", "number": 311, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxODozNToyOVrODmznyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxODo1Njo0NVrODm0HfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMDE4MjQ4OnYy", "diffSide": "RIGHT", "path": "server/pxf-jdbc/src/main/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePlugin.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxODozNToyOVrOF0b-FQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMToxNzoxMFrOF0hXpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyODUzMw==", "bodyText": "this file has formatting issues. Can you fix it before reviewing?", "url": "https://github.com/greenplum-db/pxf/pull/311#discussion_r390528533", "createdAt": "2020-03-10T18:35:29Z", "author": {"login": "frankgh"}, "path": "server/pxf-jdbc/src/main/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePlugin.java", "diffHunk": "@@ -1,582 +1,584 @@\n-package org.greenplum.pxf.plugins.jdbc;\r\n-\r\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.hadoop.conf.Configuration;\r\n-import org.greenplum.pxf.api.model.BasePlugin;\r\n-import org.greenplum.pxf.api.model.RequestContext;\r\n-import org.greenplum.pxf.api.security.SecureLogin;\r\n-import org.greenplum.pxf.api.utilities.ColumnDescriptor;\r\n-import org.greenplum.pxf.api.utilities.Utilities;\r\n-import org.greenplum.pxf.plugins.jdbc.utils.ConnectionManager;\r\n-import org.greenplum.pxf.plugins.jdbc.utils.DbProduct;\r\n-import org.greenplum.pxf.plugins.jdbc.utils.HiveJdbcUtils;\r\n-import org.slf4j.Logger;\r\n-import org.slf4j.LoggerFactory;\r\n-\r\n-import java.security.PrivilegedExceptionAction;\r\n-import java.sql.Connection;\r\n-import java.sql.DatabaseMetaData;\r\n-import java.sql.PreparedStatement;\r\n-import java.sql.SQLException;\r\n-import java.sql.Statement;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Properties;\r\n-import java.util.stream.Collectors;\r\n-\r\n-import static org.greenplum.pxf.api.security.SecureLogin.CONFIG_KEY_SERVICE_USER_IMPERSONATION;\r\n-\r\n-/**\r\n- * JDBC tables plugin (base class)\r\n- * <p>\r\n- * Implemented subclasses: {@link JdbcAccessor}, {@link JdbcResolver}.\r\n- */\r\n-public class JdbcBasePlugin extends BasePlugin {\r\n-\r\n-    private static final Logger LOG = LoggerFactory.getLogger(JdbcBasePlugin.class);\r\n-\r\n-    // '100' is a recommended value: https://docs.oracle.com/cd/E11882_01/java.112/e16548/oraperf.htm#JJDBC28754\r\n-    private static final int DEFAULT_BATCH_SIZE = 100;\r\n-    private static final int DEFAULT_FETCH_SIZE = 1000;\r\n-    private static final int DEFAULT_POOL_SIZE = 1;\r\n-\r\n-    // configuration parameter names\r\n-    private static final String JDBC_DRIVER_PROPERTY_NAME = \"jdbc.driver\";\r\n-    private static final String JDBC_URL_PROPERTY_NAME = \"jdbc.url\";\r\n-    private static final String JDBC_USER_PROPERTY_NAME = \"jdbc.user\";\r\n-    private static final String JDBC_PASSWORD_PROPERTY_NAME = \"jdbc.password\";\r\n-    private static final String JDBC_SESSION_PROPERTY_PREFIX = \"jdbc.session.property.\";\r\n-    private static final String JDBC_CONNECTION_PROPERTY_PREFIX = \"jdbc.connection.property.\";\r\n-\r\n-    // connection parameter names\r\n-    private static final String JDBC_CONNECTION_TRANSACTION_ISOLATION = \"jdbc.connection.transactionIsolation\";\r\n-\r\n-    // statement properties\r\n-    private static final String JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME = \"jdbc.statement.batchSize\";\r\n-    private static final String JDBC_STATEMENT_FETCH_SIZE_PROPERTY_NAME = \"jdbc.statement.fetchSize\";\r\n-    private static final String JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME = \"jdbc.statement.queryTimeout\";\r\n-\r\n-    // connection pool properties\r\n-    private static final String JDBC_CONNECTION_POOL_ENABLED_PROPERTY_NAME = \"jdbc.pool.enabled\";\r\n-    private static final String JDBC_CONNECTION_POOL_PROPERTY_PREFIX = \"jdbc.pool.property.\";\r\n-    private static final String JDBC_POOL_QUALIFIER_PROPERTY_NAME = \"jdbc.pool.qualifier\";\r\n-\r\n-    // DDL option names\r\n-    private static final String JDBC_DRIVER_OPTION_NAME = \"JDBC_DRIVER\";\r\n-    private static final String JDBC_URL_OPTION_NAME = \"DB_URL\";\r\n-\r\n-    private static final String FORBIDDEN_SESSION_PROPERTY_CHARACTERS = \";\\n\\b\\0\";\r\n-    private static final String QUERY_NAME_PREFIX = \"query:\";\r\n-    private static final int QUERY_NAME_PREFIX_LENGTH = QUERY_NAME_PREFIX.length();\r\n-\r\n-    private static final String HIVE_URL_PREFIX = \"jdbc:hive2://\";\r\n-    private static final String HIVE_DEFAULT_DRIVER_CLASS = \"org.apache.hive.jdbc.HiveDriver\";\r\n-\r\n-    private enum TransactionIsolation {\r\n-        READ_UNCOMMITTED(1),\r\n-        READ_COMMITTED(2),\r\n-        REPEATABLE_READ(4),\r\n-        SERIALIZABLE(8),\r\n-        NOT_PROVIDED(-1);\r\n-\r\n-        private int isolationLevel;\r\n-\r\n-        TransactionIsolation(int transactionIsolation) {\r\n-            isolationLevel = transactionIsolation;\r\n-        }\r\n-\r\n-        public int getLevel() {\r\n-            return isolationLevel;\r\n-        }\r\n-\r\n-        public static TransactionIsolation typeOf(String str) {\r\n-            return valueOf(str);\r\n-        }\r\n-    }\r\n-\r\n-    // JDBC parameters from config file or specified in DDL\r\n-\r\n-    private String jdbcUrl;\r\n-\r\n-    protected String tableName;\r\n-\r\n-    // Write batch size\r\n-    protected int batchSize;\r\n-    protected boolean batchSizeIsSetByUser = false;\r\n-\r\n-    // Read batch size\r\n-    protected int fetchSize;\r\n-\r\n-    // Thread pool size\r\n-    protected int poolSize;\r\n-\r\n-    // Query timeout.\r\n-    protected Integer queryTimeout;\r\n-\r\n-    // Quote columns setting set by user (three values are possible)\r\n-    protected Boolean quoteColumns = null;\r\n-\r\n-    // Environment variables to SET before query execution\r\n-    protected Map<String, String> sessionConfiguration = new HashMap<String, String>();\r\n-\r\n-    // Properties object to pass to JDBC Driver when connection is created\r\n-    protected Properties connectionConfiguration = new Properties();\r\n-\r\n-    // Transaction isolation level that a user can configure\r\n-    private TransactionIsolation transactionIsolation = TransactionIsolation.NOT_PROVIDED;\r\n-\r\n-    // Columns description\r\n-    protected List<ColumnDescriptor> columns = null;\r\n-\r\n-    // Name of query to execute for read flow (optional)\r\n-    protected String queryName;\r\n-\r\n-    // connection pool fields\r\n-    private boolean isConnectionPoolUsed;\r\n-    private Properties poolConfiguration;\r\n-    private String poolQualifier;\r\n-\r\n-    private ConnectionManager connectionManager;\r\n-\r\n-    static {\r\n-        // Deprecated as of Oct 22, 2019 in version 5.9.2+\r\n-        Configuration.addDeprecation(\"pxf.impersonation.jdbc\",\r\n-                CONFIG_KEY_SERVICE_USER_IMPERSONATION,\r\n-                \"The property \\\"pxf.impersonation.jdbc\\\" has been deprecated in favor of \\\"pxf.service.user.impersonation\\\".\");\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a new instance with default (singleton) instance of ConnectionManager.\r\n-     */\r\n-    public JdbcBasePlugin() {\r\n-        this(ConnectionManager.getInstance());\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a new instance with the given ConnectionManager.\r\n-     *\r\n-     * @param connectionManager connection manager instance\r\n-     */\r\n-    JdbcBasePlugin(ConnectionManager connectionManager) {\r\n-        this.connectionManager = connectionManager;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void initialize(RequestContext context) {\r\n-        super.initialize(context);\r\n-\r\n-        // Required parameter. Can be auto-overwritten by user options\r\n-        String jdbcDriver = configuration.get(JDBC_DRIVER_PROPERTY_NAME);\r\n-        assertMandatoryParameter(jdbcDriver, JDBC_DRIVER_PROPERTY_NAME, JDBC_DRIVER_OPTION_NAME);\r\n-        try {\r\n-            LOG.debug(\"JDBC driver: '{}'\", jdbcDriver);\r\n-            Class.forName(jdbcDriver);\r\n-        } catch (ClassNotFoundException e) {\r\n-            throw new RuntimeException(e);\r\n-        }\r\n-\r\n-        // Required parameter. Can be auto-overwritten by user options\r\n-        jdbcUrl = configuration.get(JDBC_URL_PROPERTY_NAME);\r\n-        assertMandatoryParameter(jdbcUrl, JDBC_URL_PROPERTY_NAME, JDBC_URL_OPTION_NAME);\r\n-\r\n-        // Required metadata\r\n-        String dataSource = context.getDataSource();\r\n-        if (StringUtils.isBlank(dataSource)) {\r\n-            throw new IllegalArgumentException(\"Data source must be provided\");\r\n-        }\r\n-\r\n-        // Determine if the datasource is a table name or a query name\r\n-        if (dataSource.startsWith(QUERY_NAME_PREFIX)) {\r\n-            queryName = dataSource.substring(QUERY_NAME_PREFIX_LENGTH);\r\n-            if (StringUtils.isBlank(queryName)) {\r\n-                throw new IllegalArgumentException(String.format(\"Query name is not provided in data source [%s]\", dataSource));\r\n-            }\r\n-            LOG.debug(\"Query name is {}\", queryName);\r\n-        } else {\r\n-            tableName = dataSource;\r\n-            LOG.debug(\"Table name is {}\", tableName);\r\n-        }\r\n-\r\n-        // Required metadata\r\n-        columns = context.getTupleDescription();\r\n-\r\n-        // Optional parameters\r\n-        batchSizeIsSetByUser = configuration.get(JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME) != null;\r\n-        batchSize = configuration.getInt(JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME, DEFAULT_BATCH_SIZE);\r\n-\r\n-        if (batchSize == 0) {\r\n-            batchSize = 1; // if user set to 0, it is the same as batchSize of 1\r\n-        } else if (batchSize < 0) {\r\n-            throw new IllegalArgumentException(String.format(\r\n-                    \"Property %s has incorrect value %s : must be a non-negative integer\", JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME, batchSize));\r\n-        }\r\n-\r\n-        fetchSize = configuration.getInt(JDBC_STATEMENT_FETCH_SIZE_PROPERTY_NAME, DEFAULT_FETCH_SIZE);\r\n-\r\n-        poolSize = context.getOption(\"POOL_SIZE\", DEFAULT_POOL_SIZE);\r\n-\r\n-        String queryTimeoutString = configuration.get(JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME);\r\n-        if (StringUtils.isNotBlank(queryTimeoutString)) {\r\n-            try {\r\n-                queryTimeout = Integer.parseUnsignedInt(queryTimeoutString);\r\n-            } catch (NumberFormatException e) {\r\n-                throw new IllegalArgumentException(String.format(\r\n-                        \"Property %s has incorrect value %s : must be a non-negative integer\",\r\n-                        JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME, queryTimeoutString), e);\r\n-            }\r\n-        }\r\n-\r\n-        // Optional parameter. The default value is null\r\n-        String quoteColumnsRaw = context.getOption(\"QUOTE_COLUMNS\");\r\n-        if (quoteColumnsRaw != null) {\r\n-            quoteColumns = Boolean.parseBoolean(quoteColumnsRaw);\r\n-        }\r\n-\r\n-        // Optional parameter. The default value is empty map\r\n-        sessionConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_SESSION_PROPERTY_PREFIX));\r\n-        // Check forbidden symbols\r\n-        // Note: PreparedStatement enables us to skip this check: its values are distinct from its SQL code\r\n-        // However, SET queries cannot be executed this way. This is why we do this check\r\n-        if (sessionConfiguration.entrySet().stream()\r\n-                .anyMatch(\r\n-                        entry ->\r\n-                                StringUtils.containsAny(\r\n-                                        entry.getKey(), FORBIDDEN_SESSION_PROPERTY_CHARACTERS\r\n-                                ) ||\r\n-                                        StringUtils.containsAny(\r\n-                                                entry.getValue(), FORBIDDEN_SESSION_PROPERTY_CHARACTERS\r\n-                                        )\r\n-                )\r\n-        ) {\r\n-            throw new IllegalArgumentException(\"Some session configuration parameter contains forbidden characters\");\r\n-        }\r\n-        if (LOG.isDebugEnabled()) {\r\n-            LOG.debug(\"Session configuration: {}\",\r\n-                    sessionConfiguration.entrySet().stream()\r\n-                            .map(entry -> \"'\" + entry.getKey() + \"'='\" + entry.getValue() + \"'\")\r\n-                            .collect(Collectors.joining(\", \"))\r\n-            );\r\n-        }\r\n-\r\n-        // Optional parameter. The default value is empty map\r\n-        connectionConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_CONNECTION_PROPERTY_PREFIX));\r\n-\r\n-        // Optional parameter. The default value depends on the database\r\n-        String transactionIsolationString = configuration.get(JDBC_CONNECTION_TRANSACTION_ISOLATION, \"NOT_PROVIDED\");\r\n-        transactionIsolation = TransactionIsolation.typeOf(transactionIsolationString);\r\n-\r\n-        // Set optional user parameter, taking into account impersonation setting for the server.\r\n-        String jdbcUser = configuration.get(JDBC_USER_PROPERTY_NAME);\r\n-        boolean impersonationEnabledForServer = configuration.getBoolean(CONFIG_KEY_SERVICE_USER_IMPERSONATION, false);\r\n-        LOG.debug(\"JDBC impersonation is {}enabled for server {}\", impersonationEnabledForServer ? \"\" : \"not \", context.getServerName());\r\n-        if (impersonationEnabledForServer) {\r\n-            if (Utilities.isSecurityEnabled(configuration) && StringUtils.startsWith(jdbcUrl, HIVE_URL_PREFIX)) {\r\n-                // secure impersonation for Hive JDBC driver requires setting URL fragment that cannot be overwritten by properties\r\n-                String updatedJdbcUrl = HiveJdbcUtils.updateImpersonationPropertyInHiveJdbcUrl(jdbcUrl, context.getUser());\r\n-                LOG.debug(\"Replaced JDBC URL {} with {}\", jdbcUrl, updatedJdbcUrl);\r\n-                jdbcUrl = updatedJdbcUrl;\r\n-            } else {\r\n-                // the jdbcUser is the GPDB user\r\n-                jdbcUser = context.getUser();\r\n-            }\r\n-        }\r\n-        if (jdbcUser != null) {\r\n-            LOG.debug(\"Effective JDBC user {}\", jdbcUser);\r\n-            connectionConfiguration.setProperty(\"user\", jdbcUser);\r\n-        } else {\r\n-            LOG.debug(\"JDBC user has not been set\");\r\n-        }\r\n-\r\n-        if (LOG.isDebugEnabled()) {\r\n-            LOG.debug(\"Connection configuration: {}\",\r\n-                    connectionConfiguration.entrySet().stream()\r\n-                            .map(entry -> \"'\" + entry.getKey() + \"'='\" + entry.getValue() + \"'\")\r\n-                            .collect(Collectors.joining(\", \"))\r\n-            );\r\n-        }\r\n-\r\n-        // This must be the last parameter parsed, as we output connectionConfiguration earlier\r\n-        // Optional parameter. By default, corresponding connectionConfiguration property is not set\r\n-        if (jdbcUser != null) {\r\n-            String jdbcPassword = configuration.get(JDBC_PASSWORD_PROPERTY_NAME);\r\n-            if (jdbcPassword != null) {\r\n-                LOG.debug(\"Connection password: {}\", ConnectionManager.maskPassword(jdbcPassword));\r\n-                connectionConfiguration.setProperty(\"password\", jdbcPassword);\r\n-            }\r\n-        }\r\n-\r\n-        // connection pool is optional, enabled by default\r\n-        isConnectionPoolUsed = configuration.getBoolean(JDBC_CONNECTION_POOL_ENABLED_PROPERTY_NAME, true);\r\n-        LOG.debug(\"Connection pool is {}enabled\", isConnectionPoolUsed ? \"\" : \"not \");\r\n-        if (isConnectionPoolUsed) {\r\n-            poolConfiguration = new Properties();\r\n-            // for PXF upgrades where jdbc-site template has not been updated, make sure there're sensible defaults\r\n-            poolConfiguration.setProperty(\"maximumPoolSize\", \"5\");\r\n-            poolConfiguration.setProperty(\"connectionTimeout\", \"30000\");\r\n-            poolConfiguration.setProperty(\"idleTimeout\", \"30000\");\r\n-            poolConfiguration.setProperty(\"minimumIdle\", \"0\");\r\n-            // apply values read from the template\r\n-            poolConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_CONNECTION_POOL_PROPERTY_PREFIX));\r\n-\r\n-            // packaged Hive JDBC Driver does not support connection.isValid() method, so we need to force set\r\n-            // connectionTestQuery parameter in this case, unless already set by the user\r\n-            if (jdbcUrl.startsWith(HIVE_URL_PREFIX) && HIVE_DEFAULT_DRIVER_CLASS.equals(jdbcDriver) && poolConfiguration.getProperty(\"connectionTestQuery\") == null) {\r\n-                poolConfiguration.setProperty(\"connectionTestQuery\", \"SELECT 1\");\r\n-            }\r\n-\r\n-            // get the qualifier for connection pool, if configured. Might be used when connection session authorization is employed\r\n-            // to switch effective user once connection is established\r\n-            poolQualifier = configuration.get(JDBC_POOL_QUALIFIER_PROPERTY_NAME);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Open a new JDBC connection\r\n-     *\r\n-     * @return {@link Connection}\r\n-     * @throws SQLException if a database access or connection error occurs\r\n-     */\r\n-    public Connection getConnection() throws SQLException {\r\n-        LOG.debug(\"Requesting a new JDBC connection. URL={} table={} txid:seg={}:{}\", jdbcUrl, tableName, context.getTransactionId(), context.getSegmentId());\r\n-\r\n-        Connection connection = null;\r\n-        try {\r\n-            connection = getConnectionInternal();\r\n-            LOG.debug(\"Obtained a JDBC connection {} for URL={} table={} txid:seg={}:{}\", connection, jdbcUrl, tableName, context.getTransactionId(), context.getSegmentId());\r\n-\r\n-            prepareConnection(connection);\r\n-        } catch (Exception e) {\r\n-            closeConnection(connection);\r\n-            if (e instanceof SQLException) {\r\n-                throw (SQLException) e;\r\n-            } else {\r\n-                String msg = e.getMessage();\r\n-                if (msg == null) {\r\n-                    Throwable t = e.getCause();\r\n-                    if (t != null) msg = t.getMessage();\r\n-                }\r\n-                throw new SQLException(msg, e);\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    /**\r\n-     * Prepare a JDBC PreparedStatement\r\n-     *\r\n-     * @param connection connection to use for creating the statement\r\n-     * @param query      query to execute\r\n-     * @return PreparedStatement\r\n-     * @throws SQLException if a database access error occurs\r\n-     */\r\n-    public PreparedStatement getPreparedStatement(Connection connection, String query) throws SQLException {\r\n-        if ((connection == null) || (query == null)) {\r\n-            throw new IllegalArgumentException(\"The provided query or connection is null\");\r\n-        }\r\n-        PreparedStatement statement = connection.prepareStatement(query);\r\n-        if (queryTimeout != null) {\r\n-            LOG.debug(\"Setting query timeout to {} seconds\", queryTimeout);\r\n-            statement.setQueryTimeout(queryTimeout);\r\n-        }\r\n-        return statement;\r\n-    }\r\n-\r\n-    /**\r\n-     * Close a JDBC statement and underlying {@link Connection}\r\n-     *\r\n-     * @param statement statement to close\r\n-     * @throws SQLException\r\n-     */\r\n-    public static void closeStatementAndConnection(Statement statement) throws SQLException {\r\n-        if (statement == null) {\r\n-            LOG.warn(\"Call to close statement and connection is ignored as statement provided was null\");\r\n-            return;\r\n-        }\r\n-\r\n-        SQLException exception = null;\r\n-        Connection connection = null;\r\n-\r\n-        try {\r\n-            connection = statement.getConnection();\r\n-        } catch (SQLException e) {\r\n-            LOG.error(\"Exception when retrieving Connection from Statement\", e);\r\n-            exception = e;\r\n-        }\r\n-\r\n-        try {\r\n-            LOG.debug(\"Closing statement for connection {}\", connection);\r\n-            statement.close();\r\n-        } catch (SQLException e) {\r\n-            LOG.error(\"Exception when closing Statement\", e);\r\n-            exception = e;\r\n-        }\r\n-\r\n-        try {\r\n-            closeConnection(connection);\r\n-        } catch (SQLException e) {\r\n-            LOG.error(String.format(\"Exception when closing connection %s\", connection), e);\r\n-            exception = e;\r\n-        }\r\n-\r\n-        if (exception != null) {\r\n-            throw exception;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * For a Kerberized Hive JDBC connection, it creates a connection as the loginUser.\r\n-     * Otherwise, it returns a new connection.\r\n-     *\r\n-     * @return for a Kerberized Hive JDBC connection, returns a new connection as the loginUser.\r\n-     * Otherwise, it returns a new connection.\r\n-     * @throws Exception\r\n-     */\r\n-    private Connection getConnectionInternal() throws Exception {\r\n-        if (Utilities.isSecurityEnabled(configuration) && StringUtils.startsWith(jdbcUrl, HIVE_URL_PREFIX)) {\r\n-            return SecureLogin.getInstance().getLoginUser(context, configuration).\r\n-                    doAs((PrivilegedExceptionAction<Connection>) () ->\r\n-                            connectionManager.getConnection(context.getServerName(), jdbcUrl, connectionConfiguration, isConnectionPoolUsed, poolConfiguration, poolQualifier));\r\n-\r\n-        } else {\r\n-            return connectionManager.getConnection(context.getServerName(), jdbcUrl, connectionConfiguration, isConnectionPoolUsed, poolConfiguration, poolQualifier);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Close a JDBC connection\r\n-     *\r\n-     * @param connection connection to close\r\n-     * @throws SQLException\r\n-     */\r\n-    private static void closeConnection(Connection connection) throws SQLException {\r\n-        if (connection == null) {\r\n-            LOG.warn(\"Call to close connection is ignored as connection provided was null\");\r\n-            return;\r\n-        }\r\n-        try {\r\n-            if (!connection.isClosed() &&\r\n-                    connection.getMetaData().supportsTransactions() &&\r\n-                    !connection.getAutoCommit()) {\r\n-\r\n-                LOG.debug(\"Committing transaction (as part of connection.close()) on connection {}\", connection);\r\n-                connection.commit();\r\n-            }\r\n-        } finally {\r\n-            try {\r\n-                LOG.debug(\"Closing connection {}\", connection);\r\n-                connection.close();\r\n-            } catch (Exception e) {\r\n-                // ignore\r\n-                LOG.warn(String.format(\"Failed to close JDBC connection %s, ignoring the error.\", connection), e);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Prepare JDBC connection by setting session-level variables in external database\r\n-     *\r\n-     * @param connection {@link Connection} to prepare\r\n-     */\r\n-    private void prepareConnection(Connection connection) throws SQLException {\r\n-        if (connection == null) {\r\n-            throw new IllegalArgumentException(\"The provided connection is null\");\r\n-        }\r\n-\r\n-        DatabaseMetaData metadata = connection.getMetaData();\r\n-\r\n-        // Handle optional connection transaction isolation level\r\n-        if (transactionIsolation != TransactionIsolation.NOT_PROVIDED) {\r\n-            // user wants to set isolation level explicitly\r\n-            if (metadata.supportsTransactionIsolationLevel(transactionIsolation.getLevel())) {\r\n-                LOG.debug(\"Setting transaction isolation level to {} on connection {}\", transactionIsolation.toString(), connection);\r\n-                connection.setTransactionIsolation(transactionIsolation.getLevel());\r\n-            } else {\r\n-                throw new RuntimeException(\r\n-                        String.format(\"Transaction isolation level %s is not supported\", transactionIsolation.toString())\r\n-                );\r\n-            }\r\n-        }\r\n-\r\n-        // Disable autocommit\r\n-        if (metadata.supportsTransactions()) {\r\n-            LOG.debug(\"Setting autoCommit to false on connection {}\", connection);\r\n-            connection.setAutoCommit(false);\r\n-        }\r\n-\r\n-        // Prepare session (process sessionConfiguration)\r\n-        if (!sessionConfiguration.isEmpty()) {\r\n-            DbProduct dbProduct = DbProduct.getDbProduct(metadata.getDatabaseProductName());\r\n-\r\n-            try (Statement statement = connection.createStatement()) {\r\n-                for (Map.Entry<String, String> e : sessionConfiguration.entrySet()) {\r\n-                    String sessionQuery = dbProduct.buildSessionQuery(e.getKey(), e.getValue());\r\n-                    LOG.debug(\"Executing statement {} on connection {}\", sessionQuery, connection);\r\n-                    statement.execute(sessionQuery);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Asserts whether a given parameter has non-empty value, throws IllegalArgumentException otherwise\r\n-     *\r\n-     * @param value      value to check\r\n-     * @param paramName  parameter name\r\n-     * @param optionName name of the option for a given parameter\r\n-     */\r\n-    private void assertMandatoryParameter(String value, String paramName, String optionName) {\r\n-        if (StringUtils.isBlank(value)) {\r\n-            throw new IllegalArgumentException(String.format(\r\n-                    \"Required parameter %s is missing or empty in jdbc-site.xml and option %s is not specified in table definition.\", paramName, optionName)\r\n-            );\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructs a mapping of configuration and includes all properties that start with the specified\r\n-     * configuration prefix.  Property names in the mapping are trimmed to remove the configuration prefix.\r\n-     * This is a method from Hadoop's Configuration class ported here to make older and custom versions of Hadoop\r\n-     * work with JDBC profile.\r\n-     *\r\n-     * @param configuration configuration map\r\n-     * @param confPrefix    configuration prefix\r\n-     * @return mapping of configuration properties with prefix stripped\r\n-     */\r\n-    private Map<String, String> getPropsWithPrefix(Configuration configuration, String confPrefix) {\r\n-        Map<String, String> configMap = new HashMap<>();\r\n-        Iterator<Map.Entry<String, String>> it = configuration.iterator();\r\n-        while (it.hasNext()) {\r\n-            String propertyName = it.next().getKey();\r\n-            if (propertyName.startsWith(confPrefix)) {\r\n-                // do not use value from the iterator as it might not come with variable substitution\r\n-                String value = configuration.get(propertyName);\r\n-                String keyName = propertyName.substring(confPrefix.length());\r\n-                configMap.put(keyName, value);\r\n-            }\r\n-        }\r\n-        return configMap;\r\n-    }\r\n-\r\n-}\r\n+package org.greenplum.pxf.plugins.jdbc;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "057403a900e5da7a67dda63e9ebdb1e20467f0d6"}, "originalPosition": 583}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU5MzQyMA==", "bodyText": "yes, in the second commit I stripped carriage returns (^M) but the first commit has the changes.", "url": "https://github.com/greenplum-db/pxf/pull/311#discussion_r390593420", "createdAt": "2020-03-10T20:33:00Z", "author": {"login": "oliverralbertini"}, "path": "server/pxf-jdbc/src/main/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePlugin.java", "diffHunk": "@@ -1,582 +1,584 @@\n-package org.greenplum.pxf.plugins.jdbc;\r\n-\r\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.hadoop.conf.Configuration;\r\n-import org.greenplum.pxf.api.model.BasePlugin;\r\n-import org.greenplum.pxf.api.model.RequestContext;\r\n-import org.greenplum.pxf.api.security.SecureLogin;\r\n-import org.greenplum.pxf.api.utilities.ColumnDescriptor;\r\n-import org.greenplum.pxf.api.utilities.Utilities;\r\n-import org.greenplum.pxf.plugins.jdbc.utils.ConnectionManager;\r\n-import org.greenplum.pxf.plugins.jdbc.utils.DbProduct;\r\n-import org.greenplum.pxf.plugins.jdbc.utils.HiveJdbcUtils;\r\n-import org.slf4j.Logger;\r\n-import org.slf4j.LoggerFactory;\r\n-\r\n-import java.security.PrivilegedExceptionAction;\r\n-import java.sql.Connection;\r\n-import java.sql.DatabaseMetaData;\r\n-import java.sql.PreparedStatement;\r\n-import java.sql.SQLException;\r\n-import java.sql.Statement;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Properties;\r\n-import java.util.stream.Collectors;\r\n-\r\n-import static org.greenplum.pxf.api.security.SecureLogin.CONFIG_KEY_SERVICE_USER_IMPERSONATION;\r\n-\r\n-/**\r\n- * JDBC tables plugin (base class)\r\n- * <p>\r\n- * Implemented subclasses: {@link JdbcAccessor}, {@link JdbcResolver}.\r\n- */\r\n-public class JdbcBasePlugin extends BasePlugin {\r\n-\r\n-    private static final Logger LOG = LoggerFactory.getLogger(JdbcBasePlugin.class);\r\n-\r\n-    // '100' is a recommended value: https://docs.oracle.com/cd/E11882_01/java.112/e16548/oraperf.htm#JJDBC28754\r\n-    private static final int DEFAULT_BATCH_SIZE = 100;\r\n-    private static final int DEFAULT_FETCH_SIZE = 1000;\r\n-    private static final int DEFAULT_POOL_SIZE = 1;\r\n-\r\n-    // configuration parameter names\r\n-    private static final String JDBC_DRIVER_PROPERTY_NAME = \"jdbc.driver\";\r\n-    private static final String JDBC_URL_PROPERTY_NAME = \"jdbc.url\";\r\n-    private static final String JDBC_USER_PROPERTY_NAME = \"jdbc.user\";\r\n-    private static final String JDBC_PASSWORD_PROPERTY_NAME = \"jdbc.password\";\r\n-    private static final String JDBC_SESSION_PROPERTY_PREFIX = \"jdbc.session.property.\";\r\n-    private static final String JDBC_CONNECTION_PROPERTY_PREFIX = \"jdbc.connection.property.\";\r\n-\r\n-    // connection parameter names\r\n-    private static final String JDBC_CONNECTION_TRANSACTION_ISOLATION = \"jdbc.connection.transactionIsolation\";\r\n-\r\n-    // statement properties\r\n-    private static final String JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME = \"jdbc.statement.batchSize\";\r\n-    private static final String JDBC_STATEMENT_FETCH_SIZE_PROPERTY_NAME = \"jdbc.statement.fetchSize\";\r\n-    private static final String JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME = \"jdbc.statement.queryTimeout\";\r\n-\r\n-    // connection pool properties\r\n-    private static final String JDBC_CONNECTION_POOL_ENABLED_PROPERTY_NAME = \"jdbc.pool.enabled\";\r\n-    private static final String JDBC_CONNECTION_POOL_PROPERTY_PREFIX = \"jdbc.pool.property.\";\r\n-    private static final String JDBC_POOL_QUALIFIER_PROPERTY_NAME = \"jdbc.pool.qualifier\";\r\n-\r\n-    // DDL option names\r\n-    private static final String JDBC_DRIVER_OPTION_NAME = \"JDBC_DRIVER\";\r\n-    private static final String JDBC_URL_OPTION_NAME = \"DB_URL\";\r\n-\r\n-    private static final String FORBIDDEN_SESSION_PROPERTY_CHARACTERS = \";\\n\\b\\0\";\r\n-    private static final String QUERY_NAME_PREFIX = \"query:\";\r\n-    private static final int QUERY_NAME_PREFIX_LENGTH = QUERY_NAME_PREFIX.length();\r\n-\r\n-    private static final String HIVE_URL_PREFIX = \"jdbc:hive2://\";\r\n-    private static final String HIVE_DEFAULT_DRIVER_CLASS = \"org.apache.hive.jdbc.HiveDriver\";\r\n-\r\n-    private enum TransactionIsolation {\r\n-        READ_UNCOMMITTED(1),\r\n-        READ_COMMITTED(2),\r\n-        REPEATABLE_READ(4),\r\n-        SERIALIZABLE(8),\r\n-        NOT_PROVIDED(-1);\r\n-\r\n-        private int isolationLevel;\r\n-\r\n-        TransactionIsolation(int transactionIsolation) {\r\n-            isolationLevel = transactionIsolation;\r\n-        }\r\n-\r\n-        public int getLevel() {\r\n-            return isolationLevel;\r\n-        }\r\n-\r\n-        public static TransactionIsolation typeOf(String str) {\r\n-            return valueOf(str);\r\n-        }\r\n-    }\r\n-\r\n-    // JDBC parameters from config file or specified in DDL\r\n-\r\n-    private String jdbcUrl;\r\n-\r\n-    protected String tableName;\r\n-\r\n-    // Write batch size\r\n-    protected int batchSize;\r\n-    protected boolean batchSizeIsSetByUser = false;\r\n-\r\n-    // Read batch size\r\n-    protected int fetchSize;\r\n-\r\n-    // Thread pool size\r\n-    protected int poolSize;\r\n-\r\n-    // Query timeout.\r\n-    protected Integer queryTimeout;\r\n-\r\n-    // Quote columns setting set by user (three values are possible)\r\n-    protected Boolean quoteColumns = null;\r\n-\r\n-    // Environment variables to SET before query execution\r\n-    protected Map<String, String> sessionConfiguration = new HashMap<String, String>();\r\n-\r\n-    // Properties object to pass to JDBC Driver when connection is created\r\n-    protected Properties connectionConfiguration = new Properties();\r\n-\r\n-    // Transaction isolation level that a user can configure\r\n-    private TransactionIsolation transactionIsolation = TransactionIsolation.NOT_PROVIDED;\r\n-\r\n-    // Columns description\r\n-    protected List<ColumnDescriptor> columns = null;\r\n-\r\n-    // Name of query to execute for read flow (optional)\r\n-    protected String queryName;\r\n-\r\n-    // connection pool fields\r\n-    private boolean isConnectionPoolUsed;\r\n-    private Properties poolConfiguration;\r\n-    private String poolQualifier;\r\n-\r\n-    private ConnectionManager connectionManager;\r\n-\r\n-    static {\r\n-        // Deprecated as of Oct 22, 2019 in version 5.9.2+\r\n-        Configuration.addDeprecation(\"pxf.impersonation.jdbc\",\r\n-                CONFIG_KEY_SERVICE_USER_IMPERSONATION,\r\n-                \"The property \\\"pxf.impersonation.jdbc\\\" has been deprecated in favor of \\\"pxf.service.user.impersonation\\\".\");\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a new instance with default (singleton) instance of ConnectionManager.\r\n-     */\r\n-    public JdbcBasePlugin() {\r\n-        this(ConnectionManager.getInstance());\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a new instance with the given ConnectionManager.\r\n-     *\r\n-     * @param connectionManager connection manager instance\r\n-     */\r\n-    JdbcBasePlugin(ConnectionManager connectionManager) {\r\n-        this.connectionManager = connectionManager;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void initialize(RequestContext context) {\r\n-        super.initialize(context);\r\n-\r\n-        // Required parameter. Can be auto-overwritten by user options\r\n-        String jdbcDriver = configuration.get(JDBC_DRIVER_PROPERTY_NAME);\r\n-        assertMandatoryParameter(jdbcDriver, JDBC_DRIVER_PROPERTY_NAME, JDBC_DRIVER_OPTION_NAME);\r\n-        try {\r\n-            LOG.debug(\"JDBC driver: '{}'\", jdbcDriver);\r\n-            Class.forName(jdbcDriver);\r\n-        } catch (ClassNotFoundException e) {\r\n-            throw new RuntimeException(e);\r\n-        }\r\n-\r\n-        // Required parameter. Can be auto-overwritten by user options\r\n-        jdbcUrl = configuration.get(JDBC_URL_PROPERTY_NAME);\r\n-        assertMandatoryParameter(jdbcUrl, JDBC_URL_PROPERTY_NAME, JDBC_URL_OPTION_NAME);\r\n-\r\n-        // Required metadata\r\n-        String dataSource = context.getDataSource();\r\n-        if (StringUtils.isBlank(dataSource)) {\r\n-            throw new IllegalArgumentException(\"Data source must be provided\");\r\n-        }\r\n-\r\n-        // Determine if the datasource is a table name or a query name\r\n-        if (dataSource.startsWith(QUERY_NAME_PREFIX)) {\r\n-            queryName = dataSource.substring(QUERY_NAME_PREFIX_LENGTH);\r\n-            if (StringUtils.isBlank(queryName)) {\r\n-                throw new IllegalArgumentException(String.format(\"Query name is not provided in data source [%s]\", dataSource));\r\n-            }\r\n-            LOG.debug(\"Query name is {}\", queryName);\r\n-        } else {\r\n-            tableName = dataSource;\r\n-            LOG.debug(\"Table name is {}\", tableName);\r\n-        }\r\n-\r\n-        // Required metadata\r\n-        columns = context.getTupleDescription();\r\n-\r\n-        // Optional parameters\r\n-        batchSizeIsSetByUser = configuration.get(JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME) != null;\r\n-        batchSize = configuration.getInt(JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME, DEFAULT_BATCH_SIZE);\r\n-\r\n-        if (batchSize == 0) {\r\n-            batchSize = 1; // if user set to 0, it is the same as batchSize of 1\r\n-        } else if (batchSize < 0) {\r\n-            throw new IllegalArgumentException(String.format(\r\n-                    \"Property %s has incorrect value %s : must be a non-negative integer\", JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME, batchSize));\r\n-        }\r\n-\r\n-        fetchSize = configuration.getInt(JDBC_STATEMENT_FETCH_SIZE_PROPERTY_NAME, DEFAULT_FETCH_SIZE);\r\n-\r\n-        poolSize = context.getOption(\"POOL_SIZE\", DEFAULT_POOL_SIZE);\r\n-\r\n-        String queryTimeoutString = configuration.get(JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME);\r\n-        if (StringUtils.isNotBlank(queryTimeoutString)) {\r\n-            try {\r\n-                queryTimeout = Integer.parseUnsignedInt(queryTimeoutString);\r\n-            } catch (NumberFormatException e) {\r\n-                throw new IllegalArgumentException(String.format(\r\n-                        \"Property %s has incorrect value %s : must be a non-negative integer\",\r\n-                        JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME, queryTimeoutString), e);\r\n-            }\r\n-        }\r\n-\r\n-        // Optional parameter. The default value is null\r\n-        String quoteColumnsRaw = context.getOption(\"QUOTE_COLUMNS\");\r\n-        if (quoteColumnsRaw != null) {\r\n-            quoteColumns = Boolean.parseBoolean(quoteColumnsRaw);\r\n-        }\r\n-\r\n-        // Optional parameter. The default value is empty map\r\n-        sessionConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_SESSION_PROPERTY_PREFIX));\r\n-        // Check forbidden symbols\r\n-        // Note: PreparedStatement enables us to skip this check: its values are distinct from its SQL code\r\n-        // However, SET queries cannot be executed this way. This is why we do this check\r\n-        if (sessionConfiguration.entrySet().stream()\r\n-                .anyMatch(\r\n-                        entry ->\r\n-                                StringUtils.containsAny(\r\n-                                        entry.getKey(), FORBIDDEN_SESSION_PROPERTY_CHARACTERS\r\n-                                ) ||\r\n-                                        StringUtils.containsAny(\r\n-                                                entry.getValue(), FORBIDDEN_SESSION_PROPERTY_CHARACTERS\r\n-                                        )\r\n-                )\r\n-        ) {\r\n-            throw new IllegalArgumentException(\"Some session configuration parameter contains forbidden characters\");\r\n-        }\r\n-        if (LOG.isDebugEnabled()) {\r\n-            LOG.debug(\"Session configuration: {}\",\r\n-                    sessionConfiguration.entrySet().stream()\r\n-                            .map(entry -> \"'\" + entry.getKey() + \"'='\" + entry.getValue() + \"'\")\r\n-                            .collect(Collectors.joining(\", \"))\r\n-            );\r\n-        }\r\n-\r\n-        // Optional parameter. The default value is empty map\r\n-        connectionConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_CONNECTION_PROPERTY_PREFIX));\r\n-\r\n-        // Optional parameter. The default value depends on the database\r\n-        String transactionIsolationString = configuration.get(JDBC_CONNECTION_TRANSACTION_ISOLATION, \"NOT_PROVIDED\");\r\n-        transactionIsolation = TransactionIsolation.typeOf(transactionIsolationString);\r\n-\r\n-        // Set optional user parameter, taking into account impersonation setting for the server.\r\n-        String jdbcUser = configuration.get(JDBC_USER_PROPERTY_NAME);\r\n-        boolean impersonationEnabledForServer = configuration.getBoolean(CONFIG_KEY_SERVICE_USER_IMPERSONATION, false);\r\n-        LOG.debug(\"JDBC impersonation is {}enabled for server {}\", impersonationEnabledForServer ? \"\" : \"not \", context.getServerName());\r\n-        if (impersonationEnabledForServer) {\r\n-            if (Utilities.isSecurityEnabled(configuration) && StringUtils.startsWith(jdbcUrl, HIVE_URL_PREFIX)) {\r\n-                // secure impersonation for Hive JDBC driver requires setting URL fragment that cannot be overwritten by properties\r\n-                String updatedJdbcUrl = HiveJdbcUtils.updateImpersonationPropertyInHiveJdbcUrl(jdbcUrl, context.getUser());\r\n-                LOG.debug(\"Replaced JDBC URL {} with {}\", jdbcUrl, updatedJdbcUrl);\r\n-                jdbcUrl = updatedJdbcUrl;\r\n-            } else {\r\n-                // the jdbcUser is the GPDB user\r\n-                jdbcUser = context.getUser();\r\n-            }\r\n-        }\r\n-        if (jdbcUser != null) {\r\n-            LOG.debug(\"Effective JDBC user {}\", jdbcUser);\r\n-            connectionConfiguration.setProperty(\"user\", jdbcUser);\r\n-        } else {\r\n-            LOG.debug(\"JDBC user has not been set\");\r\n-        }\r\n-\r\n-        if (LOG.isDebugEnabled()) {\r\n-            LOG.debug(\"Connection configuration: {}\",\r\n-                    connectionConfiguration.entrySet().stream()\r\n-                            .map(entry -> \"'\" + entry.getKey() + \"'='\" + entry.getValue() + \"'\")\r\n-                            .collect(Collectors.joining(\", \"))\r\n-            );\r\n-        }\r\n-\r\n-        // This must be the last parameter parsed, as we output connectionConfiguration earlier\r\n-        // Optional parameter. By default, corresponding connectionConfiguration property is not set\r\n-        if (jdbcUser != null) {\r\n-            String jdbcPassword = configuration.get(JDBC_PASSWORD_PROPERTY_NAME);\r\n-            if (jdbcPassword != null) {\r\n-                LOG.debug(\"Connection password: {}\", ConnectionManager.maskPassword(jdbcPassword));\r\n-                connectionConfiguration.setProperty(\"password\", jdbcPassword);\r\n-            }\r\n-        }\r\n-\r\n-        // connection pool is optional, enabled by default\r\n-        isConnectionPoolUsed = configuration.getBoolean(JDBC_CONNECTION_POOL_ENABLED_PROPERTY_NAME, true);\r\n-        LOG.debug(\"Connection pool is {}enabled\", isConnectionPoolUsed ? \"\" : \"not \");\r\n-        if (isConnectionPoolUsed) {\r\n-            poolConfiguration = new Properties();\r\n-            // for PXF upgrades where jdbc-site template has not been updated, make sure there're sensible defaults\r\n-            poolConfiguration.setProperty(\"maximumPoolSize\", \"5\");\r\n-            poolConfiguration.setProperty(\"connectionTimeout\", \"30000\");\r\n-            poolConfiguration.setProperty(\"idleTimeout\", \"30000\");\r\n-            poolConfiguration.setProperty(\"minimumIdle\", \"0\");\r\n-            // apply values read from the template\r\n-            poolConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_CONNECTION_POOL_PROPERTY_PREFIX));\r\n-\r\n-            // packaged Hive JDBC Driver does not support connection.isValid() method, so we need to force set\r\n-            // connectionTestQuery parameter in this case, unless already set by the user\r\n-            if (jdbcUrl.startsWith(HIVE_URL_PREFIX) && HIVE_DEFAULT_DRIVER_CLASS.equals(jdbcDriver) && poolConfiguration.getProperty(\"connectionTestQuery\") == null) {\r\n-                poolConfiguration.setProperty(\"connectionTestQuery\", \"SELECT 1\");\r\n-            }\r\n-\r\n-            // get the qualifier for connection pool, if configured. Might be used when connection session authorization is employed\r\n-            // to switch effective user once connection is established\r\n-            poolQualifier = configuration.get(JDBC_POOL_QUALIFIER_PROPERTY_NAME);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Open a new JDBC connection\r\n-     *\r\n-     * @return {@link Connection}\r\n-     * @throws SQLException if a database access or connection error occurs\r\n-     */\r\n-    public Connection getConnection() throws SQLException {\r\n-        LOG.debug(\"Requesting a new JDBC connection. URL={} table={} txid:seg={}:{}\", jdbcUrl, tableName, context.getTransactionId(), context.getSegmentId());\r\n-\r\n-        Connection connection = null;\r\n-        try {\r\n-            connection = getConnectionInternal();\r\n-            LOG.debug(\"Obtained a JDBC connection {} for URL={} table={} txid:seg={}:{}\", connection, jdbcUrl, tableName, context.getTransactionId(), context.getSegmentId());\r\n-\r\n-            prepareConnection(connection);\r\n-        } catch (Exception e) {\r\n-            closeConnection(connection);\r\n-            if (e instanceof SQLException) {\r\n-                throw (SQLException) e;\r\n-            } else {\r\n-                String msg = e.getMessage();\r\n-                if (msg == null) {\r\n-                    Throwable t = e.getCause();\r\n-                    if (t != null) msg = t.getMessage();\r\n-                }\r\n-                throw new SQLException(msg, e);\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    /**\r\n-     * Prepare a JDBC PreparedStatement\r\n-     *\r\n-     * @param connection connection to use for creating the statement\r\n-     * @param query      query to execute\r\n-     * @return PreparedStatement\r\n-     * @throws SQLException if a database access error occurs\r\n-     */\r\n-    public PreparedStatement getPreparedStatement(Connection connection, String query) throws SQLException {\r\n-        if ((connection == null) || (query == null)) {\r\n-            throw new IllegalArgumentException(\"The provided query or connection is null\");\r\n-        }\r\n-        PreparedStatement statement = connection.prepareStatement(query);\r\n-        if (queryTimeout != null) {\r\n-            LOG.debug(\"Setting query timeout to {} seconds\", queryTimeout);\r\n-            statement.setQueryTimeout(queryTimeout);\r\n-        }\r\n-        return statement;\r\n-    }\r\n-\r\n-    /**\r\n-     * Close a JDBC statement and underlying {@link Connection}\r\n-     *\r\n-     * @param statement statement to close\r\n-     * @throws SQLException\r\n-     */\r\n-    public static void closeStatementAndConnection(Statement statement) throws SQLException {\r\n-        if (statement == null) {\r\n-            LOG.warn(\"Call to close statement and connection is ignored as statement provided was null\");\r\n-            return;\r\n-        }\r\n-\r\n-        SQLException exception = null;\r\n-        Connection connection = null;\r\n-\r\n-        try {\r\n-            connection = statement.getConnection();\r\n-        } catch (SQLException e) {\r\n-            LOG.error(\"Exception when retrieving Connection from Statement\", e);\r\n-            exception = e;\r\n-        }\r\n-\r\n-        try {\r\n-            LOG.debug(\"Closing statement for connection {}\", connection);\r\n-            statement.close();\r\n-        } catch (SQLException e) {\r\n-            LOG.error(\"Exception when closing Statement\", e);\r\n-            exception = e;\r\n-        }\r\n-\r\n-        try {\r\n-            closeConnection(connection);\r\n-        } catch (SQLException e) {\r\n-            LOG.error(String.format(\"Exception when closing connection %s\", connection), e);\r\n-            exception = e;\r\n-        }\r\n-\r\n-        if (exception != null) {\r\n-            throw exception;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * For a Kerberized Hive JDBC connection, it creates a connection as the loginUser.\r\n-     * Otherwise, it returns a new connection.\r\n-     *\r\n-     * @return for a Kerberized Hive JDBC connection, returns a new connection as the loginUser.\r\n-     * Otherwise, it returns a new connection.\r\n-     * @throws Exception\r\n-     */\r\n-    private Connection getConnectionInternal() throws Exception {\r\n-        if (Utilities.isSecurityEnabled(configuration) && StringUtils.startsWith(jdbcUrl, HIVE_URL_PREFIX)) {\r\n-            return SecureLogin.getInstance().getLoginUser(context, configuration).\r\n-                    doAs((PrivilegedExceptionAction<Connection>) () ->\r\n-                            connectionManager.getConnection(context.getServerName(), jdbcUrl, connectionConfiguration, isConnectionPoolUsed, poolConfiguration, poolQualifier));\r\n-\r\n-        } else {\r\n-            return connectionManager.getConnection(context.getServerName(), jdbcUrl, connectionConfiguration, isConnectionPoolUsed, poolConfiguration, poolQualifier);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Close a JDBC connection\r\n-     *\r\n-     * @param connection connection to close\r\n-     * @throws SQLException\r\n-     */\r\n-    private static void closeConnection(Connection connection) throws SQLException {\r\n-        if (connection == null) {\r\n-            LOG.warn(\"Call to close connection is ignored as connection provided was null\");\r\n-            return;\r\n-        }\r\n-        try {\r\n-            if (!connection.isClosed() &&\r\n-                    connection.getMetaData().supportsTransactions() &&\r\n-                    !connection.getAutoCommit()) {\r\n-\r\n-                LOG.debug(\"Committing transaction (as part of connection.close()) on connection {}\", connection);\r\n-                connection.commit();\r\n-            }\r\n-        } finally {\r\n-            try {\r\n-                LOG.debug(\"Closing connection {}\", connection);\r\n-                connection.close();\r\n-            } catch (Exception e) {\r\n-                // ignore\r\n-                LOG.warn(String.format(\"Failed to close JDBC connection %s, ignoring the error.\", connection), e);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Prepare JDBC connection by setting session-level variables in external database\r\n-     *\r\n-     * @param connection {@link Connection} to prepare\r\n-     */\r\n-    private void prepareConnection(Connection connection) throws SQLException {\r\n-        if (connection == null) {\r\n-            throw new IllegalArgumentException(\"The provided connection is null\");\r\n-        }\r\n-\r\n-        DatabaseMetaData metadata = connection.getMetaData();\r\n-\r\n-        // Handle optional connection transaction isolation level\r\n-        if (transactionIsolation != TransactionIsolation.NOT_PROVIDED) {\r\n-            // user wants to set isolation level explicitly\r\n-            if (metadata.supportsTransactionIsolationLevel(transactionIsolation.getLevel())) {\r\n-                LOG.debug(\"Setting transaction isolation level to {} on connection {}\", transactionIsolation.toString(), connection);\r\n-                connection.setTransactionIsolation(transactionIsolation.getLevel());\r\n-            } else {\r\n-                throw new RuntimeException(\r\n-                        String.format(\"Transaction isolation level %s is not supported\", transactionIsolation.toString())\r\n-                );\r\n-            }\r\n-        }\r\n-\r\n-        // Disable autocommit\r\n-        if (metadata.supportsTransactions()) {\r\n-            LOG.debug(\"Setting autoCommit to false on connection {}\", connection);\r\n-            connection.setAutoCommit(false);\r\n-        }\r\n-\r\n-        // Prepare session (process sessionConfiguration)\r\n-        if (!sessionConfiguration.isEmpty()) {\r\n-            DbProduct dbProduct = DbProduct.getDbProduct(metadata.getDatabaseProductName());\r\n-\r\n-            try (Statement statement = connection.createStatement()) {\r\n-                for (Map.Entry<String, String> e : sessionConfiguration.entrySet()) {\r\n-                    String sessionQuery = dbProduct.buildSessionQuery(e.getKey(), e.getValue());\r\n-                    LOG.debug(\"Executing statement {} on connection {}\", sessionQuery, connection);\r\n-                    statement.execute(sessionQuery);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Asserts whether a given parameter has non-empty value, throws IllegalArgumentException otherwise\r\n-     *\r\n-     * @param value      value to check\r\n-     * @param paramName  parameter name\r\n-     * @param optionName name of the option for a given parameter\r\n-     */\r\n-    private void assertMandatoryParameter(String value, String paramName, String optionName) {\r\n-        if (StringUtils.isBlank(value)) {\r\n-            throw new IllegalArgumentException(String.format(\r\n-                    \"Required parameter %s is missing or empty in jdbc-site.xml and option %s is not specified in table definition.\", paramName, optionName)\r\n-            );\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructs a mapping of configuration and includes all properties that start with the specified\r\n-     * configuration prefix.  Property names in the mapping are trimmed to remove the configuration prefix.\r\n-     * This is a method from Hadoop's Configuration class ported here to make older and custom versions of Hadoop\r\n-     * work with JDBC profile.\r\n-     *\r\n-     * @param configuration configuration map\r\n-     * @param confPrefix    configuration prefix\r\n-     * @return mapping of configuration properties with prefix stripped\r\n-     */\r\n-    private Map<String, String> getPropsWithPrefix(Configuration configuration, String confPrefix) {\r\n-        Map<String, String> configMap = new HashMap<>();\r\n-        Iterator<Map.Entry<String, String>> it = configuration.iterator();\r\n-        while (it.hasNext()) {\r\n-            String propertyName = it.next().getKey();\r\n-            if (propertyName.startsWith(confPrefix)) {\r\n-                // do not use value from the iterator as it might not come with variable substitution\r\n-                String value = configuration.get(propertyName);\r\n-                String keyName = propertyName.substring(confPrefix.length());\r\n-                configMap.put(keyName, value);\r\n-            }\r\n-        }\r\n-        return configMap;\r\n-    }\r\n-\r\n-}\r\n+package org.greenplum.pxf.plugins.jdbc;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyODUzMw=="}, "originalCommit": {"oid": "057403a900e5da7a67dda63e9ebdb1e20467f0d6"}, "originalPosition": 583}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwNjI3OA==", "bodyText": "any functional reason we want to do that? I find it useful to be able to do a \"blame/annotate\" to look at a code in the change. However, when doing these changes, we make it more difficult to quickly determine changes in the source code", "url": "https://github.com/greenplum-db/pxf/pull/311#discussion_r390606278", "createdAt": "2020-03-10T20:57:29Z", "author": {"login": "frankgh"}, "path": "server/pxf-jdbc/src/main/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePlugin.java", "diffHunk": "@@ -1,582 +1,584 @@\n-package org.greenplum.pxf.plugins.jdbc;\r\n-\r\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.hadoop.conf.Configuration;\r\n-import org.greenplum.pxf.api.model.BasePlugin;\r\n-import org.greenplum.pxf.api.model.RequestContext;\r\n-import org.greenplum.pxf.api.security.SecureLogin;\r\n-import org.greenplum.pxf.api.utilities.ColumnDescriptor;\r\n-import org.greenplum.pxf.api.utilities.Utilities;\r\n-import org.greenplum.pxf.plugins.jdbc.utils.ConnectionManager;\r\n-import org.greenplum.pxf.plugins.jdbc.utils.DbProduct;\r\n-import org.greenplum.pxf.plugins.jdbc.utils.HiveJdbcUtils;\r\n-import org.slf4j.Logger;\r\n-import org.slf4j.LoggerFactory;\r\n-\r\n-import java.security.PrivilegedExceptionAction;\r\n-import java.sql.Connection;\r\n-import java.sql.DatabaseMetaData;\r\n-import java.sql.PreparedStatement;\r\n-import java.sql.SQLException;\r\n-import java.sql.Statement;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Properties;\r\n-import java.util.stream.Collectors;\r\n-\r\n-import static org.greenplum.pxf.api.security.SecureLogin.CONFIG_KEY_SERVICE_USER_IMPERSONATION;\r\n-\r\n-/**\r\n- * JDBC tables plugin (base class)\r\n- * <p>\r\n- * Implemented subclasses: {@link JdbcAccessor}, {@link JdbcResolver}.\r\n- */\r\n-public class JdbcBasePlugin extends BasePlugin {\r\n-\r\n-    private static final Logger LOG = LoggerFactory.getLogger(JdbcBasePlugin.class);\r\n-\r\n-    // '100' is a recommended value: https://docs.oracle.com/cd/E11882_01/java.112/e16548/oraperf.htm#JJDBC28754\r\n-    private static final int DEFAULT_BATCH_SIZE = 100;\r\n-    private static final int DEFAULT_FETCH_SIZE = 1000;\r\n-    private static final int DEFAULT_POOL_SIZE = 1;\r\n-\r\n-    // configuration parameter names\r\n-    private static final String JDBC_DRIVER_PROPERTY_NAME = \"jdbc.driver\";\r\n-    private static final String JDBC_URL_PROPERTY_NAME = \"jdbc.url\";\r\n-    private static final String JDBC_USER_PROPERTY_NAME = \"jdbc.user\";\r\n-    private static final String JDBC_PASSWORD_PROPERTY_NAME = \"jdbc.password\";\r\n-    private static final String JDBC_SESSION_PROPERTY_PREFIX = \"jdbc.session.property.\";\r\n-    private static final String JDBC_CONNECTION_PROPERTY_PREFIX = \"jdbc.connection.property.\";\r\n-\r\n-    // connection parameter names\r\n-    private static final String JDBC_CONNECTION_TRANSACTION_ISOLATION = \"jdbc.connection.transactionIsolation\";\r\n-\r\n-    // statement properties\r\n-    private static final String JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME = \"jdbc.statement.batchSize\";\r\n-    private static final String JDBC_STATEMENT_FETCH_SIZE_PROPERTY_NAME = \"jdbc.statement.fetchSize\";\r\n-    private static final String JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME = \"jdbc.statement.queryTimeout\";\r\n-\r\n-    // connection pool properties\r\n-    private static final String JDBC_CONNECTION_POOL_ENABLED_PROPERTY_NAME = \"jdbc.pool.enabled\";\r\n-    private static final String JDBC_CONNECTION_POOL_PROPERTY_PREFIX = \"jdbc.pool.property.\";\r\n-    private static final String JDBC_POOL_QUALIFIER_PROPERTY_NAME = \"jdbc.pool.qualifier\";\r\n-\r\n-    // DDL option names\r\n-    private static final String JDBC_DRIVER_OPTION_NAME = \"JDBC_DRIVER\";\r\n-    private static final String JDBC_URL_OPTION_NAME = \"DB_URL\";\r\n-\r\n-    private static final String FORBIDDEN_SESSION_PROPERTY_CHARACTERS = \";\\n\\b\\0\";\r\n-    private static final String QUERY_NAME_PREFIX = \"query:\";\r\n-    private static final int QUERY_NAME_PREFIX_LENGTH = QUERY_NAME_PREFIX.length();\r\n-\r\n-    private static final String HIVE_URL_PREFIX = \"jdbc:hive2://\";\r\n-    private static final String HIVE_DEFAULT_DRIVER_CLASS = \"org.apache.hive.jdbc.HiveDriver\";\r\n-\r\n-    private enum TransactionIsolation {\r\n-        READ_UNCOMMITTED(1),\r\n-        READ_COMMITTED(2),\r\n-        REPEATABLE_READ(4),\r\n-        SERIALIZABLE(8),\r\n-        NOT_PROVIDED(-1);\r\n-\r\n-        private int isolationLevel;\r\n-\r\n-        TransactionIsolation(int transactionIsolation) {\r\n-            isolationLevel = transactionIsolation;\r\n-        }\r\n-\r\n-        public int getLevel() {\r\n-            return isolationLevel;\r\n-        }\r\n-\r\n-        public static TransactionIsolation typeOf(String str) {\r\n-            return valueOf(str);\r\n-        }\r\n-    }\r\n-\r\n-    // JDBC parameters from config file or specified in DDL\r\n-\r\n-    private String jdbcUrl;\r\n-\r\n-    protected String tableName;\r\n-\r\n-    // Write batch size\r\n-    protected int batchSize;\r\n-    protected boolean batchSizeIsSetByUser = false;\r\n-\r\n-    // Read batch size\r\n-    protected int fetchSize;\r\n-\r\n-    // Thread pool size\r\n-    protected int poolSize;\r\n-\r\n-    // Query timeout.\r\n-    protected Integer queryTimeout;\r\n-\r\n-    // Quote columns setting set by user (three values are possible)\r\n-    protected Boolean quoteColumns = null;\r\n-\r\n-    // Environment variables to SET before query execution\r\n-    protected Map<String, String> sessionConfiguration = new HashMap<String, String>();\r\n-\r\n-    // Properties object to pass to JDBC Driver when connection is created\r\n-    protected Properties connectionConfiguration = new Properties();\r\n-\r\n-    // Transaction isolation level that a user can configure\r\n-    private TransactionIsolation transactionIsolation = TransactionIsolation.NOT_PROVIDED;\r\n-\r\n-    // Columns description\r\n-    protected List<ColumnDescriptor> columns = null;\r\n-\r\n-    // Name of query to execute for read flow (optional)\r\n-    protected String queryName;\r\n-\r\n-    // connection pool fields\r\n-    private boolean isConnectionPoolUsed;\r\n-    private Properties poolConfiguration;\r\n-    private String poolQualifier;\r\n-\r\n-    private ConnectionManager connectionManager;\r\n-\r\n-    static {\r\n-        // Deprecated as of Oct 22, 2019 in version 5.9.2+\r\n-        Configuration.addDeprecation(\"pxf.impersonation.jdbc\",\r\n-                CONFIG_KEY_SERVICE_USER_IMPERSONATION,\r\n-                \"The property \\\"pxf.impersonation.jdbc\\\" has been deprecated in favor of \\\"pxf.service.user.impersonation\\\".\");\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a new instance with default (singleton) instance of ConnectionManager.\r\n-     */\r\n-    public JdbcBasePlugin() {\r\n-        this(ConnectionManager.getInstance());\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a new instance with the given ConnectionManager.\r\n-     *\r\n-     * @param connectionManager connection manager instance\r\n-     */\r\n-    JdbcBasePlugin(ConnectionManager connectionManager) {\r\n-        this.connectionManager = connectionManager;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void initialize(RequestContext context) {\r\n-        super.initialize(context);\r\n-\r\n-        // Required parameter. Can be auto-overwritten by user options\r\n-        String jdbcDriver = configuration.get(JDBC_DRIVER_PROPERTY_NAME);\r\n-        assertMandatoryParameter(jdbcDriver, JDBC_DRIVER_PROPERTY_NAME, JDBC_DRIVER_OPTION_NAME);\r\n-        try {\r\n-            LOG.debug(\"JDBC driver: '{}'\", jdbcDriver);\r\n-            Class.forName(jdbcDriver);\r\n-        } catch (ClassNotFoundException e) {\r\n-            throw new RuntimeException(e);\r\n-        }\r\n-\r\n-        // Required parameter. Can be auto-overwritten by user options\r\n-        jdbcUrl = configuration.get(JDBC_URL_PROPERTY_NAME);\r\n-        assertMandatoryParameter(jdbcUrl, JDBC_URL_PROPERTY_NAME, JDBC_URL_OPTION_NAME);\r\n-\r\n-        // Required metadata\r\n-        String dataSource = context.getDataSource();\r\n-        if (StringUtils.isBlank(dataSource)) {\r\n-            throw new IllegalArgumentException(\"Data source must be provided\");\r\n-        }\r\n-\r\n-        // Determine if the datasource is a table name or a query name\r\n-        if (dataSource.startsWith(QUERY_NAME_PREFIX)) {\r\n-            queryName = dataSource.substring(QUERY_NAME_PREFIX_LENGTH);\r\n-            if (StringUtils.isBlank(queryName)) {\r\n-                throw new IllegalArgumentException(String.format(\"Query name is not provided in data source [%s]\", dataSource));\r\n-            }\r\n-            LOG.debug(\"Query name is {}\", queryName);\r\n-        } else {\r\n-            tableName = dataSource;\r\n-            LOG.debug(\"Table name is {}\", tableName);\r\n-        }\r\n-\r\n-        // Required metadata\r\n-        columns = context.getTupleDescription();\r\n-\r\n-        // Optional parameters\r\n-        batchSizeIsSetByUser = configuration.get(JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME) != null;\r\n-        batchSize = configuration.getInt(JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME, DEFAULT_BATCH_SIZE);\r\n-\r\n-        if (batchSize == 0) {\r\n-            batchSize = 1; // if user set to 0, it is the same as batchSize of 1\r\n-        } else if (batchSize < 0) {\r\n-            throw new IllegalArgumentException(String.format(\r\n-                    \"Property %s has incorrect value %s : must be a non-negative integer\", JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME, batchSize));\r\n-        }\r\n-\r\n-        fetchSize = configuration.getInt(JDBC_STATEMENT_FETCH_SIZE_PROPERTY_NAME, DEFAULT_FETCH_SIZE);\r\n-\r\n-        poolSize = context.getOption(\"POOL_SIZE\", DEFAULT_POOL_SIZE);\r\n-\r\n-        String queryTimeoutString = configuration.get(JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME);\r\n-        if (StringUtils.isNotBlank(queryTimeoutString)) {\r\n-            try {\r\n-                queryTimeout = Integer.parseUnsignedInt(queryTimeoutString);\r\n-            } catch (NumberFormatException e) {\r\n-                throw new IllegalArgumentException(String.format(\r\n-                        \"Property %s has incorrect value %s : must be a non-negative integer\",\r\n-                        JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME, queryTimeoutString), e);\r\n-            }\r\n-        }\r\n-\r\n-        // Optional parameter. The default value is null\r\n-        String quoteColumnsRaw = context.getOption(\"QUOTE_COLUMNS\");\r\n-        if (quoteColumnsRaw != null) {\r\n-            quoteColumns = Boolean.parseBoolean(quoteColumnsRaw);\r\n-        }\r\n-\r\n-        // Optional parameter. The default value is empty map\r\n-        sessionConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_SESSION_PROPERTY_PREFIX));\r\n-        // Check forbidden symbols\r\n-        // Note: PreparedStatement enables us to skip this check: its values are distinct from its SQL code\r\n-        // However, SET queries cannot be executed this way. This is why we do this check\r\n-        if (sessionConfiguration.entrySet().stream()\r\n-                .anyMatch(\r\n-                        entry ->\r\n-                                StringUtils.containsAny(\r\n-                                        entry.getKey(), FORBIDDEN_SESSION_PROPERTY_CHARACTERS\r\n-                                ) ||\r\n-                                        StringUtils.containsAny(\r\n-                                                entry.getValue(), FORBIDDEN_SESSION_PROPERTY_CHARACTERS\r\n-                                        )\r\n-                )\r\n-        ) {\r\n-            throw new IllegalArgumentException(\"Some session configuration parameter contains forbidden characters\");\r\n-        }\r\n-        if (LOG.isDebugEnabled()) {\r\n-            LOG.debug(\"Session configuration: {}\",\r\n-                    sessionConfiguration.entrySet().stream()\r\n-                            .map(entry -> \"'\" + entry.getKey() + \"'='\" + entry.getValue() + \"'\")\r\n-                            .collect(Collectors.joining(\", \"))\r\n-            );\r\n-        }\r\n-\r\n-        // Optional parameter. The default value is empty map\r\n-        connectionConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_CONNECTION_PROPERTY_PREFIX));\r\n-\r\n-        // Optional parameter. The default value depends on the database\r\n-        String transactionIsolationString = configuration.get(JDBC_CONNECTION_TRANSACTION_ISOLATION, \"NOT_PROVIDED\");\r\n-        transactionIsolation = TransactionIsolation.typeOf(transactionIsolationString);\r\n-\r\n-        // Set optional user parameter, taking into account impersonation setting for the server.\r\n-        String jdbcUser = configuration.get(JDBC_USER_PROPERTY_NAME);\r\n-        boolean impersonationEnabledForServer = configuration.getBoolean(CONFIG_KEY_SERVICE_USER_IMPERSONATION, false);\r\n-        LOG.debug(\"JDBC impersonation is {}enabled for server {}\", impersonationEnabledForServer ? \"\" : \"not \", context.getServerName());\r\n-        if (impersonationEnabledForServer) {\r\n-            if (Utilities.isSecurityEnabled(configuration) && StringUtils.startsWith(jdbcUrl, HIVE_URL_PREFIX)) {\r\n-                // secure impersonation for Hive JDBC driver requires setting URL fragment that cannot be overwritten by properties\r\n-                String updatedJdbcUrl = HiveJdbcUtils.updateImpersonationPropertyInHiveJdbcUrl(jdbcUrl, context.getUser());\r\n-                LOG.debug(\"Replaced JDBC URL {} with {}\", jdbcUrl, updatedJdbcUrl);\r\n-                jdbcUrl = updatedJdbcUrl;\r\n-            } else {\r\n-                // the jdbcUser is the GPDB user\r\n-                jdbcUser = context.getUser();\r\n-            }\r\n-        }\r\n-        if (jdbcUser != null) {\r\n-            LOG.debug(\"Effective JDBC user {}\", jdbcUser);\r\n-            connectionConfiguration.setProperty(\"user\", jdbcUser);\r\n-        } else {\r\n-            LOG.debug(\"JDBC user has not been set\");\r\n-        }\r\n-\r\n-        if (LOG.isDebugEnabled()) {\r\n-            LOG.debug(\"Connection configuration: {}\",\r\n-                    connectionConfiguration.entrySet().stream()\r\n-                            .map(entry -> \"'\" + entry.getKey() + \"'='\" + entry.getValue() + \"'\")\r\n-                            .collect(Collectors.joining(\", \"))\r\n-            );\r\n-        }\r\n-\r\n-        // This must be the last parameter parsed, as we output connectionConfiguration earlier\r\n-        // Optional parameter. By default, corresponding connectionConfiguration property is not set\r\n-        if (jdbcUser != null) {\r\n-            String jdbcPassword = configuration.get(JDBC_PASSWORD_PROPERTY_NAME);\r\n-            if (jdbcPassword != null) {\r\n-                LOG.debug(\"Connection password: {}\", ConnectionManager.maskPassword(jdbcPassword));\r\n-                connectionConfiguration.setProperty(\"password\", jdbcPassword);\r\n-            }\r\n-        }\r\n-\r\n-        // connection pool is optional, enabled by default\r\n-        isConnectionPoolUsed = configuration.getBoolean(JDBC_CONNECTION_POOL_ENABLED_PROPERTY_NAME, true);\r\n-        LOG.debug(\"Connection pool is {}enabled\", isConnectionPoolUsed ? \"\" : \"not \");\r\n-        if (isConnectionPoolUsed) {\r\n-            poolConfiguration = new Properties();\r\n-            // for PXF upgrades where jdbc-site template has not been updated, make sure there're sensible defaults\r\n-            poolConfiguration.setProperty(\"maximumPoolSize\", \"5\");\r\n-            poolConfiguration.setProperty(\"connectionTimeout\", \"30000\");\r\n-            poolConfiguration.setProperty(\"idleTimeout\", \"30000\");\r\n-            poolConfiguration.setProperty(\"minimumIdle\", \"0\");\r\n-            // apply values read from the template\r\n-            poolConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_CONNECTION_POOL_PROPERTY_PREFIX));\r\n-\r\n-            // packaged Hive JDBC Driver does not support connection.isValid() method, so we need to force set\r\n-            // connectionTestQuery parameter in this case, unless already set by the user\r\n-            if (jdbcUrl.startsWith(HIVE_URL_PREFIX) && HIVE_DEFAULT_DRIVER_CLASS.equals(jdbcDriver) && poolConfiguration.getProperty(\"connectionTestQuery\") == null) {\r\n-                poolConfiguration.setProperty(\"connectionTestQuery\", \"SELECT 1\");\r\n-            }\r\n-\r\n-            // get the qualifier for connection pool, if configured. Might be used when connection session authorization is employed\r\n-            // to switch effective user once connection is established\r\n-            poolQualifier = configuration.get(JDBC_POOL_QUALIFIER_PROPERTY_NAME);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Open a new JDBC connection\r\n-     *\r\n-     * @return {@link Connection}\r\n-     * @throws SQLException if a database access or connection error occurs\r\n-     */\r\n-    public Connection getConnection() throws SQLException {\r\n-        LOG.debug(\"Requesting a new JDBC connection. URL={} table={} txid:seg={}:{}\", jdbcUrl, tableName, context.getTransactionId(), context.getSegmentId());\r\n-\r\n-        Connection connection = null;\r\n-        try {\r\n-            connection = getConnectionInternal();\r\n-            LOG.debug(\"Obtained a JDBC connection {} for URL={} table={} txid:seg={}:{}\", connection, jdbcUrl, tableName, context.getTransactionId(), context.getSegmentId());\r\n-\r\n-            prepareConnection(connection);\r\n-        } catch (Exception e) {\r\n-            closeConnection(connection);\r\n-            if (e instanceof SQLException) {\r\n-                throw (SQLException) e;\r\n-            } else {\r\n-                String msg = e.getMessage();\r\n-                if (msg == null) {\r\n-                    Throwable t = e.getCause();\r\n-                    if (t != null) msg = t.getMessage();\r\n-                }\r\n-                throw new SQLException(msg, e);\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    /**\r\n-     * Prepare a JDBC PreparedStatement\r\n-     *\r\n-     * @param connection connection to use for creating the statement\r\n-     * @param query      query to execute\r\n-     * @return PreparedStatement\r\n-     * @throws SQLException if a database access error occurs\r\n-     */\r\n-    public PreparedStatement getPreparedStatement(Connection connection, String query) throws SQLException {\r\n-        if ((connection == null) || (query == null)) {\r\n-            throw new IllegalArgumentException(\"The provided query or connection is null\");\r\n-        }\r\n-        PreparedStatement statement = connection.prepareStatement(query);\r\n-        if (queryTimeout != null) {\r\n-            LOG.debug(\"Setting query timeout to {} seconds\", queryTimeout);\r\n-            statement.setQueryTimeout(queryTimeout);\r\n-        }\r\n-        return statement;\r\n-    }\r\n-\r\n-    /**\r\n-     * Close a JDBC statement and underlying {@link Connection}\r\n-     *\r\n-     * @param statement statement to close\r\n-     * @throws SQLException\r\n-     */\r\n-    public static void closeStatementAndConnection(Statement statement) throws SQLException {\r\n-        if (statement == null) {\r\n-            LOG.warn(\"Call to close statement and connection is ignored as statement provided was null\");\r\n-            return;\r\n-        }\r\n-\r\n-        SQLException exception = null;\r\n-        Connection connection = null;\r\n-\r\n-        try {\r\n-            connection = statement.getConnection();\r\n-        } catch (SQLException e) {\r\n-            LOG.error(\"Exception when retrieving Connection from Statement\", e);\r\n-            exception = e;\r\n-        }\r\n-\r\n-        try {\r\n-            LOG.debug(\"Closing statement for connection {}\", connection);\r\n-            statement.close();\r\n-        } catch (SQLException e) {\r\n-            LOG.error(\"Exception when closing Statement\", e);\r\n-            exception = e;\r\n-        }\r\n-\r\n-        try {\r\n-            closeConnection(connection);\r\n-        } catch (SQLException e) {\r\n-            LOG.error(String.format(\"Exception when closing connection %s\", connection), e);\r\n-            exception = e;\r\n-        }\r\n-\r\n-        if (exception != null) {\r\n-            throw exception;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * For a Kerberized Hive JDBC connection, it creates a connection as the loginUser.\r\n-     * Otherwise, it returns a new connection.\r\n-     *\r\n-     * @return for a Kerberized Hive JDBC connection, returns a new connection as the loginUser.\r\n-     * Otherwise, it returns a new connection.\r\n-     * @throws Exception\r\n-     */\r\n-    private Connection getConnectionInternal() throws Exception {\r\n-        if (Utilities.isSecurityEnabled(configuration) && StringUtils.startsWith(jdbcUrl, HIVE_URL_PREFIX)) {\r\n-            return SecureLogin.getInstance().getLoginUser(context, configuration).\r\n-                    doAs((PrivilegedExceptionAction<Connection>) () ->\r\n-                            connectionManager.getConnection(context.getServerName(), jdbcUrl, connectionConfiguration, isConnectionPoolUsed, poolConfiguration, poolQualifier));\r\n-\r\n-        } else {\r\n-            return connectionManager.getConnection(context.getServerName(), jdbcUrl, connectionConfiguration, isConnectionPoolUsed, poolConfiguration, poolQualifier);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Close a JDBC connection\r\n-     *\r\n-     * @param connection connection to close\r\n-     * @throws SQLException\r\n-     */\r\n-    private static void closeConnection(Connection connection) throws SQLException {\r\n-        if (connection == null) {\r\n-            LOG.warn(\"Call to close connection is ignored as connection provided was null\");\r\n-            return;\r\n-        }\r\n-        try {\r\n-            if (!connection.isClosed() &&\r\n-                    connection.getMetaData().supportsTransactions() &&\r\n-                    !connection.getAutoCommit()) {\r\n-\r\n-                LOG.debug(\"Committing transaction (as part of connection.close()) on connection {}\", connection);\r\n-                connection.commit();\r\n-            }\r\n-        } finally {\r\n-            try {\r\n-                LOG.debug(\"Closing connection {}\", connection);\r\n-                connection.close();\r\n-            } catch (Exception e) {\r\n-                // ignore\r\n-                LOG.warn(String.format(\"Failed to close JDBC connection %s, ignoring the error.\", connection), e);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Prepare JDBC connection by setting session-level variables in external database\r\n-     *\r\n-     * @param connection {@link Connection} to prepare\r\n-     */\r\n-    private void prepareConnection(Connection connection) throws SQLException {\r\n-        if (connection == null) {\r\n-            throw new IllegalArgumentException(\"The provided connection is null\");\r\n-        }\r\n-\r\n-        DatabaseMetaData metadata = connection.getMetaData();\r\n-\r\n-        // Handle optional connection transaction isolation level\r\n-        if (transactionIsolation != TransactionIsolation.NOT_PROVIDED) {\r\n-            // user wants to set isolation level explicitly\r\n-            if (metadata.supportsTransactionIsolationLevel(transactionIsolation.getLevel())) {\r\n-                LOG.debug(\"Setting transaction isolation level to {} on connection {}\", transactionIsolation.toString(), connection);\r\n-                connection.setTransactionIsolation(transactionIsolation.getLevel());\r\n-            } else {\r\n-                throw new RuntimeException(\r\n-                        String.format(\"Transaction isolation level %s is not supported\", transactionIsolation.toString())\r\n-                );\r\n-            }\r\n-        }\r\n-\r\n-        // Disable autocommit\r\n-        if (metadata.supportsTransactions()) {\r\n-            LOG.debug(\"Setting autoCommit to false on connection {}\", connection);\r\n-            connection.setAutoCommit(false);\r\n-        }\r\n-\r\n-        // Prepare session (process sessionConfiguration)\r\n-        if (!sessionConfiguration.isEmpty()) {\r\n-            DbProduct dbProduct = DbProduct.getDbProduct(metadata.getDatabaseProductName());\r\n-\r\n-            try (Statement statement = connection.createStatement()) {\r\n-                for (Map.Entry<String, String> e : sessionConfiguration.entrySet()) {\r\n-                    String sessionQuery = dbProduct.buildSessionQuery(e.getKey(), e.getValue());\r\n-                    LOG.debug(\"Executing statement {} on connection {}\", sessionQuery, connection);\r\n-                    statement.execute(sessionQuery);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Asserts whether a given parameter has non-empty value, throws IllegalArgumentException otherwise\r\n-     *\r\n-     * @param value      value to check\r\n-     * @param paramName  parameter name\r\n-     * @param optionName name of the option for a given parameter\r\n-     */\r\n-    private void assertMandatoryParameter(String value, String paramName, String optionName) {\r\n-        if (StringUtils.isBlank(value)) {\r\n-            throw new IllegalArgumentException(String.format(\r\n-                    \"Required parameter %s is missing or empty in jdbc-site.xml and option %s is not specified in table definition.\", paramName, optionName)\r\n-            );\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructs a mapping of configuration and includes all properties that start with the specified\r\n-     * configuration prefix.  Property names in the mapping are trimmed to remove the configuration prefix.\r\n-     * This is a method from Hadoop's Configuration class ported here to make older and custom versions of Hadoop\r\n-     * work with JDBC profile.\r\n-     *\r\n-     * @param configuration configuration map\r\n-     * @param confPrefix    configuration prefix\r\n-     * @return mapping of configuration properties with prefix stripped\r\n-     */\r\n-    private Map<String, String> getPropsWithPrefix(Configuration configuration, String confPrefix) {\r\n-        Map<String, String> configMap = new HashMap<>();\r\n-        Iterator<Map.Entry<String, String>> it = configuration.iterator();\r\n-        while (it.hasNext()) {\r\n-            String propertyName = it.next().getKey();\r\n-            if (propertyName.startsWith(confPrefix)) {\r\n-                // do not use value from the iterator as it might not come with variable substitution\r\n-                String value = configuration.get(propertyName);\r\n-                String keyName = propertyName.substring(confPrefix.length());\r\n-                configMap.put(keyName, value);\r\n-            }\r\n-        }\r\n-        return configMap;\r\n-    }\r\n-\r\n-}\r\n+package org.greenplum.pxf.plugins.jdbc;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyODUzMw=="}, "originalCommit": {"oid": "057403a900e5da7a67dda63e9ebdb1e20467f0d6"}, "originalPosition": 583}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYxNjk5Nw==", "bodyText": "OK, switched back to carriage returns.", "url": "https://github.com/greenplum-db/pxf/pull/311#discussion_r390616997", "createdAt": "2020-03-10T21:17:10Z", "author": {"login": "oliverralbertini"}, "path": "server/pxf-jdbc/src/main/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePlugin.java", "diffHunk": "@@ -1,582 +1,584 @@\n-package org.greenplum.pxf.plugins.jdbc;\r\n-\r\n-/*\r\n- * Licensed to the Apache Software Foundation (ASF) under one\r\n- * or more contributor license agreements.  See the NOTICE file\r\n- * distributed with this work for additional information\r\n- * regarding copyright ownership.  The ASF licenses this file\r\n- * to you under the Apache License, Version 2.0 (the\r\n- * \"License\"); you may not use this file except in compliance\r\n- * with the License.  You may obtain a copy of the License at\r\n- *\r\n- *   http://www.apache.org/licenses/LICENSE-2.0\r\n- *\r\n- * Unless required by applicable law or agreed to in writing,\r\n- * software distributed under the License is distributed on an\r\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n- * KIND, either express or implied.  See the License for the\r\n- * specific language governing permissions and limitations\r\n- * under the License.\r\n- */\r\n-\r\n-import org.apache.commons.lang.StringUtils;\r\n-import org.apache.hadoop.conf.Configuration;\r\n-import org.greenplum.pxf.api.model.BasePlugin;\r\n-import org.greenplum.pxf.api.model.RequestContext;\r\n-import org.greenplum.pxf.api.security.SecureLogin;\r\n-import org.greenplum.pxf.api.utilities.ColumnDescriptor;\r\n-import org.greenplum.pxf.api.utilities.Utilities;\r\n-import org.greenplum.pxf.plugins.jdbc.utils.ConnectionManager;\r\n-import org.greenplum.pxf.plugins.jdbc.utils.DbProduct;\r\n-import org.greenplum.pxf.plugins.jdbc.utils.HiveJdbcUtils;\r\n-import org.slf4j.Logger;\r\n-import org.slf4j.LoggerFactory;\r\n-\r\n-import java.security.PrivilegedExceptionAction;\r\n-import java.sql.Connection;\r\n-import java.sql.DatabaseMetaData;\r\n-import java.sql.PreparedStatement;\r\n-import java.sql.SQLException;\r\n-import java.sql.Statement;\r\n-import java.util.HashMap;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-import java.util.Map;\r\n-import java.util.Properties;\r\n-import java.util.stream.Collectors;\r\n-\r\n-import static org.greenplum.pxf.api.security.SecureLogin.CONFIG_KEY_SERVICE_USER_IMPERSONATION;\r\n-\r\n-/**\r\n- * JDBC tables plugin (base class)\r\n- * <p>\r\n- * Implemented subclasses: {@link JdbcAccessor}, {@link JdbcResolver}.\r\n- */\r\n-public class JdbcBasePlugin extends BasePlugin {\r\n-\r\n-    private static final Logger LOG = LoggerFactory.getLogger(JdbcBasePlugin.class);\r\n-\r\n-    // '100' is a recommended value: https://docs.oracle.com/cd/E11882_01/java.112/e16548/oraperf.htm#JJDBC28754\r\n-    private static final int DEFAULT_BATCH_SIZE = 100;\r\n-    private static final int DEFAULT_FETCH_SIZE = 1000;\r\n-    private static final int DEFAULT_POOL_SIZE = 1;\r\n-\r\n-    // configuration parameter names\r\n-    private static final String JDBC_DRIVER_PROPERTY_NAME = \"jdbc.driver\";\r\n-    private static final String JDBC_URL_PROPERTY_NAME = \"jdbc.url\";\r\n-    private static final String JDBC_USER_PROPERTY_NAME = \"jdbc.user\";\r\n-    private static final String JDBC_PASSWORD_PROPERTY_NAME = \"jdbc.password\";\r\n-    private static final String JDBC_SESSION_PROPERTY_PREFIX = \"jdbc.session.property.\";\r\n-    private static final String JDBC_CONNECTION_PROPERTY_PREFIX = \"jdbc.connection.property.\";\r\n-\r\n-    // connection parameter names\r\n-    private static final String JDBC_CONNECTION_TRANSACTION_ISOLATION = \"jdbc.connection.transactionIsolation\";\r\n-\r\n-    // statement properties\r\n-    private static final String JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME = \"jdbc.statement.batchSize\";\r\n-    private static final String JDBC_STATEMENT_FETCH_SIZE_PROPERTY_NAME = \"jdbc.statement.fetchSize\";\r\n-    private static final String JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME = \"jdbc.statement.queryTimeout\";\r\n-\r\n-    // connection pool properties\r\n-    private static final String JDBC_CONNECTION_POOL_ENABLED_PROPERTY_NAME = \"jdbc.pool.enabled\";\r\n-    private static final String JDBC_CONNECTION_POOL_PROPERTY_PREFIX = \"jdbc.pool.property.\";\r\n-    private static final String JDBC_POOL_QUALIFIER_PROPERTY_NAME = \"jdbc.pool.qualifier\";\r\n-\r\n-    // DDL option names\r\n-    private static final String JDBC_DRIVER_OPTION_NAME = \"JDBC_DRIVER\";\r\n-    private static final String JDBC_URL_OPTION_NAME = \"DB_URL\";\r\n-\r\n-    private static final String FORBIDDEN_SESSION_PROPERTY_CHARACTERS = \";\\n\\b\\0\";\r\n-    private static final String QUERY_NAME_PREFIX = \"query:\";\r\n-    private static final int QUERY_NAME_PREFIX_LENGTH = QUERY_NAME_PREFIX.length();\r\n-\r\n-    private static final String HIVE_URL_PREFIX = \"jdbc:hive2://\";\r\n-    private static final String HIVE_DEFAULT_DRIVER_CLASS = \"org.apache.hive.jdbc.HiveDriver\";\r\n-\r\n-    private enum TransactionIsolation {\r\n-        READ_UNCOMMITTED(1),\r\n-        READ_COMMITTED(2),\r\n-        REPEATABLE_READ(4),\r\n-        SERIALIZABLE(8),\r\n-        NOT_PROVIDED(-1);\r\n-\r\n-        private int isolationLevel;\r\n-\r\n-        TransactionIsolation(int transactionIsolation) {\r\n-            isolationLevel = transactionIsolation;\r\n-        }\r\n-\r\n-        public int getLevel() {\r\n-            return isolationLevel;\r\n-        }\r\n-\r\n-        public static TransactionIsolation typeOf(String str) {\r\n-            return valueOf(str);\r\n-        }\r\n-    }\r\n-\r\n-    // JDBC parameters from config file or specified in DDL\r\n-\r\n-    private String jdbcUrl;\r\n-\r\n-    protected String tableName;\r\n-\r\n-    // Write batch size\r\n-    protected int batchSize;\r\n-    protected boolean batchSizeIsSetByUser = false;\r\n-\r\n-    // Read batch size\r\n-    protected int fetchSize;\r\n-\r\n-    // Thread pool size\r\n-    protected int poolSize;\r\n-\r\n-    // Query timeout.\r\n-    protected Integer queryTimeout;\r\n-\r\n-    // Quote columns setting set by user (three values are possible)\r\n-    protected Boolean quoteColumns = null;\r\n-\r\n-    // Environment variables to SET before query execution\r\n-    protected Map<String, String> sessionConfiguration = new HashMap<String, String>();\r\n-\r\n-    // Properties object to pass to JDBC Driver when connection is created\r\n-    protected Properties connectionConfiguration = new Properties();\r\n-\r\n-    // Transaction isolation level that a user can configure\r\n-    private TransactionIsolation transactionIsolation = TransactionIsolation.NOT_PROVIDED;\r\n-\r\n-    // Columns description\r\n-    protected List<ColumnDescriptor> columns = null;\r\n-\r\n-    // Name of query to execute for read flow (optional)\r\n-    protected String queryName;\r\n-\r\n-    // connection pool fields\r\n-    private boolean isConnectionPoolUsed;\r\n-    private Properties poolConfiguration;\r\n-    private String poolQualifier;\r\n-\r\n-    private ConnectionManager connectionManager;\r\n-\r\n-    static {\r\n-        // Deprecated as of Oct 22, 2019 in version 5.9.2+\r\n-        Configuration.addDeprecation(\"pxf.impersonation.jdbc\",\r\n-                CONFIG_KEY_SERVICE_USER_IMPERSONATION,\r\n-                \"The property \\\"pxf.impersonation.jdbc\\\" has been deprecated in favor of \\\"pxf.service.user.impersonation\\\".\");\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a new instance with default (singleton) instance of ConnectionManager.\r\n-     */\r\n-    public JdbcBasePlugin() {\r\n-        this(ConnectionManager.getInstance());\r\n-    }\r\n-\r\n-    /**\r\n-     * Creates a new instance with the given ConnectionManager.\r\n-     *\r\n-     * @param connectionManager connection manager instance\r\n-     */\r\n-    JdbcBasePlugin(ConnectionManager connectionManager) {\r\n-        this.connectionManager = connectionManager;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void initialize(RequestContext context) {\r\n-        super.initialize(context);\r\n-\r\n-        // Required parameter. Can be auto-overwritten by user options\r\n-        String jdbcDriver = configuration.get(JDBC_DRIVER_PROPERTY_NAME);\r\n-        assertMandatoryParameter(jdbcDriver, JDBC_DRIVER_PROPERTY_NAME, JDBC_DRIVER_OPTION_NAME);\r\n-        try {\r\n-            LOG.debug(\"JDBC driver: '{}'\", jdbcDriver);\r\n-            Class.forName(jdbcDriver);\r\n-        } catch (ClassNotFoundException e) {\r\n-            throw new RuntimeException(e);\r\n-        }\r\n-\r\n-        // Required parameter. Can be auto-overwritten by user options\r\n-        jdbcUrl = configuration.get(JDBC_URL_PROPERTY_NAME);\r\n-        assertMandatoryParameter(jdbcUrl, JDBC_URL_PROPERTY_NAME, JDBC_URL_OPTION_NAME);\r\n-\r\n-        // Required metadata\r\n-        String dataSource = context.getDataSource();\r\n-        if (StringUtils.isBlank(dataSource)) {\r\n-            throw new IllegalArgumentException(\"Data source must be provided\");\r\n-        }\r\n-\r\n-        // Determine if the datasource is a table name or a query name\r\n-        if (dataSource.startsWith(QUERY_NAME_PREFIX)) {\r\n-            queryName = dataSource.substring(QUERY_NAME_PREFIX_LENGTH);\r\n-            if (StringUtils.isBlank(queryName)) {\r\n-                throw new IllegalArgumentException(String.format(\"Query name is not provided in data source [%s]\", dataSource));\r\n-            }\r\n-            LOG.debug(\"Query name is {}\", queryName);\r\n-        } else {\r\n-            tableName = dataSource;\r\n-            LOG.debug(\"Table name is {}\", tableName);\r\n-        }\r\n-\r\n-        // Required metadata\r\n-        columns = context.getTupleDescription();\r\n-\r\n-        // Optional parameters\r\n-        batchSizeIsSetByUser = configuration.get(JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME) != null;\r\n-        batchSize = configuration.getInt(JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME, DEFAULT_BATCH_SIZE);\r\n-\r\n-        if (batchSize == 0) {\r\n-            batchSize = 1; // if user set to 0, it is the same as batchSize of 1\r\n-        } else if (batchSize < 0) {\r\n-            throw new IllegalArgumentException(String.format(\r\n-                    \"Property %s has incorrect value %s : must be a non-negative integer\", JDBC_STATEMENT_BATCH_SIZE_PROPERTY_NAME, batchSize));\r\n-        }\r\n-\r\n-        fetchSize = configuration.getInt(JDBC_STATEMENT_FETCH_SIZE_PROPERTY_NAME, DEFAULT_FETCH_SIZE);\r\n-\r\n-        poolSize = context.getOption(\"POOL_SIZE\", DEFAULT_POOL_SIZE);\r\n-\r\n-        String queryTimeoutString = configuration.get(JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME);\r\n-        if (StringUtils.isNotBlank(queryTimeoutString)) {\r\n-            try {\r\n-                queryTimeout = Integer.parseUnsignedInt(queryTimeoutString);\r\n-            } catch (NumberFormatException e) {\r\n-                throw new IllegalArgumentException(String.format(\r\n-                        \"Property %s has incorrect value %s : must be a non-negative integer\",\r\n-                        JDBC_STATEMENT_QUERY_TIMEOUT_PROPERTY_NAME, queryTimeoutString), e);\r\n-            }\r\n-        }\r\n-\r\n-        // Optional parameter. The default value is null\r\n-        String quoteColumnsRaw = context.getOption(\"QUOTE_COLUMNS\");\r\n-        if (quoteColumnsRaw != null) {\r\n-            quoteColumns = Boolean.parseBoolean(quoteColumnsRaw);\r\n-        }\r\n-\r\n-        // Optional parameter. The default value is empty map\r\n-        sessionConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_SESSION_PROPERTY_PREFIX));\r\n-        // Check forbidden symbols\r\n-        // Note: PreparedStatement enables us to skip this check: its values are distinct from its SQL code\r\n-        // However, SET queries cannot be executed this way. This is why we do this check\r\n-        if (sessionConfiguration.entrySet().stream()\r\n-                .anyMatch(\r\n-                        entry ->\r\n-                                StringUtils.containsAny(\r\n-                                        entry.getKey(), FORBIDDEN_SESSION_PROPERTY_CHARACTERS\r\n-                                ) ||\r\n-                                        StringUtils.containsAny(\r\n-                                                entry.getValue(), FORBIDDEN_SESSION_PROPERTY_CHARACTERS\r\n-                                        )\r\n-                )\r\n-        ) {\r\n-            throw new IllegalArgumentException(\"Some session configuration parameter contains forbidden characters\");\r\n-        }\r\n-        if (LOG.isDebugEnabled()) {\r\n-            LOG.debug(\"Session configuration: {}\",\r\n-                    sessionConfiguration.entrySet().stream()\r\n-                            .map(entry -> \"'\" + entry.getKey() + \"'='\" + entry.getValue() + \"'\")\r\n-                            .collect(Collectors.joining(\", \"))\r\n-            );\r\n-        }\r\n-\r\n-        // Optional parameter. The default value is empty map\r\n-        connectionConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_CONNECTION_PROPERTY_PREFIX));\r\n-\r\n-        // Optional parameter. The default value depends on the database\r\n-        String transactionIsolationString = configuration.get(JDBC_CONNECTION_TRANSACTION_ISOLATION, \"NOT_PROVIDED\");\r\n-        transactionIsolation = TransactionIsolation.typeOf(transactionIsolationString);\r\n-\r\n-        // Set optional user parameter, taking into account impersonation setting for the server.\r\n-        String jdbcUser = configuration.get(JDBC_USER_PROPERTY_NAME);\r\n-        boolean impersonationEnabledForServer = configuration.getBoolean(CONFIG_KEY_SERVICE_USER_IMPERSONATION, false);\r\n-        LOG.debug(\"JDBC impersonation is {}enabled for server {}\", impersonationEnabledForServer ? \"\" : \"not \", context.getServerName());\r\n-        if (impersonationEnabledForServer) {\r\n-            if (Utilities.isSecurityEnabled(configuration) && StringUtils.startsWith(jdbcUrl, HIVE_URL_PREFIX)) {\r\n-                // secure impersonation for Hive JDBC driver requires setting URL fragment that cannot be overwritten by properties\r\n-                String updatedJdbcUrl = HiveJdbcUtils.updateImpersonationPropertyInHiveJdbcUrl(jdbcUrl, context.getUser());\r\n-                LOG.debug(\"Replaced JDBC URL {} with {}\", jdbcUrl, updatedJdbcUrl);\r\n-                jdbcUrl = updatedJdbcUrl;\r\n-            } else {\r\n-                // the jdbcUser is the GPDB user\r\n-                jdbcUser = context.getUser();\r\n-            }\r\n-        }\r\n-        if (jdbcUser != null) {\r\n-            LOG.debug(\"Effective JDBC user {}\", jdbcUser);\r\n-            connectionConfiguration.setProperty(\"user\", jdbcUser);\r\n-        } else {\r\n-            LOG.debug(\"JDBC user has not been set\");\r\n-        }\r\n-\r\n-        if (LOG.isDebugEnabled()) {\r\n-            LOG.debug(\"Connection configuration: {}\",\r\n-                    connectionConfiguration.entrySet().stream()\r\n-                            .map(entry -> \"'\" + entry.getKey() + \"'='\" + entry.getValue() + \"'\")\r\n-                            .collect(Collectors.joining(\", \"))\r\n-            );\r\n-        }\r\n-\r\n-        // This must be the last parameter parsed, as we output connectionConfiguration earlier\r\n-        // Optional parameter. By default, corresponding connectionConfiguration property is not set\r\n-        if (jdbcUser != null) {\r\n-            String jdbcPassword = configuration.get(JDBC_PASSWORD_PROPERTY_NAME);\r\n-            if (jdbcPassword != null) {\r\n-                LOG.debug(\"Connection password: {}\", ConnectionManager.maskPassword(jdbcPassword));\r\n-                connectionConfiguration.setProperty(\"password\", jdbcPassword);\r\n-            }\r\n-        }\r\n-\r\n-        // connection pool is optional, enabled by default\r\n-        isConnectionPoolUsed = configuration.getBoolean(JDBC_CONNECTION_POOL_ENABLED_PROPERTY_NAME, true);\r\n-        LOG.debug(\"Connection pool is {}enabled\", isConnectionPoolUsed ? \"\" : \"not \");\r\n-        if (isConnectionPoolUsed) {\r\n-            poolConfiguration = new Properties();\r\n-            // for PXF upgrades where jdbc-site template has not been updated, make sure there're sensible defaults\r\n-            poolConfiguration.setProperty(\"maximumPoolSize\", \"5\");\r\n-            poolConfiguration.setProperty(\"connectionTimeout\", \"30000\");\r\n-            poolConfiguration.setProperty(\"idleTimeout\", \"30000\");\r\n-            poolConfiguration.setProperty(\"minimumIdle\", \"0\");\r\n-            // apply values read from the template\r\n-            poolConfiguration.putAll(getPropsWithPrefix(configuration, JDBC_CONNECTION_POOL_PROPERTY_PREFIX));\r\n-\r\n-            // packaged Hive JDBC Driver does not support connection.isValid() method, so we need to force set\r\n-            // connectionTestQuery parameter in this case, unless already set by the user\r\n-            if (jdbcUrl.startsWith(HIVE_URL_PREFIX) && HIVE_DEFAULT_DRIVER_CLASS.equals(jdbcDriver) && poolConfiguration.getProperty(\"connectionTestQuery\") == null) {\r\n-                poolConfiguration.setProperty(\"connectionTestQuery\", \"SELECT 1\");\r\n-            }\r\n-\r\n-            // get the qualifier for connection pool, if configured. Might be used when connection session authorization is employed\r\n-            // to switch effective user once connection is established\r\n-            poolQualifier = configuration.get(JDBC_POOL_QUALIFIER_PROPERTY_NAME);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Open a new JDBC connection\r\n-     *\r\n-     * @return {@link Connection}\r\n-     * @throws SQLException if a database access or connection error occurs\r\n-     */\r\n-    public Connection getConnection() throws SQLException {\r\n-        LOG.debug(\"Requesting a new JDBC connection. URL={} table={} txid:seg={}:{}\", jdbcUrl, tableName, context.getTransactionId(), context.getSegmentId());\r\n-\r\n-        Connection connection = null;\r\n-        try {\r\n-            connection = getConnectionInternal();\r\n-            LOG.debug(\"Obtained a JDBC connection {} for URL={} table={} txid:seg={}:{}\", connection, jdbcUrl, tableName, context.getTransactionId(), context.getSegmentId());\r\n-\r\n-            prepareConnection(connection);\r\n-        } catch (Exception e) {\r\n-            closeConnection(connection);\r\n-            if (e instanceof SQLException) {\r\n-                throw (SQLException) e;\r\n-            } else {\r\n-                String msg = e.getMessage();\r\n-                if (msg == null) {\r\n-                    Throwable t = e.getCause();\r\n-                    if (t != null) msg = t.getMessage();\r\n-                }\r\n-                throw new SQLException(msg, e);\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    /**\r\n-     * Prepare a JDBC PreparedStatement\r\n-     *\r\n-     * @param connection connection to use for creating the statement\r\n-     * @param query      query to execute\r\n-     * @return PreparedStatement\r\n-     * @throws SQLException if a database access error occurs\r\n-     */\r\n-    public PreparedStatement getPreparedStatement(Connection connection, String query) throws SQLException {\r\n-        if ((connection == null) || (query == null)) {\r\n-            throw new IllegalArgumentException(\"The provided query or connection is null\");\r\n-        }\r\n-        PreparedStatement statement = connection.prepareStatement(query);\r\n-        if (queryTimeout != null) {\r\n-            LOG.debug(\"Setting query timeout to {} seconds\", queryTimeout);\r\n-            statement.setQueryTimeout(queryTimeout);\r\n-        }\r\n-        return statement;\r\n-    }\r\n-\r\n-    /**\r\n-     * Close a JDBC statement and underlying {@link Connection}\r\n-     *\r\n-     * @param statement statement to close\r\n-     * @throws SQLException\r\n-     */\r\n-    public static void closeStatementAndConnection(Statement statement) throws SQLException {\r\n-        if (statement == null) {\r\n-            LOG.warn(\"Call to close statement and connection is ignored as statement provided was null\");\r\n-            return;\r\n-        }\r\n-\r\n-        SQLException exception = null;\r\n-        Connection connection = null;\r\n-\r\n-        try {\r\n-            connection = statement.getConnection();\r\n-        } catch (SQLException e) {\r\n-            LOG.error(\"Exception when retrieving Connection from Statement\", e);\r\n-            exception = e;\r\n-        }\r\n-\r\n-        try {\r\n-            LOG.debug(\"Closing statement for connection {}\", connection);\r\n-            statement.close();\r\n-        } catch (SQLException e) {\r\n-            LOG.error(\"Exception when closing Statement\", e);\r\n-            exception = e;\r\n-        }\r\n-\r\n-        try {\r\n-            closeConnection(connection);\r\n-        } catch (SQLException e) {\r\n-            LOG.error(String.format(\"Exception when closing connection %s\", connection), e);\r\n-            exception = e;\r\n-        }\r\n-\r\n-        if (exception != null) {\r\n-            throw exception;\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * For a Kerberized Hive JDBC connection, it creates a connection as the loginUser.\r\n-     * Otherwise, it returns a new connection.\r\n-     *\r\n-     * @return for a Kerberized Hive JDBC connection, returns a new connection as the loginUser.\r\n-     * Otherwise, it returns a new connection.\r\n-     * @throws Exception\r\n-     */\r\n-    private Connection getConnectionInternal() throws Exception {\r\n-        if (Utilities.isSecurityEnabled(configuration) && StringUtils.startsWith(jdbcUrl, HIVE_URL_PREFIX)) {\r\n-            return SecureLogin.getInstance().getLoginUser(context, configuration).\r\n-                    doAs((PrivilegedExceptionAction<Connection>) () ->\r\n-                            connectionManager.getConnection(context.getServerName(), jdbcUrl, connectionConfiguration, isConnectionPoolUsed, poolConfiguration, poolQualifier));\r\n-\r\n-        } else {\r\n-            return connectionManager.getConnection(context.getServerName(), jdbcUrl, connectionConfiguration, isConnectionPoolUsed, poolConfiguration, poolQualifier);\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Close a JDBC connection\r\n-     *\r\n-     * @param connection connection to close\r\n-     * @throws SQLException\r\n-     */\r\n-    private static void closeConnection(Connection connection) throws SQLException {\r\n-        if (connection == null) {\r\n-            LOG.warn(\"Call to close connection is ignored as connection provided was null\");\r\n-            return;\r\n-        }\r\n-        try {\r\n-            if (!connection.isClosed() &&\r\n-                    connection.getMetaData().supportsTransactions() &&\r\n-                    !connection.getAutoCommit()) {\r\n-\r\n-                LOG.debug(\"Committing transaction (as part of connection.close()) on connection {}\", connection);\r\n-                connection.commit();\r\n-            }\r\n-        } finally {\r\n-            try {\r\n-                LOG.debug(\"Closing connection {}\", connection);\r\n-                connection.close();\r\n-            } catch (Exception e) {\r\n-                // ignore\r\n-                LOG.warn(String.format(\"Failed to close JDBC connection %s, ignoring the error.\", connection), e);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Prepare JDBC connection by setting session-level variables in external database\r\n-     *\r\n-     * @param connection {@link Connection} to prepare\r\n-     */\r\n-    private void prepareConnection(Connection connection) throws SQLException {\r\n-        if (connection == null) {\r\n-            throw new IllegalArgumentException(\"The provided connection is null\");\r\n-        }\r\n-\r\n-        DatabaseMetaData metadata = connection.getMetaData();\r\n-\r\n-        // Handle optional connection transaction isolation level\r\n-        if (transactionIsolation != TransactionIsolation.NOT_PROVIDED) {\r\n-            // user wants to set isolation level explicitly\r\n-            if (metadata.supportsTransactionIsolationLevel(transactionIsolation.getLevel())) {\r\n-                LOG.debug(\"Setting transaction isolation level to {} on connection {}\", transactionIsolation.toString(), connection);\r\n-                connection.setTransactionIsolation(transactionIsolation.getLevel());\r\n-            } else {\r\n-                throw new RuntimeException(\r\n-                        String.format(\"Transaction isolation level %s is not supported\", transactionIsolation.toString())\r\n-                );\r\n-            }\r\n-        }\r\n-\r\n-        // Disable autocommit\r\n-        if (metadata.supportsTransactions()) {\r\n-            LOG.debug(\"Setting autoCommit to false on connection {}\", connection);\r\n-            connection.setAutoCommit(false);\r\n-        }\r\n-\r\n-        // Prepare session (process sessionConfiguration)\r\n-        if (!sessionConfiguration.isEmpty()) {\r\n-            DbProduct dbProduct = DbProduct.getDbProduct(metadata.getDatabaseProductName());\r\n-\r\n-            try (Statement statement = connection.createStatement()) {\r\n-                for (Map.Entry<String, String> e : sessionConfiguration.entrySet()) {\r\n-                    String sessionQuery = dbProduct.buildSessionQuery(e.getKey(), e.getValue());\r\n-                    LOG.debug(\"Executing statement {} on connection {}\", sessionQuery, connection);\r\n-                    statement.execute(sessionQuery);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Asserts whether a given parameter has non-empty value, throws IllegalArgumentException otherwise\r\n-     *\r\n-     * @param value      value to check\r\n-     * @param paramName  parameter name\r\n-     * @param optionName name of the option for a given parameter\r\n-     */\r\n-    private void assertMandatoryParameter(String value, String paramName, String optionName) {\r\n-        if (StringUtils.isBlank(value)) {\r\n-            throw new IllegalArgumentException(String.format(\r\n-                    \"Required parameter %s is missing or empty in jdbc-site.xml and option %s is not specified in table definition.\", paramName, optionName)\r\n-            );\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructs a mapping of configuration and includes all properties that start with the specified\r\n-     * configuration prefix.  Property names in the mapping are trimmed to remove the configuration prefix.\r\n-     * This is a method from Hadoop's Configuration class ported here to make older and custom versions of Hadoop\r\n-     * work with JDBC profile.\r\n-     *\r\n-     * @param configuration configuration map\r\n-     * @param confPrefix    configuration prefix\r\n-     * @return mapping of configuration properties with prefix stripped\r\n-     */\r\n-    private Map<String, String> getPropsWithPrefix(Configuration configuration, String confPrefix) {\r\n-        Map<String, String> configMap = new HashMap<>();\r\n-        Iterator<Map.Entry<String, String>> it = configuration.iterator();\r\n-        while (it.hasNext()) {\r\n-            String propertyName = it.next().getKey();\r\n-            if (propertyName.startsWith(confPrefix)) {\r\n-                // do not use value from the iterator as it might not come with variable substitution\r\n-                String value = configuration.get(propertyName);\r\n-                String keyName = propertyName.substring(confPrefix.length());\r\n-                configMap.put(keyName, value);\r\n-            }\r\n-        }\r\n-        return configMap;\r\n-    }\r\n-\r\n-}\r\n+package org.greenplum.pxf.plugins.jdbc;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUyODUzMw=="}, "originalCommit": {"oid": "057403a900e5da7a67dda63e9ebdb1e20467f0d6"}, "originalPosition": 583}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMDI2MzY1OnYy", "diffSide": "RIGHT", "path": "server/pxf-jdbc/src/test/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePluginTestInitialize.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxODo1Njo0NVrOF0cwlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMDo1ODowMFrOF0gusA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0MTQ2Mg==", "bodyText": "while this is fine, using @rule method would allow to check for the error message as well.", "url": "https://github.com/greenplum-db/pxf/pull/311#discussion_r390541462", "createdAt": "2020-03-10T18:56:45Z", "author": {"login": "denalex"}, "path": "server/pxf-jdbc/src/test/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePluginTestInitialize.java", "diffHunk": "@@ -189,7 +193,35 @@ public void testBatchSize2() throws Exception {\n \n         // Checks\n         assertEquals(2, getInternalState(plugin, \"batchSize\"));\n-        assertTrue((boolean)getInternalState(plugin, \"batchSizeIsSetByUser\"));\n+        assertTrue((boolean) getInternalState(plugin, \"batchSizeIsSetByUser\"));\n+    }\n+\n+    @Test\n+    public void testBatchSizeOnRead() throws Exception {\n+        // Configuration\n+        Configuration configuration = makeConfiguration();\n+        configuration.set(\"jdbc.statement.batchSize\", \"foobar\");\n+\n+        // Initialize plugin\n+        prepareBaseConfigurationFactory(configuration);\n+        JdbcBasePlugin plugin = new JdbcBasePlugin();\n+        RequestContext context = makeContext();\n+        context.setRequestType(RequestContext.RequestType.READ_BRIDGE);\n+        plugin.initialize(context);\n+\n+        // should not error because we don't validate this on the READ path\n+    }\n+\n+    @Test(expected = NumberFormatException.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "057403a900e5da7a67dda63e9ebdb1e20467f0d6"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU5MzYyMA==", "bodyText": "How'd I know you would say this?", "url": "https://github.com/greenplum-db/pxf/pull/311#discussion_r390593620", "createdAt": "2020-03-10T20:33:22Z", "author": {"login": "oliverralbertini"}, "path": "server/pxf-jdbc/src/test/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePluginTestInitialize.java", "diffHunk": "@@ -189,7 +193,35 @@ public void testBatchSize2() throws Exception {\n \n         // Checks\n         assertEquals(2, getInternalState(plugin, \"batchSize\"));\n-        assertTrue((boolean)getInternalState(plugin, \"batchSizeIsSetByUser\"));\n+        assertTrue((boolean) getInternalState(plugin, \"batchSizeIsSetByUser\"));\n+    }\n+\n+    @Test\n+    public void testBatchSizeOnRead() throws Exception {\n+        // Configuration\n+        Configuration configuration = makeConfiguration();\n+        configuration.set(\"jdbc.statement.batchSize\", \"foobar\");\n+\n+        // Initialize plugin\n+        prepareBaseConfigurationFactory(configuration);\n+        JdbcBasePlugin plugin = new JdbcBasePlugin();\n+        RequestContext context = makeContext();\n+        context.setRequestType(RequestContext.RequestType.READ_BRIDGE);\n+        plugin.initialize(context);\n+\n+        // should not error because we don't validate this on the READ path\n+    }\n+\n+    @Test(expected = NumberFormatException.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0MTQ2Mg=="}, "originalCommit": {"oid": "057403a900e5da7a67dda63e9ebdb1e20467f0d6"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwNjUxMg==", "bodyText": "I switched all the tests to use @Rule", "url": "https://github.com/greenplum-db/pxf/pull/311#discussion_r390606512", "createdAt": "2020-03-10T20:58:00Z", "author": {"login": "oliverralbertini"}, "path": "server/pxf-jdbc/src/test/java/org/greenplum/pxf/plugins/jdbc/JdbcBasePluginTestInitialize.java", "diffHunk": "@@ -189,7 +193,35 @@ public void testBatchSize2() throws Exception {\n \n         // Checks\n         assertEquals(2, getInternalState(plugin, \"batchSize\"));\n-        assertTrue((boolean)getInternalState(plugin, \"batchSizeIsSetByUser\"));\n+        assertTrue((boolean) getInternalState(plugin, \"batchSizeIsSetByUser\"));\n+    }\n+\n+    @Test\n+    public void testBatchSizeOnRead() throws Exception {\n+        // Configuration\n+        Configuration configuration = makeConfiguration();\n+        configuration.set(\"jdbc.statement.batchSize\", \"foobar\");\n+\n+        // Initialize plugin\n+        prepareBaseConfigurationFactory(configuration);\n+        JdbcBasePlugin plugin = new JdbcBasePlugin();\n+        RequestContext context = makeContext();\n+        context.setRequestType(RequestContext.RequestType.READ_BRIDGE);\n+        plugin.initialize(context);\n+\n+        // should not error because we don't validate this on the READ path\n+    }\n+\n+    @Test(expected = NumberFormatException.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0MTQ2Mg=="}, "originalCommit": {"oid": "057403a900e5da7a67dda63e9ebdb1e20467f0d6"}, "originalPosition": 74}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3589, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}