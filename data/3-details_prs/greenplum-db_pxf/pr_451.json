{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3Mzg2NDEw", "number": 451, "title": "Support dropping columns in PXF external tables", "bodyText": "PXF does not support dropping columns from readable external tables.\nThis commit adds support for dropping columns, especially when the\nformat is CUSTOM and the formatter is pxfwritable_import. This also\napplies for TEXT/CSV format, but the complexity lies in the\npxfwritable_import formatter. Add automation tests for altering PXF\nreadable external tables.\nPXF does not support dropping columns from writable external tables.\nThis commit adds support for dropping columns in PXF writable external\ntables. The complexity of the implementation lies in the\npxfwritable_export formatter. Add automation tests for altering PXF\nwritable external tables.", "createdAt": "2020-09-15T15:39:15Z", "url": "https://github.com/greenplum-db/pxf/pull/451", "merged": true, "mergeCommit": {"oid": "0f19e424d27fe8935970ae3b339716b487ebb3d7"}, "closed": true, "closedAt": "2020-09-23T00:49:05Z", "author": {"login": "frankgh"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdJ49iPgFqTQ5MTAxOTE5MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdLhepwgBqjM3OTU2Nzg2OTY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxMDE5MTkx", "url": "https://github.com/greenplum-db/pxf/pull/451#pullrequestreview-491019191", "createdAt": "2020-09-17T22:01:26Z", "commit": {"oid": "904003217a18f82003afbc540c1c01398c5bce5c"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMjowMToyN1rOHT3CLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMjowNjoxMlrOHT3Jog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NjY3MQ==", "bodyText": "why do you need sleep?", "url": "https://github.com/greenplum-db/pxf/pull/451#discussion_r490586671", "createdAt": "2020-09-17T22:01:27Z", "author": {"login": "ashuka24"}, "path": "automation/src/test/java/org/greenplum/pxf/automation/features/general/AlterTableTest.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.greenplum.pxf.automation.features.general;\n+\n+import org.greenplum.pxf.automation.features.BaseFeature;\n+import org.greenplum.pxf.automation.structures.tables.basic.Table;\n+import org.greenplum.pxf.automation.structures.tables.pxf.ReadableExternalTable;\n+import org.greenplum.pxf.automation.structures.tables.pxf.WritableExternalTable;\n+import org.greenplum.pxf.automation.structures.tables.utils.TableFactory;\n+import org.greenplum.pxf.automation.utils.system.ProtocolEnum;\n+import org.greenplum.pxf.automation.utils.system.ProtocolUtils;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static java.lang.Thread.sleep;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "904003217a18f82003afbc540c1c01398c5bce5c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NzIzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Attempt to query data on a table that has a column that does not exist.\n          \n          \n            \n                 * Attempt to query data on a table with column that does not exist.", "url": "https://github.com/greenplum-db/pxf/pull/451#discussion_r490587233", "createdAt": "2020-09-17T22:02:55Z", "author": {"login": "ashuka24"}, "path": "automation/src/test/java/org/greenplum/pxf/automation/features/general/AlterTableTest.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.greenplum.pxf.automation.features.general;\n+\n+import org.greenplum.pxf.automation.features.BaseFeature;\n+import org.greenplum.pxf.automation.structures.tables.basic.Table;\n+import org.greenplum.pxf.automation.structures.tables.pxf.ReadableExternalTable;\n+import org.greenplum.pxf.automation.structures.tables.pxf.WritableExternalTable;\n+import org.greenplum.pxf.automation.structures.tables.utils.TableFactory;\n+import org.greenplum.pxf.automation.utils.system.ProtocolEnum;\n+import org.greenplum.pxf.automation.utils.system.ProtocolUtils;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static java.lang.Thread.sleep;\n+\n+public class AlterTableTest extends BaseFeature {\n+\n+    private static final String AVRO_TYPES_FILE_NAME = \"supported_primitive_types\";\n+    private static final String FILE_SCHEME = \"file://\";\n+    private static final String PXF_ALTER_AVRO_TABLE = \"pxf_alter_avro_table\";\n+    private static final String PXF_ALTER_CSV_TABLE = \"pxf_alter_csv_table\";\n+    private static final String PXF_PARQUET_TABLE_SOURCE = \"pxf_alter_parquet_primitive_types\";\n+    private static final String PXF_ALTER_PARQUET_TABLE = \"pxf_alter_parquet_table\";\n+    private static final String PXF_ALTER_WRITE_PARQUET_TABLE = \"pxf_alter_write_parquet_table\";\n+    private static final String PARQUET_PRIMITIVE_TYPES = \"parquet_primitive_types\";\n+    private static final String PARQUET_WRITE_PRIMITIVES = \"parquet_write_primitives\";\n+    private static final String SUFFIX_JSON = \".json\";\n+    private static final String SUFFIX_AVRO = \".avro\";\n+    private static final String SUFFIX_AVSC = \".avsc\";\n+\n+    private static final String[] PARQUET_TABLE_COLUMNS = new String[]{\n+            \"s1    TEXT\",\n+            \"s2    TEXT\",\n+            \"n1    INTEGER\",\n+            \"d1    DOUBLE PRECISION\",\n+            \"dc1   NUMERIC\",\n+            \"tm    TIMESTAMP\",\n+            \"f     REAL\",\n+            \"bg    BIGINT\",\n+            \"b     BOOLEAN\",\n+            \"tn    SMALLINT\",\n+            \"vc1   VARCHAR(5)\",\n+            \"sml   SMALLINT\",\n+            \"c1    CHAR(3)\",\n+            \"bin   BYTEA\"\n+    };\n+\n+    private static final String[] PARQUET_TABLE_SUBSET_COLUMNS = new String[]{\n+            \"s1    TEXT\",\n+            \"s2    TEXT\",\n+            \"n1    INTEGER\",\n+            \"d1    DOUBLE PRECISION\",\n+            \"dc1   NUMERIC\",\n+            \"f     REAL\",\n+            \"bg    BIGINT\",\n+            \"b     BOOLEAN\",\n+            \"tn    SMALLINT\",\n+            \"vc1   VARCHAR(5)\",\n+            \"sml   SMALLINT\",\n+            \"c1    CHAR(3)\"\n+    };\n+\n+    private String hdfsPath;\n+\n+    @Override\n+    public void beforeClass() throws Exception {\n+        // path for storing data on HDFS (for processing by PXF)\n+        hdfsPath = hdfs.getWorkingDirectory() + \"/alter-tests\";\n+\n+        String resourcePath = localDataResourcesFolder + \"/parquet/\";\n+        hdfs.copyFromLocal(resourcePath + PARQUET_PRIMITIVE_TYPES, hdfsPath + \"/parquet/\" + PARQUET_PRIMITIVE_TYPES);\n+\n+        // Create Data and write it to HDFS\n+        Table dataTable = getSmallData();\n+        hdfs.writeTableToFile(hdfsPath + \"/csv/\" + fileName, dataTable, \",\");\n+\n+        // Avro\n+        // location of schema and data files\n+        String absolutePath = getClass().getClassLoader().getResource(\"data\").getPath();\n+        resourcePath = absolutePath + \"/avro/\";\n+        hdfs.writeAvroFileFromJson(hdfsPath + \"/avro/\" + AVRO_TYPES_FILE_NAME + SUFFIX_AVRO,\n+                FILE_SCHEME + resourcePath + AVRO_TYPES_FILE_NAME + SUFFIX_AVSC,\n+                FILE_SCHEME + resourcePath + AVRO_TYPES_FILE_NAME + SUFFIX_JSON, null);\n+    }\n+\n+    /**\n+     * Query data on a table, then drops column(s), then queries again.\n+     * Finally, the test adds back one of the dropped columns to the table,\n+     * and a new query is performed. The query uses parquet which supports\n+     * column projection, and uses the pxfwritable_import formatter.\n+     *\n+     * @throws Exception when the test execution fails\n+     */\n+    @Test(groups = {\"features\", \"gpdb\", \"security\"})\n+    public void dropAndAddColumnsPxfWritableImportWithColumnProjectionSupport() throws Exception {\n+\n+        exTable = new ReadableExternalTable(PXF_ALTER_PARQUET_TABLE,\n+                PARQUET_TABLE_COLUMNS, hdfsPath + \"/parquet/\" + PARQUET_PRIMITIVE_TYPES, \"custom\");\n+        exTable.setHost(pxfHost);\n+        exTable.setPort(pxfPort);\n+        exTable.setFormatter(\"pxfwritable_import\");\n+        exTable.setProfile(ProtocolUtils.getProtocol().value() + \":parquet\");\n+\n+        gpdb.createTableAndVerify(exTable);\n+\n+        runTincTest(\"pxf.features.general.alter.pxfwritable_import.with_column_projection.runTest\");\n+    }\n+\n+    @Test(groups = {\"features\", \"gpdb\", \"security\"})\n+    public void dropColumnsPxfWritableExport() throws Exception {\n+\n+        // Create source table\n+        exTable = new ReadableExternalTable(PXF_PARQUET_TABLE_SOURCE,\n+                PARQUET_TABLE_COLUMNS, hdfsPath + \"/parquet/\" + PARQUET_PRIMITIVE_TYPES, \"custom\");\n+        exTable.setHost(pxfHost);\n+        exTable.setPort(pxfPort);\n+        exTable.setFormatter(\"pxfwritable_import\");\n+        exTable.setProfile(ProtocolUtils.getProtocol().value() + \":parquet\");\n+        gpdb.createTableAndVerify(exTable);\n+\n+        // Create writable table\n+        exTable = new WritableExternalTable(PXF_ALTER_WRITE_PARQUET_TABLE,\n+                PARQUET_TABLE_COLUMNS, hdfsPath + \"/parquet-write/\" + PARQUET_WRITE_PRIMITIVES, \"custom\");\n+        exTable.setHost(pxfHost);\n+        exTable.setPort(pxfPort);\n+        exTable.setFormatter(\"pxfwritable_export\");\n+        exTable.setProfile(ProtocolUtils.getProtocol().value() + \":parquet\");\n+        gpdb.createTableAndVerify(exTable);\n+\n+        // Create validation table\n+        exTable = new ReadableExternalTable(PXF_ALTER_WRITE_PARQUET_TABLE + \"_r\",\n+                PARQUET_TABLE_SUBSET_COLUMNS, hdfsPath + \"/parquet-write/\" + PARQUET_WRITE_PRIMITIVES, \"custom\");\n+        exTable.setHost(pxfHost);\n+        exTable.setPort(pxfPort);\n+        exTable.setFormatter(\"pxfwritable_import\");\n+        exTable.setProfile(ProtocolUtils.getProtocol().value() + \":parquet\");\n+        gpdb.createTableAndVerify(exTable);\n+\n+        runTincTest(\"pxf.features.general.alter.pxfwritable_export.parquet.runTest\");\n+    }\n+\n+    @Test(groups = {\"features\", \"gpdb\", \"security\"})\n+    public void dropAndAddColumnsPxfWritableImportWithoutColumnProjectionSupport() throws Exception {\n+        // default external table with common settings\n+        exTable = new ReadableExternalTable(PXF_ALTER_AVRO_TABLE, new String[]{\n+                \"type_int int\",\n+                \"type_double float8\",\n+                \"type_string text\",\n+                \"type_float real\",\n+                \"col_does_not_exist text\",\n+                \"type_long bigint\",\n+                \"type_bytes bytea\",\n+                \"type_boolean bool\"}, hdfsPath + \"/avro/\" + AVRO_TYPES_FILE_NAME + SUFFIX_AVRO, \"custom\");\n+        exTable.setHost(pxfHost);\n+        exTable.setPort(pxfPort);\n+        exTable.setFormatter(\"pxfwritable_import\");\n+        exTable.setProfile(ProtocolUtils.getProtocol().value() + \":avro\");\n+\n+        gpdb.createTableAndVerify(exTable);\n+\n+        // Verify results\n+        runTincTest(\"pxf.features.general.alter.pxfwritable_import.without_column_projection.runTest\");\n+    }\n+\n+    /**\n+     * Attempt to query data on a table that has a column that does not exist.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "904003217a18f82003afbc540c1c01398c5bce5c"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NzczMA==", "bodyText": "could you please clarify this? if it tries to query data on a non-existent column, then what exactly is being dropped?", "url": "https://github.com/greenplum-db/pxf/pull/451#discussion_r490587730", "createdAt": "2020-09-17T22:04:08Z", "author": {"login": "ashuka24"}, "path": "automation/src/test/java/org/greenplum/pxf/automation/features/general/AlterTableTest.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.greenplum.pxf.automation.features.general;\n+\n+import org.greenplum.pxf.automation.features.BaseFeature;\n+import org.greenplum.pxf.automation.structures.tables.basic.Table;\n+import org.greenplum.pxf.automation.structures.tables.pxf.ReadableExternalTable;\n+import org.greenplum.pxf.automation.structures.tables.pxf.WritableExternalTable;\n+import org.greenplum.pxf.automation.structures.tables.utils.TableFactory;\n+import org.greenplum.pxf.automation.utils.system.ProtocolEnum;\n+import org.greenplum.pxf.automation.utils.system.ProtocolUtils;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static java.lang.Thread.sleep;\n+\n+public class AlterTableTest extends BaseFeature {\n+\n+    private static final String AVRO_TYPES_FILE_NAME = \"supported_primitive_types\";\n+    private static final String FILE_SCHEME = \"file://\";\n+    private static final String PXF_ALTER_AVRO_TABLE = \"pxf_alter_avro_table\";\n+    private static final String PXF_ALTER_CSV_TABLE = \"pxf_alter_csv_table\";\n+    private static final String PXF_PARQUET_TABLE_SOURCE = \"pxf_alter_parquet_primitive_types\";\n+    private static final String PXF_ALTER_PARQUET_TABLE = \"pxf_alter_parquet_table\";\n+    private static final String PXF_ALTER_WRITE_PARQUET_TABLE = \"pxf_alter_write_parquet_table\";\n+    private static final String PARQUET_PRIMITIVE_TYPES = \"parquet_primitive_types\";\n+    private static final String PARQUET_WRITE_PRIMITIVES = \"parquet_write_primitives\";\n+    private static final String SUFFIX_JSON = \".json\";\n+    private static final String SUFFIX_AVRO = \".avro\";\n+    private static final String SUFFIX_AVSC = \".avsc\";\n+\n+    private static final String[] PARQUET_TABLE_COLUMNS = new String[]{\n+            \"s1    TEXT\",\n+            \"s2    TEXT\",\n+            \"n1    INTEGER\",\n+            \"d1    DOUBLE PRECISION\",\n+            \"dc1   NUMERIC\",\n+            \"tm    TIMESTAMP\",\n+            \"f     REAL\",\n+            \"bg    BIGINT\",\n+            \"b     BOOLEAN\",\n+            \"tn    SMALLINT\",\n+            \"vc1   VARCHAR(5)\",\n+            \"sml   SMALLINT\",\n+            \"c1    CHAR(3)\",\n+            \"bin   BYTEA\"\n+    };\n+\n+    private static final String[] PARQUET_TABLE_SUBSET_COLUMNS = new String[]{\n+            \"s1    TEXT\",\n+            \"s2    TEXT\",\n+            \"n1    INTEGER\",\n+            \"d1    DOUBLE PRECISION\",\n+            \"dc1   NUMERIC\",\n+            \"f     REAL\",\n+            \"bg    BIGINT\",\n+            \"b     BOOLEAN\",\n+            \"tn    SMALLINT\",\n+            \"vc1   VARCHAR(5)\",\n+            \"sml   SMALLINT\",\n+            \"c1    CHAR(3)\"\n+    };\n+\n+    private String hdfsPath;\n+\n+    @Override\n+    public void beforeClass() throws Exception {\n+        // path for storing data on HDFS (for processing by PXF)\n+        hdfsPath = hdfs.getWorkingDirectory() + \"/alter-tests\";\n+\n+        String resourcePath = localDataResourcesFolder + \"/parquet/\";\n+        hdfs.copyFromLocal(resourcePath + PARQUET_PRIMITIVE_TYPES, hdfsPath + \"/parquet/\" + PARQUET_PRIMITIVE_TYPES);\n+\n+        // Create Data and write it to HDFS\n+        Table dataTable = getSmallData();\n+        hdfs.writeTableToFile(hdfsPath + \"/csv/\" + fileName, dataTable, \",\");\n+\n+        // Avro\n+        // location of schema and data files\n+        String absolutePath = getClass().getClassLoader().getResource(\"data\").getPath();\n+        resourcePath = absolutePath + \"/avro/\";\n+        hdfs.writeAvroFileFromJson(hdfsPath + \"/avro/\" + AVRO_TYPES_FILE_NAME + SUFFIX_AVRO,\n+                FILE_SCHEME + resourcePath + AVRO_TYPES_FILE_NAME + SUFFIX_AVSC,\n+                FILE_SCHEME + resourcePath + AVRO_TYPES_FILE_NAME + SUFFIX_JSON, null);\n+    }\n+\n+    /**\n+     * Query data on a table, then drops column(s), then queries again.\n+     * Finally, the test adds back one of the dropped columns to the table,\n+     * and a new query is performed. The query uses parquet which supports\n+     * column projection, and uses the pxfwritable_import formatter.\n+     *\n+     * @throws Exception when the test execution fails\n+     */\n+    @Test(groups = {\"features\", \"gpdb\", \"security\"})\n+    public void dropAndAddColumnsPxfWritableImportWithColumnProjectionSupport() throws Exception {\n+\n+        exTable = new ReadableExternalTable(PXF_ALTER_PARQUET_TABLE,\n+                PARQUET_TABLE_COLUMNS, hdfsPath + \"/parquet/\" + PARQUET_PRIMITIVE_TYPES, \"custom\");\n+        exTable.setHost(pxfHost);\n+        exTable.setPort(pxfPort);\n+        exTable.setFormatter(\"pxfwritable_import\");\n+        exTable.setProfile(ProtocolUtils.getProtocol().value() + \":parquet\");\n+\n+        gpdb.createTableAndVerify(exTable);\n+\n+        runTincTest(\"pxf.features.general.alter.pxfwritable_import.with_column_projection.runTest\");\n+    }\n+\n+    @Test(groups = {\"features\", \"gpdb\", \"security\"})\n+    public void dropColumnsPxfWritableExport() throws Exception {\n+\n+        // Create source table\n+        exTable = new ReadableExternalTable(PXF_PARQUET_TABLE_SOURCE,\n+                PARQUET_TABLE_COLUMNS, hdfsPath + \"/parquet/\" + PARQUET_PRIMITIVE_TYPES, \"custom\");\n+        exTable.setHost(pxfHost);\n+        exTable.setPort(pxfPort);\n+        exTable.setFormatter(\"pxfwritable_import\");\n+        exTable.setProfile(ProtocolUtils.getProtocol().value() + \":parquet\");\n+        gpdb.createTableAndVerify(exTable);\n+\n+        // Create writable table\n+        exTable = new WritableExternalTable(PXF_ALTER_WRITE_PARQUET_TABLE,\n+                PARQUET_TABLE_COLUMNS, hdfsPath + \"/parquet-write/\" + PARQUET_WRITE_PRIMITIVES, \"custom\");\n+        exTable.setHost(pxfHost);\n+        exTable.setPort(pxfPort);\n+        exTable.setFormatter(\"pxfwritable_export\");\n+        exTable.setProfile(ProtocolUtils.getProtocol().value() + \":parquet\");\n+        gpdb.createTableAndVerify(exTable);\n+\n+        // Create validation table\n+        exTable = new ReadableExternalTable(PXF_ALTER_WRITE_PARQUET_TABLE + \"_r\",\n+                PARQUET_TABLE_SUBSET_COLUMNS, hdfsPath + \"/parquet-write/\" + PARQUET_WRITE_PRIMITIVES, \"custom\");\n+        exTable.setHost(pxfHost);\n+        exTable.setPort(pxfPort);\n+        exTable.setFormatter(\"pxfwritable_import\");\n+        exTable.setProfile(ProtocolUtils.getProtocol().value() + \":parquet\");\n+        gpdb.createTableAndVerify(exTable);\n+\n+        runTincTest(\"pxf.features.general.alter.pxfwritable_export.parquet.runTest\");\n+    }\n+\n+    @Test(groups = {\"features\", \"gpdb\", \"security\"})\n+    public void dropAndAddColumnsPxfWritableImportWithoutColumnProjectionSupport() throws Exception {\n+        // default external table with common settings\n+        exTable = new ReadableExternalTable(PXF_ALTER_AVRO_TABLE, new String[]{\n+                \"type_int int\",\n+                \"type_double float8\",\n+                \"type_string text\",\n+                \"type_float real\",\n+                \"col_does_not_exist text\",\n+                \"type_long bigint\",\n+                \"type_bytes bytea\",\n+                \"type_boolean bool\"}, hdfsPath + \"/avro/\" + AVRO_TYPES_FILE_NAME + SUFFIX_AVRO, \"custom\");\n+        exTable.setHost(pxfHost);\n+        exTable.setPort(pxfPort);\n+        exTable.setFormatter(\"pxfwritable_import\");\n+        exTable.setProfile(ProtocolUtils.getProtocol().value() + \":avro\");\n+\n+        gpdb.createTableAndVerify(exTable);\n+\n+        // Verify results\n+        runTincTest(\"pxf.features.general.alter.pxfwritable_import.without_column_projection.runTest\");\n+    }\n+\n+    /**\n+     * Attempt to query data on a table that has a column that does not exist.\n+     * It then drops the column and performs the query successfully.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "904003217a18f82003afbc540c1c01398c5bce5c"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4ODU3OA==", "bodyText": "or maybe\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Attempt to query data on a table that has a column that does not exist.\n          \n          \n            \n                 * Attempt to query data on a column from a table where the column does not exist.", "url": "https://github.com/greenplum-db/pxf/pull/451#discussion_r490588578", "createdAt": "2020-09-17T22:06:12Z", "author": {"login": "ashuka24"}, "path": "automation/src/test/java/org/greenplum/pxf/automation/features/general/AlterTableTest.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.greenplum.pxf.automation.features.general;\n+\n+import org.greenplum.pxf.automation.features.BaseFeature;\n+import org.greenplum.pxf.automation.structures.tables.basic.Table;\n+import org.greenplum.pxf.automation.structures.tables.pxf.ReadableExternalTable;\n+import org.greenplum.pxf.automation.structures.tables.pxf.WritableExternalTable;\n+import org.greenplum.pxf.automation.structures.tables.utils.TableFactory;\n+import org.greenplum.pxf.automation.utils.system.ProtocolEnum;\n+import org.greenplum.pxf.automation.utils.system.ProtocolUtils;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+\n+import static java.lang.Thread.sleep;\n+\n+public class AlterTableTest extends BaseFeature {\n+\n+    private static final String AVRO_TYPES_FILE_NAME = \"supported_primitive_types\";\n+    private static final String FILE_SCHEME = \"file://\";\n+    private static final String PXF_ALTER_AVRO_TABLE = \"pxf_alter_avro_table\";\n+    private static final String PXF_ALTER_CSV_TABLE = \"pxf_alter_csv_table\";\n+    private static final String PXF_PARQUET_TABLE_SOURCE = \"pxf_alter_parquet_primitive_types\";\n+    private static final String PXF_ALTER_PARQUET_TABLE = \"pxf_alter_parquet_table\";\n+    private static final String PXF_ALTER_WRITE_PARQUET_TABLE = \"pxf_alter_write_parquet_table\";\n+    private static final String PARQUET_PRIMITIVE_TYPES = \"parquet_primitive_types\";\n+    private static final String PARQUET_WRITE_PRIMITIVES = \"parquet_write_primitives\";\n+    private static final String SUFFIX_JSON = \".json\";\n+    private static final String SUFFIX_AVRO = \".avro\";\n+    private static final String SUFFIX_AVSC = \".avsc\";\n+\n+    private static final String[] PARQUET_TABLE_COLUMNS = new String[]{\n+            \"s1    TEXT\",\n+            \"s2    TEXT\",\n+            \"n1    INTEGER\",\n+            \"d1    DOUBLE PRECISION\",\n+            \"dc1   NUMERIC\",\n+            \"tm    TIMESTAMP\",\n+            \"f     REAL\",\n+            \"bg    BIGINT\",\n+            \"b     BOOLEAN\",\n+            \"tn    SMALLINT\",\n+            \"vc1   VARCHAR(5)\",\n+            \"sml   SMALLINT\",\n+            \"c1    CHAR(3)\",\n+            \"bin   BYTEA\"\n+    };\n+\n+    private static final String[] PARQUET_TABLE_SUBSET_COLUMNS = new String[]{\n+            \"s1    TEXT\",\n+            \"s2    TEXT\",\n+            \"n1    INTEGER\",\n+            \"d1    DOUBLE PRECISION\",\n+            \"dc1   NUMERIC\",\n+            \"f     REAL\",\n+            \"bg    BIGINT\",\n+            \"b     BOOLEAN\",\n+            \"tn    SMALLINT\",\n+            \"vc1   VARCHAR(5)\",\n+            \"sml   SMALLINT\",\n+            \"c1    CHAR(3)\"\n+    };\n+\n+    private String hdfsPath;\n+\n+    @Override\n+    public void beforeClass() throws Exception {\n+        // path for storing data on HDFS (for processing by PXF)\n+        hdfsPath = hdfs.getWorkingDirectory() + \"/alter-tests\";\n+\n+        String resourcePath = localDataResourcesFolder + \"/parquet/\";\n+        hdfs.copyFromLocal(resourcePath + PARQUET_PRIMITIVE_TYPES, hdfsPath + \"/parquet/\" + PARQUET_PRIMITIVE_TYPES);\n+\n+        // Create Data and write it to HDFS\n+        Table dataTable = getSmallData();\n+        hdfs.writeTableToFile(hdfsPath + \"/csv/\" + fileName, dataTable, \",\");\n+\n+        // Avro\n+        // location of schema and data files\n+        String absolutePath = getClass().getClassLoader().getResource(\"data\").getPath();\n+        resourcePath = absolutePath + \"/avro/\";\n+        hdfs.writeAvroFileFromJson(hdfsPath + \"/avro/\" + AVRO_TYPES_FILE_NAME + SUFFIX_AVRO,\n+                FILE_SCHEME + resourcePath + AVRO_TYPES_FILE_NAME + SUFFIX_AVSC,\n+                FILE_SCHEME + resourcePath + AVRO_TYPES_FILE_NAME + SUFFIX_JSON, null);\n+    }\n+\n+    /**\n+     * Query data on a table, then drops column(s), then queries again.\n+     * Finally, the test adds back one of the dropped columns to the table,\n+     * and a new query is performed. The query uses parquet which supports\n+     * column projection, and uses the pxfwritable_import formatter.\n+     *\n+     * @throws Exception when the test execution fails\n+     */\n+    @Test(groups = {\"features\", \"gpdb\", \"security\"})\n+    public void dropAndAddColumnsPxfWritableImportWithColumnProjectionSupport() throws Exception {\n+\n+        exTable = new ReadableExternalTable(PXF_ALTER_PARQUET_TABLE,\n+                PARQUET_TABLE_COLUMNS, hdfsPath + \"/parquet/\" + PARQUET_PRIMITIVE_TYPES, \"custom\");\n+        exTable.setHost(pxfHost);\n+        exTable.setPort(pxfPort);\n+        exTable.setFormatter(\"pxfwritable_import\");\n+        exTable.setProfile(ProtocolUtils.getProtocol().value() + \":parquet\");\n+\n+        gpdb.createTableAndVerify(exTable);\n+\n+        runTincTest(\"pxf.features.general.alter.pxfwritable_import.with_column_projection.runTest\");\n+    }\n+\n+    @Test(groups = {\"features\", \"gpdb\", \"security\"})\n+    public void dropColumnsPxfWritableExport() throws Exception {\n+\n+        // Create source table\n+        exTable = new ReadableExternalTable(PXF_PARQUET_TABLE_SOURCE,\n+                PARQUET_TABLE_COLUMNS, hdfsPath + \"/parquet/\" + PARQUET_PRIMITIVE_TYPES, \"custom\");\n+        exTable.setHost(pxfHost);\n+        exTable.setPort(pxfPort);\n+        exTable.setFormatter(\"pxfwritable_import\");\n+        exTable.setProfile(ProtocolUtils.getProtocol().value() + \":parquet\");\n+        gpdb.createTableAndVerify(exTable);\n+\n+        // Create writable table\n+        exTable = new WritableExternalTable(PXF_ALTER_WRITE_PARQUET_TABLE,\n+                PARQUET_TABLE_COLUMNS, hdfsPath + \"/parquet-write/\" + PARQUET_WRITE_PRIMITIVES, \"custom\");\n+        exTable.setHost(pxfHost);\n+        exTable.setPort(pxfPort);\n+        exTable.setFormatter(\"pxfwritable_export\");\n+        exTable.setProfile(ProtocolUtils.getProtocol().value() + \":parquet\");\n+        gpdb.createTableAndVerify(exTable);\n+\n+        // Create validation table\n+        exTable = new ReadableExternalTable(PXF_ALTER_WRITE_PARQUET_TABLE + \"_r\",\n+                PARQUET_TABLE_SUBSET_COLUMNS, hdfsPath + \"/parquet-write/\" + PARQUET_WRITE_PRIMITIVES, \"custom\");\n+        exTable.setHost(pxfHost);\n+        exTable.setPort(pxfPort);\n+        exTable.setFormatter(\"pxfwritable_import\");\n+        exTable.setProfile(ProtocolUtils.getProtocol().value() + \":parquet\");\n+        gpdb.createTableAndVerify(exTable);\n+\n+        runTincTest(\"pxf.features.general.alter.pxfwritable_export.parquet.runTest\");\n+    }\n+\n+    @Test(groups = {\"features\", \"gpdb\", \"security\"})\n+    public void dropAndAddColumnsPxfWritableImportWithoutColumnProjectionSupport() throws Exception {\n+        // default external table with common settings\n+        exTable = new ReadableExternalTable(PXF_ALTER_AVRO_TABLE, new String[]{\n+                \"type_int int\",\n+                \"type_double float8\",\n+                \"type_string text\",\n+                \"type_float real\",\n+                \"col_does_not_exist text\",\n+                \"type_long bigint\",\n+                \"type_bytes bytea\",\n+                \"type_boolean bool\"}, hdfsPath + \"/avro/\" + AVRO_TYPES_FILE_NAME + SUFFIX_AVRO, \"custom\");\n+        exTable.setHost(pxfHost);\n+        exTable.setPort(pxfPort);\n+        exTable.setFormatter(\"pxfwritable_import\");\n+        exTable.setProfile(ProtocolUtils.getProtocol().value() + \":avro\");\n+\n+        gpdb.createTableAndVerify(exTable);\n+\n+        // Verify results\n+        runTincTest(\"pxf.features.general.alter.pxfwritable_import.without_column_projection.runTest\");\n+    }\n+\n+    /**\n+     * Attempt to query data on a table that has a column that does not exist.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NzIzMw=="}, "originalCommit": {"oid": "904003217a18f82003afbc540c1c01398c5bce5c"}, "originalPosition": 166}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODk2OTAw", "url": "https://github.com/greenplum-db/pxf/pull/451#pullrequestreview-492896900", "createdAt": "2020-09-21T19:00:05Z", "commit": {"oid": "09ac7cfbdde52f0a9daf4223a8c1797835c9b752"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTowMDowNVrOHVeZlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTozODoyMVrOHVfrgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI4MDIxMw==", "bodyText": "why not inline this on line 361 since attr is not used anywhere else ?", "url": "https://github.com/greenplum-db/pxf/pull/451#discussion_r492280213", "createdAt": "2020-09-21T19:00:05Z", "author": {"login": "denalex"}, "path": "external-table/src/gpdbwritableformatter.c", "diffHunk": "@@ -323,16 +329,41 @@ boolArrayToByteArray(bool *data, int len, int *outlen)\n /*\n  * Helper routine to convert byte array to boolean array\n  * It'll write the output to booldata.\n+ *\n+ * This routine supports dropped columns, in the case of tables with dropped\n+ * columns booldata's size will match the number of original columns\n+ * (including dropped columns), and the source `data` will match the number\n+ * of columns provided by the PXF server, so if there are dropped columns,\n+ * PXF server will only provide the subset of columns. Below a graphical\n+ * representation of the mapping.\n+ *\n+ *  --------------------------------------------\n+ * |  col1  |  col2  |  col3  |  col5  |  col6  |  input: *data\n+ *  --------------------------------------------\n+ *     |        |        |         |        \u2514----------------\u2b0e\n+ *     \u2193        \u2193        \u2193         \u2514----------------\u2b0e        \u2193\n+ *  -------------------------------------------------------------\n+ * |  col1  |  col2  |  col3  |  col4 (dropped)  | col5  | col6  | output: **booldata\n+ *  -------------------------------------------------------------\n  */\n static void\n-byteArrayToBoolArray(bits8 *data, int len, bool **booldata, int boollen)\n+byteArrayToBoolArray(bits8 *data, int len, bool **booldata, int boollen, TupleDesc tupdesc)\n {\n \tint\t\t\ti,\n \t\t\t\tj,\n \t\t\t\tk;\n \n \tfor (i = 0, j = 0, k = 7; i < boollen; i++)\n \t{\n+\t\tForm_pg_attribute attr = tupdesc->attrs[i];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09ac7cfbdde52f0a9daf4223a8c1797835c9b752"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI4ODU5MA==", "bodyText": "why not init at declaration ?", "url": "https://github.com/greenplum-db/pxf/pull/451#discussion_r492288590", "createdAt": "2020-09-21T19:14:36Z", "author": {"login": "denalex"}, "path": "external-table/src/gpdbwritableformatter.c", "diffHunk": "@@ -637,8 +695,14 @@ gpdbwritableformatter_import(PG_FUNCTION_ARGS)\n \n \t/* Get our internal description of the formatter */\n \tncolumns = tupdesc->natts;\n+\tnvalidcolumns = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09ac7cfbdde52f0a9daf4223a8c1797835c9b752"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI4OTY3MQ==", "bodyText": "wouldn't ncolumns_remote and nvalidcolumns be the same ?", "url": "https://github.com/greenplum-db/pxf/pull/451#discussion_r492289671", "createdAt": "2020-09-21T19:16:34Z", "author": {"login": "denalex"}, "path": "external-table/src/gpdbwritableformatter.c", "diffHunk": "@@ -757,27 +820,27 @@ gpdbwritableformatter_import(PG_FUNCTION_ARGS)\n \n \t/* Verify once on the first row */\n \tif (FIRST_LINE_NUM == myData->lineno++)\n-\t{\n-\t\tverifyExternalTableDefinition(ncolumns_remote, ncolumns, tupdesc, data_buf, &bufidx);\n-\t}\n-\t/* Skipping the columns' enum types */\n-\telse\n-\t{\n-\t\tbufidx += ncolumns;\n-\t}\n+\t\tverifyExternalTableDefinition(ncolumns_remote, nvalidcolumns, ncolumns, tupdesc, data_buf, &bufidx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09ac7cfbdde52f0a9daf4223a8c1797835c9b752"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwMTE4NA==", "bodyText": "not sure what this FirstLowInvalidHeapAttributeNumber is and where it is coming from. Also, do we need to cleanup allocated BMS attrs_used at the end ?", "url": "https://github.com/greenplum-db/pxf/pull/451#discussion_r492301184", "createdAt": "2020-09-21T19:38:21Z", "author": {"login": "denalex"}, "path": "external-table/src/pxfheaders.c", "diffHunk": "@@ -376,8 +412,9 @@ add_projection_desc_httpheader(CHURL_HEADERS headers,\n \tfor (i = 0; varNumbers && i < numSimpleVars; i++)\n #endif\n \t{\n-\t\tadd_projection_index_header(headers,\n-\t\t\t\t\t\t\t\t\tformatter, varNumbers[i] - 1, long_number);\n+\t\tattrs_used =\n+\t\t\tbms_add_member(attrs_used,\n+\t\t\t\t\t\t varNumbers[i] - FirstLowInvalidHeapAttributeNumber);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09ac7cfbdde52f0a9daf4223a8c1797835c9b752"}, "originalPosition": 246}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzOTEyOTU0", "url": "https://github.com/greenplum-db/pxf/pull/451#pullrequestreview-493912954", "createdAt": "2020-09-22T23:29:09Z", "commit": {"oid": "561e3ded86367e50d351199a98f0df62e2a5a684"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c83c8630b623b13e5934cc1f0eb97dd8f07c4dac", "author": {"user": null}, "url": "https://github.com/greenplum-db/pxf/commit/c83c8630b623b13e5934cc1f0eb97dd8f07c4dac", "committedDate": "2020-09-23T00:30:30Z", "message": "Support dropping columns in PXF readable external tables\n\nPXF does not support dropping columns from readable external tables.\nThis commit adds support for dropping columns, especially when the\nformat is CUSTOM and the formatter is `pxfwritable_import`. This also\napplies for TEXT/CSV format, but the complexity lies in the\n`pxfwritable_import` formatter. Add automation tests for altering PXF\nreadable external tables."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba4105151e844d016383f0968ad7ae556b3a6e16", "author": {"user": null}, "url": "https://github.com/greenplum-db/pxf/commit/ba4105151e844d016383f0968ad7ae556b3a6e16", "committedDate": "2020-09-23T00:30:37Z", "message": "Support dropping columns in PXF writable external tables\n\nPXF does not support dropping columns from writable external tables.\nThis commit adds support for dropping columns in PXF writable external\ntables. The complexity of the implementation lies in the\n`pxfwritable_export` formatter. Add automation tests for altering PXF\nwritable external tables."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "561e3ded86367e50d351199a98f0df62e2a5a684", "author": {"user": null}, "url": "https://github.com/greenplum-db/pxf/commit/561e3ded86367e50d351199a98f0df62e2a5a684", "committedDate": "2020-09-21T20:03:08Z", "message": "Address PR feedback"}, "afterCommit": {"oid": "ba4105151e844d016383f0968ad7ae556b3a6e16", "author": {"user": null}, "url": "https://github.com/greenplum-db/pxf/commit/ba4105151e844d016383f0968ad7ae556b3a6e16", "committedDate": "2020-09-23T00:30:37Z", "message": "Support dropping columns in PXF writable external tables\n\nPXF does not support dropping columns from writable external tables.\nThis commit adds support for dropping columns in PXF writable external\ntables. The complexity of the implementation lies in the\n`pxfwritable_export` formatter. Add automation tests for altering PXF\nwritable external tables."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4881, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}