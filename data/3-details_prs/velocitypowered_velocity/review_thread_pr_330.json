{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUwMTI3NDIy", "number": 330, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzowMToyOVrOEPOEiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjoyNzoyNlrOEQs79g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Mzk0NjMzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/velocitypowered/api/newcommand/BrigadierCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzowMToyOVrOGy0HrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzowMToyOVrOGy0HrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNTkxNg==", "bodyText": "A command that uses Brigadier for parsing the command and providing suggestions to the client.", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r455935916", "createdAt": "2020-07-16T17:01:29Z", "author": {"login": "astei"}, "path": "api/src/main/java/com/velocitypowered/api/newcommand/BrigadierCommand.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package com.velocitypowered.api.newcommand;\n+\n+import com.mojang.brigadier.exceptions.CommandSyntaxException;\n+import com.mojang.brigadier.suggestion.SuggestionProvider;\n+import com.mojang.brigadier.suggestion.Suggestions;\n+import com.mojang.brigadier.tree.LiteralCommandNode;\n+import com.velocitypowered.api.command.CommandSource;\n+\n+/**\n+ * A command that uses the Brigadier library for parsing.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b242d36210eb776c465804654bd7374bcf5cc32"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Mzk1Mzk3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/velocitypowered/api/newcommand/Command.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzowMzo0MlrOGy0Mmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzoyNDoyNVrOGy09-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNzE3OA==", "bodyText": "I think this is a good idea", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r455937178", "createdAt": "2020-07-16T17:03:42Z", "author": {"login": "astei"}, "path": "api/src/main/java/com/velocitypowered/api/newcommand/Command.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package com.velocitypowered.api.newcommand;\n+\n+import com.velocitypowered.api.command.CommandSource;\n+import com.velocitypowered.api.proxy.Player;\n+\n+/**\n+ * Represents a command that can be executed by a {@link CommandSource},\n+ * such as a {@link Player} or the console.\n+ *\n+ * @param <C> the type of the execution context\n+ */\n+public interface Command<C extends CommandExecutionContext> {\n+\n+    /**\n+     * Represents the command type, which determines\n+     * its parsing capabilities.\n+     */\n+    // TODO Introduce CommandMeta and move there?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b242d36210eb776c465804654bd7374bcf5cc32"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0MzQ3MA==", "bodyText": "I'm leaning more towards Command containing the immutable meta and have an associated CommandExecutor. This way we can have builders that automatically register commands on construction (similar to the scheduler system). Also, we can get rid of the Type enum to let users provide their own Command implementations (i.e. get rid of RawCommand).", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r455943470", "createdAt": "2020-07-16T17:13:53Z", "author": {"login": "hugmanrique"}, "path": "api/src/main/java/com/velocitypowered/api/newcommand/Command.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package com.velocitypowered.api.newcommand;\n+\n+import com.velocitypowered.api.command.CommandSource;\n+import com.velocitypowered.api.proxy.Player;\n+\n+/**\n+ * Represents a command that can be executed by a {@link CommandSource},\n+ * such as a {@link Player} or the console.\n+ *\n+ * @param <C> the type of the execution context\n+ */\n+public interface Command<C extends CommandExecutionContext> {\n+\n+    /**\n+     * Represents the command type, which determines\n+     * its parsing capabilities.\n+     */\n+    // TODO Introduce CommandMeta and move there?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNzE3OA=="}, "originalCommit": {"oid": "3b242d36210eb776c465804654bd7374bcf5cc32"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0OTgxOA==", "bodyText": "I'm happy to run with this idea (Command.Type is kind of a kludge anyway).", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r455949818", "createdAt": "2020-07-16T17:24:25Z", "author": {"login": "astei"}, "path": "api/src/main/java/com/velocitypowered/api/newcommand/Command.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package com.velocitypowered.api.newcommand;\n+\n+import com.velocitypowered.api.command.CommandSource;\n+import com.velocitypowered.api.proxy.Player;\n+\n+/**\n+ * Represents a command that can be executed by a {@link CommandSource},\n+ * such as a {@link Player} or the console.\n+ *\n+ * @param <C> the type of the execution context\n+ */\n+public interface Command<C extends CommandExecutionContext> {\n+\n+    /**\n+     * Represents the command type, which determines\n+     * its parsing capabilities.\n+     */\n+    // TODO Introduce CommandMeta and move there?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNzE3OA=="}, "originalCommit": {"oid": "3b242d36210eb776c465804654bd7374bcf5cc32"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Mzk3MTAxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/velocitypowered/api/newcommand/CommandManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzowODowN1rOGy0W9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzowODowN1rOGy0W9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzOTgzMQ==", "bodyText": "The previous Javadoc description should have read Unregisters the specified alias from the command manager.", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r455939831", "createdAt": "2020-07-16T17:08:07Z", "author": {"login": "astei"}, "path": "api/src/main/java/com/velocitypowered/api/newcommand/CommandManager.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package com.velocitypowered.api.newcommand;\n+\n+import com.velocitypowered.api.command.CommandSource;\n+import com.velocitypowered.api.event.command.CommandExecuteEvent;\n+import java.util.concurrent.CompletableFuture;\n+\n+/**\n+ * Registers and executes commands.\n+ */\n+public interface CommandManager {\n+\n+    /**\n+     * Registers the specified command.\n+     *\n+     * @param command the command to register\n+     */\n+    void register(Command<?> command);\n+\n+    /**\n+     * Unregisters the specified command.\n+     *\n+     * @param command the command to unregister\n+     */\n+    void unregister(Command<?> command);\n+\n+    /**\n+     * Unregisters the command with the specified alias.\n+     *\n+     * @param alias the alias of the command\n+     */\n+    // TODO Previous javadoc is ambiguous, does this unregister all the aliases of the command,\n+    // or just the given alias?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b242d36210eb776c465804654bd7374bcf5cc32"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Mzk3MzA4OnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzowODo0NVrOGy0YTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjoyNToyMVrOG1AApQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0MDE3Mg==", "bodyText": "Is this some kind of local change you made? We don't build on Windows.", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r455940172", "createdAt": "2020-07-16T17:08:45Z", "author": {"login": "astei"}, "path": "build.gradle", "diffHunk": "@@ -30,7 +30,7 @@ allprojects {\n         getCurrentShortRevision = {\n             new ByteArrayOutputStream().withStream { os ->\n                 exec {\n-                    executable = \"git\"\n+                    executable = \"git.bat\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b242d36210eb776c465804654bd7374bcf5cc32"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0MTc5Ng==", "bodyText": "Didn't mean to push this, my bad. Signs of my janky WSL setup.", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r455941796", "createdAt": "2020-07-16T17:11:27Z", "author": {"login": "hugmanrique"}, "path": "build.gradle", "diffHunk": "@@ -30,7 +30,7 @@ allprojects {\n         getCurrentShortRevision = {\n             new ByteArrayOutputStream().withStream { os ->\n                 exec {\n-                    executable = \"git\"\n+                    executable = \"git.bat\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0MDE3Mg=="}, "originalCommit": {"oid": "3b242d36210eb776c465804654bd7374bcf5cc32"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyNzg3Nw==", "bodyText": "This is still live. Can you still revert this?", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r458227877", "createdAt": "2020-07-21T16:25:21Z", "author": {"login": "astei"}, "path": "build.gradle", "diffHunk": "@@ -30,7 +30,7 @@ allprojects {\n         getCurrentShortRevision = {\n             new ByteArrayOutputStream().withStream { os ->\n                 exec {\n-                    executable = \"git\"\n+                    executable = \"git.bat\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0MDE3Mg=="}, "originalCommit": {"oid": "3b242d36210eb776c465804654bd7374bcf5cc32"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NDMyODMwOnYy", "diffSide": "LEFT", "path": "api/src/main/java/com/velocitypowered/api/command/CommandManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODo0Mjo0M1rOGy3z3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODo0ODoyN1rOGy3_yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk5NjM4MQ==", "bodyText": "Question: As this presently stands this would break the API. I assume you just want to put the API in front of users before you add any backwards compatibility?", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r455996381", "createdAt": "2020-07-16T18:42:43Z", "author": {"login": "astei"}, "path": "api/src/main/java/com/velocitypowered/api/command/CommandManager.java", "diffHunk": "@@ -1,87 +1,60 @@\n package com.velocitypowered.api.command;\n \n+import com.velocitypowered.api.event.command.CommandExecuteEvent;\n import java.util.concurrent.CompletableFuture;\n \n /**\n- * Represents an interface to register a command executor with the proxy.\n+ * Handles the registration and execution of commands.\n  */\n public interface CommandManager {\n \n   /**\n-   * Registers the specified command with the manager with the specified aliases.\n+   * Returns a builder to register a {@link LegacyCommand}.\n    *\n-   * @param command the command to register\n-   * @param aliases the alias to use\n-   *\n-   * @deprecated This method requires at least one alias, but this is only enforced at runtime.\n-   *             Prefer {@link #register(String, Command, String...)} instead.\n+   * @return a legacy command builder\n    */\n-  @Deprecated\n-  void register(Command command, String... aliases);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afbb9617902a5ef8f70370fe97b471991871211"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk5OTQzNA==", "bodyText": "Yeah, this would require a major bump, so it's a long-term PR. Users are expected to not instantiate the Command interface/subclass it and instead use LegacyCommand.Builder and BrigadierCommand.Builder instances obtainable from the command manager.\nI'm thinking about how to minimize the breakage and still allow plugins to implement Command.", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r455999434", "createdAt": "2020-07-16T18:48:27Z", "author": {"login": "hugmanrique"}, "path": "api/src/main/java/com/velocitypowered/api/command/CommandManager.java", "diffHunk": "@@ -1,87 +1,60 @@\n package com.velocitypowered.api.command;\n \n+import com.velocitypowered.api.event.command.CommandExecuteEvent;\n import java.util.concurrent.CompletableFuture;\n \n /**\n- * Represents an interface to register a command executor with the proxy.\n+ * Handles the registration and execution of commands.\n  */\n public interface CommandManager {\n \n   /**\n-   * Registers the specified command with the manager with the specified aliases.\n+   * Returns a builder to register a {@link LegacyCommand}.\n    *\n-   * @param command the command to register\n-   * @param aliases the alias to use\n-   *\n-   * @deprecated This method requires at least one alias, but this is only enforced at runtime.\n-   *             Prefer {@link #register(String, Command, String...)} instead.\n+   * @return a legacy command builder\n    */\n-  @Deprecated\n-  void register(Command command, String... aliases);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk5NjM4MQ=="}, "originalCommit": {"oid": "7afbb9617902a5ef8f70370fe97b471991871211"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NDMzNzY0OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/velocitypowered/api/command/LegacyCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODo0NToxOVrOGy35Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODo0NToxOVrOGy35Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk5Nzc2Mw==", "bodyText": "I'm thinking of replacing this consumer by a LegacyCommandExecutor functional interface (I think) users are more familiarized with.", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r455997763", "createdAt": "2020-07-16T18:45:19Z", "author": {"login": "hugmanrique"}, "path": "api/src/main/java/com/velocitypowered/api/command/LegacyCommand.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package com.velocitypowered.api.command;\n+\n+import java.util.function.Consumer;\n+\n+/**\n+ * A legacy 1.12-style command.\n+ */\n+public interface LegacyCommand extends Command<LegacyCommandExecutionContext> {\n+\n+  /**\n+   * Provides a fluent interface to register a legacy command.\n+   */\n+  interface Builder extends Command.Builder<LegacyCommand, Builder> {\n+\n+    /**\n+     * Specifies additional aliases that can be used to execute the command.\n+     *\n+     * @param aliases the command aliases\n+     * @return this builder, for chaining\n+     */\n+    Builder aliases(String... aliases);\n+\n+    /**\n+     * Registers the command with the specified execution handler.\n+     *\n+     * @param onExecute the execution handler\n+     * @return the registered command\n+     */\n+    LegacyCommand register(Consumer<LegacyCommandExecutionContext> onExecute);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7afbb9617902a5ef8f70370fe97b471991871211"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODkxNTcyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/velocitypowered/api/command/BrigadierCommand.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjo0MToxMFrOGzi8eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMTozODoyMlrOGznt0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwMzA5Nw==", "bodyText": "I would like to see some better description on why this is the case. This isn't obvious on first glance.", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r456703097", "createdAt": "2020-07-17T22:41:10Z", "author": {"login": "astei"}, "path": "api/src/main/java/com/velocitypowered/api/command/BrigadierCommand.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package com.velocitypowered.api.command;\n+\n+import com.mojang.brigadier.builder.ArgumentBuilder;\n+import com.mojang.brigadier.builder.LiteralArgumentBuilder;\n+import com.mojang.brigadier.tree.CommandNode;\n+\n+/**\n+ * A command that uses Brigadier for parsing the command and providing\n+ * suggestions to the client.\n+ */\n+public interface BrigadierCommand extends Command<BrigadierCommandInvocation> {\n+\n+  /**\n+   * Returns an {@link ArgumentBuilder} used to specify the structure of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "609f7779ef58aeb6457cadc1eef57fc065f9af47"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc4MTI2Nw==", "bodyText": "This is a helper method, callers can still use the longer LiteralArgumentBuilder.<CommandSource>.literal(alias). Most examples I could find of Brigadier commands prefer to use the statically imported literal(), but it's not possible in our case since it requires to specify the <CommandSource> type.", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r456781267", "createdAt": "2020-07-18T11:38:22Z", "author": {"login": "hugmanrique"}, "path": "api/src/main/java/com/velocitypowered/api/command/BrigadierCommand.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package com.velocitypowered.api.command;\n+\n+import com.mojang.brigadier.builder.ArgumentBuilder;\n+import com.mojang.brigadier.builder.LiteralArgumentBuilder;\n+import com.mojang.brigadier.tree.CommandNode;\n+\n+/**\n+ * A command that uses Brigadier for parsing the command and providing\n+ * suggestions to the client.\n+ */\n+public interface BrigadierCommand extends Command<BrigadierCommandInvocation> {\n+\n+  /**\n+   * Returns an {@link ArgumentBuilder} used to specify the structure of", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwMzA5Nw=="}, "originalCommit": {"oid": "609f7779ef58aeb6457cadc1eef57fc065f9af47"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODkxNjc2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/velocitypowered/api/command/BrigadierCommandInvocation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjo0MTo0M1rOGzi9BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjo0MTo0M1rOGzi9BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwMzIzNw==", "bodyText": "Returns the result of parsing the given command.", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r456703237", "createdAt": "2020-07-17T22:41:43Z", "author": {"login": "astei"}, "path": "api/src/main/java/com/velocitypowered/api/command/BrigadierCommandInvocation.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package com.velocitypowered.api.command;\n+\n+import com.mojang.brigadier.ParseResults;\n+\n+/**\n+ * Contains the invocation data for a {@link BrigadierCommand}.\n+ */\n+public interface BrigadierCommandInvocation extends CommandInvocation {\n+\n+  /**\n+   * Returns the valid parse results.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "609f7779ef58aeb6457cadc1eef57fc065f9af47"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODkxODUyOnYy", "diffSide": "LEFT", "path": "api/src/main/java/com/velocitypowered/api/command/Command.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjo0Mjo1M1rOGzi-GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMTozNTo0MVrOGzns1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwMzUxMw==", "bodyText": "Still API-breaking here - is there a better solution?", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r456703513", "createdAt": "2020-07-17T22:42:53Z", "author": {"login": "astei"}, "path": "api/src/main/java/com/velocitypowered/api/command/Command.java", "diffHunk": "@@ -1,59 +1,73 @@\n package com.velocitypowered.api.command;\n \n import com.google.common.collect.ImmutableList;\n+import com.velocitypowered.api.proxy.Player;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n-import org.checkerframework.checker.nullness.qual.NonNull;\n \n /**\n- * Represents a command that can be executed by a {@link CommandSource}, such as a {@link\n- * com.velocitypowered.api.proxy.Player} or the console.\n+ * Represents a command that can be executed by a {@link CommandSource}, such as\n+ * a {@link Player} or the console.\n  */\n-public interface Command {\n+public interface Command<I extends CommandInvocation> {\n \n   /**\n-   * Executes the command for the specified {@link CommandSource}.\n+   * Executes the command for the specified invocation.\n    *\n-   * @param source the source of this command\n-   * @param args the arguments for this command\n+   * @param invocation the invocation context\n    */\n-  void execute(CommandSource source, String @NonNull [] args);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "609f7779ef58aeb6457cadc1eef57fc065f9af47"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc4MTAxNA==", "bodyText": "If a command class now doesn't implement LegacyCommand, BrigadierCommand or RawCommand, the fallback methods will be executed. On 2.0.0 we can open up the possibility for custom CommandInvocation factories and Command implementations. As it stands, I don't think there's a way to detect a class using the deprecated methods without calling them.", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r456781014", "createdAt": "2020-07-18T11:35:41Z", "author": {"login": "hugmanrique"}, "path": "api/src/main/java/com/velocitypowered/api/command/Command.java", "diffHunk": "@@ -1,59 +1,73 @@\n package com.velocitypowered.api.command;\n \n import com.google.common.collect.ImmutableList;\n+import com.velocitypowered.api.proxy.Player;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n-import org.checkerframework.checker.nullness.qual.NonNull;\n \n /**\n- * Represents a command that can be executed by a {@link CommandSource}, such as a {@link\n- * com.velocitypowered.api.proxy.Player} or the console.\n+ * Represents a command that can be executed by a {@link CommandSource}, such as\n+ * a {@link Player} or the console.\n  */\n-public interface Command {\n+public interface Command<I extends CommandInvocation> {\n \n   /**\n-   * Executes the command for the specified {@link CommandSource}.\n+   * Executes the command for the specified invocation.\n    *\n-   * @param source the source of this command\n-   * @param args the arguments for this command\n+   * @param invocation the invocation context\n    */\n-  void execute(CommandSource source, String @NonNull [] args);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwMzUxMw=="}, "originalCommit": {"oid": "609f7779ef58aeb6457cadc1eef57fc065f9af47"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODkyMjY3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/velocitypowered/api/command/LegacyCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjo0NToyM1rOGzjAVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjo0NToyM1rOGzjAVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwNDA4NA==", "bodyText": "A legacy command, modelled after the convention popularized by Bukkit and BungeeCord. Prefer {@code BrigadierCommand} if possible, which is also backwards-compatible with older clients.\nAssuming (of course) that Brigadier support in Velocity does support older clients. Test this perhaps?", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r456704084", "createdAt": "2020-07-17T22:45:23Z", "author": {"login": "astei"}, "path": "api/src/main/java/com/velocitypowered/api/command/LegacyCommand.java", "diffHunk": "@@ -0,0 +1,8 @@\n+package com.velocitypowered.api.command;\n+\n+/**\n+ * A legacy 1.12-style command.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "609f7779ef58aeb6457cadc1eef57fc065f9af47"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODkyNDE2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/velocitypowered/api/command/RawCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjo0NjoxOVrOGzjBMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjo0NjoxOVrOGzjBMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwNDMwNA==", "bodyText": "should pass the command and its arguments directly without further processing", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r456704304", "createdAt": "2020-07-17T22:46:19Z", "author": {"login": "astei"}, "path": "api/src/main/java/com/velocitypowered/api/command/RawCommand.java", "diffHunk": "@@ -1,67 +1,10 @@\n package com.velocitypowered.api.command;\n \n-import com.google.common.collect.ImmutableList;\n-import java.util.List;\n-import java.util.concurrent.CompletableFuture;\n-import org.checkerframework.checker.nullness.qual.NonNull;\n-\n /**\n- * A specialized sub-interface of {@code Command} which indicates that the proxy should pass a\n- * raw command to the command. This is useful for bolting on external command frameworks to\n+ * A specialized sub-interface of {@code Command} which indicates that the proxy should pass\n+ * a raw command to the command. This is useful for bolting on external command frameworks to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "609f7779ef58aeb6457cadc1eef57fc065f9af47"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODkyNjgzOnYy", "diffSide": "RIGHT", "path": "proxy/src/main/java/com/velocitypowered/proxy/command/VelocityBrigadierCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjo0Nzo0OFrOGzjCoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjo0Nzo0OFrOGzjCoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwNDY3Mw==", "bodyText": "Should explain why we need to use this method.", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r456704673", "createdAt": "2020-07-17T22:47:48Z", "author": {"login": "astei"}, "path": "proxy/src/main/java/com/velocitypowered/proxy/command/VelocityBrigadierCommand.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package com.velocitypowered.proxy.command;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Lists;\n+import com.mojang.brigadier.builder.LiteralArgumentBuilder;\n+import com.mojang.brigadier.context.ParsedCommandNode;\n+import com.mojang.brigadier.exceptions.CommandSyntaxException;\n+import com.mojang.brigadier.suggestion.Suggestion;\n+import com.mojang.brigadier.tree.CommandNode;\n+import com.velocitypowered.api.command.BrigadierCommand;\n+import com.velocitypowered.api.command.BrigadierCommandInvocation;\n+import com.velocitypowered.api.command.CommandSource;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.CompletableFuture;\n+\n+final class VelocityBrigadierCommand implements BrigadierCommand {\n+\n+  /**\n+   * Returns a node builder with the given alias to the specified destination node.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "609f7779ef58aeb6457cadc1eef57fc065f9af47"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODkyOTg3OnYy", "diffSide": "RIGHT", "path": "proxy/src/main/java/com/velocitypowered/proxy/command/VelocityCommandManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjo0OTo0NVrOGzjEXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjo0OTo0NVrOGzjEXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwNTExNg==", "bodyText": "I would call this field brigadierDispatcher", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r456705116", "createdAt": "2020-07-17T22:49:45Z", "author": {"login": "astei"}, "path": "proxy/src/main/java/com/velocitypowered/proxy/command/VelocityCommandManager.java", "diffHunk": "@@ -20,47 +26,101 @@\n \n public class VelocityCommandManager implements CommandManager {\n \n-  private final Map<String, RawCommand> commands = new HashMap<>();\n+  // `commands` contains all registered command case-insensitive aliases.\n+  // Multiple aliases may map to the same command.\n+  //\n+  // On execution, suggestion offers and permission checks, the corresponding Command object\n+  // is retrieved. Then, a CommandInvocation describing the request is created by\n+  // the invocation factory registry. This object is then passed to the underlying command,\n+  // which may use the Brigadier dispatcher iff it implements BrigadierCommand.\n+  //\n+  // By design, the API doesn't provide CommandInvocation implementations.\n+  // Commands are not meant to be executed directly. Instead, users should\n+  // call CommandManager#execute.\n+\n+  private final Map<String, Command<?>> commands = new HashMap<>();\n+\n+  private final CommandInvocationFactoryRegistry invocationFactory =\n+          new CommandInvocationFactoryRegistry();\n+  private final CommandDispatcher<CommandSource> dispatcher = new CommandDispatcher<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "609f7779ef58aeb6457cadc1eef57fc065f9af47"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODkzMzcyOnYy", "diffSide": "LEFT", "path": "proxy/src/main/java/com/velocitypowered/proxy/command/VelocityCommandManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QyMjo1MjoxNVrOGzjGpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMTozMjo1N1rOGznr8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwNTcwMA==", "bodyText": "I would like to us to be able to inject proxy commands into tab-complete requests and into the Brigadier command tree if we can.", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r456705700", "createdAt": "2020-07-17T22:52:15Z", "author": {"login": "astei"}, "path": "proxy/src/main/java/com/velocitypowered/proxy/command/VelocityCommandManager.java", "diffHunk": "@@ -69,107 +129,111 @@ public void unregister(final String alias) {\n   }\n \n   @Override\n-  public boolean execute(CommandSource source, String cmdLine) {\n+  public CompletableFuture<Boolean> execute(final CommandSource source, final String cmdLine) {\n     Preconditions.checkNotNull(source, \"source\");\n     Preconditions.checkNotNull(cmdLine, \"cmdLine\");\n \n-    CommandExecuteEvent event = callCommandEvent(source, cmdLine).join();\n-    CommandResult commandResult = event.getResult();\n-    if (commandResult.isForwardToServer() || !commandResult.isAllowed()) {\n-      return false;\n-    }\n-    cmdLine = commandResult.getCommand().orElse(event.getCommand());\n+    return callCommandEvent(source, cmdLine).thenApply(event -> {\n+      CommandResult commandResult = event.getResult();\n+      if (commandResult.isForwardToServer() || !commandResult.isAllowed()) {\n+        return false;\n+      }\n \n-    return executeImmediately(source, cmdLine);\n+      String command = commandResult.getCommand().orElse(event.getCommand());\n+      return executeImmediately0(source, command);\n+    });\n   }\n \n   @Override\n-  public boolean executeImmediately(CommandSource source, String cmdLine) {\n+  public CompletableFuture<Boolean> executeImmediately(final CommandSource source,\n+                                                       final String cmdLine) {\n     Preconditions.checkNotNull(source, \"source\");\n     Preconditions.checkNotNull(cmdLine, \"cmdLine\");\n \n+    return CompletableFuture.supplyAsync(\n+        () -> executeImmediately0(source, cmdLine), eventManager.getService());\n+  }\n+\n+  private <I extends CommandInvocation> boolean executeImmediately0(final CommandSource source,\n+                                                                    final String cmdLine) {\n     String alias = cmdLine;\n     String args = \"\";\n     int firstSpace = cmdLine.indexOf(' ');\n     if (firstSpace != -1) {\n       alias = cmdLine.substring(0, firstSpace);\n       args = cmdLine.substring(firstSpace);\n     }\n-    RawCommand command = commands.get(alias.toLowerCase(Locale.ENGLISH));\n+\n+    Command<I> command = getCommand(alias);\n     if (command == null) {\n       return false;\n     }\n \n+    I invocation = invocationFactory.createInvocation(command, source, alias, args);\n     try {\n-      if (!command.hasPermission(source, args)) {\n+      if (!command.hasPermission(invocation)) {\n         return false;\n       }\n-      command.execute(source, args);\n+\n+      command.execute(invocation);\n       return true;\n-    } catch (Exception e) {\n+    } catch (final Exception e) {\n+      if (e.getCause() instanceof CommandSyntaxException) {\n+        // TODO Send invalid syntax message to player (exception contains details)\n+        return false;\n+      }\n+\n       throw new RuntimeException(\"Unable to invoke command \" + cmdLine + \" for \" + source, e);\n     }\n   }\n \n+  // Suggestions\n \n-  @Override\n-  public CompletableFuture<Boolean> executeAsync(CommandSource source, String cmdLine) {\n-    CompletableFuture<Boolean> result = new CompletableFuture<>();\n-    callCommandEvent(source, cmdLine).thenAccept(event -> {\n-      CommandResult commandResult = event.getResult();\n-      if (commandResult.isForwardToServer() || !commandResult.isAllowed()) {\n-        result.complete(false);\n-      }\n-      String command = commandResult.getCommand().orElse(event.getCommand());\n-      try {\n-        result.complete(executeImmediately(source, command));\n-      } catch (Exception e) {\n-        result.completeExceptionally(e);\n-      }\n-    });\n-    return result;\n-  }\n+  private <I extends CommandInvocation> CompletableFuture<List<String>> offerSuggestions(\n+          final CommandSource source, final String alias, final String args) {\n+    Command<I> command = getCommand(alias);\n+    if (command == null) {\n+      // No such command, so we can't offer any tab complete suggestions.\n+      return CompletableFuture.completedFuture(ImmutableList.of());\n+    }\n \n-  @Override\n-  public CompletableFuture<Boolean> executeImmediatelyAsync(CommandSource source, String cmdLine) {\n-    Preconditions.checkNotNull(source, \"source\");\n-    Preconditions.checkNotNull(cmdLine, \"cmdLine\");\n-    CompletableFuture<Boolean> result = new CompletableFuture<>();\n-    eventManager.getService().execute(() -> {\n-      try {\n-        result.complete(executeImmediately(source, cmdLine));\n-      } catch (Exception e) {\n-        result.completeExceptionally(e);\n+    I invocation = invocationFactory.createInvocation(command, source, alias, args);\n+    try {\n+      if (!command.hasPermission(invocation)) {\n+        return CompletableFuture.completedFuture(ImmutableList.of());\n       }\n-    });\n-    return result;\n-  }\n \n-  public boolean hasCommand(String command) {\n-    return commands.containsKey(command);\n-  }\n+      return command.suggestAsync(invocation).thenApply(ImmutableList::copyOf);\n+    } catch (final Exception e) {\n+      if (e.getCause() instanceof CommandSyntaxException) {\n+        return CompletableFuture.completedFuture(ImmutableList.of());\n+      }\n \n-  public Set<String> getAllRegisteredCommands() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "609f7779ef58aeb6457cadc1eef57fc065f9af47"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc3Nzk3OA==", "bodyText": "I think this is already handled by \n  \n    \n      Velocity/proxy/src/main/java/com/velocitypowered/proxy/connection/client/ClientPlaySessionHandler.java\n    \n    \n         Line 400\n      in\n      21ad6a4\n    \n    \n    \n    \n\n        \n          \n           server.getCommandManager().offerSuggestions(player, command) \n        \n    \n  \n\n, CommandManager#offerSuggestions merges all suggestions from all command types, including BrigadierCommands.", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r456777978", "createdAt": "2020-07-18T10:58:29Z", "author": {"login": "hugmanrique"}, "path": "proxy/src/main/java/com/velocitypowered/proxy/command/VelocityCommandManager.java", "diffHunk": "@@ -69,107 +129,111 @@ public void unregister(final String alias) {\n   }\n \n   @Override\n-  public boolean execute(CommandSource source, String cmdLine) {\n+  public CompletableFuture<Boolean> execute(final CommandSource source, final String cmdLine) {\n     Preconditions.checkNotNull(source, \"source\");\n     Preconditions.checkNotNull(cmdLine, \"cmdLine\");\n \n-    CommandExecuteEvent event = callCommandEvent(source, cmdLine).join();\n-    CommandResult commandResult = event.getResult();\n-    if (commandResult.isForwardToServer() || !commandResult.isAllowed()) {\n-      return false;\n-    }\n-    cmdLine = commandResult.getCommand().orElse(event.getCommand());\n+    return callCommandEvent(source, cmdLine).thenApply(event -> {\n+      CommandResult commandResult = event.getResult();\n+      if (commandResult.isForwardToServer() || !commandResult.isAllowed()) {\n+        return false;\n+      }\n \n-    return executeImmediately(source, cmdLine);\n+      String command = commandResult.getCommand().orElse(event.getCommand());\n+      return executeImmediately0(source, command);\n+    });\n   }\n \n   @Override\n-  public boolean executeImmediately(CommandSource source, String cmdLine) {\n+  public CompletableFuture<Boolean> executeImmediately(final CommandSource source,\n+                                                       final String cmdLine) {\n     Preconditions.checkNotNull(source, \"source\");\n     Preconditions.checkNotNull(cmdLine, \"cmdLine\");\n \n+    return CompletableFuture.supplyAsync(\n+        () -> executeImmediately0(source, cmdLine), eventManager.getService());\n+  }\n+\n+  private <I extends CommandInvocation> boolean executeImmediately0(final CommandSource source,\n+                                                                    final String cmdLine) {\n     String alias = cmdLine;\n     String args = \"\";\n     int firstSpace = cmdLine.indexOf(' ');\n     if (firstSpace != -1) {\n       alias = cmdLine.substring(0, firstSpace);\n       args = cmdLine.substring(firstSpace);\n     }\n-    RawCommand command = commands.get(alias.toLowerCase(Locale.ENGLISH));\n+\n+    Command<I> command = getCommand(alias);\n     if (command == null) {\n       return false;\n     }\n \n+    I invocation = invocationFactory.createInvocation(command, source, alias, args);\n     try {\n-      if (!command.hasPermission(source, args)) {\n+      if (!command.hasPermission(invocation)) {\n         return false;\n       }\n-      command.execute(source, args);\n+\n+      command.execute(invocation);\n       return true;\n-    } catch (Exception e) {\n+    } catch (final Exception e) {\n+      if (e.getCause() instanceof CommandSyntaxException) {\n+        // TODO Send invalid syntax message to player (exception contains details)\n+        return false;\n+      }\n+\n       throw new RuntimeException(\"Unable to invoke command \" + cmdLine + \" for \" + source, e);\n     }\n   }\n \n+  // Suggestions\n \n-  @Override\n-  public CompletableFuture<Boolean> executeAsync(CommandSource source, String cmdLine) {\n-    CompletableFuture<Boolean> result = new CompletableFuture<>();\n-    callCommandEvent(source, cmdLine).thenAccept(event -> {\n-      CommandResult commandResult = event.getResult();\n-      if (commandResult.isForwardToServer() || !commandResult.isAllowed()) {\n-        result.complete(false);\n-      }\n-      String command = commandResult.getCommand().orElse(event.getCommand());\n-      try {\n-        result.complete(executeImmediately(source, command));\n-      } catch (Exception e) {\n-        result.completeExceptionally(e);\n-      }\n-    });\n-    return result;\n-  }\n+  private <I extends CommandInvocation> CompletableFuture<List<String>> offerSuggestions(\n+          final CommandSource source, final String alias, final String args) {\n+    Command<I> command = getCommand(alias);\n+    if (command == null) {\n+      // No such command, so we can't offer any tab complete suggestions.\n+      return CompletableFuture.completedFuture(ImmutableList.of());\n+    }\n \n-  @Override\n-  public CompletableFuture<Boolean> executeImmediatelyAsync(CommandSource source, String cmdLine) {\n-    Preconditions.checkNotNull(source, \"source\");\n-    Preconditions.checkNotNull(cmdLine, \"cmdLine\");\n-    CompletableFuture<Boolean> result = new CompletableFuture<>();\n-    eventManager.getService().execute(() -> {\n-      try {\n-        result.complete(executeImmediately(source, cmdLine));\n-      } catch (Exception e) {\n-        result.completeExceptionally(e);\n+    I invocation = invocationFactory.createInvocation(command, source, alias, args);\n+    try {\n+      if (!command.hasPermission(invocation)) {\n+        return CompletableFuture.completedFuture(ImmutableList.of());\n       }\n-    });\n-    return result;\n-  }\n \n-  public boolean hasCommand(String command) {\n-    return commands.containsKey(command);\n-  }\n+      return command.suggestAsync(invocation).thenApply(ImmutableList::copyOf);\n+    } catch (final Exception e) {\n+      if (e.getCause() instanceof CommandSyntaxException) {\n+        return CompletableFuture.completedFuture(ImmutableList.of());\n+      }\n \n-  public Set<String> getAllRegisteredCommands() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwNTcwMA=="}, "originalCommit": {"oid": "609f7779ef58aeb6457cadc1eef57fc065f9af47"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc4MDc4NQ==", "bodyText": "But how about merging the proxy's Brigadier tree with that from the remote server?", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r456780785", "createdAt": "2020-07-18T11:32:57Z", "author": {"login": "astei"}, "path": "proxy/src/main/java/com/velocitypowered/proxy/command/VelocityCommandManager.java", "diffHunk": "@@ -69,107 +129,111 @@ public void unregister(final String alias) {\n   }\n \n   @Override\n-  public boolean execute(CommandSource source, String cmdLine) {\n+  public CompletableFuture<Boolean> execute(final CommandSource source, final String cmdLine) {\n     Preconditions.checkNotNull(source, \"source\");\n     Preconditions.checkNotNull(cmdLine, \"cmdLine\");\n \n-    CommandExecuteEvent event = callCommandEvent(source, cmdLine).join();\n-    CommandResult commandResult = event.getResult();\n-    if (commandResult.isForwardToServer() || !commandResult.isAllowed()) {\n-      return false;\n-    }\n-    cmdLine = commandResult.getCommand().orElse(event.getCommand());\n+    return callCommandEvent(source, cmdLine).thenApply(event -> {\n+      CommandResult commandResult = event.getResult();\n+      if (commandResult.isForwardToServer() || !commandResult.isAllowed()) {\n+        return false;\n+      }\n \n-    return executeImmediately(source, cmdLine);\n+      String command = commandResult.getCommand().orElse(event.getCommand());\n+      return executeImmediately0(source, command);\n+    });\n   }\n \n   @Override\n-  public boolean executeImmediately(CommandSource source, String cmdLine) {\n+  public CompletableFuture<Boolean> executeImmediately(final CommandSource source,\n+                                                       final String cmdLine) {\n     Preconditions.checkNotNull(source, \"source\");\n     Preconditions.checkNotNull(cmdLine, \"cmdLine\");\n \n+    return CompletableFuture.supplyAsync(\n+        () -> executeImmediately0(source, cmdLine), eventManager.getService());\n+  }\n+\n+  private <I extends CommandInvocation> boolean executeImmediately0(final CommandSource source,\n+                                                                    final String cmdLine) {\n     String alias = cmdLine;\n     String args = \"\";\n     int firstSpace = cmdLine.indexOf(' ');\n     if (firstSpace != -1) {\n       alias = cmdLine.substring(0, firstSpace);\n       args = cmdLine.substring(firstSpace);\n     }\n-    RawCommand command = commands.get(alias.toLowerCase(Locale.ENGLISH));\n+\n+    Command<I> command = getCommand(alias);\n     if (command == null) {\n       return false;\n     }\n \n+    I invocation = invocationFactory.createInvocation(command, source, alias, args);\n     try {\n-      if (!command.hasPermission(source, args)) {\n+      if (!command.hasPermission(invocation)) {\n         return false;\n       }\n-      command.execute(source, args);\n+\n+      command.execute(invocation);\n       return true;\n-    } catch (Exception e) {\n+    } catch (final Exception e) {\n+      if (e.getCause() instanceof CommandSyntaxException) {\n+        // TODO Send invalid syntax message to player (exception contains details)\n+        return false;\n+      }\n+\n       throw new RuntimeException(\"Unable to invoke command \" + cmdLine + \" for \" + source, e);\n     }\n   }\n \n+  // Suggestions\n \n-  @Override\n-  public CompletableFuture<Boolean> executeAsync(CommandSource source, String cmdLine) {\n-    CompletableFuture<Boolean> result = new CompletableFuture<>();\n-    callCommandEvent(source, cmdLine).thenAccept(event -> {\n-      CommandResult commandResult = event.getResult();\n-      if (commandResult.isForwardToServer() || !commandResult.isAllowed()) {\n-        result.complete(false);\n-      }\n-      String command = commandResult.getCommand().orElse(event.getCommand());\n-      try {\n-        result.complete(executeImmediately(source, command));\n-      } catch (Exception e) {\n-        result.completeExceptionally(e);\n-      }\n-    });\n-    return result;\n-  }\n+  private <I extends CommandInvocation> CompletableFuture<List<String>> offerSuggestions(\n+          final CommandSource source, final String alias, final String args) {\n+    Command<I> command = getCommand(alias);\n+    if (command == null) {\n+      // No such command, so we can't offer any tab complete suggestions.\n+      return CompletableFuture.completedFuture(ImmutableList.of());\n+    }\n \n-  @Override\n-  public CompletableFuture<Boolean> executeImmediatelyAsync(CommandSource source, String cmdLine) {\n-    Preconditions.checkNotNull(source, \"source\");\n-    Preconditions.checkNotNull(cmdLine, \"cmdLine\");\n-    CompletableFuture<Boolean> result = new CompletableFuture<>();\n-    eventManager.getService().execute(() -> {\n-      try {\n-        result.complete(executeImmediately(source, cmdLine));\n-      } catch (Exception e) {\n-        result.completeExceptionally(e);\n+    I invocation = invocationFactory.createInvocation(command, source, alias, args);\n+    try {\n+      if (!command.hasPermission(invocation)) {\n+        return CompletableFuture.completedFuture(ImmutableList.of());\n       }\n-    });\n-    return result;\n-  }\n \n-  public boolean hasCommand(String command) {\n-    return commands.containsKey(command);\n-  }\n+      return command.suggestAsync(invocation).thenApply(ImmutableList::copyOf);\n+    } catch (final Exception e) {\n+      if (e.getCause() instanceof CommandSyntaxException) {\n+        return CompletableFuture.completedFuture(ImmutableList.of());\n+      }\n \n-  public Set<String> getAllRegisteredCommands() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjcwNTcwMA=="}, "originalCommit": {"oid": "609f7779ef58aeb6457cadc1eef57fc065f9af47"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0OTU0MDgxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/velocitypowered/api/command/Command.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMTozOToxMFrOGznuAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOFQxMTozOToxMFrOGznuAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc4MTMxNQ==", "bodyText": "<p>For this reason, the legacy {@code execute(CommandSender, String...)}, {@code suggest(CommandSender, String...)}, and {@code hasPermission(CommandSender, String...)} methods are deprecated and will be removed in Velocity 2.0.0. We suggest implementing one of the more specific subinterfaces instead.", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r456781315", "createdAt": "2020-07-18T11:39:10Z", "author": {"login": "astei"}, "path": "api/src/main/java/com/velocitypowered/api/command/Command.java", "diffHunk": "@@ -4,10 +4,35 @@\n import com.velocitypowered.api.proxy.Player;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n \n /**\n  * Represents a command that can be executed by a {@link CommandSource}, such as\n  * a {@link Player} or the console.\n+ *\n+ * <p>Velocity 1.1.0 introduces specialized command subinterfaces to separate\n+ * command parsing concerns. These include, in order of preference:\n+ *\n+ * <ul>\n+ * <li>{@link BrigadierCommand}, which supports parameterized arguments and\n+ * specialized execution, tab complete suggestions and permission-checking logic.\n+ *\n+ * <li>{@link LegacyCommand}, modelled after the convention popularized by\n+ * Bukkit and BungeeCord. Older classes directly implementing {@link Command}\n+ * are suggested to migrate to this interface.\n+ *\n+ * <li>{@link RawCommand}, useful for bolting on external command frameworks\n+ * to Velocity.\n+ *\n+ * </ul>\n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f28b7b210f2d577153c7e2998d710d320070dfac"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTQ2Mzc1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/velocitypowered/api/command/BrigadierCommand.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjoyMToyMFrOG0_2TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMToxODowN1rOG1d94g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyNTIyOQ==", "bodyText": "Specify that you should use if you don't want the command to be sent to the backend server at all.", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r458225229", "createdAt": "2020-07-21T16:21:20Z", "author": {"login": "astei"}, "path": "api/src/main/java/com/velocitypowered/api/command/BrigadierCommand.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.velocitypowered.api.command;\n+\n+import com.mojang.brigadier.builder.LiteralArgumentBuilder;\n+import com.mojang.brigadier.context.CommandContext;\n+import com.mojang.brigadier.tree.CommandNode;\n+import com.mojang.brigadier.tree.LiteralCommandNode;\n+import java.util.function.Predicate;\n+\n+/**\n+ * A command that uses Brigadier for parsing the command and providing\n+ * suggestions to the client.\n+ *\n+ * <p>Brigadier commands may be registered using a {@link Builder} instance\n+ * obtainable via the {@link CommandManager#brigadierBuilder()} method.\n+ */\n+public interface BrigadierCommand extends Command {\n+\n+  /**\n+   * Provides a fluent interface to register a Brigadier command.\n+   */\n+  interface Builder extends Command.Builder<BrigadierCommand, Builder> {\n+\n+    /**\n+     * Specifies the permission-checking predicate the {@link CommandSource}\n+     * must pass to execute the command.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb846499aa9df2f59d1d19d7ffb017d21655563a"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4NDExNA==", "bodyText": "I'm thinking about the use cases for this, and letting Brigadier commands return a special code (as the implementation does right now) to indicate a redirect is desired would be simpler and easier (the current injection is a mess).\nI originally added this because I thought not having permission for some specific arguments wouldn't redirect the command to the backend as it currently does. Thoughts on this behavior?", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r458284114", "createdAt": "2020-07-21T17:55:23Z", "author": {"login": "hugmanrique"}, "path": "api/src/main/java/com/velocitypowered/api/command/BrigadierCommand.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.velocitypowered.api.command;\n+\n+import com.mojang.brigadier.builder.LiteralArgumentBuilder;\n+import com.mojang.brigadier.context.CommandContext;\n+import com.mojang.brigadier.tree.CommandNode;\n+import com.mojang.brigadier.tree.LiteralCommandNode;\n+import java.util.function.Predicate;\n+\n+/**\n+ * A command that uses Brigadier for parsing the command and providing\n+ * suggestions to the client.\n+ *\n+ * <p>Brigadier commands may be registered using a {@link Builder} instance\n+ * obtainable via the {@link CommandManager#brigadierBuilder()} method.\n+ */\n+public interface BrigadierCommand extends Command {\n+\n+  /**\n+   * Provides a fluent interface to register a Brigadier command.\n+   */\n+  interface Builder extends Command.Builder<BrigadierCommand, Builder> {\n+\n+    /**\n+     * Specifies the permission-checking predicate the {@link CommandSource}\n+     * must pass to execute the command.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyNTIyOQ=="}, "originalCommit": {"oid": "cb846499aa9df2f59d1d19d7ffb017d21655563a"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxODY5MA==", "bodyText": "I added a BrigadierCommand#FORWARD so implementations can indicate a command execution should be forwarded to the backend server. This is more general and is not only limited to the previous permission-checking logic. Commands can now use the regular ArgumentBuilder#requires method to specify a predicate.", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r458718690", "createdAt": "2020-07-22T11:18:07Z", "author": {"login": "hugmanrique"}, "path": "api/src/main/java/com/velocitypowered/api/command/BrigadierCommand.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.velocitypowered.api.command;\n+\n+import com.mojang.brigadier.builder.LiteralArgumentBuilder;\n+import com.mojang.brigadier.context.CommandContext;\n+import com.mojang.brigadier.tree.CommandNode;\n+import com.mojang.brigadier.tree.LiteralCommandNode;\n+import java.util.function.Predicate;\n+\n+/**\n+ * A command that uses Brigadier for parsing the command and providing\n+ * suggestions to the client.\n+ *\n+ * <p>Brigadier commands may be registered using a {@link Builder} instance\n+ * obtainable via the {@link CommandManager#brigadierBuilder()} method.\n+ */\n+public interface BrigadierCommand extends Command {\n+\n+  /**\n+   * Provides a fluent interface to register a Brigadier command.\n+   */\n+  interface Builder extends Command.Builder<BrigadierCommand, Builder> {\n+\n+    /**\n+     * Specifies the permission-checking predicate the {@link CommandSource}\n+     * must pass to execute the command.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyNTIyOQ=="}, "originalCommit": {"oid": "cb846499aa9df2f59d1d19d7ffb017d21655563a"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTQ3NzkxOnYy", "diffSide": "LEFT", "path": "api/src/main/java/com/velocitypowered/api/command/CommandManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjoyNDo0NlrOG0__EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjoyNDo0NlrOG0__EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyNzQ3Mw==", "bodyText": "This is still API-breaking...", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r458227473", "createdAt": "2020-07-21T16:24:46Z", "author": {"login": "astei"}, "path": "api/src/main/java/com/velocitypowered/api/command/CommandManager.java", "diffHunk": "@@ -1,87 +1,68 @@\n package com.velocitypowered.api.command;\n \n+import com.velocitypowered.api.event.command.CommandExecuteEvent;\n import java.util.concurrent.CompletableFuture;\n \n /**\n- * Represents an interface to register a command executor with the proxy.\n+ * Handles the registration and execution of commands.\n  */\n public interface CommandManager {\n \n   /**\n-   * Registers the specified command with the manager with the specified aliases.\n+   * Returns a builder to register a {@link BrigadierCommand}.\n+   *\n+   * @return a Brigadier command builder\n+   */\n+  BrigadierCommand.Builder brigadierBuilder();\n+\n+  /**\n+   * Registers the specified command with the specified aliases.\n    *\n    * @param command the command to register\n-   * @param aliases the alias to use\n+   * @param aliases the command aliases\n    *\n+   * @throws IllegalArgumentException if one of the given aliases is already registered\n    * @deprecated This method requires at least one alias, but this is only enforced at runtime.\n-   *             Prefer {@link #register(String, Command, String...)} instead.\n+   *             Prefer {@link #register(String, Command, String...)}\n    */\n   @Deprecated\n   void register(Command command, String... aliases);\n \n   /**\n-   * Registers the specified command with the manager with the specified aliases.\n+   * Registers the specified command with the specified aliases.\n    *\n-   * @param alias the first alias to register\n+   * @param alias the first command alias\n    * @param command the command to register\n-   * @param otherAliases the other aliases to use\n+   * @param otherAliases additional aliases\n+   * @throws IllegalArgumentException if one of the given aliases is already registered\n    */\n   void register(String alias, Command command, String... otherAliases);\n \n   /**\n-   * Unregisters a command.\n+   * Unregisters the specified command alias from the manager, if registered.\n    *\n    * @param alias the command alias to unregister\n    */\n   void unregister(String alias);\n \n   /**\n-   * Calls CommandExecuteEvent and attempts to execute a command using the specified {@code cmdLine}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb846499aa9df2f59d1d19d7ffb017d21655563a"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTQ4OTE4OnYy", "diffSide": "RIGHT", "path": "proxy/src/main/java/com/velocitypowered/proxy/command/builtin/ShutdownCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjoyNzoyNlrOG1AGDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjoyNzoyNlrOG1AGDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyOTI2Mw==", "bodyText": "I would probably make this a RawCommand", "url": "https://github.com/VelocityPowered/Velocity/pull/330#discussion_r458229263", "createdAt": "2020-07-21T16:27:26Z", "author": {"login": "astei"}, "path": "proxy/src/main/java/com/velocitypowered/proxy/command/builtin/ShutdownCommand.java", "diffHunk": "@@ -1,12 +1,10 @@\n-package com.velocitypowered.proxy.command;\n+package com.velocitypowered.proxy.command.builtin;\n \n-import com.velocitypowered.api.command.Command;\n-import com.velocitypowered.api.command.CommandSource;\n+import com.velocitypowered.api.command.LegacyCommand;\n import com.velocitypowered.proxy.VelocityServer;\n import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;\n-import org.checkerframework.checker.nullness.qual.NonNull;\n \n-public class ShutdownCommand implements Command {\n+public class ShutdownCommand implements LegacyCommand {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb846499aa9df2f59d1d19d7ffb017d21655563a"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2761, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}