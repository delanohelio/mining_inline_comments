{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0MjE2OTg0", "number": 63, "title": "Implement byte stream splitting by delimiter", "bodyText": "Related  to #32\nByteByByteSplit is the first step in the process of implementing reactive multipart parsing", "createdAt": "2020-03-05T11:19:46Z", "url": "https://github.com/artipie/http/pull/63", "merged": true, "mergeCommit": {"oid": "5b955ad486f2a340e590e9d04142040d1ffe9fee"}, "closed": true, "closedAt": "2020-03-11T08:04:24Z", "author": {"login": "Sammers21"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIGkHIgH2gAyMzg0MjE2OTg0OmE2MzU1ZjYwZTNiYzRjNGEwOTQ3YjM4YzdlOTA2ZGI3ZWVlNmJlYTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMifQQgFqTM3MjUzOTQ1OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a6355f60e3bc4c4a0947b38c7e906db7eee6bea4", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/a6355f60e3bc4c4a0947b38c7e906db7eee6bea4", "committedDate": "2020-02-26T13:16:21Z", "message": "introduce byte stream splitters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "276f0a912b64830b191e6cf42e0c075878fbe2f1", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/276f0a912b64830b191e6cf42e0c075878fbe2f1", "committedDate": "2020-02-27T13:56:00Z", "message": "use RingBuffers from guava"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3432a31a88b6f9eabc2e29616386ccf121e2144", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/c3432a31a88b6f9eabc2e29616386ccf121e2144", "committedDate": "2020-02-28T09:16:38Z", "message": "add more implementation details"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bd7e170865856345f36d01f0c5b76fdbbb7fb53", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/9bd7e170865856345f36d01f0c5b76fdbbb7fb53", "committedDate": "2020-03-02T15:09:34Z", "message": "update multipart splitter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ac1a5ac6f6d6a3e2fd2b219a070e3190604c4fe", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/2ac1a5ac6f6d6a3e2fd2b219a070e3190604c4fe", "committedDate": "2020-03-03T09:11:48Z", "message": "continue to work on splitter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64b5b9d56932bdb8fbd6560daeddbb776b6a70d1", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/64b5b9d56932bdb8fbd6560daeddbb776b6a70d1", "committedDate": "2020-03-03T12:38:33Z", "message": "continue to work on splitter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d071b1cb4dfed5f81d586b9563e283f544848a5", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/6d071b1cb4dfed5f81d586b9563e283f544848a5", "committedDate": "2020-03-03T14:30:33Z", "message": "continue to work on splitter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6ff4ba7cf950f762180944e23134ad358a9b351", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/f6ff4ba7cf950f762180944e23134ad358a9b351", "committedDate": "2020-03-03T16:07:20Z", "message": "continue to work on splitter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c19cbe1ef7bd379cc5a0c575b6129999b622b1ee", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/c19cbe1ef7bd379cc5a0c575b6129999b622b1ee", "committedDate": "2020-03-03T18:07:45Z", "message": "fixing qulice warnings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2236c8cd8c0b2558d587553bd39ebc2328bb0547", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/2236c8cd8c0b2558d587553bd39ebc2328bb0547", "committedDate": "2020-03-05T11:18:28Z", "message": "implement byte stream splitting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5d4caa9e9db06a03e4f299b98093f4afcc77278", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/d5d4caa9e9db06a03e4f299b98093f4afcc77278", "committedDate": "2020-03-05T11:34:25Z", "message": "remove useless dependencies"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e6088dbdf379d7fc1806186a5784ab50c4e370a", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/3e6088dbdf379d7fc1806186a5784ab50c4e370a", "committedDate": "2020-03-05T12:05:01Z", "message": "add todos for subsequent changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abd8e7adea81e4b6076dfad3cca3c61d725b4056", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/abd8e7adea81e4b6076dfad3cca3c61d725b4056", "committedDate": "2020-03-05T12:09:05Z", "message": "Merge branch 'master' of github.com:artipie/http into stream_splitters"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb86f7901cd20b0d5c894f7b9d6a2d39d62f04b2", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/eb86f7901cd20b0d5c894f7b9d6a2d39d62f04b2", "committedDate": "2020-03-05T12:13:09Z", "message": "add apache commons"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/356854b1bdc3ceeb24b5228136c627caa2a6eb51", "committedDate": "2020-03-05T12:18:02Z", "message": "make apache commons non test dependency"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODgxNzg1", "url": "https://github.com/artipie/http/pull/63#pullrequestreview-369881785", "createdAt": "2020-03-05T20:14:59Z", "commit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzI5Mzg4", "url": "https://github.com/artipie/http/pull/63#pullrequestreview-370729388", "createdAt": "2020-03-07T07:33:38Z", "commit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwNzozMzozOFrOFzNC7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwNzo1NDo1MFrOFzNHAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTQzNg==", "bodyText": "@Sammers21 Let's stick to conventions and call this class ByteByByteSplitTest", "url": "https://github.com/artipie/http/pull/63#discussion_r389235436", "createdAt": "2020-03-07T07:33:38Z", "author": {"login": "HDouss"}, "path": "src/test/java/com/artipie/http/stream/SplitTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import io.reactivex.Flowable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.hamcrest.MatcherAssert;\n+import org.hamcrest.core.IsEqual;\n+import org.junit.jupiter.api.RepeatedTest;\n+\n+/**\n+ * Tests for {@link ByteByByteSplit}.\n+ *\n+ * @since 0.4\n+ * @checkstyle MagicNumberCheck (500 lines)\n+ */\n+public final class SplitTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTUxMQ==", "bodyText": "@Sammers21 The varibales actual and flow are used only once. Let's inline them.", "url": "https://github.com/artipie/http/pull/63#discussion_r389235511", "createdAt": "2020-03-07T07:35:28Z", "author": {"login": "HDouss"}, "path": "src/test/java/com/artipie/http/stream/SplitTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import io.reactivex.Flowable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.hamcrest.MatcherAssert;\n+import org.hamcrest.core.IsEqual;\n+import org.junit.jupiter.api.RepeatedTest;\n+\n+/**\n+ * Tests for {@link ByteByByteSplit}.\n+ *\n+ * @since 0.4\n+ * @checkstyle MagicNumberCheck (500 lines)\n+ */\n+public final class SplitTest {\n+\n+    @RepeatedTest(10_000)\n+    public void basicSplitWorks() {\n+        final Flowable<ByteBuffer> flow = Flowable.fromArray(\n+            Arrays.stream(\n+                ArrayUtils.toObject(\"how are you\".getBytes())\n+            ).map(\n+                (Byte aByte) -> {\n+                    final byte[] bytes = new byte[1];\n+                    bytes[0] = aByte;\n+                    return ByteBuffer.wrap(bytes);\n+                }\n+            ).toArray(ByteBuffer[]::new)\n+        );\n+        final ByteByByteSplit split = new ByteByByteSplit(\" \".getBytes());\n+        flow.subscribe(split);\n+        final String actual = new String(\n+            Flowable.fromPublisher(split)\n+                .flatMap(pub -> pub)\n+                .toList()\n+                .blockingGet()\n+                .stream()\n+                .map(\n+                    byteBuffer -> {\n+                        final byte[] res = new byte[byteBuffer.remaining()];\n+                        byteBuffer.get(res);\n+                        return res;\n+                    }\n+                )\n+                .reduce(\n+                    (one, another) -> {\n+                        final byte[] res = new byte[one.length + another.length];\n+                        System.arraycopy(one, 0, res, 0, one.length);\n+                        System.arraycopy(another, 0, res, one.length, another.length);\n+                        return res;\n+                    }\n+                )\n+                .get()\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTY3Mg==", "bodyText": "@Sammers21 Unless a misuse of the API, I don't think downstream could be empty here, we can remove this test.", "url": "https://github.com/artipie/http/pull/63#discussion_r389235672", "createdAt": "2020-03-07T07:38:48Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();\n+            if (eviction) {\n+                final Byte last = this.ring.get(this.delim.length - 1);\n+                current.put(last);\n+            }\n+            this.ring.add(each);\n+            final byte[] primitive = this.ringBytes();\n+            if (Arrays.equals(this.delim, primitive)) {\n+                this.ring.clear();\n+                current.limit(current.position());\n+                current.reset();\n+                this.emit(Optional.of(current));\n+                this.emit(Optional.empty());\n+                current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+            }\n+        }\n+        current.limit(current.position());\n+        current.reset();\n+        this.emit(Optional.of(current));\n+    }\n+\n+    @Override\n+    public void onError(final Throwable throwable) {\n+        this.upstreamTerminated.set(true);\n+        final Subscriber<? super Publisher<ByteBuffer>> subscriber = this.downstream.get();\n+        if (subscriber != null) {\n+            subscriber.onError(throwable);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        this.upstreamTerminated.set(true);\n+        this.emit(Optional.of(ByteBuffer.wrap(this.ringBytes())));\n+    }\n+\n+    /**\n+     * Create buffer with initial.\n+     *\n+     * @param size The buf size.\n+     * @return Buffer with the initial mark.\n+     */\n+    private static ByteBuffer bufWithInitMark(final int size) {\n+        final ByteBuffer current = ByteBuffer.allocate(size);\n+        current.mark();\n+        return current;\n+    }\n+\n+    /**\n+     * Return currently held buffer bytes.\n+     * @return Currently held buffer bytes.\n+     */\n+    private byte[] ringBytes() {\n+        return ArrayUtils.toPrimitive(this.ring.stream().toArray(Byte[]::new));\n+    }\n+\n+    /**\n+     * Try to start the processor.\n+     */\n+    private void tryToStart() {\n+        if (this.downstream.get() != null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTc1Ng==", "bodyText": "@Sammers21 Let's inline eviction here", "url": "https://github.com/artipie/http/pull/63#discussion_r389235756", "createdAt": "2020-03-07T07:40:52Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTc5MA==", "bodyText": "@Sammers21 and inline last variable", "url": "https://github.com/artipie/http/pull/63#discussion_r389235790", "createdAt": "2020-03-07T07:41:17Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();\n+            if (eviction) {\n+                final Byte last = this.ring.get(this.delim.length - 1);\n+                current.put(last);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTgyNg==", "bodyText": "@Sammers21 We can also inline primitive", "url": "https://github.com/artipie/http/pull/63#discussion_r389235826", "createdAt": "2020-03-07T07:42:08Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();\n+            if (eviction) {\n+                final Byte last = this.ring.get(this.delim.length - 1);\n+                current.put(last);\n+            }\n+            this.ring.add(each);\n+            final byte[] primitive = this.ringBytes();\n+            if (Arrays.equals(this.delim, primitive)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNjE2NQ==", "bodyText": "@Sammers21 typo: should be \"need\"", "url": "https://github.com/artipie/http/pull/63#discussion_r389236165", "createdAt": "2020-03-07T07:48:20Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNjQ4MQ==", "bodyText": "@Sammers21 We have too many checks on null in this class. Maybe we could have atomic references to Optional<> that got set with Optional.empty at initialization.", "url": "https://github.com/artipie/http/pull/63#discussion_r389236481", "createdAt": "2020-03-07T07:54:50Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 67}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3df6bb9f8e75acdb44b62d5aabcc9c8efacdbd3", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/f3df6bb9f8e75acdb44b62d5aabcc9c8efacdbd3", "committedDate": "2020-03-10T13:31:12Z", "message": "rename SplitTest to ByteByByteSplitTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6021d11401ad8a20b4ab21ed8ea56f4d0c4de5c9", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/6021d11401ad8a20b4ab21ed8ea56f4d0c4de5c9", "committedDate": "2020-03-10T13:32:27Z", "message": "inline flow and actual"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "defcac95a2a0a54433b5742b9a20c3f1ea366330", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/defcac95a2a0a54433b5742b9a20c3f1ea366330", "committedDate": "2020-03-10T13:34:47Z", "message": "fix qulice warning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "daf61e94e0e7ba73598cb87e485ee9ca2c9c5cc0", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/daf61e94e0e7ba73598cb87e485ee9ca2c9c5cc0", "committedDate": "2020-03-10T13:35:11Z", "message": "repeat test 100 times instead of 10000"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8e8716216d24537419a8df16a56a979ac10d281", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/e8e8716216d24537419a8df16a56a979ac10d281", "committedDate": "2020-03-10T14:54:36Z", "message": "inline primitive"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75c3842b01fd0ca1381927a26b9d18f4b7acd627", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/75c3842b01fd0ca1381927a26b9d18f4b7acd627", "committedDate": "2020-03-10T14:54:53Z", "message": "fix typo"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ba243fe44de7d7c3abaa8839f863d26ad660cc2", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/3ba243fe44de7d7c3abaa8839f863d26ad660cc2", "committedDate": "2020-03-10T15:00:15Z", "message": "using optional instead of null"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxOTkxMjU4", "url": "https://github.com/artipie/http/pull/63#pullrequestreview-371991258", "createdAt": "2020-03-10T14:15:49Z", "commit": {"oid": "daf61e94e0e7ba73598cb87e485ee9ca2c9c5cc0"}, "state": "DISMISSED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNDoxNTo0OVrOF0QutQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNDoxOTo1MVrOF0Q68A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM0NDM3Mw==", "bodyText": "@Sammers21 Generally we inline one-time used variables. Will approve this if @g4s8 accepts this exception.", "url": "https://github.com/artipie/http/pull/63#discussion_r390344373", "createdAt": "2020-03-10T14:15:49Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTc1Ng=="}, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM0NTAyMw==", "bodyText": "@Sammers21 Same as above. I don't see any harm in inlining this.", "url": "https://github.com/artipie/http/pull/63#discussion_r390345023", "createdAt": "2020-03-10T14:16:41Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();\n+            if (eviction) {\n+                final Byte last = this.ring.get(this.delim.length - 1);\n+                current.put(last);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTc5MA=="}, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM0NzUwNA==", "bodyText": "@Sammers21 I agree with that in general. My comment says that downstream could never be empty at this point of execution, unless someone call subscribe method with null.", "url": "https://github.com/artipie/http/pull/63#discussion_r390347504", "createdAt": "2020-03-10T14:19:51Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();\n+            if (eviction) {\n+                final Byte last = this.ring.get(this.delim.length - 1);\n+                current.put(last);\n+            }\n+            this.ring.add(each);\n+            final byte[] primitive = this.ringBytes();\n+            if (Arrays.equals(this.delim, primitive)) {\n+                this.ring.clear();\n+                current.limit(current.position());\n+                current.reset();\n+                this.emit(Optional.of(current));\n+                this.emit(Optional.empty());\n+                current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+            }\n+        }\n+        current.limit(current.position());\n+        current.reset();\n+        this.emit(Optional.of(current));\n+    }\n+\n+    @Override\n+    public void onError(final Throwable throwable) {\n+        this.upstreamTerminated.set(true);\n+        final Subscriber<? super Publisher<ByteBuffer>> subscriber = this.downstream.get();\n+        if (subscriber != null) {\n+            subscriber.onError(throwable);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        this.upstreamTerminated.set(true);\n+        this.emit(Optional.of(ByteBuffer.wrap(this.ringBytes())));\n+    }\n+\n+    /**\n+     * Create buffer with initial.\n+     *\n+     * @param size The buf size.\n+     * @return Buffer with the initial mark.\n+     */\n+    private static ByteBuffer bufWithInitMark(final int size) {\n+        final ByteBuffer current = ByteBuffer.allocate(size);\n+        current.mark();\n+        return current;\n+    }\n+\n+    /**\n+     * Return currently held buffer bytes.\n+     * @return Currently held buffer bytes.\n+     */\n+    private byte[] ringBytes() {\n+        return ArrayUtils.toPrimitive(this.ring.stream().toArray(Byte[]::new));\n+    }\n+\n+    /**\n+     * Try to start the processor.\n+     */\n+    private void tryToStart() {\n+        if (this.downstream.get() != null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTY3Mg=="}, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 234}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNTIwNTk2", "url": "https://github.com/artipie/http/pull/63#pullrequestreview-372520596", "createdAt": "2020-03-11T07:22:29Z", "commit": {"oid": "3ba243fe44de7d7c3abaa8839f863d26ad660cc2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzoyMjoyOVrOF0re8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzoyNjoxNFrOF0rj6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc4MjcwNg==", "bodyText": "@Sammers21 is it possible to use IdentityProcessorVerification base test class from tck here?", "url": "https://github.com/artipie/http/pull/63#discussion_r390782706", "createdAt": "2020-03-11T07:22:29Z", "author": {"login": "g4s8"}, "path": "src/test/java/com/artipie/http/stream/ByteByByteSplitTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import io.reactivex.Flowable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.hamcrest.MatcherAssert;\n+import org.hamcrest.core.IsEqual;\n+import org.junit.jupiter.api.RepeatedTest;\n+\n+/**\n+ * Tests for {@link ByteByByteSplit}.\n+ *\n+ * @since 0.4\n+ * @checkstyle MagicNumberCheck (500 lines)\n+ */\n+public final class ByteByByteSplitTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba243fe44de7d7c3abaa8839f863d26ad660cc2"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc4MjkxNA==", "bodyText": "@Sammers21 I don't think we need RepeatedTest here", "url": "https://github.com/artipie/http/pull/63#discussion_r390782914", "createdAt": "2020-03-11T07:23:07Z", "author": {"login": "g4s8"}, "path": "src/test/java/com/artipie/http/stream/ByteByByteSplitTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import io.reactivex.Flowable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.hamcrest.MatcherAssert;\n+import org.hamcrest.core.IsEqual;\n+import org.junit.jupiter.api.RepeatedTest;\n+\n+/**\n+ * Tests for {@link ByteByByteSplit}.\n+ *\n+ * @since 0.4\n+ * @checkstyle MagicNumberCheck (500 lines)\n+ */\n+public final class ByteByByteSplitTest {\n+\n+    @RepeatedTest(100)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba243fe44de7d7c3abaa8839f863d26ad660cc2"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc4MzM4Mw==", "bodyText": "@Sammers21 you need to add one space indentation for todo puzzle, see https://github.com/yegor256/pdd#how-to-format", "url": "https://github.com/artipie/http/pull/63#discussion_r390783383", "createdAt": "2020-03-11T07:24:36Z", "author": {"login": "g4s8"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba243fe44de7d7c3abaa8839f863d26ad660cc2"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc4Mzk3OA==", "bodyText": "@Sammers21 @HDouss  I'd keep eviction and last here, since this class and methods are too complex for reading. Maybe we'll need to refactor it later", "url": "https://github.com/artipie/http/pull/63#discussion_r390783978", "createdAt": "2020-03-11T07:26:14Z", "author": {"login": "g4s8"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTc1Ng=="}, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 174}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c4836e16f17e33217692e5b8f8805fece854a82", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/0c4836e16f17e33217692e5b8f8805fece854a82", "committedDate": "2020-03-11T07:51:04Z", "message": "Update ByteByByteSplitTest.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a423e78a3c157b0bcaf79ac2f21a43b7fc33d0f", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/4a423e78a3c157b0bcaf79ac2f21a43b7fc33d0f", "committedDate": "2020-03-11T07:57:50Z", "message": "remove trailing space"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f12885c356aaca2f9e0823edf092125c926a0c47", "author": {"user": {"login": "Sammers21", "name": "Pavel Drankov"}}, "url": "https://github.com/artipie/http/commit/f12885c356aaca2f9e0823edf092125c926a0c47", "committedDate": "2020-03-11T07:59:22Z", "message": "add one space identation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNTM5NDU4", "url": "https://github.com/artipie/http/pull/63#pullrequestreview-372539458", "createdAt": "2020-03-11T08:04:05Z", "commit": {"oid": "f12885c356aaca2f9e0823edf092125c926a0c47"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3326, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}