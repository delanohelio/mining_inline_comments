{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0MjE2OTg0", "number": 63, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwNzozMzozOFrODmACIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzoyNDozNlrODm9iAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTczMDI3OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/artipie/http/stream/SplitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwNzozMzozOFrOFzNC7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwNzozMzozOFrOFzNC7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTQzNg==", "bodyText": "@Sammers21 Let's stick to conventions and call this class ByteByByteSplitTest", "url": "https://github.com/artipie/http/pull/63#discussion_r389235436", "createdAt": "2020-03-07T07:33:38Z", "author": {"login": "HDouss"}, "path": "src/test/java/com/artipie/http/stream/SplitTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import io.reactivex.Flowable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.hamcrest.MatcherAssert;\n+import org.hamcrest.core.IsEqual;\n+import org.junit.jupiter.api.RepeatedTest;\n+\n+/**\n+ * Tests for {@link ByteByByteSplit}.\n+ *\n+ * @since 0.4\n+ * @checkstyle MagicNumberCheck (500 lines)\n+ */\n+public final class SplitTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTczMDg0OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/artipie/http/stream/SplitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwNzozNToyOFrOFzNDNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwNzozNToyOFrOFzNDNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTUxMQ==", "bodyText": "@Sammers21 The varibales actual and flow are used only once. Let's inline them.", "url": "https://github.com/artipie/http/pull/63#discussion_r389235511", "createdAt": "2020-03-07T07:35:28Z", "author": {"login": "HDouss"}, "path": "src/test/java/com/artipie/http/stream/SplitTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import io.reactivex.Flowable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.hamcrest.MatcherAssert;\n+import org.hamcrest.core.IsEqual;\n+import org.junit.jupiter.api.RepeatedTest;\n+\n+/**\n+ * Tests for {@link ByteByByteSplit}.\n+ *\n+ * @since 0.4\n+ * @checkstyle MagicNumberCheck (500 lines)\n+ */\n+public final class SplitTest {\n+\n+    @RepeatedTest(10_000)\n+    public void basicSplitWorks() {\n+        final Flowable<ByteBuffer> flow = Flowable.fromArray(\n+            Arrays.stream(\n+                ArrayUtils.toObject(\"how are you\".getBytes())\n+            ).map(\n+                (Byte aByte) -> {\n+                    final byte[] bytes = new byte[1];\n+                    bytes[0] = aByte;\n+                    return ByteBuffer.wrap(bytes);\n+                }\n+            ).toArray(ByteBuffer[]::new)\n+        );\n+        final ByteByByteSplit split = new ByteByByteSplit(\" \".getBytes());\n+        flow.subscribe(split);\n+        final String actual = new String(\n+            Flowable.fromPublisher(split)\n+                .flatMap(pub -> pub)\n+                .toList()\n+                .blockingGet()\n+                .stream()\n+                .map(\n+                    byteBuffer -> {\n+                        final byte[] res = new byte[byteBuffer.remaining()];\n+                        byteBuffer.get(res);\n+                        return res;\n+                    }\n+                )\n+                .reduce(\n+                    (one, another) -> {\n+                        final byte[] res = new byte[one.length + another.length];\n+                        System.arraycopy(one, 0, res, 0, one.length);\n+                        System.arraycopy(another, 0, res, one.length, another.length);\n+                        return res;\n+                    }\n+                )\n+                .get()\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTczMTk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwNzozODo0OFrOFzND2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNDoxOTo1MVrOF0Q68A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTY3Mg==", "bodyText": "@Sammers21 Unless a misuse of the API, I don't think downstream could be empty here, we can remove this test.", "url": "https://github.com/artipie/http/pull/63#discussion_r389235672", "createdAt": "2020-03-07T07:38:48Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();\n+            if (eviction) {\n+                final Byte last = this.ring.get(this.delim.length - 1);\n+                current.put(last);\n+            }\n+            this.ring.add(each);\n+            final byte[] primitive = this.ringBytes();\n+            if (Arrays.equals(this.delim, primitive)) {\n+                this.ring.clear();\n+                current.limit(current.position());\n+                current.reset();\n+                this.emit(Optional.of(current));\n+                this.emit(Optional.empty());\n+                current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+            }\n+        }\n+        current.limit(current.position());\n+        current.reset();\n+        this.emit(Optional.of(current));\n+    }\n+\n+    @Override\n+    public void onError(final Throwable throwable) {\n+        this.upstreamTerminated.set(true);\n+        final Subscriber<? super Publisher<ByteBuffer>> subscriber = this.downstream.get();\n+        if (subscriber != null) {\n+            subscriber.onError(throwable);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        this.upstreamTerminated.set(true);\n+        this.emit(Optional.of(ByteBuffer.wrap(this.ringBytes())));\n+    }\n+\n+    /**\n+     * Create buffer with initial.\n+     *\n+     * @param size The buf size.\n+     * @return Buffer with the initial mark.\n+     */\n+    private static ByteBuffer bufWithInitMark(final int size) {\n+        final ByteBuffer current = ByteBuffer.allocate(size);\n+        current.mark();\n+        return current;\n+    }\n+\n+    /**\n+     * Return currently held buffer bytes.\n+     * @return Currently held buffer bytes.\n+     */\n+    private byte[] ringBytes() {\n+        return ArrayUtils.toPrimitive(this.ring.stream().toArray(Byte[]::new));\n+    }\n+\n+    /**\n+     * Try to start the processor.\n+     */\n+    private void tryToStart() {\n+        if (this.downstream.get() != null", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxNjI5Ng==", "bodyText": "No, in order to start the processor, we need to ensure that down and up streams are defined.", "url": "https://github.com/artipie/http/pull/63#discussion_r390316296", "createdAt": "2020-03-10T13:36:14Z", "author": {"login": "Sammers21"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();\n+            if (eviction) {\n+                final Byte last = this.ring.get(this.delim.length - 1);\n+                current.put(last);\n+            }\n+            this.ring.add(each);\n+            final byte[] primitive = this.ringBytes();\n+            if (Arrays.equals(this.delim, primitive)) {\n+                this.ring.clear();\n+                current.limit(current.position());\n+                current.reset();\n+                this.emit(Optional.of(current));\n+                this.emit(Optional.empty());\n+                current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+            }\n+        }\n+        current.limit(current.position());\n+        current.reset();\n+        this.emit(Optional.of(current));\n+    }\n+\n+    @Override\n+    public void onError(final Throwable throwable) {\n+        this.upstreamTerminated.set(true);\n+        final Subscriber<? super Publisher<ByteBuffer>> subscriber = this.downstream.get();\n+        if (subscriber != null) {\n+            subscriber.onError(throwable);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        this.upstreamTerminated.set(true);\n+        this.emit(Optional.of(ByteBuffer.wrap(this.ringBytes())));\n+    }\n+\n+    /**\n+     * Create buffer with initial.\n+     *\n+     * @param size The buf size.\n+     * @return Buffer with the initial mark.\n+     */\n+    private static ByteBuffer bufWithInitMark(final int size) {\n+        final ByteBuffer current = ByteBuffer.allocate(size);\n+        current.mark();\n+        return current;\n+    }\n+\n+    /**\n+     * Return currently held buffer bytes.\n+     * @return Currently held buffer bytes.\n+     */\n+    private byte[] ringBytes() {\n+        return ArrayUtils.toPrimitive(this.ring.stream().toArray(Byte[]::new));\n+    }\n+\n+    /**\n+     * Try to start the processor.\n+     */\n+    private void tryToStart() {\n+        if (this.downstream.get() != null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTY3Mg=="}, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM0NzUwNA==", "bodyText": "@Sammers21 I agree with that in general. My comment says that downstream could never be empty at this point of execution, unless someone call subscribe method with null.", "url": "https://github.com/artipie/http/pull/63#discussion_r390347504", "createdAt": "2020-03-10T14:19:51Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();\n+            if (eviction) {\n+                final Byte last = this.ring.get(this.delim.length - 1);\n+                current.put(last);\n+            }\n+            this.ring.add(each);\n+            final byte[] primitive = this.ringBytes();\n+            if (Arrays.equals(this.delim, primitive)) {\n+                this.ring.clear();\n+                current.limit(current.position());\n+                current.reset();\n+                this.emit(Optional.of(current));\n+                this.emit(Optional.empty());\n+                current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+            }\n+        }\n+        current.limit(current.position());\n+        current.reset();\n+        this.emit(Optional.of(current));\n+    }\n+\n+    @Override\n+    public void onError(final Throwable throwable) {\n+        this.upstreamTerminated.set(true);\n+        final Subscriber<? super Publisher<ByteBuffer>> subscriber = this.downstream.get();\n+        if (subscriber != null) {\n+            subscriber.onError(throwable);\n+        }\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        this.upstreamTerminated.set(true);\n+        this.emit(Optional.of(ByteBuffer.wrap(this.ringBytes())));\n+    }\n+\n+    /**\n+     * Create buffer with initial.\n+     *\n+     * @param size The buf size.\n+     * @return Buffer with the initial mark.\n+     */\n+    private static ByteBuffer bufWithInitMark(final int size) {\n+        final ByteBuffer current = ByteBuffer.allocate(size);\n+        current.mark();\n+        return current;\n+    }\n+\n+    /**\n+     * Return currently held buffer bytes.\n+     * @return Currently held buffer bytes.\n+     */\n+    private byte[] ringBytes() {\n+        return ArrayUtils.toPrimitive(this.ring.stream().toArray(Byte[]::new));\n+    }\n+\n+    /**\n+     * Try to start the processor.\n+     */\n+    private void tryToStart() {\n+        if (this.downstream.get() != null", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTY3Mg=="}, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 234}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTczMjYwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwNzo0MDo1MlrOFzNELA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzoyNjoxNFrOF0rj6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTc1Ng==", "bodyText": "@Sammers21 Let's inline eviction here", "url": "https://github.com/artipie/http/pull/63#discussion_r389235756", "createdAt": "2020-03-07T07:40:52Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxOTA4OQ==", "bodyText": "@HDouss, I would not do it because of a reason similar to #63 (comment)", "url": "https://github.com/artipie/http/pull/63#discussion_r390319089", "createdAt": "2020-03-10T13:40:21Z", "author": {"login": "Sammers21"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTc1Ng=="}, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM0NDM3Mw==", "bodyText": "@Sammers21 Generally we inline one-time used variables. Will approve this if @g4s8 accepts this exception.", "url": "https://github.com/artipie/http/pull/63#discussion_r390344373", "createdAt": "2020-03-10T14:15:49Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTc1Ng=="}, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc4Mzk3OA==", "bodyText": "@Sammers21 @HDouss  I'd keep eviction and last here, since this class and methods are too complex for reading. Maybe we'll need to refactor it later", "url": "https://github.com/artipie/http/pull/63#discussion_r390783978", "createdAt": "2020-03-11T07:26:14Z", "author": {"login": "g4s8"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTc1Ng=="}, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTczMjkwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwNzo0MToxN1rOFzNETg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNDoxNjo0MVrOF0QxPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTc5MA==", "bodyText": "@Sammers21 and inline last variable", "url": "https://github.com/artipie/http/pull/63#discussion_r389235790", "createdAt": "2020-03-07T07:41:17Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();\n+            if (eviction) {\n+                final Byte last = this.ring.get(this.delim.length - 1);\n+                current.put(last);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxODIxNA==", "bodyText": "@HDouss, would prefer to keep it as is, last is more representative than this.ring.get(this.delim.length - 1). In this case, inlining would be even harmful.", "url": "https://github.com/artipie/http/pull/63#discussion_r390318214", "createdAt": "2020-03-10T13:39:07Z", "author": {"login": "Sammers21"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();\n+            if (eviction) {\n+                final Byte last = this.ring.get(this.delim.length - 1);\n+                current.put(last);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTc5MA=="}, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM0NTAyMw==", "bodyText": "@Sammers21 Same as above. I don't see any harm in inlining this.", "url": "https://github.com/artipie/http/pull/63#discussion_r390345023", "createdAt": "2020-03-10T14:16:41Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();\n+            if (eviction) {\n+                final Byte last = this.ring.get(this.delim.length - 1);\n+                current.put(last);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTc5MA=="}, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTczMzE4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwNzo0MjowOFrOFzNEcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwNzo0MjowOFrOFzNEcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNTgyNg==", "bodyText": "@Sammers21 We can also inline primitive", "url": "https://github.com/artipie/http/pull/63#discussion_r389235826", "createdAt": "2020-03-07T07:42:08Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {\n+\n+    /**\n+     * A ring buffer with bytes. Used for delimiter findings.\n+     */\n+    private final CircularFifoQueue<Byte> ring;\n+\n+    /**\n+     * The stream delimiter.\n+     */\n+    private final byte[] delim;\n+\n+    /**\n+     * The splitted buffers. Empty means delimiter.\n+     */\n+    private final LinkedBlockingQueue<Optional<ByteBuffer>> storage;\n+\n+    /**\n+     * The upstream to request elements from.\n+     */\n+    private final AtomicReference<Subscription> upstream;\n+\n+    /**\n+     * Downstream to emit elements to.\n+     */\n+    private final AtomicReference<Subscriber<? super Publisher<ByteBuffer>>> downstream;\n+\n+    /**\n+     * Downstream of a downstream element.\n+     */\n+    private final AtomicReference<Subscriber<? super ByteBuffer>> downDownstream;\n+\n+    /**\n+     * Is this processor already started?\n+     */\n+    private final AtomicBoolean started;\n+\n+    /**\n+     * Has upstream been terminated.\n+     */\n+    private final AtomicBoolean upstreamTerminated;\n+\n+    /**\n+     * The downstream demand.\n+     */\n+    private final AtomicLong downDemand;\n+\n+    /**\n+     * The down downstream demand.\n+     */\n+    private final AtomicLong downDownDemand;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param delim The delimiter.\n+     */\n+    public ByteByByteSplit(final byte[] delim) {\n+        this.ring = new CircularFifoQueue<>(delim.length);\n+        this.delim = Arrays.copyOf(delim, delim.length);\n+        this.upstream = new AtomicReference<>();\n+        this.downstream = new AtomicReference<>();\n+        this.started = new AtomicBoolean(false);\n+        this.downDownstream = new AtomicReference<>();\n+        this.storage = new LinkedBlockingQueue<>();\n+        this.upstreamTerminated = new AtomicBoolean(false);\n+        this.downDemand = new AtomicLong(0);\n+        this.downDownDemand = new AtomicLong(0);\n+    }\n+\n+    @Override\n+    public void subscribe(final Subscriber<? super Publisher<ByteBuffer>> sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.downstream.set(sub);\n+        sub.onSubscribe(\n+            new Subscription() {\n+                @Override\n+                public void request(final long ask) {\n+                    ByteByByteSplit.this.downDemand.updateAndGet(operand -> operand + ask);\n+                    ByteByByteSplit.this.upstream.get().request(ask);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    throw new IllegalStateException(\"Cancel is not allowed\");\n+                }\n+            }\n+        );\n+        this.tryToStart();\n+    }\n+\n+    @Override\n+    public void onSubscribe(final Subscription sub) {\n+        if (this.downstream.get() != null) {\n+            throw new IllegalStateException(\"Only one subscription is allowed\");\n+        }\n+        this.upstream.set(sub);\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final ByteBuffer next) {\n+        final byte[] bytes = new byte[next.remaining()];\n+        next.get(bytes);\n+        ByteBuffer current = ByteByByteSplit.bufWithInitMark(bytes.length);\n+        for (final byte each : bytes) {\n+            final boolean eviction = this.ring.isAtFullCapacity();\n+            if (eviction) {\n+                final Byte last = this.ring.get(this.delim.length - 1);\n+                current.put(last);\n+            }\n+            this.ring.add(each);\n+            final byte[] primitive = this.ringBytes();\n+            if (Arrays.equals(this.delim, primitive)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTczNTg1OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwNzo0ODoyMFrOFzNFxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwNzo0ODoyMFrOFzNFxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNjE2NQ==", "bodyText": "@Sammers21 typo: should be \"need\"", "url": "https://github.com/artipie/http/pull/63#discussion_r389236165", "createdAt": "2020-03-07T07:48:20Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMTczODQ4OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QwNzo1NDo1MFrOFzNHAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNTowMDozMVrOF0S5Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNjQ4MQ==", "bodyText": "@Sammers21 We have too many checks on null in this class. Maybe we could have atomic references to Optional<> that got set with Optional.empty at initialization.", "url": "https://github.com/artipie/http/pull/63#discussion_r389236481", "createdAt": "2020-03-07T07:54:50Z", "author": {"login": "HDouss"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NTY3OA==", "bodyText": "make sense.", "url": "https://github.com/artipie/http/pull/63#discussion_r390375678", "createdAt": "2020-03-10T14:55:20Z", "author": {"login": "Sammers21"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNjQ4MQ=="}, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3OTc5MQ==", "bodyText": "@HDouss, done", "url": "https://github.com/artipie/http/pull/63#discussion_r390379791", "createdAt": "2020-03-10T15:00:31Z", "author": {"login": "Sammers21"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,\n+ * but we definitely nee to have it.\n+ * @todo #32:30min Downstream emission subscription.\n+ * We need to be aware of the fact that downstream switch doesn't happen instantly.\n+ * For now, implementation does not rely on that.\n+ * @todo #32:30min Full reactive streams tck compatibility.\n+ * The processor implementation should be verified by reactive streams tck in order to ensure\n+ * specification compatibility.\n+ * @since 0.4\n+ * @checkstyle MemberNameCheck (500 lines)\n+ * @checkstyle LongVariable (500 lines)\n+ * @checkstyle TooManyMethods (500 lines)\n+ * @checkstyle EmptyLineSeparatorCheck (500 lines)\n+ */\n+@SuppressWarnings({\n+    \"PMD.AvoidSynchronizedAtMethodLevel\",\n+    \"PMD.LongVariable\",\n+    \"PMD.TooManyMethods\",\n+    \"PMD.AvoidDuplicateLiterals\"\n+})\n+public final class ByteByByteSplit implements Processor<ByteBuffer, Publisher<ByteBuffer>> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNjQ4MQ=="}, "originalCommit": {"oid": "356854b1bdc3ceeb24b5228136c627caa2a6eb51"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTgwMTY3OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/artipie/http/stream/ByteByByteSplitTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzoyMjoyOVrOF0re8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzo0NDo0NVrOF0r9hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc4MjcwNg==", "bodyText": "@Sammers21 is it possible to use IdentityProcessorVerification base test class from tck here?", "url": "https://github.com/artipie/http/pull/63#discussion_r390782706", "createdAt": "2020-03-11T07:22:29Z", "author": {"login": "g4s8"}, "path": "src/test/java/com/artipie/http/stream/ByteByByteSplitTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import io.reactivex.Flowable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.hamcrest.MatcherAssert;\n+import org.hamcrest.core.IsEqual;\n+import org.junit.jupiter.api.RepeatedTest;\n+\n+/**\n+ * Tests for {@link ByteByByteSplit}.\n+ *\n+ * @since 0.4\n+ * @checkstyle MagicNumberCheck (500 lines)\n+ */\n+public final class ByteByByteSplitTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba243fe44de7d7c3abaa8839f863d26ad660cc2"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5MDUyNg==", "bodyText": "No, this class is not tck compliant for now. There is a todo for that", "url": "https://github.com/artipie/http/pull/63#discussion_r390790526", "createdAt": "2020-03-11T07:44:44Z", "author": {"login": "Sammers21"}, "path": "src/test/java/com/artipie/http/stream/ByteByByteSplitTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import io.reactivex.Flowable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.hamcrest.MatcherAssert;\n+import org.hamcrest.core.IsEqual;\n+import org.junit.jupiter.api.RepeatedTest;\n+\n+/**\n+ * Tests for {@link ByteByByteSplit}.\n+ *\n+ * @since 0.4\n+ * @checkstyle MagicNumberCheck (500 lines)\n+ */\n+public final class ByteByByteSplitTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc4MjcwNg=="}, "originalCommit": {"oid": "3ba243fe44de7d7c3abaa8839f863d26ad660cc2"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5MDUzNA==", "bodyText": "No, this class is not tck compliant for now. There is a todo for that", "url": "https://github.com/artipie/http/pull/63#discussion_r390790534", "createdAt": "2020-03-11T07:44:45Z", "author": {"login": "Sammers21"}, "path": "src/test/java/com/artipie/http/stream/ByteByByteSplitTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import io.reactivex.Flowable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.hamcrest.MatcherAssert;\n+import org.hamcrest.core.IsEqual;\n+import org.junit.jupiter.api.RepeatedTest;\n+\n+/**\n+ * Tests for {@link ByteByByteSplit}.\n+ *\n+ * @since 0.4\n+ * @checkstyle MagicNumberCheck (500 lines)\n+ */\n+public final class ByteByByteSplitTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc4MjcwNg=="}, "originalCommit": {"oid": "3ba243fe44de7d7c3abaa8839f863d26ad660cc2"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTgwMzA2OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/artipie/http/stream/ByteByByteSplitTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzoyMzowN1rOF0rfwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzoyMzowN1rOF0rfwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc4MjkxNA==", "bodyText": "@Sammers21 I don't think we need RepeatedTest here", "url": "https://github.com/artipie/http/pull/63#discussion_r390782914", "createdAt": "2020-03-11T07:23:07Z", "author": {"login": "g4s8"}, "path": "src/test/java/com/artipie/http/stream/ByteByByteSplitTest.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import io.reactivex.Flowable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.hamcrest.MatcherAssert;\n+import org.hamcrest.core.IsEqual;\n+import org.junit.jupiter.api.RepeatedTest;\n+\n+/**\n+ * Tests for {@link ByteByByteSplit}.\n+ *\n+ * @since 0.4\n+ * @checkstyle MagicNumberCheck (500 lines)\n+ */\n+public final class ByteByByteSplitTest {\n+\n+    @RepeatedTest(100)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba243fe44de7d7c3abaa8839f863d26ad660cc2"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyMTgwNjA5OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzoyNDozNlrOF0rhlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwNzoyNDozNlrOF0rhlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc4MzM4Mw==", "bodyText": "@Sammers21 you need to add one space indentation for todo puzzle, see https://github.com/yegor256/pdd#how-to-format", "url": "https://github.com/artipie/http/pull/63#discussion_r390783383", "createdAt": "2020-03-11T07:24:36Z", "author": {"login": "g4s8"}, "path": "src/main/java/com/artipie/http/stream/ByteByByteSplit.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.stream;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.reactivestreams.Processor;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * Byte stream split implementation based on Circular buffer of bytes.\n+ *\n+ * @todo #32:30min Thread safety improvements.\n+ * We need to ensure that there is no threading issues in case upstream emit items in a\n+ * multi threaded way.\n+ * @todo #32:30min Cancellation support.\n+ * For now downstream and down downstream cancellation is not supported,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3ba243fe44de7d7c3abaa8839f863d26ad660cc2"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1969, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}