{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI5ODY4NTIx", "number": 1942, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwODozNjoyOVrOEDOD1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwODozNjo1MlrOEDOD7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODExNTQyOnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/schema/idl/ArgValueOfAllowedTypeChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwODozNjoyOVrOGgIC9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwODozNjoyOVrOGgIC9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzOTQ0Nw==", "bodyText": "This is the guts of the fix here.  Sorry for all the other guff (broken windows and all)\nWe didn't include extensions in this pre argument checking code", "url": "https://github.com/graphql-java/graphql-java/pull/1942#discussion_r436339447", "createdAt": "2020-06-07T08:36:29Z", "author": {"login": "bbakerman"}, "path": "src/main/java/graphql/schema/idl/ArgValueOfAllowedTypeChecker.java", "diffHunk": "@@ -139,66 +147,72 @@ private void checkArgValueMatchesAllowedInputType(List<GraphQLError> errors, Val\n         // then it must be the same type as the definition\n \n         List<ObjectField> fields = objectValue.getObjectFields();\n-        List<InputValueDefinition> inputValueDefinitions = allowedTypeDefinition.getInputValueDefinitions();\n+        List<InputObjectTypeExtensionDefinition> inputObjExt = typeRegistry.inputObjectTypeExtensions().getOrDefault(allowedTypeDefinition.getName(), emptyList());\n+        Stream<InputValueDefinition> inputObjExtValues = inputObjExt.stream().flatMap(inputObj -> inputObj.getInputValueDefinitions().stream());\n+        List<InputValueDefinition> inputValueDefinitions = Stream.concat(allowedTypeDefinition.getInputValueDefinitions().stream(), inputObjExtValues).collect(toList());\n \n         // check for duplicated fields\n         Map<String, Long> fieldsToOccurrenceMap = fields.stream().map(ObjectField::getName)\n-                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n+                .collect(groupingBy(Function.identity(), counting()));\n \n         if (fieldsToOccurrenceMap.values().stream().anyMatch(count -> count > 1)) {\n             addValidationError(errors, DUPLICATED_KEYS_MESSAGE, fieldsToOccurrenceMap.entrySet().stream()\n                     .filter(entry -> entry.getValue() > 1)\n                     .map(Map.Entry::getKey)\n-                    .collect(Collectors.joining(\",\")));\n+                    .collect(joining(\",\")));\n             return;\n         }\n \n         // check for unknown fields\n         Map<String, InputValueDefinition> nameToInputValueDefMap = inputValueDefinitions.stream()\n-                .collect(Collectors.toMap(InputValueDefinition::getName, inputValueDef -> inputValueDef));\n+                .collect(toMap(InputValueDefinition::getName, inputValueDef -> inputValueDef));\n \n         List<ObjectField> unknownFields = fields.stream()\n                 .filter(field -> !nameToInputValueDefMap.containsKey(field.getName()))\n-                .collect(Collectors.toList());\n+                .collect(toList());\n \n         if (!unknownFields.isEmpty()) {\n             addValidationError(errors, UNKNOWN_FIELDS_MESSAGE,\n                     unknownFields.stream()\n                             .map(ObjectField::getName)\n-                            .collect(Collectors.joining(\",\")),\n+                            .collect(joining(\",\")),\n                     allowedTypeDefinition.getName());\n             return;\n         }\n \n         // fields to map for easy access\n         Map<String, ObjectField> nameToFieldsMap = fields.stream()\n-                .collect(Collectors.toMap(ObjectField::getName, objectField -> objectField));\n+                .collect(toMap(ObjectField::getName, objectField -> objectField));\n         // check each single field with its definition\n         inputValueDefinitions.forEach(allowedValueDef -> {\n             ObjectField objectField = nameToFieldsMap.get(allowedValueDef.getName());\n             checkArgInputObjectValueFieldMatchesAllowedDefinition(errors, objectField, allowedValueDef);\n         });\n     }\n \n-    private void checkArgValueMatchesAllowedEnum(List<GraphQLError> errors, Value instanceValue, EnumTypeDefinition allowedTypeDefinition) {\n+    private void checkArgValueMatchesAllowedEnum(List<GraphQLError> errors, Value<?> instanceValue, EnumTypeDefinition allowedTypeDefinition) {\n         if (!(instanceValue instanceof EnumValue)) {\n             addValidationError(errors, EXPECTED_ENUM_MESSAGE, instanceValue.getClass().getSimpleName());\n             return;\n         }\n \n         EnumValue enumValue = ((EnumValue) instanceValue);\n \n-        boolean noneMatchAllowedEnumValue = allowedTypeDefinition.getEnumValueDefinitions().stream()\n+        List<EnumTypeExtensionDefinition> enumExtensions = typeRegistry.enumTypeExtensions().getOrDefault(allowedTypeDefinition.getName(), emptyList());\n+        Stream<EnumValueDefinition> enumExtStream = enumExtensions.stream().flatMap(enumExt -> enumExt.getEnumValueDefinitions().stream());\n+        List<EnumValueDefinition> enumValueDefinitions = Stream.concat(allowedTypeDefinition.getEnumValueDefinitions().stream(), enumExtStream).collect(toList());\n+\n+        boolean noneMatchAllowedEnumValue = enumValueDefinitions.stream()\n                 .noneMatch(enumAllowedValue -> enumAllowedValue.getName().equals(enumValue.getName()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1d8a4b36fc847b5f219e2600e8989c0ebe8c3a9"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODExNTY2OnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/schema/idl/ArgValueOfAllowedTypeChecker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwODozNjo1MlrOGgIDFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwODozNjo1MlrOGgIDFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzOTQ3Nw==", "bodyText": "InputObjects has the same bug", "url": "https://github.com/graphql-java/graphql-java/pull/1942#discussion_r436339477", "createdAt": "2020-06-07T08:36:52Z", "author": {"login": "bbakerman"}, "path": "src/main/java/graphql/schema/idl/ArgValueOfAllowedTypeChecker.java", "diffHunk": "@@ -139,66 +147,72 @@ private void checkArgValueMatchesAllowedInputType(List<GraphQLError> errors, Val\n         // then it must be the same type as the definition\n \n         List<ObjectField> fields = objectValue.getObjectFields();\n-        List<InputValueDefinition> inputValueDefinitions = allowedTypeDefinition.getInputValueDefinitions();\n+        List<InputObjectTypeExtensionDefinition> inputObjExt = typeRegistry.inputObjectTypeExtensions().getOrDefault(allowedTypeDefinition.getName(), emptyList());\n+        Stream<InputValueDefinition> inputObjExtValues = inputObjExt.stream().flatMap(inputObj -> inputObj.getInputValueDefinitions().stream());\n+        List<InputValueDefinition> inputValueDefinitions = Stream.concat(allowedTypeDefinition.getInputValueDefinitions().stream(), inputObjExtValues).collect(toList());\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1d8a4b36fc847b5f219e2600e8989c0ebe8c3a9"}, "originalPosition": 121}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4519, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}