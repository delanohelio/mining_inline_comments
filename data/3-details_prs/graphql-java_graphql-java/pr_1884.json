{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5Mzk1NTYx", "number": 1884, "title": "1764 allow interfaces to implement other interfaces", "bodyText": "Allows interfaces to implement other interfaces, as described in the draft spec.\nfixes: #1764", "createdAt": "2020-04-27T10:11:03Z", "url": "https://github.com/graphql-java/graphql-java/pull/1884", "merged": true, "mergeCommit": {"oid": "c508ac31600a6f12e69793ffb01d9338209bc683"}, "closed": true, "closedAt": "2020-05-24T06:39:01Z", "author": {"login": "felipe-gdr"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcbrUIwgH2gAyNDA5Mzk1NTYxOjFiMTIwYjI4NThmMDhjZDUzNWZjZWIwNGU1NmY1MzgwZmIwZGU1MmQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABckVj1PAH2gAyNDA5Mzk1NTYxOjc2MDE4ODk4NDY4NWQ3NTcyODkzMDI3ZTJlOWI5MmFmOWMyNjdmMjI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1b120b2858f08cd535fceb04e56f5380fb0de52d", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/1b120b2858f08cd535fceb04e56f5380fb0de52d", "committedDate": "2020-04-27T08:49:57Z", "message": "1764: Interfaces implementing interfaces working with partial validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5dca065f49021a26ec7041dfdd85d0eec334c638", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/5dca065f49021a26ec7041dfdd85d0eec334c638", "committedDate": "2020-04-27T09:34:40Z", "message": "1764: Assert error messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecb52d31d3db49aeca521fccc8f2b6c1e15eb040", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/ecb52d31d3db49aeca521fccc8f2b6c1e15eb040", "committedDate": "2020-04-27T10:08:04Z", "message": "1764: Check if interface is implementing itself\n\nfixes: #1764"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea740efacc54ea02d415f35448aa3e5e4fefd95a", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/ea740efacc54ea02d415f35448aa3e5e4fefd95a", "committedDate": "2020-04-28T23:07:02Z", "message": "1764: Fix bug with circular dependency"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "84a5b99404ae657cb11996b301d8491806e029db", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/84a5b99404ae657cb11996b301d8491806e029db", "committedDate": "2020-04-28T23:04:31Z", "message": "1764: Fix bug with circular dependency"}, "afterCommit": {"oid": "ea740efacc54ea02d415f35448aa3e5e4fefd95a", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/ea740efacc54ea02d415f35448aa3e5e4fefd95a", "committedDate": "2020-04-28T23:07:02Z", "message": "1764: Fix bug with circular dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3dfdab1b12fa64c4032737d59dec792083c86bb8", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/3dfdab1b12fa64c4032737d59dec792083c86bb8", "committedDate": "2020-04-28T23:19:56Z", "message": "1764: Use String.join instead of realying on Collection#toString"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a95b71cc9071eb625f8cf66afa99a83955ecfb3", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/0a95b71cc9071eb625f8cf66afa99a83955ecfb3", "committedDate": "2020-04-28T23:13:10Z", "message": "1764: Use String.join instead of realying on Collection#toString"}, "afterCommit": {"oid": "3dfdab1b12fa64c4032737d59dec792083c86bb8", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/3dfdab1b12fa64c4032737d59dec792083c86bb8", "committedDate": "2020-04-28T23:19:56Z", "message": "1764: Use String.join instead of realying on Collection#toString"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae71b4a3898bb26823ea0c158856b0cdae044dc7", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/ae71b4a3898bb26823ea0c158856b0cdae044dc7", "committedDate": "2020-04-29T08:44:59Z", "message": "1764: Better test assertions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81b1b2628018493c6ff265ce7906270d2a7cf765", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/81b1b2628018493c6ff265ce7906270d2a7cf765", "committedDate": "2020-04-29T09:01:37Z", "message": "1764: Add tests for transitive implementation declared in interface extensions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0039150ff8f3179d5bd98ec72f64225e9c026fd7", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/0039150ff8f3179d5bd98ec72f64225e9c026fd7", "committedDate": "2020-04-29T22:57:58Z", "message": "1764: Simplify implementation of transitive validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "465e4a98490411b1011dd09b68aa9ff10b1f2c3b", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/465e4a98490411b1011dd09b68aa9ff10b1f2c3b", "committedDate": "2020-05-17T09:52:17Z", "message": "1764: Fix transitive implementation declared in extension interface bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "committedDate": "2020-05-17T09:52:29Z", "message": "1764: Add tests for field and arguments check"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "311ef3279caf46bd693c8f441a7e731aa7c16694", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/311ef3279caf46bd693c8f441a7e731aa7c16694", "committedDate": "2020-05-04T22:11:16Z", "message": "1764: Fix transitive implementation declared in extension interface bug"}, "afterCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/4015f0d1ef7403a8ca96add2ac75c42aa98398ae", "committedDate": "2020-05-17T09:52:29Z", "message": "1764: Add tests for field and arguments check"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMzA3MzU3", "url": "https://github.com/graphql-java/graphql-java/pull/1884#pullrequestreview-413307357", "createdAt": "2020-05-18T06:41:13Z", "commit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjo0MToxNFrOGWpUWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjo0MToxNFrOGWpUWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5ODgxMQ==", "bodyText": "Nice one!  We should do this in other tests.\nCan you please rewrite all our tests to this pattern please! ;)", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426398811", "createdAt": "2020-05-18T06:41:14Z", "author": {"login": "bbakerman"}, "path": "src/test/groovy/graphql/InterfacesImplementingInterfacesTest.groovy", "diffHunk": "@@ -0,0 +1,861 @@\n+package graphql\n+\n+import graphql.schema.idl.SchemaGenerator\n+import graphql.schema.idl.SchemaParser\n+import graphql.schema.idl.errors.SchemaProblem\n+import spock.lang.Specification\n+\n+class InterfacesImplementingInterfacesTest extends Specification {\n+    def 'Simple interface implementing interface'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When implementing interface does not declare required field, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface type 'Resource' [@n:n] does not have a field 'id' required via interface 'Node' [@n:n]\")\n+    }\n+\n+    def 'Transitively implemented interfaces defined in implementing interface'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            interface Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+\n+    def 'Transitively implemented interfaces defined in implementing type'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            type Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When not all transitively implemented interfaces are defined in implementing interface, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            interface Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \n+            interface LargeImage implements Image & Resource {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+              large: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+        assertErrorMessage(error, \"The interface type 'LargeImage' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Image' [@n:n]\")\n+        assertErrorMessage(error, \"The interface type 'LargeImage' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When not all transitively implemented interfaces are defined in implementing type, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            type Image implements Resource {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The object type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When interface implements itself, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node implements Named & Node {\n+              id: ID!\n+              name: String\n+            }\n+            \n+            interface Named implements Node & Named {\n+              id: ID!\n+              name: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+        assertErrorMessage(error, \"The interface type 'Node' [@n:n] cannot implement itself\")\n+        assertErrorMessage(error, \"The interface type 'Named' [@n:n] cannot implement itself\")\n+    }\n+\n+    def 'When interface extension implements interface and declares required field, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID!\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension implements interface but doesn\\'t declare required field, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+              extraField: String\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID!\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface extension type 'Resource' [@n:n] does not have a field 'extraField' required via interface 'Node' [@n:n]\")\n+    }\n+\n+    def 'When object extension implements all transitive interfaces, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            type Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend type Image implements Node & Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When object extension does not implement all transitive interfaces, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            type Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend type Image implements Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The object extension type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When interface extension implements all transitive interfaces, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            interface Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend interface Image implements Node & Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension does not implement all transitive interfaces, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            interface Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend interface Image implements Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface extension type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When hierarchy results in circular reference, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface3 & Interface2 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+            \n+            interface Interface2 implements Interface1 & Interface3 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+            \n+            interface Interface3 implements Interface2 & Interface1 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+\n+        error.errors.size() == 6\n+\n+        assertErrorMessage(error, \"The interface type 'Interface1' [@n:n] cannot implement 'Interface2' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface1' [@n:n] cannot implement 'Interface3' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface2' [@n:n] cannot implement 'Interface3' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface2' [@n:n] cannot implement 'Interface1' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface3' [@n:n] cannot implement 'Interface1' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface3' [@n:n] cannot implement 'Interface2' [@n:n] as this would result in a circular reference\")\n+    }\n+\n+    def 'When interface doesn\\'t implement transitive interface declared in extension, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            interface Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface2 implements Interface3 {\n+              field3: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+\n+        assertErrorMessage(\n+                error,\n+                \"The interface type 'Interface1' [@n:n] must implement 'Interface3' [@n:n] because it is implemented by 'Interface2' [@n:n]\"\n+        )\n+    }\n+\n+    def 'When interface implements transitive interface declared in extension, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            interface Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface2 implements Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface1 implements Interface3 {\n+              field3: String\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When field required by new extension implementation is declared in original interface type, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            extend interface Interface1 implements Interface2\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When type declares interface and extension declares required field, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            extend interface Interface1 {\n+              field2: String\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface implements same interface more than once via extensions, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+           type Query {\n+              find(id: String!): Type1\n+           }\n+           \n+           type Type1 {\n+             field1: String\n+           }\n+           \n+           interface Interface2  {\n+             field20: String\n+             field21: String\n+           }\n+           \n+           extend type Type1 implements Interface2 {\n+             field20: String\n+           }\n+           \n+           extend type Type1 implements Interface2 {\n+             field21: String\n+           }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+\n+        assertErrorMessage(error, \"The object extension type 'Type1' [@n:n] can only implement 'Interface2' [@n:n] once.\")\n+    }\n+\n+    def 'When interface implements same interface more than once, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+           type Query {\n+              find(id: String!): Type1\n+           }\n+           \n+           type Type1 implements Interface2 {\n+             field1: String\n+             field20: String\n+           }\n+           \n+           interface Interface2  {\n+             field20: String\n+             field21: String\n+           }\n+           \n+           extend type Type1 implements Interface2 {\n+             field21: String\n+           }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+\n+        assertErrorMessage(error, \"The object extension type 'Type1' [@n:n] can only implement 'Interface2' [@n:n] once.\")\n+        assertErrorMessage(error, \"The object type 'Type1' [@n:n] can only implement 'Interface2' [@n:n] once.\")\n+    }\n+\n+    def 'When interface implements interface and redefines non-null field as nullable, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              url: String\n+              id: ID\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+\n+        assertErrorMessage(error, \"The interface type 'Resource' [@n:n] has tried to redefine field 'id' defined via interface 'Node' [@n:n] from 'ID!' to 'ID'\")\n+    }\n+\n+    def 'When interface extension implements interface and redefines non-null field as nullable, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+\n+        assertErrorMessage(error, \"The interface extension type 'Resource' [@n:n] has tried to redefine field 'id' defined via interface 'Node' [@n:n] from 'ID!' to 'ID'\")\n+    }\n+\n+    def 'When interface implements interface and redefines nullable field as non-null, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID\n+            }\n+\n+            interface Resource implements Node {\n+              url: String\n+              id: ID!\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension implements interface and redefines nullable field as non-null, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID!\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension implements interface and misses field arguments, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            interface InterfaceType {\n+                fieldA(arg1 : Int) : Int \n+                fieldB(arg1 : String = \"defaultVal\", arg2 : String, arg3 : Int) : String \n+            }\n+\n+            interface BaseInterface {\n+                fieldX : Int\n+            }\n+\n+            extend interface BaseInterface implements InterfaceType {\n+                fieldA : Int\n+                fieldB(arg1 : String = \"defaultValX\", arg2 : String!, arg3 : String) : String \n+            }\n+            \n+            type Query {\n+               mock: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 4\n+\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] field 'fieldA' does not have the same number of arguments as specified via interface 'InterfaceType' [@n:n]\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg1:String =\\\"defaultVal\\\"' to 'arg1:String =\\\"defaultValX\\\"\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg2:String' to 'arg2:String!\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg3:Int' to 'arg3:String\")\n+    }\n+\n+    def 'When interface implements interface and misses field arguments, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            interface InterfaceType {\n+                fieldA(arg1 : Int) : Int \n+                fieldB(arg1 : String = \"defaultVal\", arg2 : String, arg3 : Int) : String \n+            }\n+\n+            interface BaseInterface implements InterfaceType {\n+                fieldX : Int\n+                fieldA : Int\n+                fieldB(arg1 : String = \"defaultValX\", arg2 : String!, arg3 : String) : String \n+            }\n+            \n+            type Query {\n+               mock: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 4\n+\n+        assertErrorMessage(error, \"The interface type 'BaseInterface' [@n:n] field 'fieldA' does not have the same number of arguments as specified via interface 'InterfaceType' [@n:n]\")\n+        assertErrorMessage(error, \"The interface type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg1:String =\\\"defaultVal\\\"' to 'arg1:String =\\\"defaultValX\\\"\")\n+        assertErrorMessage(error, \"The interface type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg2:String' to 'arg2:String!\")\n+        assertErrorMessage(error, \"The interface type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg3:Int' to 'arg3:String\")\n+    }\n+\n+    def 'When interface implements interface via extension and misses field arguments, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            interface InterfaceType {\n+                fieldA(arg1 : Int) : Int \n+                fieldB(arg1 : String = \"defaultVal\", arg2 : String, arg3 : Int) : String \n+            }\n+\n+            interface BaseInterface {\n+                fieldX : Int\n+                fieldA : Int\n+                fieldB(arg1 : String = \"defaultValX\", arg2 : String!, arg3 : String) : String \n+            }\n+            \n+            extend interface BaseInterface implements InterfaceType\n+            \n+            type BaseType {\n+                id: ID!\n+            }\n+\n+            type Query {\n+               mock: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 4\n+\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] field 'fieldA' does not have the same number of arguments as specified via interface 'InterfaceType' [@n:n]\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg1:String =\\\"defaultVal\\\"' to 'arg1:String =\\\"defaultValX\\\"\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg2:String' to 'arg2:String!\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg3:Int' to 'arg3:String\")\n+    }\n+\n+    def assertErrorMessage(SchemaProblem error, expectedMessage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 843}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMzA3ODA1", "url": "https://github.com/graphql-java/graphql-java/pull/1884#pullrequestreview-413307805", "createdAt": "2020-05-18T06:42:11Z", "commit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjo0MjoxMVrOGWpVyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjo0MjoxMVrOGWpVyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5OTE3OA==", "bodyText": "Why does this need to be removed?  Is it no longer valid or just not longer relevant and tested in the other places", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426399178", "createdAt": "2020-05-18T06:42:11Z", "author": {"login": "bbakerman"}, "path": "src/test/groovy/graphql/schema/idl/SchemaGeneratorTest.groovy", "diffHunk": "@@ -542,13 +542,6 @@ class SchemaGeneratorTest extends Specification {\n             extend type BaseType {\n                extraField5 : Boolean!\n             }\n-            #\n-            # if we repeat a definition, that's ok as long as its the same types as before\n-            # they will be de-duped since the effect is the same\n-            #\n-            extend type BaseType implements Interface1 {\n-               extraField1 : String\n-            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMzA4MTkx", "url": "https://github.com/graphql-java/graphql-java/pull/1884#pullrequestreview-413308191", "createdAt": "2020-05-18T06:43:00Z", "commit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjo0MzowMVrOGWpW-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjo0MzowMVrOGWpW-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5OTQ4Mw==", "bodyText": "My comment below is covered by this test", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426399483", "createdAt": "2020-05-18T06:43:01Z", "author": {"login": "bbakerman"}, "path": "src/test/groovy/graphql/InterfacesImplementingInterfacesTest.groovy", "diffHunk": "@@ -0,0 +1,861 @@\n+package graphql\n+\n+import graphql.schema.idl.SchemaGenerator\n+import graphql.schema.idl.SchemaParser\n+import graphql.schema.idl.errors.SchemaProblem\n+import spock.lang.Specification\n+\n+class InterfacesImplementingInterfacesTest extends Specification {\n+    def 'Simple interface implementing interface'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When implementing interface does not declare required field, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface type 'Resource' [@n:n] does not have a field 'id' required via interface 'Node' [@n:n]\")\n+    }\n+\n+    def 'Transitively implemented interfaces defined in implementing interface'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            interface Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+\n+    def 'Transitively implemented interfaces defined in implementing type'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            type Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When not all transitively implemented interfaces are defined in implementing interface, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            interface Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \n+            interface LargeImage implements Image & Resource {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+              large: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+        assertErrorMessage(error, \"The interface type 'LargeImage' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Image' [@n:n]\")\n+        assertErrorMessage(error, \"The interface type 'LargeImage' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When not all transitively implemented interfaces are defined in implementing type, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            type Image implements Resource {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The object type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When interface implements itself, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node implements Named & Node {\n+              id: ID!\n+              name: String\n+            }\n+            \n+            interface Named implements Node & Named {\n+              id: ID!\n+              name: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+        assertErrorMessage(error, \"The interface type 'Node' [@n:n] cannot implement itself\")\n+        assertErrorMessage(error, \"The interface type 'Named' [@n:n] cannot implement itself\")\n+    }\n+\n+    def 'When interface extension implements interface and declares required field, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID!\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension implements interface but doesn\\'t declare required field, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+              extraField: String\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID!\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface extension type 'Resource' [@n:n] does not have a field 'extraField' required via interface 'Node' [@n:n]\")\n+    }\n+\n+    def 'When object extension implements all transitive interfaces, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            type Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend type Image implements Node & Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When object extension does not implement all transitive interfaces, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            type Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend type Image implements Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The object extension type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When interface extension implements all transitive interfaces, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            interface Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend interface Image implements Node & Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension does not implement all transitive interfaces, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            interface Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend interface Image implements Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface extension type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When hierarchy results in circular reference, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface3 & Interface2 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+            \n+            interface Interface2 implements Interface1 & Interface3 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+            \n+            interface Interface3 implements Interface2 & Interface1 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+\n+        error.errors.size() == 6\n+\n+        assertErrorMessage(error, \"The interface type 'Interface1' [@n:n] cannot implement 'Interface2' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface1' [@n:n] cannot implement 'Interface3' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface2' [@n:n] cannot implement 'Interface3' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface2' [@n:n] cannot implement 'Interface1' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface3' [@n:n] cannot implement 'Interface1' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface3' [@n:n] cannot implement 'Interface2' [@n:n] as this would result in a circular reference\")\n+    }\n+\n+    def 'When interface doesn\\'t implement transitive interface declared in extension, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            interface Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface2 implements Interface3 {\n+              field3: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+\n+        assertErrorMessage(\n+                error,\n+                \"The interface type 'Interface1' [@n:n] must implement 'Interface3' [@n:n] because it is implemented by 'Interface2' [@n:n]\"\n+        )\n+    }\n+\n+    def 'When interface implements transitive interface declared in extension, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            interface Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface2 implements Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface1 implements Interface3 {\n+              field3: String\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When field required by new extension implementation is declared in original interface type, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            extend interface Interface1 implements Interface2\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When type declares interface and extension declares required field, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            extend interface Interface1 {\n+              field2: String\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface implements same interface more than once via extensions, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+           type Query {\n+              find(id: String!): Type1\n+           }\n+           \n+           type Type1 {\n+             field1: String\n+           }\n+           \n+           interface Interface2  {\n+             field20: String\n+             field21: String\n+           }\n+           \n+           extend type Type1 implements Interface2 {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 584}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMzA4NTEz", "url": "https://github.com/graphql-java/graphql-java/pull/1884#pullrequestreview-413308513", "createdAt": "2020-05-18T06:43:41Z", "commit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzOTcyNDM5", "url": "https://github.com/graphql-java/graphql-java/pull/1884#pullrequestreview-413972439", "createdAt": "2020-05-18T22:10:27Z", "commit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxMDoyN1rOGXJHfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxNzowNlrOGXJRLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxOTgwNw==", "bodyText": "please use our map static function instead of streams directly", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426919807", "createdAt": "2020-05-18T22:10:27Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/introspection/IntrospectionResultToSchema.java", "diffHunk": "@@ -185,6 +184,13 @@ InterfaceTypeDefinition createInterface(Map<String, Object> input) {\n \n         InterfaceTypeDefinition.Builder interfaceTypeDefinition = InterfaceTypeDefinition.newInterfaceTypeDefinition().name((String) input.get(\"name\"));\n         interfaceTypeDefinition.description(toDescription(input));\n+        if (input.containsKey(\"interfaces\") && input.get(\"interfaces\") != null) {\n+            interfaceTypeDefinition.implementz(\n+                    ((List<Map<String, Object>>) input.get(\"interfaces\")).stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMDU2MQ==", "bodyText": "why the recursive type definition here?", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426920561", "createdAt": "2020-05-18T22:12:26Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/language/ImplementingTypeDefinition.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package graphql.language;\n+\n+\n+import graphql.PublicApi;\n+\n+import java.util.List;\n+\n+/**\n+ * A {@link TypeDefinition} that might implement interfaces\n+ *\n+ * @param <T>\n+ */\n+@PublicApi\n+public interface ImplementingTypeDefinition<T extends ImplementingTypeDefinition> extends TypeDefinition<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMDcyMA==", "bodyText": "not great name, but not in scope to change it here.", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426920720", "createdAt": "2020-05-18T22:12:50Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/language/ImplementingTypeDefinition.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package graphql.language;\n+\n+\n+import graphql.PublicApi;\n+\n+import java.util.List;\n+\n+/**\n+ * A {@link TypeDefinition} that might implement interfaces\n+ *\n+ * @param <T>\n+ */\n+@PublicApi\n+public interface ImplementingTypeDefinition<T extends ImplementingTypeDefinition> extends TypeDefinition<T> {\n+\n+    List<Type> getImplements();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMTQwNg==", "bodyText": "please use our map util function.", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426921406", "createdAt": "2020-05-18T22:14:42Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/parser/GraphqlAntlrToLanguage.java", "diffHunk": "@@ -882,4 +878,14 @@ protected SourceLocation getSourceLocation(ParserRuleContext parserRuleContext)\n         return comments;\n     }\n \n+\n+    private List<Type> getImplementz(GraphqlParser.ImplementsInterfacesContext implementsInterfacesContext) {\n+        List<Type> implementz = new ArrayList<>();\n+        while (implementsInterfacesContext != null) {\n+            List<TypeName> typeNames = implementsInterfacesContext.typeName().stream().map(this::createTypeName).collect(toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMTgxOA==", "bodyText": "please use the util function", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426921818", "createdAt": "2020-05-18T22:15:47Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/idl/SchemaTypeChecker.java", "diffHunk": "@@ -90,7 +85,7 @@\n \n     private void checkForMissingTypes(List<GraphQLError> errors, TypeDefinitionRegistry typeRegistry) {\n         // type extensions\n-        List<ObjectTypeExtensionDefinition> typeExtensions = typeRegistry.objectTypeExtensions().values().stream().flatMap(Collection::stream).collect(Collectors.toList());\n+        List<ObjectTypeExtensionDefinition> typeExtensions = typeRegistry.objectTypeExtensions().values().stream().flatMap(Collection::stream).collect(toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMjI4NQ==", "bodyText": "this is a breaking change. Should we consider adding another one and keeping this one for use object implementations?", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426922285", "createdAt": "2020-05-18T22:17:06Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/idl/TypeDefinitionRegistry.java", "diffHunk": "@@ -453,13 +454,13 @@ public boolean isObjectType(Type type) {\n     }\n \n     /**\n-     * Returns the list of object types that implement the given interface type\n+     * Returns the list of object and interface types that implement the given interface type\n      *\n      * @param targetInterface the target to search for\n      * @return the list of object types that implement the given interface type\n      */\n-    public List<ObjectTypeDefinition> getImplementationsOf(InterfaceTypeDefinition targetInterface) {\n-        List<ObjectTypeDefinition> objectTypeDefinitions = getTypes(ObjectTypeDefinition.class);\n+    public List<ImplementingTypeDefinition> getImplementationsOf(InterfaceTypeDefinition targetInterface) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfe170ee8966c63d2a8e10ba7f75f7cc24b8b2ce", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/cfe170ee8966c63d2a8e10ba7f75f7cc24b8b2ce", "committedDate": "2020-05-20T10:42:05Z", "message": "1764: Create integration test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04cfbe74b09e7b67094c0b7a69cff427d113f5bb", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/04cfbe74b09e7b67094c0b7a69cff427d113f5bb", "committedDate": "2020-05-20T10:46:58Z", "message": "1764: PR feedback\n- use FpKit\n- fix Generic definition in ImplementingTypeDefinition\n- don't break public API in TypeDefinitionRegistry"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1339a86bdb73acc7f07b6be041a21dc690445735", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/1339a86bdb73acc7f07b6be041a21dc690445735", "committedDate": "2020-05-20T10:45:42Z", "message": "1898: PR feedback\n- use FpKit\n- fix Generic definition in ImplementingTypeDefinition\n- don't break public API in TypeDefinitionRegistry"}, "afterCommit": {"oid": "04cfbe74b09e7b67094c0b7a69cff427d113f5bb", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/04cfbe74b09e7b67094c0b7a69cff427d113f5bb", "committedDate": "2020-05-20T10:46:58Z", "message": "1764: PR feedback\n- use FpKit\n- fix Generic definition in ImplementingTypeDefinition\n- don't break public API in TypeDefinitionRegistry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39dc3d4f59671ef3459dd138e384e5802eea1208", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/39dc3d4f59671ef3459dd138e384e5802eea1208", "committedDate": "2020-05-21T22:12:22Z", "message": "1764: Improve query integration test and add introspection query test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "765698305714677f61fb0e1c2ac469ed97f6a48c", "author": {"user": {"login": "andimarek", "name": "Andreas Marek"}}, "url": "https://github.com/graphql-java/graphql-java/commit/765698305714677f61fb0e1c2ac469ed97f6a48c", "committedDate": "2020-05-21T23:19:18Z", "message": "improve tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d04a6ec315e1fc2301c22a1f44712ab16842b507", "author": {"user": {"login": "andimarek", "name": "Andreas Marek"}}, "url": "https://github.com/graphql-java/graphql-java/commit/d04a6ec315e1fc2301c22a1f44712ab16842b507", "committedDate": "2020-05-22T00:47:51Z", "message": "add Interfaces to GraphQLInterfaceType\nfix introspection interfaces field"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b785a5b0266e4bb1ff191be541c62d90d76de519", "author": {"user": {"login": "andimarek", "name": "Andreas Marek"}}, "url": "https://github.com/graphql-java/graphql-java/commit/b785a5b0266e4bb1ff191be541c62d90d76de519", "committedDate": "2020-05-22T01:38:48Z", "message": "test programmatically GraphQLInterfaceType\nand test SchemaPrinter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2792f3aaa692d17bb86332a78a7c3f4ab94f1452", "author": {"user": {"login": "andimarek", "name": "Andreas Marek"}}, "url": "https://github.com/graphql-java/graphql-java/commit/2792f3aaa692d17bb86332a78a7c3f4ab94f1452", "committedDate": "2020-05-22T01:49:13Z", "message": "transitively declaring all interfaces"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24150503f8a7db0cdd7d7c567cc317d24a9ea731", "author": {"user": {"login": "andimarek", "name": "Andreas Marek"}}, "url": "https://github.com/graphql-java/graphql-java/commit/24150503f8a7db0cdd7d7c567cc317d24a9ea731", "committedDate": "2020-05-22T04:35:09Z", "message": "astprinter handles interfaces in interfaces"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7a5d841afff2d81c011aae33e4c37cb9898de19", "author": {"user": {"login": "andimarek", "name": "Andreas Marek"}}, "url": "https://github.com/graphql-java/graphql-java/commit/e7a5d841afff2d81c011aae33e4c37cb9898de19", "committedDate": "2020-05-22T04:46:28Z", "message": "add schema printer test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "420481f12a40de2abf22578a711a50d921ffd620", "author": {"user": {"login": "felipe-gdr", "name": "Felipe Reis"}}, "url": "https://github.com/graphql-java/graphql-java/commit/420481f12a40de2abf22578a711a50d921ffd620", "committedDate": "2020-05-24T04:30:12Z", "message": "1764: Implemente interface implement interface validation in SchemaValidator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08d4bb9d8bb83148e2fdef4e25fedcc850a3029d", "author": {"user": {"login": "andimarek", "name": "Andreas Marek"}}, "url": "https://github.com/graphql-java/graphql-java/commit/08d4bb9d8bb83148e2fdef4e25fedcc850a3029d", "committedDate": "2020-05-24T06:19:00Z", "message": "add test for interface extensions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "760188984685d7572893027e2e9b92af9c267f22", "author": {"user": {"login": "andimarek", "name": "Andreas Marek"}}, "url": "https://github.com/graphql-java/graphql-java/commit/760188984685d7572893027e2e9b92af9c267f22", "committedDate": "2020-05-24T06:34:30Z", "message": "Merge branch 'master' into 1764_allow-interfaces-to-implement-other-interfaces"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4441, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}