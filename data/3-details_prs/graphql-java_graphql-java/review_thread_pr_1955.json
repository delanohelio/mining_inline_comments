{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzOTUwODcz", "number": 1955, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwNjoxNDo0MFrOEHALsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwNjoyMzozN1rOEHASPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Nzc4NDgyOnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwNjoxNDo0MFrOGmJQhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNzo1MDoyMFrOGmc5uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MDc1Ng==", "bodyText": "we should only treat the build-in scalar types (Int, Float, String, Boolean and ID) in a special way. The others are not really special and should be treated as every other custom scalar.\nWe also have a helper method in Scalars (I believe) to determine if the type is a build-in one or not", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442650756", "createdAt": "2020-06-19T06:14:40Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();\n+        for (Type memberType : memberTypes) {\n+            String typeName = ((TypeName) memberType).getName();\n+            GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);\n+            if (!(graphQLNamedType instanceof GraphQLObjectType)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format(\"The member types of a Union type must all be Object base types. member type \\\"%s\\\" in Union \\\"%s\\\" is invalid.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            if (typeNames.contains(typeName)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format(\"The member types of a Union type must be unique. member type \\\"%s\\\" in Union \\\"%s\\\" is not unique.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            typeNames.add(typeName);\n+        }\n+    }\n+\n+    private void validateScalar(GraphQLScalarType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+    }\n+\n+    private void validateEnum(GraphQLEnumType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLEnumValueDefinition> enumValueDefinitions = type.getValues();\n+        if (enumValueDefinitions == null || enumValueDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.EnumLackOfValueError, String.format(\"Enum type \\\"%s\\\" must define one or more enum values.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        } else {\n+            for (GraphQLEnumValueDefinition enumValueDefinition : enumValueDefinitions) {\n+                assertEnumValueDefinitionName(type.getName(), enumValueDefinition.getName(), errorCollector);\n+            }\n+        }\n+\n+    }\n+\n+    private void validateFieldDefinition(String typeName, GraphQLFieldDefinition fieldDefinition, SchemaValidationErrorCollector errorCollector) {\n+        assertFieldName(typeName, fieldDefinition.getName(), errorCollector);\n+        assertNonNullType(fieldDefinition.getType(), errorCollector);\n+\n+        List<GraphQLArgument> fieldDefinitionArguments = fieldDefinition.getArguments();\n+        if (fieldDefinitionArguments != null || fieldDefinitionArguments.size() != 0) {\n+            for (GraphQLArgument fieldDefinitionArgument : fieldDefinitionArguments) {\n+                validateFieldDefinitionArgument(typeName, fieldDefinition.getName(), fieldDefinitionArgument, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateFieldDefinitionArgument(String typeName, String fieldName, GraphQLArgument argument, SchemaValidationErrorCollector errorCollector) {\n+        assertArgumentName(typeName, fieldName, argument.getName(), errorCollector);\n+        assertNonNullType(argument.getType(), errorCollector);\n+    }\n+\n+    private void assertTypeName(String typeName, SchemaValidationErrorCollector validationErrorCollector) {\n+        if (typeName.length() >= 2 && typeName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", typeName));\n+            validationErrorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertFieldName(String typeName, String fieldName, SchemaValidationErrorCollector errorCollector) {\n+        if (fieldName.length() >= 2 && fieldName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" in \\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", fieldName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertArgumentName(String typeName, String fieldName, String argumentName, SchemaValidationErrorCollector errorCollector) {\n+        if (argumentName.length() >= 2 && argumentName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"Argument name \\\"%s\\\" in \\\"%s-%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", argumentName, typeName, fieldName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertEnumValueDefinitionName(String typeName, String enumValueDefinitionName, SchemaValidationErrorCollector errorCollector) {\n+        if (enumValueDefinitionName.length() >= 2 && enumValueDefinitionName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"EnumValueDefinition \\\"%s\\\" in  \\\"%s\\\"  must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", enumValueDefinitionName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertNonNullType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLNonNull && ((GraphQLNonNull) type).getWrappedType() instanceof GraphQLNonNull) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.NonNullWrapNonNullError,\n+                    String.format(\"Non\u2010Null type \\\"%s\\\" must not wrap another Non\u2010Null type.\", GraphQLTypeUtil.simplePrint(type)));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private List<GraphQLNamedType> filterScalarAndIntrospectionTypes(List<GraphQLNamedType> graphQLNamedTypes) {\n+        if (graphQLNamedTypes == null || graphQLNamedTypes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        return graphQLNamedTypes.stream().filter(type -> !isScalarOrIntrospectionTypes(type)).collect(Collectors.toList());\n+    }\n+\n+    private boolean isScalarOrIntrospectionTypes(GraphQLNamedType type) {\n+        if (type instanceof GraphQLScalarType && (\n+                type.getName().equals(\"Int\") || type.getName().equals(\"Float\") || type.getName().equals(\"String\") ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk3MjYwMA==", "bodyText": "Thanks for your suggestion.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442972600", "createdAt": "2020-06-19T17:50:20Z", "author": {"login": "dugenkui03"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();\n+        for (Type memberType : memberTypes) {\n+            String typeName = ((TypeName) memberType).getName();\n+            GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);\n+            if (!(graphQLNamedType instanceof GraphQLObjectType)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format(\"The member types of a Union type must all be Object base types. member type \\\"%s\\\" in Union \\\"%s\\\" is invalid.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            if (typeNames.contains(typeName)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format(\"The member types of a Union type must be unique. member type \\\"%s\\\" in Union \\\"%s\\\" is not unique.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            typeNames.add(typeName);\n+        }\n+    }\n+\n+    private void validateScalar(GraphQLScalarType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+    }\n+\n+    private void validateEnum(GraphQLEnumType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLEnumValueDefinition> enumValueDefinitions = type.getValues();\n+        if (enumValueDefinitions == null || enumValueDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.EnumLackOfValueError, String.format(\"Enum type \\\"%s\\\" must define one or more enum values.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        } else {\n+            for (GraphQLEnumValueDefinition enumValueDefinition : enumValueDefinitions) {\n+                assertEnumValueDefinitionName(type.getName(), enumValueDefinition.getName(), errorCollector);\n+            }\n+        }\n+\n+    }\n+\n+    private void validateFieldDefinition(String typeName, GraphQLFieldDefinition fieldDefinition, SchemaValidationErrorCollector errorCollector) {\n+        assertFieldName(typeName, fieldDefinition.getName(), errorCollector);\n+        assertNonNullType(fieldDefinition.getType(), errorCollector);\n+\n+        List<GraphQLArgument> fieldDefinitionArguments = fieldDefinition.getArguments();\n+        if (fieldDefinitionArguments != null || fieldDefinitionArguments.size() != 0) {\n+            for (GraphQLArgument fieldDefinitionArgument : fieldDefinitionArguments) {\n+                validateFieldDefinitionArgument(typeName, fieldDefinition.getName(), fieldDefinitionArgument, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateFieldDefinitionArgument(String typeName, String fieldName, GraphQLArgument argument, SchemaValidationErrorCollector errorCollector) {\n+        assertArgumentName(typeName, fieldName, argument.getName(), errorCollector);\n+        assertNonNullType(argument.getType(), errorCollector);\n+    }\n+\n+    private void assertTypeName(String typeName, SchemaValidationErrorCollector validationErrorCollector) {\n+        if (typeName.length() >= 2 && typeName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", typeName));\n+            validationErrorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertFieldName(String typeName, String fieldName, SchemaValidationErrorCollector errorCollector) {\n+        if (fieldName.length() >= 2 && fieldName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" in \\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", fieldName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertArgumentName(String typeName, String fieldName, String argumentName, SchemaValidationErrorCollector errorCollector) {\n+        if (argumentName.length() >= 2 && argumentName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"Argument name \\\"%s\\\" in \\\"%s-%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", argumentName, typeName, fieldName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertEnumValueDefinitionName(String typeName, String enumValueDefinitionName, SchemaValidationErrorCollector errorCollector) {\n+        if (enumValueDefinitionName.length() >= 2 && enumValueDefinitionName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"EnumValueDefinition \\\"%s\\\" in  \\\"%s\\\"  must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", enumValueDefinitionName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertNonNullType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLNonNull && ((GraphQLNonNull) type).getWrappedType() instanceof GraphQLNonNull) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.NonNullWrapNonNullError,\n+                    String.format(\"Non\u2010Null type \\\"%s\\\" must not wrap another Non\u2010Null type.\", GraphQLTypeUtil.simplePrint(type)));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private List<GraphQLNamedType> filterScalarAndIntrospectionTypes(List<GraphQLNamedType> graphQLNamedTypes) {\n+        if (graphQLNamedTypes == null || graphQLNamedTypes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        return graphQLNamedTypes.stream().filter(type -> !isScalarOrIntrospectionTypes(type)).collect(Collectors.toList());\n+    }\n+\n+    private boolean isScalarOrIntrospectionTypes(GraphQLNamedType type) {\n+        if (type instanceof GraphQLScalarType && (\n+                type.getName().equals(\"Int\") || type.getName().equals(\"Float\") || type.getName().equals(\"String\") ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MDc1Ng=="}, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 245}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Nzc5MDExOnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwNjoxNzozN1rOGmJT5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxODo0NzozMlrOGmeTMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MTYyMQ==", "bodyText": "we should not need to check the AST definition here. Just getting the members of the type should be enough.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442651621", "createdAt": "2020-06-19T06:17:37Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5MjA0Mg==", "bodyText": "types in GraphQLUnionType.Builder is a Map(code link), which will lost the type with duplicated name.\nMaybe it will be better to move unique member check to SchemaTypeChecker.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442992042", "createdAt": "2020-06-19T18:38:38Z", "author": {"login": "dugenkui03"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MTYyMQ=="}, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5NTUwNQ==", "bodyText": "I will followed your suggestion instead of removed it, because types definied in GraphQLUnionType is list after all.\nThen I will add unique member check to SchemaTypeChecker in another PR.\nIs that appropriate?", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442995505", "createdAt": "2020-06-19T18:47:32Z", "author": {"login": "dugenkui03"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MTYyMQ=="}, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Nzc5MjY1OnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwNjoxODo0OFrOGmJVXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNToxNDoyOFrOGmYXAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MTk5OA==", "bodyText": "can we combine validateObject and validateInterface?\nI would also suggest a more prescriptive name like validateContainsField or so.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442651998", "createdAt": "2020-06-19T06:18:48Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg5ODE3Nw==", "bodyText": "Thanks for your suggestion.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442898177", "createdAt": "2020-06-19T15:14:28Z", "author": {"login": "dugenkui03"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MTk5OA=="}, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Nzc5Mzc3OnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwNjoxOToyMFrOGmJWEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNDoxMjozNVrOGmWSZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MjE3Ng==", "bodyText": "IntrospectionQuery is not a special type at all (it is just a name).", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442652176", "createdAt": "2020-06-19T06:19:20Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();\n+        for (Type memberType : memberTypes) {\n+            String typeName = ((TypeName) memberType).getName();\n+            GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);\n+            if (!(graphQLNamedType instanceof GraphQLObjectType)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format(\"The member types of a Union type must all be Object base types. member type \\\"%s\\\" in Union \\\"%s\\\" is invalid.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            if (typeNames.contains(typeName)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format(\"The member types of a Union type must be unique. member type \\\"%s\\\" in Union \\\"%s\\\" is not unique.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            typeNames.add(typeName);\n+        }\n+    }\n+\n+    private void validateScalar(GraphQLScalarType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+    }\n+\n+    private void validateEnum(GraphQLEnumType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLEnumValueDefinition> enumValueDefinitions = type.getValues();\n+        if (enumValueDefinitions == null || enumValueDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.EnumLackOfValueError, String.format(\"Enum type \\\"%s\\\" must define one or more enum values.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        } else {\n+            for (GraphQLEnumValueDefinition enumValueDefinition : enumValueDefinitions) {\n+                assertEnumValueDefinitionName(type.getName(), enumValueDefinition.getName(), errorCollector);\n+            }\n+        }\n+\n+    }\n+\n+    private void validateFieldDefinition(String typeName, GraphQLFieldDefinition fieldDefinition, SchemaValidationErrorCollector errorCollector) {\n+        assertFieldName(typeName, fieldDefinition.getName(), errorCollector);\n+        assertNonNullType(fieldDefinition.getType(), errorCollector);\n+\n+        List<GraphQLArgument> fieldDefinitionArguments = fieldDefinition.getArguments();\n+        if (fieldDefinitionArguments != null || fieldDefinitionArguments.size() != 0) {\n+            for (GraphQLArgument fieldDefinitionArgument : fieldDefinitionArguments) {\n+                validateFieldDefinitionArgument(typeName, fieldDefinition.getName(), fieldDefinitionArgument, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateFieldDefinitionArgument(String typeName, String fieldName, GraphQLArgument argument, SchemaValidationErrorCollector errorCollector) {\n+        assertArgumentName(typeName, fieldName, argument.getName(), errorCollector);\n+        assertNonNullType(argument.getType(), errorCollector);\n+    }\n+\n+    private void assertTypeName(String typeName, SchemaValidationErrorCollector validationErrorCollector) {\n+        if (typeName.length() >= 2 && typeName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", typeName));\n+            validationErrorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertFieldName(String typeName, String fieldName, SchemaValidationErrorCollector errorCollector) {\n+        if (fieldName.length() >= 2 && fieldName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" in \\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", fieldName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertArgumentName(String typeName, String fieldName, String argumentName, SchemaValidationErrorCollector errorCollector) {\n+        if (argumentName.length() >= 2 && argumentName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"Argument name \\\"%s\\\" in \\\"%s-%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", argumentName, typeName, fieldName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertEnumValueDefinitionName(String typeName, String enumValueDefinitionName, SchemaValidationErrorCollector errorCollector) {\n+        if (enumValueDefinitionName.length() >= 2 && enumValueDefinitionName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"EnumValueDefinition \\\"%s\\\" in  \\\"%s\\\"  must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", enumValueDefinitionName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertNonNullType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLNonNull && ((GraphQLNonNull) type).getWrappedType() instanceof GraphQLNonNull) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.NonNullWrapNonNullError,\n+                    String.format(\"Non\u2010Null type \\\"%s\\\" must not wrap another Non\u2010Null type.\", GraphQLTypeUtil.simplePrint(type)));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private List<GraphQLNamedType> filterScalarAndIntrospectionTypes(List<GraphQLNamedType> graphQLNamedTypes) {\n+        if (graphQLNamedTypes == null || graphQLNamedTypes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        return graphQLNamedTypes.stream().filter(type -> !isScalarOrIntrospectionTypes(type)).collect(Collectors.toList());\n+    }\n+\n+    private boolean isScalarOrIntrospectionTypes(GraphQLNamedType type) {\n+        if (type instanceof GraphQLScalarType && (\n+                type.getName().equals(\"Int\") || type.getName().equals(\"Float\") || type.getName().equals(\"String\") ||\n+                        type.getName().equals(\"Boolean\") || type.getName().equals(\"ID\") || type.getName().equals(\"Long\") || type.getName().equals(\"Short\") ||\n+                        type.getName().equals(\"BigInteger\") || type.getName().equals(\"BigDecimal\") || type.getName().equals(\"Char\")\n+        )) {\n+            return true;\n+        }\n+\n+        if (type instanceof GraphQLEnumType && (type.getName().equals(\"__DirectiveLocation\") || type.getName().equals(\"__TypeKind\"))) {\n+            return true;\n+        }\n+\n+        if (type instanceof GraphQLObjectType && (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2NDIzMA==", "bodyText": "graphql-java framework contains a type named IntrospectionQuery, which contains fields start with '__', and is used for introspection.\nI add a method named isIntrospectionTypes(), which is used in filterBuiltInTypes(). details in new commit.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442864230", "createdAt": "2020-06-19T14:12:35Z", "author": {"login": "dugenkui03"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();\n+        for (Type memberType : memberTypes) {\n+            String typeName = ((TypeName) memberType).getName();\n+            GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);\n+            if (!(graphQLNamedType instanceof GraphQLObjectType)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format(\"The member types of a Union type must all be Object base types. member type \\\"%s\\\" in Union \\\"%s\\\" is invalid.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            if (typeNames.contains(typeName)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format(\"The member types of a Union type must be unique. member type \\\"%s\\\" in Union \\\"%s\\\" is not unique.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            typeNames.add(typeName);\n+        }\n+    }\n+\n+    private void validateScalar(GraphQLScalarType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+    }\n+\n+    private void validateEnum(GraphQLEnumType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLEnumValueDefinition> enumValueDefinitions = type.getValues();\n+        if (enumValueDefinitions == null || enumValueDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.EnumLackOfValueError, String.format(\"Enum type \\\"%s\\\" must define one or more enum values.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        } else {\n+            for (GraphQLEnumValueDefinition enumValueDefinition : enumValueDefinitions) {\n+                assertEnumValueDefinitionName(type.getName(), enumValueDefinition.getName(), errorCollector);\n+            }\n+        }\n+\n+    }\n+\n+    private void validateFieldDefinition(String typeName, GraphQLFieldDefinition fieldDefinition, SchemaValidationErrorCollector errorCollector) {\n+        assertFieldName(typeName, fieldDefinition.getName(), errorCollector);\n+        assertNonNullType(fieldDefinition.getType(), errorCollector);\n+\n+        List<GraphQLArgument> fieldDefinitionArguments = fieldDefinition.getArguments();\n+        if (fieldDefinitionArguments != null || fieldDefinitionArguments.size() != 0) {\n+            for (GraphQLArgument fieldDefinitionArgument : fieldDefinitionArguments) {\n+                validateFieldDefinitionArgument(typeName, fieldDefinition.getName(), fieldDefinitionArgument, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateFieldDefinitionArgument(String typeName, String fieldName, GraphQLArgument argument, SchemaValidationErrorCollector errorCollector) {\n+        assertArgumentName(typeName, fieldName, argument.getName(), errorCollector);\n+        assertNonNullType(argument.getType(), errorCollector);\n+    }\n+\n+    private void assertTypeName(String typeName, SchemaValidationErrorCollector validationErrorCollector) {\n+        if (typeName.length() >= 2 && typeName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", typeName));\n+            validationErrorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertFieldName(String typeName, String fieldName, SchemaValidationErrorCollector errorCollector) {\n+        if (fieldName.length() >= 2 && fieldName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" in \\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", fieldName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertArgumentName(String typeName, String fieldName, String argumentName, SchemaValidationErrorCollector errorCollector) {\n+        if (argumentName.length() >= 2 && argumentName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"Argument name \\\"%s\\\" in \\\"%s-%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", argumentName, typeName, fieldName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertEnumValueDefinitionName(String typeName, String enumValueDefinitionName, SchemaValidationErrorCollector errorCollector) {\n+        if (enumValueDefinitionName.length() >= 2 && enumValueDefinitionName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"EnumValueDefinition \\\"%s\\\" in  \\\"%s\\\"  must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", enumValueDefinitionName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertNonNullType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLNonNull && ((GraphQLNonNull) type).getWrappedType() instanceof GraphQLNonNull) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.NonNullWrapNonNullError,\n+                    String.format(\"Non\u2010Null type \\\"%s\\\" must not wrap another Non\u2010Null type.\", GraphQLTypeUtil.simplePrint(type)));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private List<GraphQLNamedType> filterScalarAndIntrospectionTypes(List<GraphQLNamedType> graphQLNamedTypes) {\n+        if (graphQLNamedTypes == null || graphQLNamedTypes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        return graphQLNamedTypes.stream().filter(type -> !isScalarOrIntrospectionTypes(type)).collect(Collectors.toList());\n+    }\n+\n+    private boolean isScalarOrIntrospectionTypes(GraphQLNamedType type) {\n+        if (type instanceof GraphQLScalarType && (\n+                type.getName().equals(\"Int\") || type.getName().equals(\"Float\") || type.getName().equals(\"String\") ||\n+                        type.getName().equals(\"Boolean\") || type.getName().equals(\"ID\") || type.getName().equals(\"Long\") || type.getName().equals(\"Short\") ||\n+                        type.getName().equals(\"BigInteger\") || type.getName().equals(\"BigDecimal\") || type.getName().equals(\"Char\")\n+        )) {\n+            return true;\n+        }\n+\n+        if (type instanceof GraphQLEnumType && (type.getName().equals(\"__DirectiveLocation\") || type.getName().equals(\"__TypeKind\"))) {\n+            return true;\n+        }\n+\n+        if (type instanceof GraphQLObjectType && (", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MjE3Ng=="}, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Nzc5NDY0OnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwNjoxOTo1MVrOGmJWmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxODo1NDo0M1rOGmedaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MjMxNQ==", "bodyText": "could this whole method just check for __ prefix?", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442652315", "createdAt": "2020-06-19T06:19:51Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();\n+        for (Type memberType : memberTypes) {\n+            String typeName = ((TypeName) memberType).getName();\n+            GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);\n+            if (!(graphQLNamedType instanceof GraphQLObjectType)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format(\"The member types of a Union type must all be Object base types. member type \\\"%s\\\" in Union \\\"%s\\\" is invalid.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            if (typeNames.contains(typeName)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format(\"The member types of a Union type must be unique. member type \\\"%s\\\" in Union \\\"%s\\\" is not unique.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            typeNames.add(typeName);\n+        }\n+    }\n+\n+    private void validateScalar(GraphQLScalarType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+    }\n+\n+    private void validateEnum(GraphQLEnumType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLEnumValueDefinition> enumValueDefinitions = type.getValues();\n+        if (enumValueDefinitions == null || enumValueDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.EnumLackOfValueError, String.format(\"Enum type \\\"%s\\\" must define one or more enum values.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        } else {\n+            for (GraphQLEnumValueDefinition enumValueDefinition : enumValueDefinitions) {\n+                assertEnumValueDefinitionName(type.getName(), enumValueDefinition.getName(), errorCollector);\n+            }\n+        }\n+\n+    }\n+\n+    private void validateFieldDefinition(String typeName, GraphQLFieldDefinition fieldDefinition, SchemaValidationErrorCollector errorCollector) {\n+        assertFieldName(typeName, fieldDefinition.getName(), errorCollector);\n+        assertNonNullType(fieldDefinition.getType(), errorCollector);\n+\n+        List<GraphQLArgument> fieldDefinitionArguments = fieldDefinition.getArguments();\n+        if (fieldDefinitionArguments != null || fieldDefinitionArguments.size() != 0) {\n+            for (GraphQLArgument fieldDefinitionArgument : fieldDefinitionArguments) {\n+                validateFieldDefinitionArgument(typeName, fieldDefinition.getName(), fieldDefinitionArgument, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateFieldDefinitionArgument(String typeName, String fieldName, GraphQLArgument argument, SchemaValidationErrorCollector errorCollector) {\n+        assertArgumentName(typeName, fieldName, argument.getName(), errorCollector);\n+        assertNonNullType(argument.getType(), errorCollector);\n+    }\n+\n+    private void assertTypeName(String typeName, SchemaValidationErrorCollector validationErrorCollector) {\n+        if (typeName.length() >= 2 && typeName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", typeName));\n+            validationErrorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertFieldName(String typeName, String fieldName, SchemaValidationErrorCollector errorCollector) {\n+        if (fieldName.length() >= 2 && fieldName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" in \\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", fieldName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertArgumentName(String typeName, String fieldName, String argumentName, SchemaValidationErrorCollector errorCollector) {\n+        if (argumentName.length() >= 2 && argumentName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"Argument name \\\"%s\\\" in \\\"%s-%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", argumentName, typeName, fieldName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertEnumValueDefinitionName(String typeName, String enumValueDefinitionName, SchemaValidationErrorCollector errorCollector) {\n+        if (enumValueDefinitionName.length() >= 2 && enumValueDefinitionName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"EnumValueDefinition \\\"%s\\\" in  \\\"%s\\\"  must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", enumValueDefinitionName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertNonNullType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLNonNull && ((GraphQLNonNull) type).getWrappedType() instanceof GraphQLNonNull) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.NonNullWrapNonNullError,\n+                    String.format(\"Non\u2010Null type \\\"%s\\\" must not wrap another Non\u2010Null type.\", GraphQLTypeUtil.simplePrint(type)));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private List<GraphQLNamedType> filterScalarAndIntrospectionTypes(List<GraphQLNamedType> graphQLNamedTypes) {\n+        if (graphQLNamedTypes == null || graphQLNamedTypes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        return graphQLNamedTypes.stream().filter(type -> !isScalarOrIntrospectionTypes(type)).collect(Collectors.toList());\n+    }\n+\n+    private boolean isScalarOrIntrospectionTypes(GraphQLNamedType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5ODEyMQ==", "bodyText": "Replace it by filterBuiltInTypes, which aimed to filter Built-In Types.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442998121", "createdAt": "2020-06-19T18:54:43Z", "author": {"login": "dugenkui03"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();\n+        for (Type memberType : memberTypes) {\n+            String typeName = ((TypeName) memberType).getName();\n+            GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);\n+            if (!(graphQLNamedType instanceof GraphQLObjectType)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format(\"The member types of a Union type must all be Object base types. member type \\\"%s\\\" in Union \\\"%s\\\" is invalid.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            if (typeNames.contains(typeName)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format(\"The member types of a Union type must be unique. member type \\\"%s\\\" in Union \\\"%s\\\" is not unique.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            typeNames.add(typeName);\n+        }\n+    }\n+\n+    private void validateScalar(GraphQLScalarType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+    }\n+\n+    private void validateEnum(GraphQLEnumType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLEnumValueDefinition> enumValueDefinitions = type.getValues();\n+        if (enumValueDefinitions == null || enumValueDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.EnumLackOfValueError, String.format(\"Enum type \\\"%s\\\" must define one or more enum values.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        } else {\n+            for (GraphQLEnumValueDefinition enumValueDefinition : enumValueDefinitions) {\n+                assertEnumValueDefinitionName(type.getName(), enumValueDefinition.getName(), errorCollector);\n+            }\n+        }\n+\n+    }\n+\n+    private void validateFieldDefinition(String typeName, GraphQLFieldDefinition fieldDefinition, SchemaValidationErrorCollector errorCollector) {\n+        assertFieldName(typeName, fieldDefinition.getName(), errorCollector);\n+        assertNonNullType(fieldDefinition.getType(), errorCollector);\n+\n+        List<GraphQLArgument> fieldDefinitionArguments = fieldDefinition.getArguments();\n+        if (fieldDefinitionArguments != null || fieldDefinitionArguments.size() != 0) {\n+            for (GraphQLArgument fieldDefinitionArgument : fieldDefinitionArguments) {\n+                validateFieldDefinitionArgument(typeName, fieldDefinition.getName(), fieldDefinitionArgument, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateFieldDefinitionArgument(String typeName, String fieldName, GraphQLArgument argument, SchemaValidationErrorCollector errorCollector) {\n+        assertArgumentName(typeName, fieldName, argument.getName(), errorCollector);\n+        assertNonNullType(argument.getType(), errorCollector);\n+    }\n+\n+    private void assertTypeName(String typeName, SchemaValidationErrorCollector validationErrorCollector) {\n+        if (typeName.length() >= 2 && typeName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", typeName));\n+            validationErrorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertFieldName(String typeName, String fieldName, SchemaValidationErrorCollector errorCollector) {\n+        if (fieldName.length() >= 2 && fieldName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" in \\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", fieldName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertArgumentName(String typeName, String fieldName, String argumentName, SchemaValidationErrorCollector errorCollector) {\n+        if (argumentName.length() >= 2 && argumentName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"Argument name \\\"%s\\\" in \\\"%s-%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", argumentName, typeName, fieldName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertEnumValueDefinitionName(String typeName, String enumValueDefinitionName, SchemaValidationErrorCollector errorCollector) {\n+        if (enumValueDefinitionName.length() >= 2 && enumValueDefinitionName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"EnumValueDefinition \\\"%s\\\" in  \\\"%s\\\"  must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", enumValueDefinitionName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertNonNullType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLNonNull && ((GraphQLNonNull) type).getWrappedType() instanceof GraphQLNonNull) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.NonNullWrapNonNullError,\n+                    String.format(\"Non\u2010Null type \\\"%s\\\" must not wrap another Non\u2010Null type.\", GraphQLTypeUtil.simplePrint(type)));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private List<GraphQLNamedType> filterScalarAndIntrospectionTypes(List<GraphQLNamedType> graphQLNamedTypes) {\n+        if (graphQLNamedTypes == null || graphQLNamedTypes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        return graphQLNamedTypes.stream().filter(type -> !isScalarOrIntrospectionTypes(type)).collect(Collectors.toList());\n+    }\n+\n+    private boolean isScalarOrIntrospectionTypes(GraphQLNamedType type) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MjMxNQ=="}, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Nzc5NzQxOnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwNjoyMToyMVrOGmJYQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxODo1NToxOVrOGmeeYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MjczOQ==", "bodyText": "We have static util methods  (in FpKit I believe), please use them instead of using directly filter etc.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442652739", "createdAt": "2020-06-19T06:21:21Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();\n+        for (Type memberType : memberTypes) {\n+            String typeName = ((TypeName) memberType).getName();\n+            GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);\n+            if (!(graphQLNamedType instanceof GraphQLObjectType)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format(\"The member types of a Union type must all be Object base types. member type \\\"%s\\\" in Union \\\"%s\\\" is invalid.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            if (typeNames.contains(typeName)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format(\"The member types of a Union type must be unique. member type \\\"%s\\\" in Union \\\"%s\\\" is not unique.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            typeNames.add(typeName);\n+        }\n+    }\n+\n+    private void validateScalar(GraphQLScalarType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+    }\n+\n+    private void validateEnum(GraphQLEnumType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLEnumValueDefinition> enumValueDefinitions = type.getValues();\n+        if (enumValueDefinitions == null || enumValueDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.EnumLackOfValueError, String.format(\"Enum type \\\"%s\\\" must define one or more enum values.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        } else {\n+            for (GraphQLEnumValueDefinition enumValueDefinition : enumValueDefinitions) {\n+                assertEnumValueDefinitionName(type.getName(), enumValueDefinition.getName(), errorCollector);\n+            }\n+        }\n+\n+    }\n+\n+    private void validateFieldDefinition(String typeName, GraphQLFieldDefinition fieldDefinition, SchemaValidationErrorCollector errorCollector) {\n+        assertFieldName(typeName, fieldDefinition.getName(), errorCollector);\n+        assertNonNullType(fieldDefinition.getType(), errorCollector);\n+\n+        List<GraphQLArgument> fieldDefinitionArguments = fieldDefinition.getArguments();\n+        if (fieldDefinitionArguments != null || fieldDefinitionArguments.size() != 0) {\n+            for (GraphQLArgument fieldDefinitionArgument : fieldDefinitionArguments) {\n+                validateFieldDefinitionArgument(typeName, fieldDefinition.getName(), fieldDefinitionArgument, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateFieldDefinitionArgument(String typeName, String fieldName, GraphQLArgument argument, SchemaValidationErrorCollector errorCollector) {\n+        assertArgumentName(typeName, fieldName, argument.getName(), errorCollector);\n+        assertNonNullType(argument.getType(), errorCollector);\n+    }\n+\n+    private void assertTypeName(String typeName, SchemaValidationErrorCollector validationErrorCollector) {\n+        if (typeName.length() >= 2 && typeName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", typeName));\n+            validationErrorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertFieldName(String typeName, String fieldName, SchemaValidationErrorCollector errorCollector) {\n+        if (fieldName.length() >= 2 && fieldName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" in \\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", fieldName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertArgumentName(String typeName, String fieldName, String argumentName, SchemaValidationErrorCollector errorCollector) {\n+        if (argumentName.length() >= 2 && argumentName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"Argument name \\\"%s\\\" in \\\"%s-%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", argumentName, typeName, fieldName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertEnumValueDefinitionName(String typeName, String enumValueDefinitionName, SchemaValidationErrorCollector errorCollector) {\n+        if (enumValueDefinitionName.length() >= 2 && enumValueDefinitionName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"EnumValueDefinition \\\"%s\\\" in  \\\"%s\\\"  must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", enumValueDefinitionName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertNonNullType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLNonNull && ((GraphQLNonNull) type).getWrappedType() instanceof GraphQLNonNull) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.NonNullWrapNonNullError,\n+                    String.format(\"Non\u2010Null type \\\"%s\\\" must not wrap another Non\u2010Null type.\", GraphQLTypeUtil.simplePrint(type)));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private List<GraphQLNamedType> filterScalarAndIntrospectionTypes(List<GraphQLNamedType> graphQLNamedTypes) {\n+        if (graphQLNamedTypes == null || graphQLNamedTypes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        return graphQLNamedTypes.stream().filter(type -> !isScalarOrIntrospectionTypes(type)).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5ODM2OA==", "bodyText": "Thanks for your suggestion.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442998368", "createdAt": "2020-06-19T18:55:19Z", "author": {"login": "dugenkui03"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();\n+        for (Type memberType : memberTypes) {\n+            String typeName = ((TypeName) memberType).getName();\n+            GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);\n+            if (!(graphQLNamedType instanceof GraphQLObjectType)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format(\"The member types of a Union type must all be Object base types. member type \\\"%s\\\" in Union \\\"%s\\\" is invalid.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            if (typeNames.contains(typeName)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format(\"The member types of a Union type must be unique. member type \\\"%s\\\" in Union \\\"%s\\\" is not unique.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            typeNames.add(typeName);\n+        }\n+    }\n+\n+    private void validateScalar(GraphQLScalarType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+    }\n+\n+    private void validateEnum(GraphQLEnumType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLEnumValueDefinition> enumValueDefinitions = type.getValues();\n+        if (enumValueDefinitions == null || enumValueDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.EnumLackOfValueError, String.format(\"Enum type \\\"%s\\\" must define one or more enum values.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        } else {\n+            for (GraphQLEnumValueDefinition enumValueDefinition : enumValueDefinitions) {\n+                assertEnumValueDefinitionName(type.getName(), enumValueDefinition.getName(), errorCollector);\n+            }\n+        }\n+\n+    }\n+\n+    private void validateFieldDefinition(String typeName, GraphQLFieldDefinition fieldDefinition, SchemaValidationErrorCollector errorCollector) {\n+        assertFieldName(typeName, fieldDefinition.getName(), errorCollector);\n+        assertNonNullType(fieldDefinition.getType(), errorCollector);\n+\n+        List<GraphQLArgument> fieldDefinitionArguments = fieldDefinition.getArguments();\n+        if (fieldDefinitionArguments != null || fieldDefinitionArguments.size() != 0) {\n+            for (GraphQLArgument fieldDefinitionArgument : fieldDefinitionArguments) {\n+                validateFieldDefinitionArgument(typeName, fieldDefinition.getName(), fieldDefinitionArgument, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateFieldDefinitionArgument(String typeName, String fieldName, GraphQLArgument argument, SchemaValidationErrorCollector errorCollector) {\n+        assertArgumentName(typeName, fieldName, argument.getName(), errorCollector);\n+        assertNonNullType(argument.getType(), errorCollector);\n+    }\n+\n+    private void assertTypeName(String typeName, SchemaValidationErrorCollector validationErrorCollector) {\n+        if (typeName.length() >= 2 && typeName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", typeName));\n+            validationErrorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertFieldName(String typeName, String fieldName, SchemaValidationErrorCollector errorCollector) {\n+        if (fieldName.length() >= 2 && fieldName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" in \\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", fieldName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertArgumentName(String typeName, String fieldName, String argumentName, SchemaValidationErrorCollector errorCollector) {\n+        if (argumentName.length() >= 2 && argumentName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"Argument name \\\"%s\\\" in \\\"%s-%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", argumentName, typeName, fieldName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertEnumValueDefinitionName(String typeName, String enumValueDefinitionName, SchemaValidationErrorCollector errorCollector) {\n+        if (enumValueDefinitionName.length() >= 2 && enumValueDefinitionName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"EnumValueDefinition \\\"%s\\\" in  \\\"%s\\\"  must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", enumValueDefinitionName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertNonNullType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLNonNull && ((GraphQLNonNull) type).getWrappedType() instanceof GraphQLNonNull) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.NonNullWrapNonNullError,\n+                    String.format(\"Non\u2010Null type \\\"%s\\\" must not wrap another Non\u2010Null type.\", GraphQLTypeUtil.simplePrint(type)));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private List<GraphQLNamedType> filterScalarAndIntrospectionTypes(List<GraphQLNamedType> graphQLNamedTypes) {\n+        if (graphQLNamedTypes == null || graphQLNamedTypes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        return graphQLNamedTypes.stream().filter(type -> !isScalarOrIntrospectionTypes(type)).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MjczOQ=="}, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Nzc5ODM2OnYy", "diffSide": "RIGHT", "path": "src/test/groovy/graphql/schema/validation/TypeAndFieldRuleTest.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwNjoyMTo1MlrOGmJY2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxODo1NTowM1rOGmed8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1Mjg5MQ==", "bodyText": "we should add tests for Interfaces here as well.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442652891", "createdAt": "2020-06-19T06:21:52Z", "author": {"login": "andimarek"}, "path": "src/test/groovy/graphql/schema/validation/TypeAndFieldRuleTest.groovy", "diffHunk": "@@ -0,0 +1,123 @@\n+package graphql.schema.validation\n+\n+import graphql.AssertException\n+import graphql.TestUtil\n+import graphql.schema.GraphQLNonNull\n+import graphql.schema.GraphQLObjectType\n+import spock.lang.Specification\n+\n+\n+import static graphql.Scalars.GraphQLString\n+import static graphql.schema.GraphQLFieldDefinition.newFieldDefinition\n+import static graphql.schema.GraphQLObjectType.newObject\n+import static graphql.schema.GraphQLSchema.newSchema\n+\n+class TypeAndFieldRuleTest extends Specification {\n+\n+\n+    def \"type must define one or more fields.\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5ODI1Ng==", "bodyText": "Thanks for your suggestion.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442998256", "createdAt": "2020-06-19T18:55:03Z", "author": {"login": "dugenkui03"}, "path": "src/test/groovy/graphql/schema/validation/TypeAndFieldRuleTest.groovy", "diffHunk": "@@ -0,0 +1,123 @@\n+package graphql.schema.validation\n+\n+import graphql.AssertException\n+import graphql.TestUtil\n+import graphql.schema.GraphQLNonNull\n+import graphql.schema.GraphQLObjectType\n+import spock.lang.Specification\n+\n+\n+import static graphql.Scalars.GraphQLString\n+import static graphql.schema.GraphQLFieldDefinition.newFieldDefinition\n+import static graphql.schema.GraphQLObjectType.newObject\n+import static graphql.schema.GraphQLSchema.newSchema\n+\n+class TypeAndFieldRuleTest extends Specification {\n+\n+\n+    def \"type must define one or more fields.\"() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1Mjg5MQ=="}, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzgwMTU5OnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwNjoyMzozN1rOGmJa6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNDoxMzoxNFrOGmWTqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MzQxNw==", "bodyText": "I think a Set is better here as track just the names we already saw.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442653417", "createdAt": "2020-06-19T06:23:37Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2NDU1Mg==", "bodyText": "Thanks for your suggestion.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442864552", "createdAt": "2020-06-19T14:13:14Z", "author": {"login": "dugenkui03"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MzQxNw=="}, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 141}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4523, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}