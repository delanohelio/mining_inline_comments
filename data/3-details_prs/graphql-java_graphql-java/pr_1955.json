{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzOTUwODcz", "number": 1955, "title": "New validation rules about type, field, argument", "bodyText": "The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n\nTypes must define one or more fields;\nEnum type must define one or more enum values;\nUnion type must include one or more unique member types;\nThe member types of a Union type must all be Object base types;\nNon\u2010Null type must not wrap another Non\u2010Null type;\nInvalid name begin with \"__\" (two underscores).\n\nDetails in specification: TypeSystem", "createdAt": "2020-06-13T03:14:55Z", "url": "https://github.com/graphql-java/graphql-java/pull/1955", "merged": true, "mergeCommit": {"oid": "c801fd8c16e05dd499b8e9da20ce5ed3df89c8d1"}, "closed": true, "closedAt": "2020-11-10T21:22:30Z", "author": {"login": "dugenkui03"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqx1ORgH2gAyNDMzOTUwODczOmE5MGU0ZTNmYjRmNTQ4YjI4NTJkNzBjN2M5ZTdhYjQ3OTE0YmQ1ZGI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdGwUIogH2gAyNDMzOTUwODczOjkzNjViOTAxOTNmZGIxZjU4OThmZDdlMGM5ZWNjZGI3MGFjNTNhOGU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db", "author": {"user": {"login": "dugenkui03", "name": "dugenkui"}}, "url": "https://github.com/graphql-java/graphql-java/commit/a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db", "committedDate": "2020-06-13T06:54:23Z", "message": "add some schema validation rules: type, field, argument."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "256cb9ae138290a79e168be820d05015ad8dd71e", "author": {"user": {"login": "dugenkui03", "name": "dugenkui"}}, "url": "https://github.com/graphql-java/graphql-java/commit/256cb9ae138290a79e168be820d05015ad8dd71e", "committedDate": "2020-06-13T06:52:35Z", "message": "addSchemaValidationRules"}, "afterCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db", "author": {"user": {"login": "dugenkui03", "name": "dugenkui"}}, "url": "https://github.com/graphql-java/graphql-java/commit/a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db", "committedDate": "2020-06-13T06:54:23Z", "message": "add some schema validation rules: type, field, argument."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzODI2NTk0", "url": "https://github.com/graphql-java/graphql-java/pull/1955#pullrequestreview-433826594", "createdAt": "2020-06-19T06:14:40Z", "commit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwNjoxNDo0MFrOGmJQhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwNjoyMzozN1rOGmJa6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MDc1Ng==", "bodyText": "we should only treat the build-in scalar types (Int, Float, String, Boolean and ID) in a special way. The others are not really special and should be treated as every other custom scalar.\nWe also have a helper method in Scalars (I believe) to determine if the type is a build-in one or not", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442650756", "createdAt": "2020-06-19T06:14:40Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();\n+        for (Type memberType : memberTypes) {\n+            String typeName = ((TypeName) memberType).getName();\n+            GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);\n+            if (!(graphQLNamedType instanceof GraphQLObjectType)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format(\"The member types of a Union type must all be Object base types. member type \\\"%s\\\" in Union \\\"%s\\\" is invalid.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            if (typeNames.contains(typeName)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format(\"The member types of a Union type must be unique. member type \\\"%s\\\" in Union \\\"%s\\\" is not unique.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            typeNames.add(typeName);\n+        }\n+    }\n+\n+    private void validateScalar(GraphQLScalarType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+    }\n+\n+    private void validateEnum(GraphQLEnumType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLEnumValueDefinition> enumValueDefinitions = type.getValues();\n+        if (enumValueDefinitions == null || enumValueDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.EnumLackOfValueError, String.format(\"Enum type \\\"%s\\\" must define one or more enum values.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        } else {\n+            for (GraphQLEnumValueDefinition enumValueDefinition : enumValueDefinitions) {\n+                assertEnumValueDefinitionName(type.getName(), enumValueDefinition.getName(), errorCollector);\n+            }\n+        }\n+\n+    }\n+\n+    private void validateFieldDefinition(String typeName, GraphQLFieldDefinition fieldDefinition, SchemaValidationErrorCollector errorCollector) {\n+        assertFieldName(typeName, fieldDefinition.getName(), errorCollector);\n+        assertNonNullType(fieldDefinition.getType(), errorCollector);\n+\n+        List<GraphQLArgument> fieldDefinitionArguments = fieldDefinition.getArguments();\n+        if (fieldDefinitionArguments != null || fieldDefinitionArguments.size() != 0) {\n+            for (GraphQLArgument fieldDefinitionArgument : fieldDefinitionArguments) {\n+                validateFieldDefinitionArgument(typeName, fieldDefinition.getName(), fieldDefinitionArgument, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateFieldDefinitionArgument(String typeName, String fieldName, GraphQLArgument argument, SchemaValidationErrorCollector errorCollector) {\n+        assertArgumentName(typeName, fieldName, argument.getName(), errorCollector);\n+        assertNonNullType(argument.getType(), errorCollector);\n+    }\n+\n+    private void assertTypeName(String typeName, SchemaValidationErrorCollector validationErrorCollector) {\n+        if (typeName.length() >= 2 && typeName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", typeName));\n+            validationErrorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertFieldName(String typeName, String fieldName, SchemaValidationErrorCollector errorCollector) {\n+        if (fieldName.length() >= 2 && fieldName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" in \\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", fieldName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertArgumentName(String typeName, String fieldName, String argumentName, SchemaValidationErrorCollector errorCollector) {\n+        if (argumentName.length() >= 2 && argumentName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"Argument name \\\"%s\\\" in \\\"%s-%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", argumentName, typeName, fieldName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertEnumValueDefinitionName(String typeName, String enumValueDefinitionName, SchemaValidationErrorCollector errorCollector) {\n+        if (enumValueDefinitionName.length() >= 2 && enumValueDefinitionName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"EnumValueDefinition \\\"%s\\\" in  \\\"%s\\\"  must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", enumValueDefinitionName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertNonNullType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLNonNull && ((GraphQLNonNull) type).getWrappedType() instanceof GraphQLNonNull) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.NonNullWrapNonNullError,\n+                    String.format(\"Non\u2010Null type \\\"%s\\\" must not wrap another Non\u2010Null type.\", GraphQLTypeUtil.simplePrint(type)));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private List<GraphQLNamedType> filterScalarAndIntrospectionTypes(List<GraphQLNamedType> graphQLNamedTypes) {\n+        if (graphQLNamedTypes == null || graphQLNamedTypes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        return graphQLNamedTypes.stream().filter(type -> !isScalarOrIntrospectionTypes(type)).collect(Collectors.toList());\n+    }\n+\n+    private boolean isScalarOrIntrospectionTypes(GraphQLNamedType type) {\n+        if (type instanceof GraphQLScalarType && (\n+                type.getName().equals(\"Int\") || type.getName().equals(\"Float\") || type.getName().equals(\"String\") ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MTYyMQ==", "bodyText": "we should not need to check the AST definition here. Just getting the members of the type should be enough.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442651621", "createdAt": "2020-06-19T06:17:37Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MTk5OA==", "bodyText": "can we combine validateObject and validateInterface?\nI would also suggest a more prescriptive name like validateContainsField or so.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442651998", "createdAt": "2020-06-19T06:18:48Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MjE3Ng==", "bodyText": "IntrospectionQuery is not a special type at all (it is just a name).", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442652176", "createdAt": "2020-06-19T06:19:20Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();\n+        for (Type memberType : memberTypes) {\n+            String typeName = ((TypeName) memberType).getName();\n+            GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);\n+            if (!(graphQLNamedType instanceof GraphQLObjectType)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format(\"The member types of a Union type must all be Object base types. member type \\\"%s\\\" in Union \\\"%s\\\" is invalid.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            if (typeNames.contains(typeName)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format(\"The member types of a Union type must be unique. member type \\\"%s\\\" in Union \\\"%s\\\" is not unique.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            typeNames.add(typeName);\n+        }\n+    }\n+\n+    private void validateScalar(GraphQLScalarType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+    }\n+\n+    private void validateEnum(GraphQLEnumType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLEnumValueDefinition> enumValueDefinitions = type.getValues();\n+        if (enumValueDefinitions == null || enumValueDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.EnumLackOfValueError, String.format(\"Enum type \\\"%s\\\" must define one or more enum values.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        } else {\n+            for (GraphQLEnumValueDefinition enumValueDefinition : enumValueDefinitions) {\n+                assertEnumValueDefinitionName(type.getName(), enumValueDefinition.getName(), errorCollector);\n+            }\n+        }\n+\n+    }\n+\n+    private void validateFieldDefinition(String typeName, GraphQLFieldDefinition fieldDefinition, SchemaValidationErrorCollector errorCollector) {\n+        assertFieldName(typeName, fieldDefinition.getName(), errorCollector);\n+        assertNonNullType(fieldDefinition.getType(), errorCollector);\n+\n+        List<GraphQLArgument> fieldDefinitionArguments = fieldDefinition.getArguments();\n+        if (fieldDefinitionArguments != null || fieldDefinitionArguments.size() != 0) {\n+            for (GraphQLArgument fieldDefinitionArgument : fieldDefinitionArguments) {\n+                validateFieldDefinitionArgument(typeName, fieldDefinition.getName(), fieldDefinitionArgument, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateFieldDefinitionArgument(String typeName, String fieldName, GraphQLArgument argument, SchemaValidationErrorCollector errorCollector) {\n+        assertArgumentName(typeName, fieldName, argument.getName(), errorCollector);\n+        assertNonNullType(argument.getType(), errorCollector);\n+    }\n+\n+    private void assertTypeName(String typeName, SchemaValidationErrorCollector validationErrorCollector) {\n+        if (typeName.length() >= 2 && typeName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", typeName));\n+            validationErrorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertFieldName(String typeName, String fieldName, SchemaValidationErrorCollector errorCollector) {\n+        if (fieldName.length() >= 2 && fieldName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" in \\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", fieldName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertArgumentName(String typeName, String fieldName, String argumentName, SchemaValidationErrorCollector errorCollector) {\n+        if (argumentName.length() >= 2 && argumentName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"Argument name \\\"%s\\\" in \\\"%s-%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", argumentName, typeName, fieldName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertEnumValueDefinitionName(String typeName, String enumValueDefinitionName, SchemaValidationErrorCollector errorCollector) {\n+        if (enumValueDefinitionName.length() >= 2 && enumValueDefinitionName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"EnumValueDefinition \\\"%s\\\" in  \\\"%s\\\"  must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", enumValueDefinitionName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertNonNullType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLNonNull && ((GraphQLNonNull) type).getWrappedType() instanceof GraphQLNonNull) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.NonNullWrapNonNullError,\n+                    String.format(\"Non\u2010Null type \\\"%s\\\" must not wrap another Non\u2010Null type.\", GraphQLTypeUtil.simplePrint(type)));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private List<GraphQLNamedType> filterScalarAndIntrospectionTypes(List<GraphQLNamedType> graphQLNamedTypes) {\n+        if (graphQLNamedTypes == null || graphQLNamedTypes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        return graphQLNamedTypes.stream().filter(type -> !isScalarOrIntrospectionTypes(type)).collect(Collectors.toList());\n+    }\n+\n+    private boolean isScalarOrIntrospectionTypes(GraphQLNamedType type) {\n+        if (type instanceof GraphQLScalarType && (\n+                type.getName().equals(\"Int\") || type.getName().equals(\"Float\") || type.getName().equals(\"String\") ||\n+                        type.getName().equals(\"Boolean\") || type.getName().equals(\"ID\") || type.getName().equals(\"Long\") || type.getName().equals(\"Short\") ||\n+                        type.getName().equals(\"BigInteger\") || type.getName().equals(\"BigDecimal\") || type.getName().equals(\"Char\")\n+        )) {\n+            return true;\n+        }\n+\n+        if (type instanceof GraphQLEnumType && (type.getName().equals(\"__DirectiveLocation\") || type.getName().equals(\"__TypeKind\"))) {\n+            return true;\n+        }\n+\n+        if (type instanceof GraphQLObjectType && (", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MjMxNQ==", "bodyText": "could this whole method just check for __ prefix?", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442652315", "createdAt": "2020-06-19T06:19:51Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();\n+        for (Type memberType : memberTypes) {\n+            String typeName = ((TypeName) memberType).getName();\n+            GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);\n+            if (!(graphQLNamedType instanceof GraphQLObjectType)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format(\"The member types of a Union type must all be Object base types. member type \\\"%s\\\" in Union \\\"%s\\\" is invalid.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            if (typeNames.contains(typeName)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format(\"The member types of a Union type must be unique. member type \\\"%s\\\" in Union \\\"%s\\\" is not unique.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            typeNames.add(typeName);\n+        }\n+    }\n+\n+    private void validateScalar(GraphQLScalarType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+    }\n+\n+    private void validateEnum(GraphQLEnumType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLEnumValueDefinition> enumValueDefinitions = type.getValues();\n+        if (enumValueDefinitions == null || enumValueDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.EnumLackOfValueError, String.format(\"Enum type \\\"%s\\\" must define one or more enum values.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        } else {\n+            for (GraphQLEnumValueDefinition enumValueDefinition : enumValueDefinitions) {\n+                assertEnumValueDefinitionName(type.getName(), enumValueDefinition.getName(), errorCollector);\n+            }\n+        }\n+\n+    }\n+\n+    private void validateFieldDefinition(String typeName, GraphQLFieldDefinition fieldDefinition, SchemaValidationErrorCollector errorCollector) {\n+        assertFieldName(typeName, fieldDefinition.getName(), errorCollector);\n+        assertNonNullType(fieldDefinition.getType(), errorCollector);\n+\n+        List<GraphQLArgument> fieldDefinitionArguments = fieldDefinition.getArguments();\n+        if (fieldDefinitionArguments != null || fieldDefinitionArguments.size() != 0) {\n+            for (GraphQLArgument fieldDefinitionArgument : fieldDefinitionArguments) {\n+                validateFieldDefinitionArgument(typeName, fieldDefinition.getName(), fieldDefinitionArgument, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateFieldDefinitionArgument(String typeName, String fieldName, GraphQLArgument argument, SchemaValidationErrorCollector errorCollector) {\n+        assertArgumentName(typeName, fieldName, argument.getName(), errorCollector);\n+        assertNonNullType(argument.getType(), errorCollector);\n+    }\n+\n+    private void assertTypeName(String typeName, SchemaValidationErrorCollector validationErrorCollector) {\n+        if (typeName.length() >= 2 && typeName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", typeName));\n+            validationErrorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertFieldName(String typeName, String fieldName, SchemaValidationErrorCollector errorCollector) {\n+        if (fieldName.length() >= 2 && fieldName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" in \\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", fieldName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertArgumentName(String typeName, String fieldName, String argumentName, SchemaValidationErrorCollector errorCollector) {\n+        if (argumentName.length() >= 2 && argumentName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"Argument name \\\"%s\\\" in \\\"%s-%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", argumentName, typeName, fieldName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertEnumValueDefinitionName(String typeName, String enumValueDefinitionName, SchemaValidationErrorCollector errorCollector) {\n+        if (enumValueDefinitionName.length() >= 2 && enumValueDefinitionName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"EnumValueDefinition \\\"%s\\\" in  \\\"%s\\\"  must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", enumValueDefinitionName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertNonNullType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLNonNull && ((GraphQLNonNull) type).getWrappedType() instanceof GraphQLNonNull) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.NonNullWrapNonNullError,\n+                    String.format(\"Non\u2010Null type \\\"%s\\\" must not wrap another Non\u2010Null type.\", GraphQLTypeUtil.simplePrint(type)));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private List<GraphQLNamedType> filterScalarAndIntrospectionTypes(List<GraphQLNamedType> graphQLNamedTypes) {\n+        if (graphQLNamedTypes == null || graphQLNamedTypes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        return graphQLNamedTypes.stream().filter(type -> !isScalarOrIntrospectionTypes(type)).collect(Collectors.toList());\n+    }\n+\n+    private boolean isScalarOrIntrospectionTypes(GraphQLNamedType type) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MjczOQ==", "bodyText": "We have static util methods  (in FpKit I believe), please use them instead of using directly filter etc.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442652739", "createdAt": "2020-06-19T06:21:21Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();\n+        for (Type memberType : memberTypes) {\n+            String typeName = ((TypeName) memberType).getName();\n+            GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);\n+            if (!(graphQLNamedType instanceof GraphQLObjectType)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format(\"The member types of a Union type must all be Object base types. member type \\\"%s\\\" in Union \\\"%s\\\" is invalid.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            if (typeNames.contains(typeName)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format(\"The member types of a Union type must be unique. member type \\\"%s\\\" in Union \\\"%s\\\" is not unique.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            typeNames.add(typeName);\n+        }\n+    }\n+\n+    private void validateScalar(GraphQLScalarType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+    }\n+\n+    private void validateEnum(GraphQLEnumType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLEnumValueDefinition> enumValueDefinitions = type.getValues();\n+        if (enumValueDefinitions == null || enumValueDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.EnumLackOfValueError, String.format(\"Enum type \\\"%s\\\" must define one or more enum values.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        } else {\n+            for (GraphQLEnumValueDefinition enumValueDefinition : enumValueDefinitions) {\n+                assertEnumValueDefinitionName(type.getName(), enumValueDefinition.getName(), errorCollector);\n+            }\n+        }\n+\n+    }\n+\n+    private void validateFieldDefinition(String typeName, GraphQLFieldDefinition fieldDefinition, SchemaValidationErrorCollector errorCollector) {\n+        assertFieldName(typeName, fieldDefinition.getName(), errorCollector);\n+        assertNonNullType(fieldDefinition.getType(), errorCollector);\n+\n+        List<GraphQLArgument> fieldDefinitionArguments = fieldDefinition.getArguments();\n+        if (fieldDefinitionArguments != null || fieldDefinitionArguments.size() != 0) {\n+            for (GraphQLArgument fieldDefinitionArgument : fieldDefinitionArguments) {\n+                validateFieldDefinitionArgument(typeName, fieldDefinition.getName(), fieldDefinitionArgument, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateFieldDefinitionArgument(String typeName, String fieldName, GraphQLArgument argument, SchemaValidationErrorCollector errorCollector) {\n+        assertArgumentName(typeName, fieldName, argument.getName(), errorCollector);\n+        assertNonNullType(argument.getType(), errorCollector);\n+    }\n+\n+    private void assertTypeName(String typeName, SchemaValidationErrorCollector validationErrorCollector) {\n+        if (typeName.length() >= 2 && typeName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", typeName));\n+            validationErrorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertFieldName(String typeName, String fieldName, SchemaValidationErrorCollector errorCollector) {\n+        if (fieldName.length() >= 2 && fieldName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" in \\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", fieldName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertArgumentName(String typeName, String fieldName, String argumentName, SchemaValidationErrorCollector errorCollector) {\n+        if (argumentName.length() >= 2 && argumentName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"Argument name \\\"%s\\\" in \\\"%s-%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", argumentName, typeName, fieldName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertEnumValueDefinitionName(String typeName, String enumValueDefinitionName, SchemaValidationErrorCollector errorCollector) {\n+        if (enumValueDefinitionName.length() >= 2 && enumValueDefinitionName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"EnumValueDefinition \\\"%s\\\" in  \\\"%s\\\"  must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", enumValueDefinitionName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertNonNullType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLNonNull && ((GraphQLNonNull) type).getWrappedType() instanceof GraphQLNonNull) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.NonNullWrapNonNullError,\n+                    String.format(\"Non\u2010Null type \\\"%s\\\" must not wrap another Non\u2010Null type.\", GraphQLTypeUtil.simplePrint(type)));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private List<GraphQLNamedType> filterScalarAndIntrospectionTypes(List<GraphQLNamedType> graphQLNamedTypes) {\n+        if (graphQLNamedTypes == null || graphQLNamedTypes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        return graphQLNamedTypes.stream().filter(type -> !isScalarOrIntrospectionTypes(type)).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1Mjg5MQ==", "bodyText": "we should add tests for Interfaces here as well.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442652891", "createdAt": "2020-06-19T06:21:52Z", "author": {"login": "andimarek"}, "path": "src/test/groovy/graphql/schema/validation/TypeAndFieldRuleTest.groovy", "diffHunk": "@@ -0,0 +1,123 @@\n+package graphql.schema.validation\n+\n+import graphql.AssertException\n+import graphql.TestUtil\n+import graphql.schema.GraphQLNonNull\n+import graphql.schema.GraphQLObjectType\n+import spock.lang.Specification\n+\n+\n+import static graphql.Scalars.GraphQLString\n+import static graphql.schema.GraphQLFieldDefinition.newFieldDefinition\n+import static graphql.schema.GraphQLObjectType.newObject\n+import static graphql.schema.GraphQLSchema.newSchema\n+\n+class TypeAndFieldRuleTest extends Specification {\n+\n+\n+    def \"type must define one or more fields.\"() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MzQxNw==", "bodyText": "I think a Set is better here as track just the names we already saw.", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442653417", "createdAt": "2020-06-19T06:23:37Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db"}, "originalPosition": 141}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a23d7e48b686a1f6037f1650d16c754ed7d65a52", "author": {"user": {"login": "dugenkui03", "name": "dugenkui"}}, "url": "https://github.com/graphql-java/graphql-java/commit/a23d7e48b686a1f6037f1650d16c754ed7d65a52", "committedDate": "2020-06-19T19:07:36Z", "message": "add some schema validation rules: type, field, argument."}, "afterCommit": {"oid": "59a137797e75bee67d54f45c4a9032a09399df14", "author": {"user": {"login": "dugenkui03", "name": "dugenkui"}}, "url": "https://github.com/graphql-java/graphql-java/commit/59a137797e75bee67d54f45c4a9032a09399df14", "committedDate": "2020-06-20T11:54:12Z", "message": "add isIntrospectionTypes method in Introspection."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ff53d2ee9f4ad74754540badff1edaa0c7d4983", "author": {"user": {"login": "dugenkui03", "name": "dugenkui"}}, "url": "https://github.com/graphql-java/graphql-java/commit/9ff53d2ee9f4ad74754540badff1edaa0c7d4983", "committedDate": "2020-06-21T04:25:05Z", "message": "add isIntrospectionTypes method in Introspection."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "59a137797e75bee67d54f45c4a9032a09399df14", "author": {"user": {"login": "dugenkui03", "name": "dugenkui"}}, "url": "https://github.com/graphql-java/graphql-java/commit/59a137797e75bee67d54f45c4a9032a09399df14", "committedDate": "2020-06-20T11:54:12Z", "message": "add isIntrospectionTypes method in Introspection."}, "afterCommit": {"oid": "9ff53d2ee9f4ad74754540badff1edaa0c7d4983", "author": {"user": {"login": "dugenkui03", "name": "dugenkui"}}, "url": "https://github.com/graphql-java/graphql-java/commit/9ff53d2ee9f4ad74754540badff1edaa0c7d4983", "committedDate": "2020-06-21T04:25:05Z", "message": "add isIntrospectionTypes method in Introspection."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "982cd2942f03ae564face2dffa1034b08e9de558", "author": {"user": {"login": "dugenkui03", "name": "dugenkui"}}, "url": "https://github.com/graphql-java/graphql-java/commit/982cd2942f03ae564face2dffa1034b08e9de558", "committedDate": "2020-06-25T07:52:57Z", "message": "rules about input object type"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9365b90193fdb1f5898fd7e0c9eccdb70ac53a8e", "author": {"user": {"login": "dugenkui03", "name": "dugenkui"}}, "url": "https://github.com/graphql-java/graphql-java/commit/9365b90193fdb1f5898fd7e0c9eccdb70ac53a8e", "committedDate": "2020-09-08T04:58:13Z", "message": "merge master and fix conflict; update unit test for GraphQLUnionTypy"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4326, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}