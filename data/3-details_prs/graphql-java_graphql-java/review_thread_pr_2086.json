{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyMjAyNTcz", "number": 2086, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMToyMTozNFrOEzfMRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNzo1NjozOVrOE3Gf9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDIzODc5OnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/language/Field.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMToyMTozNFrOHqvLQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMTozMDoxOFrOHqvc0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3NTE2OQ==", "bodyText": "The next level would be for input methods to TAKE immutablke lists.  eg here we throw the responsibility back onto the caller to give us an immutable list.\nThoughts?\nIf we did this, then com.google.collect.ImmutableList becomes implicit API.", "url": "https://github.com/graphql-java/graphql-java/pull/2086#discussion_r514575169", "createdAt": "2020-10-29T21:21:34Z", "author": {"login": "bbakerman"}, "path": "src/main/java/graphql/language/Field.java", "diffHunk": "@@ -257,13 +257,13 @@ public Builder alias(String alias) {\n         }\n \n         public Builder arguments(List<Argument> arguments) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b39d8f2ed0f6f81c2f44fadbe36f5934d1ac96d"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3OTY2Nw==", "bodyText": "We don't need to make it explicit: If you give us a (GraphQL Java) Immutable List it is already optimized inside Guava itself.", "url": "https://github.com/graphql-java/graphql-java/pull/2086#discussion_r514579667", "createdAt": "2020-10-29T21:30:18Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/language/Field.java", "diffHunk": "@@ -257,13 +257,13 @@ public Builder alias(String alias) {\n         }\n \n         public Builder arguments(List<Argument> arguments) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3NTE2OQ=="}, "originalCommit": {"oid": "7b39d8f2ed0f6f81c2f44fadbe36f5934d1ac96d"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNDIzOTU2OnYy", "diffSide": "RIGHT", "path": "build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMToyMTo1MFrOHqvLuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMTozMDo1OVrOHqvd_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3NTI4OQ==", "bodyText": "didnt need base??", "url": "https://github.com/graphql-java/graphql-java/pull/2086#discussion_r514575289", "createdAt": "2020-10-29T21:21:50Z", "author": {"login": "bbakerman"}, "path": "build.gradle", "diffHunk": "@@ -83,6 +88,26 @@ dependencies {\n     testImplementation 'org.openjdk.jmh:jmh-generator-annprocess:1.21'\n }\n \n+shadowJar {\n+    minimize()\n+    archiveClassifier.set('')\n+    configurations = [project.configurations.compileClasspath]\n+    relocate('com.google.common', 'graphql.com.google.common') {\n+        include 'com.google.common.collect.*'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b39d8f2ed0f6f81c2f44fadbe36f5934d1ac96d"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3OTk2Nw==", "bodyText": "still working on it: currently whole guava is added to jar. There is no obvious way to split guava itself up.", "url": "https://github.com/graphql-java/graphql-java/pull/2086#discussion_r514579967", "createdAt": "2020-10-29T21:30:59Z", "author": {"login": "andimarek"}, "path": "build.gradle", "diffHunk": "@@ -83,6 +88,26 @@ dependencies {\n     testImplementation 'org.openjdk.jmh:jmh-generator-annprocess:1.21'\n }\n \n+shadowJar {\n+    minimize()\n+    archiveClassifier.set('')\n+    configurations = [project.configurations.compileClasspath]\n+    relocate('com.google.common', 'graphql.com.google.common') {\n+        include 'com.google.common.collect.*'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3NTI4OQ=="}, "originalCommit": {"oid": "7b39d8f2ed0f6f81c2f44fadbe36f5934d1ac96d"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTY4NTQ3OnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/collect/ImmutableMapWithNullValues.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo0MjowMVrOHsYgvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo0MjowMVrOHsYgvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMDk4OA==", "bodyText": "Didnt want to put a of helper here\nImmutableMapWithNullValues.of(\"k1\", \"v1\")\nImmutableMapWithNullValues.of(\"k1\", \"v1\", \"k2\", \"v2\")", "url": "https://github.com/graphql-java/graphql-java/pull/2086#discussion_r516300988", "createdAt": "2020-11-02T22:42:01Z", "author": {"login": "bbakerman"}, "path": "src/main/java/graphql/collect/ImmutableMapWithNullValues.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package graphql.collect;\n+\n+import graphql.Internal;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+@Internal\n+public final class ImmutableMapWithNullValues<K, V> implements Map<K, V> {\n+\n+    private final Map<K, V> delegate;\n+\n+    private static final ImmutableMapWithNullValues emptyMap = copyOf(new LinkedHashMap<>());\n+\n+    private ImmutableMapWithNullValues(Map<K, V> values) {\n+        this.delegate = Collections.unmodifiableMap(new LinkedHashMap<>(values));\n+    }\n+\n+\n+    public static <K, V> ImmutableMapWithNullValues<K, V> empty() {\n+        return emptyMap;\n+    }\n+\n+    public static <K, V> ImmutableMapWithNullValues<K, V> copyOf(Map<K, V> values) {\n+        if (values instanceof ImmutableMapWithNullValues) {\n+            return (ImmutableMapWithNullValues<K, V>) values;\n+        }\n+        return new ImmutableMapWithNullValues<>(values);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fda0f999c51567ead558a4f97ba7decaba341131"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjIwNDc0OnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/schema/DataFetchingEnvironmentImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMTozMzoxOVrOHsdnCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMTozMzoxOVrOHsdnCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4NDUyMA==", "bodyText": "Maybe renamed ImmutableMapWithNullValues.empty() =to ImmutableMapWithNullValues.emptyMap() - this would be clearer in my book and also better on static import\nthis.variables = builder.variables == null ? emptyMap() : builder.variables;", "url": "https://github.com/graphql-java/graphql-java/pull/2086#discussion_r516384520", "createdAt": "2020-11-03T01:33:19Z", "author": {"login": "bbakerman"}, "path": "src/main/java/graphql/schema/DataFetchingEnvironmentImpl.java", "diffHunk": "@@ -66,7 +69,7 @@ private DataFetchingEnvironmentImpl(Builder builder) {\n         this.locale = builder.locale;\n         this.operationDefinition = builder.operationDefinition;\n         this.document = builder.document;\n-        this.variables = builder.variables == null ? Collections.emptyMap() : builder.variables;\n+        this.variables = builder.variables == null ? ImmutableMapWithNullValues.empty() : builder.variables;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fda0f999c51567ead558a4f97ba7decaba341131"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjEyMDg1OnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/execution/instrumentation/ChainedInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNzo1MTo1NFrOHwP65A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNzo1MTo1NFrOHwP65A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1NDUzMg==", "bodyText": "why the format change here?", "url": "https://github.com/graphql-java/graphql-java/pull/2086#discussion_r520354532", "createdAt": "2020-11-10T07:51:54Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/execution/instrumentation/ChainedInstrumentation.java", "diffHunk": "@@ -71,103 +71,83 @@ public InstrumentationState createState(InstrumentationCreateStateParameters par\n \n     @Override\n     public InstrumentationContext<ExecutionResult> beginExecution(final InstrumentationExecutionParameters parameters) {\n-        return new ChainedInstrumentationContext<>(instrumentations.stream()\n-                .map(instrumentation -> {\n-                    InstrumentationState state = getState(instrumentation, parameters.getInstrumentationState());\n-                    return instrumentation.beginExecution(parameters.withNewState(state));\n-                })\n-                .collect(toList()));\n+        return new ChainedInstrumentationContext<>(map(instrumentations, instrumentation -> {\n+            InstrumentationState state = getState(instrumentation, parameters.getInstrumentationState());\n+            return instrumentation.beginExecution(parameters.withNewState(state));\n+        }));\n     }\n \n     @Override\n     public InstrumentationContext<Document> beginParse(InstrumentationExecutionParameters parameters) {\n-        return new ChainedInstrumentationContext<>(instrumentations.stream()\n-                .map(instrumentation -> {\n-                    InstrumentationState state = getState(instrumentation, parameters.getInstrumentationState());\n-                    return instrumentation.beginParse(parameters.withNewState(state));\n-                })\n-                .collect(toList()));\n+        return new ChainedInstrumentationContext<>(map(instrumentations, instrumentation -> {\n+            InstrumentationState state = getState(instrumentation, parameters.getInstrumentationState());\n+            return instrumentation.beginParse(parameters.withNewState(state));\n+        }));\n     }\n \n     @Override\n     public InstrumentationContext<List<ValidationError>> beginValidation(InstrumentationValidationParameters parameters) {\n-        return new ChainedInstrumentationContext<>(instrumentations.stream()\n-                .map(instrumentation -> {\n-                    InstrumentationState state = getState(instrumentation, parameters.getInstrumentationState());\n-                    return instrumentation.beginValidation(parameters.withNewState(state));\n-                })\n-                .collect(toList()));\n+        return new ChainedInstrumentationContext<>(map(instrumentations, instrumentation -> {\n+            InstrumentationState state = getState(instrumentation, parameters.getInstrumentationState());\n+            return instrumentation.beginValidation(parameters.withNewState(state));\n+        }));\n     }\n \n     @Override\n     public InstrumentationContext<ExecutionResult> beginExecuteOperation(InstrumentationExecuteOperationParameters parameters) {\n-        return new ChainedInstrumentationContext<>(instrumentations.stream()\n-                .map(instrumentation -> {\n-                    InstrumentationState state = getState(instrumentation, parameters.getInstrumentationState());\n-                    return instrumentation.beginExecuteOperation(parameters.withNewState(state));\n-                })\n-                .collect(toList()));\n+        return new ChainedInstrumentationContext<>(map(instrumentations, instrumentation -> {\n+            InstrumentationState state = getState(instrumentation, parameters.getInstrumentationState());\n+            return instrumentation.beginExecuteOperation(parameters.withNewState(state));\n+        }));\n     }\n \n     @Override\n     public ExecutionStrategyInstrumentationContext beginExecutionStrategy(InstrumentationExecutionStrategyParameters parameters) {\n-        return new ChainedExecutionStrategyInstrumentationContext(instrumentations.stream()\n-                .map(instrumentation -> {\n-                    InstrumentationState state = getState(instrumentation, parameters.getInstrumentationState());\n-                    return instrumentation.beginExecutionStrategy(parameters.withNewState(state));\n-                })\n-                .collect(toList()));\n+        return new ChainedExecutionStrategyInstrumentationContext(map(instrumentations, instrumentation -> {\n+            InstrumentationState state = getState(instrumentation, parameters.getInstrumentationState());\n+            return instrumentation.beginExecutionStrategy(parameters.withNewState(state));\n+        }));\n     }\n \n \n     @Override\n     public InstrumentationContext<ExecutionResult> beginSubscribedFieldEvent(InstrumentationFieldParameters parameters) {\n-        return new ChainedInstrumentationContext<>(instrumentations.stream()\n-                .map(instrumentation -> {\n-                    InstrumentationState state = getState(instrumentation, parameters.getInstrumentationState());\n-                    return instrumentation.beginSubscribedFieldEvent(parameters.withNewState(state));\n-                })\n-                .collect(toList()));\n+        return new ChainedInstrumentationContext<>(map(instrumentations, instrumentation -> {\n+            InstrumentationState state = getState(instrumentation, parameters.getInstrumentationState());\n+            return instrumentation.beginSubscribedFieldEvent(parameters.withNewState(state));\n+        }));\n     }\n \n     @Override\n     public InstrumentationContext<ExecutionResult> beginField(InstrumentationFieldParameters parameters) {\n-        return new ChainedInstrumentationContext<>(instrumentations.stream()\n-                .map(instrumentation -> {\n-                    InstrumentationState state = getState(instrumentation, parameters.getInstrumentationState());\n-                    return instrumentation.beginField(parameters.withNewState(state));\n-                })\n-                .collect(toList()));\n+        return new ChainedInstrumentationContext<>(map(instrumentations, instrumentation -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03df6106bfae8bb3bb4ea7b249202333f6a5e568"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjEzNjIyOnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/schema/GraphQLSchema.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNzo1NjozOVrOHwQELQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNzo1NjozOVrOHwQELQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1NjkwOQ==", "bodyText": "doesn't nee to be a copy", "url": "https://github.com/graphql-java/graphql-java/pull/2086#discussion_r520356909", "createdAt": "2020-11-10T07:56:39Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/GraphQLSchema.java", "diffHunk": "@@ -169,7 +196,7 @@ public GraphQLObjectType getObjectType(String typeName) {\n     }\n \n     public Map<String, GraphQLNamedType> getTypeMap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03df6106bfae8bb3bb4ea7b249202333f6a5e568"}, "originalPosition": 125}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4575, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}