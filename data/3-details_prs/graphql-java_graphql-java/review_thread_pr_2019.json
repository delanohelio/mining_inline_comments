{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgwNTAwNzI2", "number": 2019, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQxMjowNDoxNlrOEgmOhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQxMjowNjoxMFrOEgmPLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNjE2MTk5OnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/schema/PropertyDataFetcherHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQxMjowNDoxNlrOHNho5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQxMjowNDoxNlrOHNho5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk0NDY3OA==", "bodyText": "I flipped the negative cache down in the order because I think the \"positive case\" is more likely - that is for any property X on a source object we have a method to get it.\nSo now if we DONT have a cached method we will try to see if its negatively cached (could not be found before) and the do the full search for it\nThis is a minor improvement because it avoids a map lookup in the case where we have methods, which I beleive is the best case to chase first", "url": "https://github.com/graphql-java/graphql-java/pull/2019#discussion_r483944678", "createdAt": "2020-09-05T12:04:16Z", "author": {"login": "bbakerman"}, "path": "src/main/java/graphql/schema/PropertyDataFetcherHelper.java", "diffHunk": "@@ -42,49 +52,52 @@ public static Object getPropertyValue(String propertyName, Object object, GraphQ\n             return ((Map<?, ?>) object).get(propertyName);\n         }\n \n-        String key = mkKey(object, propertyName);\n-        //\n-        // if we have tried all strategies before and they have all failed then we negatively cache\n-        // the key and assume that its never going to turn up.  This shortcuts the property lookup\n-        // in systems where there was a `foo` graphql property but they never provided an POJO\n-        // version of `foo`.\n-        if (isNegativelyCached(key)) {\n-            return null;\n-        }\n-        // lets try positive cache mechanisms next.  If we have seen the method or field before\n+        String cacheKey = mkKey(object, propertyName);\n+        // lets try positive cache mechanisms first.  If we have seen the method or field before\n         // then we invoke it directly without burning any cycles doing reflection.\n-        Method cachedMethod = METHOD_CACHE.get(key);\n+        CachedMethod cachedMethod = METHOD_CACHE.get(cacheKey);\n         if (cachedMethod != null) {\n-            MethodFinder methodFinder = (aClass, methodName) -> cachedMethod;\n             try {\n-                return getPropertyViaGetterMethod(object, propertyName, graphQLType, methodFinder, environment);\n+                return invokeMethod(object, environment, cachedMethod.method, cachedMethod.takesDataFetcherEnvironmentAsOnlyArgument);\n             } catch (NoSuchMethodException ignored) {\n-                assertShouldNeverHappen(\"A method cached as '%s' is no longer available??\", key);\n+                assertShouldNeverHappen(\"A method cached as '%s' is no longer available??\", cacheKey);\n             }\n         }\n-        Field cachedField = FIELD_CACHE.get(key);\n+        Field cachedField = FIELD_CACHE.get(cacheKey);\n         if (cachedField != null) {\n-            try {\n-                return getPropertyViaFieldAccess(object, propertyName);\n-            } catch (FastNoSuchMethodException ignored) {\n-                assertShouldNeverHappen(\"A field cached as '%s' is no longer available??\", key);\n-            }\n+            return invokeField(object, cachedField);\n         }\n \n+        //\n+        // if we have tried all strategies before and they have all failed then we negatively cache\n+        // the cacheKey and assume that its never going to turn up.  This shortcuts the property lookup\n+        // in systems where there was a `foo` graphql property but they never provided an POJO\n+        // version of `foo`.\n+        //\n+        // we do this second because we believe in the positive cached version will mostly prevail\n+        // but if we then look it up and negatively cache it then lest do that look up next\n+        //\n+        if (isNegativelyCached(cacheKey)) {\n+            return null;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18f7217f9f7cb5315d15ef49d8841a7279b84fa0"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNjE2MjEzOnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/schema/PropertyDataFetcherHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQxMjowNDozMVrOHNho9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQxMjowNDozMVrOHNho9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk0NDY5Mw==", "bodyText": "We now do LESS work to invoke the property get", "url": "https://github.com/graphql-java/graphql-java/pull/2019#discussion_r483944693", "createdAt": "2020-09-05T12:04:31Z", "author": {"login": "bbakerman"}, "path": "src/main/java/graphql/schema/PropertyDataFetcherHelper.java", "diffHunk": "@@ -42,49 +52,52 @@ public static Object getPropertyValue(String propertyName, Object object, GraphQ\n             return ((Map<?, ?>) object).get(propertyName);\n         }\n \n-        String key = mkKey(object, propertyName);\n-        //\n-        // if we have tried all strategies before and they have all failed then we negatively cache\n-        // the key and assume that its never going to turn up.  This shortcuts the property lookup\n-        // in systems where there was a `foo` graphql property but they never provided an POJO\n-        // version of `foo`.\n-        if (isNegativelyCached(key)) {\n-            return null;\n-        }\n-        // lets try positive cache mechanisms next.  If we have seen the method or field before\n+        String cacheKey = mkKey(object, propertyName);\n+        // lets try positive cache mechanisms first.  If we have seen the method or field before\n         // then we invoke it directly without burning any cycles doing reflection.\n-        Method cachedMethod = METHOD_CACHE.get(key);\n+        CachedMethod cachedMethod = METHOD_CACHE.get(cacheKey);\n         if (cachedMethod != null) {\n-            MethodFinder methodFinder = (aClass, methodName) -> cachedMethod;\n             try {\n-                return getPropertyViaGetterMethod(object, propertyName, graphQLType, methodFinder, environment);\n+                return invokeMethod(object, environment, cachedMethod.method, cachedMethod.takesDataFetcherEnvironmentAsOnlyArgument);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18f7217f9f7cb5315d15ef49d8841a7279b84fa0"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNjE2Mjk1OnYy", "diffSide": "LEFT", "path": "src/main/java/graphql/schema/PropertyDataFetcherHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQxMjowNToxN1rOHNhpTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQxMjowNToxN1rOHNhpTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk0NDc4Mg==", "bodyText": "previously we always did this method call - now we cache this knowledge just like the method itself", "url": "https://github.com/graphql-java/graphql-java/pull/2019#discussion_r483944782", "createdAt": "2020-09-05T12:05:17Z", "author": {"login": "bbakerman"}, "path": "src/main/java/graphql/schema/PropertyDataFetcherHelper.java", "diffHunk": "@@ -122,22 +135,10 @@ private static Object getPropertyViaGetterMethod(Object object, String propertyN\n \n     private static Object getPropertyViaGetterUsingPrefix(Object object, String propertyName, String prefix, MethodFinder methodFinder, DataFetchingEnvironment environment) throws NoSuchMethodException {\n         String getterName = prefix + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);\n-        try {\n-            Method method = methodFinder.apply(object.getClass(), getterName);\n-            if (takesDataFetcherEnvironmentAsOnlyArgument(method)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18f7217f9f7cb5315d15ef49d8841a7279b84fa0"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNjE2MzY0OnYy", "diffSide": "RIGHT", "path": "src/test/groovy/graphql/schema/PropertyDataFetcherTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQxMjowNjoxMFrOHNhppg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQxMjowNjoxMFrOHNhppg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk0NDg3MA==", "bodyText": "the tests all pass and I tweaked this one to ensure out caching works for Foo extends Bar case", "url": "https://github.com/graphql-java/graphql-java/pull/2019#discussion_r483944870", "createdAt": "2020-09-05T12:06:10Z", "author": {"login": "bbakerman"}, "path": "src/test/groovy/graphql/schema/PropertyDataFetcherTest.groovy", "diffHunk": "@@ -458,5 +458,12 @@ class PropertyDataFetcherTest extends Specification {\n \n         then:\n         result == \"bar\"\n+\n+        // repeat - should be cached\n+        when:\n+        result = propertyDataFetcher.get(dfe)\n+\n+        then:\n+        result == \"bar\"\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18f7217f9f7cb5315d15ef49d8841a7279b84fa0"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4539, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}