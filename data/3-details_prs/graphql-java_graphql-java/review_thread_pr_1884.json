{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5Mzk1NTYx", "number": 1884, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjo0MToxNFrOD9QiXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxNzowNlrOD9kfug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTYwNjY5OnYy", "diffSide": "RIGHT", "path": "src/test/groovy/graphql/InterfacesImplementingInterfacesTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjo0MToxNFrOGWpUWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjo0MToxNFrOGWpUWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5ODgxMQ==", "bodyText": "Nice one!  We should do this in other tests.\nCan you please rewrite all our tests to this pattern please! ;)", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426398811", "createdAt": "2020-05-18T06:41:14Z", "author": {"login": "bbakerman"}, "path": "src/test/groovy/graphql/InterfacesImplementingInterfacesTest.groovy", "diffHunk": "@@ -0,0 +1,861 @@\n+package graphql\n+\n+import graphql.schema.idl.SchemaGenerator\n+import graphql.schema.idl.SchemaParser\n+import graphql.schema.idl.errors.SchemaProblem\n+import spock.lang.Specification\n+\n+class InterfacesImplementingInterfacesTest extends Specification {\n+    def 'Simple interface implementing interface'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When implementing interface does not declare required field, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface type 'Resource' [@n:n] does not have a field 'id' required via interface 'Node' [@n:n]\")\n+    }\n+\n+    def 'Transitively implemented interfaces defined in implementing interface'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            interface Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+\n+    def 'Transitively implemented interfaces defined in implementing type'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            type Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When not all transitively implemented interfaces are defined in implementing interface, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            interface Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \n+            interface LargeImage implements Image & Resource {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+              large: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+        assertErrorMessage(error, \"The interface type 'LargeImage' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Image' [@n:n]\")\n+        assertErrorMessage(error, \"The interface type 'LargeImage' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When not all transitively implemented interfaces are defined in implementing type, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            type Image implements Resource {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The object type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When interface implements itself, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node implements Named & Node {\n+              id: ID!\n+              name: String\n+            }\n+            \n+            interface Named implements Node & Named {\n+              id: ID!\n+              name: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+        assertErrorMessage(error, \"The interface type 'Node' [@n:n] cannot implement itself\")\n+        assertErrorMessage(error, \"The interface type 'Named' [@n:n] cannot implement itself\")\n+    }\n+\n+    def 'When interface extension implements interface and declares required field, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID!\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension implements interface but doesn\\'t declare required field, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+              extraField: String\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID!\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface extension type 'Resource' [@n:n] does not have a field 'extraField' required via interface 'Node' [@n:n]\")\n+    }\n+\n+    def 'When object extension implements all transitive interfaces, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            type Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend type Image implements Node & Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When object extension does not implement all transitive interfaces, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            type Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend type Image implements Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The object extension type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When interface extension implements all transitive interfaces, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            interface Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend interface Image implements Node & Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension does not implement all transitive interfaces, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            interface Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend interface Image implements Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface extension type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When hierarchy results in circular reference, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface3 & Interface2 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+            \n+            interface Interface2 implements Interface1 & Interface3 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+            \n+            interface Interface3 implements Interface2 & Interface1 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+\n+        error.errors.size() == 6\n+\n+        assertErrorMessage(error, \"The interface type 'Interface1' [@n:n] cannot implement 'Interface2' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface1' [@n:n] cannot implement 'Interface3' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface2' [@n:n] cannot implement 'Interface3' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface2' [@n:n] cannot implement 'Interface1' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface3' [@n:n] cannot implement 'Interface1' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface3' [@n:n] cannot implement 'Interface2' [@n:n] as this would result in a circular reference\")\n+    }\n+\n+    def 'When interface doesn\\'t implement transitive interface declared in extension, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            interface Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface2 implements Interface3 {\n+              field3: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+\n+        assertErrorMessage(\n+                error,\n+                \"The interface type 'Interface1' [@n:n] must implement 'Interface3' [@n:n] because it is implemented by 'Interface2' [@n:n]\"\n+        )\n+    }\n+\n+    def 'When interface implements transitive interface declared in extension, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            interface Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface2 implements Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface1 implements Interface3 {\n+              field3: String\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When field required by new extension implementation is declared in original interface type, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            extend interface Interface1 implements Interface2\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When type declares interface and extension declares required field, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            extend interface Interface1 {\n+              field2: String\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface implements same interface more than once via extensions, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+           type Query {\n+              find(id: String!): Type1\n+           }\n+           \n+           type Type1 {\n+             field1: String\n+           }\n+           \n+           interface Interface2  {\n+             field20: String\n+             field21: String\n+           }\n+           \n+           extend type Type1 implements Interface2 {\n+             field20: String\n+           }\n+           \n+           extend type Type1 implements Interface2 {\n+             field21: String\n+           }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+\n+        assertErrorMessage(error, \"The object extension type 'Type1' [@n:n] can only implement 'Interface2' [@n:n] once.\")\n+    }\n+\n+    def 'When interface implements same interface more than once, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+           type Query {\n+              find(id: String!): Type1\n+           }\n+           \n+           type Type1 implements Interface2 {\n+             field1: String\n+             field20: String\n+           }\n+           \n+           interface Interface2  {\n+             field20: String\n+             field21: String\n+           }\n+           \n+           extend type Type1 implements Interface2 {\n+             field21: String\n+           }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+\n+        assertErrorMessage(error, \"The object extension type 'Type1' [@n:n] can only implement 'Interface2' [@n:n] once.\")\n+        assertErrorMessage(error, \"The object type 'Type1' [@n:n] can only implement 'Interface2' [@n:n] once.\")\n+    }\n+\n+    def 'When interface implements interface and redefines non-null field as nullable, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              url: String\n+              id: ID\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+\n+        assertErrorMessage(error, \"The interface type 'Resource' [@n:n] has tried to redefine field 'id' defined via interface 'Node' [@n:n] from 'ID!' to 'ID'\")\n+    }\n+\n+    def 'When interface extension implements interface and redefines non-null field as nullable, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+\n+        assertErrorMessage(error, \"The interface extension type 'Resource' [@n:n] has tried to redefine field 'id' defined via interface 'Node' [@n:n] from 'ID!' to 'ID'\")\n+    }\n+\n+    def 'When interface implements interface and redefines nullable field as non-null, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID\n+            }\n+\n+            interface Resource implements Node {\n+              url: String\n+              id: ID!\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension implements interface and redefines nullable field as non-null, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID!\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension implements interface and misses field arguments, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            interface InterfaceType {\n+                fieldA(arg1 : Int) : Int \n+                fieldB(arg1 : String = \"defaultVal\", arg2 : String, arg3 : Int) : String \n+            }\n+\n+            interface BaseInterface {\n+                fieldX : Int\n+            }\n+\n+            extend interface BaseInterface implements InterfaceType {\n+                fieldA : Int\n+                fieldB(arg1 : String = \"defaultValX\", arg2 : String!, arg3 : String) : String \n+            }\n+            \n+            type Query {\n+               mock: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 4\n+\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] field 'fieldA' does not have the same number of arguments as specified via interface 'InterfaceType' [@n:n]\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg1:String =\\\"defaultVal\\\"' to 'arg1:String =\\\"defaultValX\\\"\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg2:String' to 'arg2:String!\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg3:Int' to 'arg3:String\")\n+    }\n+\n+    def 'When interface implements interface and misses field arguments, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            interface InterfaceType {\n+                fieldA(arg1 : Int) : Int \n+                fieldB(arg1 : String = \"defaultVal\", arg2 : String, arg3 : Int) : String \n+            }\n+\n+            interface BaseInterface implements InterfaceType {\n+                fieldX : Int\n+                fieldA : Int\n+                fieldB(arg1 : String = \"defaultValX\", arg2 : String!, arg3 : String) : String \n+            }\n+            \n+            type Query {\n+               mock: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 4\n+\n+        assertErrorMessage(error, \"The interface type 'BaseInterface' [@n:n] field 'fieldA' does not have the same number of arguments as specified via interface 'InterfaceType' [@n:n]\")\n+        assertErrorMessage(error, \"The interface type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg1:String =\\\"defaultVal\\\"' to 'arg1:String =\\\"defaultValX\\\"\")\n+        assertErrorMessage(error, \"The interface type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg2:String' to 'arg2:String!\")\n+        assertErrorMessage(error, \"The interface type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg3:Int' to 'arg3:String\")\n+    }\n+\n+    def 'When interface implements interface via extension and misses field arguments, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            interface InterfaceType {\n+                fieldA(arg1 : Int) : Int \n+                fieldB(arg1 : String = \"defaultVal\", arg2 : String, arg3 : Int) : String \n+            }\n+\n+            interface BaseInterface {\n+                fieldX : Int\n+                fieldA : Int\n+                fieldB(arg1 : String = \"defaultValX\", arg2 : String!, arg3 : String) : String \n+            }\n+            \n+            extend interface BaseInterface implements InterfaceType\n+            \n+            type BaseType {\n+                id: ID!\n+            }\n+\n+            type Query {\n+               mock: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 4\n+\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] field 'fieldA' does not have the same number of arguments as specified via interface 'InterfaceType' [@n:n]\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg1:String =\\\"defaultVal\\\"' to 'arg1:String =\\\"defaultValX\\\"\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg2:String' to 'arg2:String!\")\n+        assertErrorMessage(error, \"The interface extension type 'BaseInterface' [@n:n] has tried to redefine field 'fieldB' arguments defined via interface 'InterfaceType' [@n:n] from 'arg3:Int' to 'arg3:String\")\n+    }\n+\n+    def assertErrorMessage(SchemaProblem error, expectedMessage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 843}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTYwOTE0OnYy", "diffSide": "LEFT", "path": "src/test/groovy/graphql/schema/idl/SchemaGeneratorTest.groovy", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjo0MjoxMVrOGWpVyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwODoyOTo0NVrOGWstnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5OTE3OA==", "bodyText": "Why does this need to be removed?  Is it no longer valid or just not longer relevant and tested in the other places", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426399178", "createdAt": "2020-05-18T06:42:11Z", "author": {"login": "bbakerman"}, "path": "src/test/groovy/graphql/schema/idl/SchemaGeneratorTest.groovy", "diffHunk": "@@ -542,13 +542,6 @@ class SchemaGeneratorTest extends Specification {\n             extend type BaseType {\n                extraField5 : Boolean!\n             }\n-            #\n-            # if we repeat a definition, that's ok as long as its the same types as before\n-            # they will be de-duped since the effect is the same\n-            #\n-            extend type BaseType implements Interface1 {\n-               extraField1 : String\n-            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ1NDQyOQ==", "bodyText": "This is actually invalid now.\nI've added a new validation rule which prevents extensions from implementing an interface which has already been implemented from a base type, or other extensions for the same type.\nThis will make the graphql-java validation more aligned with graphql-js", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426454429", "createdAt": "2020-05-18T08:29:45Z", "author": {"login": "felipe-gdr"}, "path": "src/test/groovy/graphql/schema/idl/SchemaGeneratorTest.groovy", "diffHunk": "@@ -542,13 +542,6 @@ class SchemaGeneratorTest extends Specification {\n             extend type BaseType {\n                extraField5 : Boolean!\n             }\n-            #\n-            # if we repeat a definition, that's ok as long as its the same types as before\n-            # they will be de-duped since the effect is the same\n-            #\n-            extend type BaseType implements Interface1 {\n-               extraField1 : String\n-            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5OTE3OA=="}, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTYxMTIyOnYy", "diffSide": "RIGHT", "path": "src/test/groovy/graphql/InterfacesImplementingInterfacesTest.groovy", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjo0MzowMVrOGWpW-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjo0MzowMVrOGWpW-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5OTQ4Mw==", "bodyText": "My comment below is covered by this test", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426399483", "createdAt": "2020-05-18T06:43:01Z", "author": {"login": "bbakerman"}, "path": "src/test/groovy/graphql/InterfacesImplementingInterfacesTest.groovy", "diffHunk": "@@ -0,0 +1,861 @@\n+package graphql\n+\n+import graphql.schema.idl.SchemaGenerator\n+import graphql.schema.idl.SchemaParser\n+import graphql.schema.idl.errors.SchemaProblem\n+import spock.lang.Specification\n+\n+class InterfacesImplementingInterfacesTest extends Specification {\n+    def 'Simple interface implementing interface'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When implementing interface does not declare required field, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface type 'Resource' [@n:n] does not have a field 'id' required via interface 'Node' [@n:n]\")\n+    }\n+\n+    def 'Transitively implemented interfaces defined in implementing interface'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            interface Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+\n+    def 'Transitively implemented interfaces defined in implementing type'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            type Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When not all transitively implemented interfaces are defined in implementing interface, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            interface Image implements Resource & Node {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \n+            interface LargeImage implements Image & Resource {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+              large: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+        assertErrorMessage(error, \"The interface type 'LargeImage' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Image' [@n:n]\")\n+        assertErrorMessage(error, \"The interface type 'LargeImage' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When not all transitively implemented interfaces are defined in implementing type, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+            \n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+\n+            type Image implements Resource {\n+              id: ID!\n+              url: String\n+              thumbnail: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The object type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When interface implements itself, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node implements Named & Node {\n+              id: ID!\n+              name: String\n+            }\n+            \n+            interface Named implements Node & Named {\n+              id: ID!\n+              name: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 2\n+        assertErrorMessage(error, \"The interface type 'Node' [@n:n] cannot implement itself\")\n+        assertErrorMessage(error, \"The interface type 'Named' [@n:n] cannot implement itself\")\n+    }\n+\n+    def 'When interface extension implements interface and declares required field, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID!\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension implements interface but doesn\\'t declare required field, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+              extraField: String\n+            }\n+\n+            interface Resource {\n+              url: String\n+            }\n+            \n+            extend interface Resource implements Node {\n+                id: ID!\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface extension type 'Resource' [@n:n] does not have a field 'extraField' required via interface 'Node' [@n:n]\")\n+    }\n+\n+    def 'When object extension implements all transitive interfaces, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            type Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend type Image implements Node & Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When object extension does not implement all transitive interfaces, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            type Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend type Image implements Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The object extension type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When interface extension implements all transitive interfaces, then parsing is successful'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            interface Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend interface Image implements Node & Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface extension does not implement all transitive interfaces, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Node\n+            }\n+            \n+            interface Node {\n+              id: ID!\n+            }\n+\n+            interface Resource implements Node {\n+              id: ID!\n+              url: String\n+            }\n+            \n+            interface Image {\n+                thumbnail: String!\n+            }\n+            \n+            extend interface Image implements Resource {\n+                id: ID!\n+                url: String\n+            }\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+        assertErrorMessage(error, \"The interface extension type 'Image' [@n:n] must implement 'Node' [@n:n] because it is implemented by 'Resource' [@n:n]\")\n+    }\n+\n+    def 'When hierarchy results in circular reference, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface3 & Interface2 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+            \n+            interface Interface2 implements Interface1 & Interface3 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+            \n+            interface Interface3 implements Interface2 & Interface1 {\n+              field1: String\n+              field2: String\n+              field3: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+\n+        error.errors.size() == 6\n+\n+        assertErrorMessage(error, \"The interface type 'Interface1' [@n:n] cannot implement 'Interface2' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface1' [@n:n] cannot implement 'Interface3' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface2' [@n:n] cannot implement 'Interface3' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface2' [@n:n] cannot implement 'Interface1' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface3' [@n:n] cannot implement 'Interface1' [@n:n] as this would result in a circular reference\")\n+        assertErrorMessage(error, \"The interface type 'Interface3' [@n:n] cannot implement 'Interface2' [@n:n] as this would result in a circular reference\")\n+    }\n+\n+    def 'When interface doesn\\'t implement transitive interface declared in extension, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            interface Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface2 implements Interface3 {\n+              field3: String\n+            }\n+\n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        def error = thrown(SchemaProblem)\n+        error.errors.size() == 1\n+\n+        assertErrorMessage(\n+                error,\n+                \"The interface type 'Interface1' [@n:n] must implement 'Interface3' [@n:n] because it is implemented by 'Interface2' [@n:n]\"\n+        )\n+    }\n+\n+    def 'When interface implements transitive interface declared in extension, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            interface Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface2 implements Interface3 {\n+              field3: String\n+            }\n+            \n+            extend interface Interface1 implements Interface3 {\n+              field3: String\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When field required by new extension implementation is declared in original interface type, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 {\n+              field1: String\n+              field2: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            extend interface Interface1 implements Interface2\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When type declares interface and extension declares required field, then parsing succeeds'() {\n+        when:\n+        def schema = \"\"\"\n+            type Query {\n+               find(id: String!): Interface1\n+            }\n+            \n+            interface Interface1 implements Interface2 {\n+              field1: String\n+            }\n+            \n+            interface Interface2  {\n+              field2: String\n+            }\n+            \n+            extend interface Interface1 {\n+              field2: String\n+            }\n+            \n+            \"\"\"\n+\n+        parseSchema(schema)\n+\n+        then:\n+        noExceptionThrown()\n+    }\n+\n+    def 'When interface implements same interface more than once via extensions, then parsing fails'() {\n+        when:\n+        def schema = \"\"\"\n+           type Query {\n+              find(id: String!): Type1\n+           }\n+           \n+           type Type1 {\n+             field1: String\n+           }\n+           \n+           interface Interface2  {\n+             field20: String\n+             field21: String\n+           }\n+           \n+           extend type Type1 implements Interface2 {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 584}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODg2MDkwOnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/introspection/IntrospectionResultToSchema.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxMDoyN1rOGXJHfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxMDoyN1rOGXJHfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkxOTgwNw==", "bodyText": "please use our map static function instead of streams directly", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426919807", "createdAt": "2020-05-18T22:10:27Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/introspection/IntrospectionResultToSchema.java", "diffHunk": "@@ -185,6 +184,13 @@ InterfaceTypeDefinition createInterface(Map<String, Object> input) {\n \n         InterfaceTypeDefinition.Builder interfaceTypeDefinition = InterfaceTypeDefinition.newInterfaceTypeDefinition().name((String) input.get(\"name\"));\n         interfaceTypeDefinition.description(toDescription(input));\n+        if (input.containsKey(\"interfaces\") && input.get(\"interfaces\") != null) {\n+            interfaceTypeDefinition.implementz(\n+                    ((List<Map<String, Object>>) input.get(\"interfaces\")).stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODg2NTgzOnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/language/ImplementingTypeDefinition.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxMjoyNlrOGXJKcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwODoyMDoyNVrOGXVHtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMDU2MQ==", "bodyText": "why the recursive type definition here?", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426920561", "createdAt": "2020-05-18T22:12:26Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/language/ImplementingTypeDefinition.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package graphql.language;\n+\n+\n+import graphql.PublicApi;\n+\n+import java.util.List;\n+\n+/**\n+ * A {@link TypeDefinition} that might implement interfaces\n+ *\n+ * @param <T>\n+ */\n+@PublicApi\n+public interface ImplementingTypeDefinition<T extends ImplementingTypeDefinition> extends TypeDefinition<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzExNjQ3MA==", "bodyText": "Yep, not needed. <T extends TypeDefinition> should be enough.", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r427116470", "createdAt": "2020-05-19T08:20:25Z", "author": {"login": "felipe-gdr"}, "path": "src/main/java/graphql/language/ImplementingTypeDefinition.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package graphql.language;\n+\n+\n+import graphql.PublicApi;\n+\n+import java.util.List;\n+\n+/**\n+ * A {@link TypeDefinition} that might implement interfaces\n+ *\n+ * @param <T>\n+ */\n+@PublicApi\n+public interface ImplementingTypeDefinition<T extends ImplementingTypeDefinition> extends TypeDefinition<T> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMDU2MQ=="}, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODg2NjgzOnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/language/ImplementingTypeDefinition.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxMjo1MFrOGXJLEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxMjo1MFrOGXJLEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMDcyMA==", "bodyText": "not great name, but not in scope to change it here.", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426920720", "createdAt": "2020-05-18T22:12:50Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/language/ImplementingTypeDefinition.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package graphql.language;\n+\n+\n+import graphql.PublicApi;\n+\n+import java.util.List;\n+\n+/**\n+ * A {@link TypeDefinition} that might implement interfaces\n+ *\n+ * @param <T>\n+ */\n+@PublicApi\n+public interface ImplementingTypeDefinition<T extends ImplementingTypeDefinition> extends TypeDefinition<T> {\n+\n+    List<Type> getImplements();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODg3MDk2OnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/parser/GraphqlAntlrToLanguage.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxNDo0MlrOGXJNvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxNDo0MlrOGXJNvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMTQwNg==", "bodyText": "please use our map util function.", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426921406", "createdAt": "2020-05-18T22:14:42Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/parser/GraphqlAntlrToLanguage.java", "diffHunk": "@@ -882,4 +878,14 @@ protected SourceLocation getSourceLocation(ParserRuleContext parserRuleContext)\n         return comments;\n     }\n \n+\n+    private List<Type> getImplementz(GraphqlParser.ImplementsInterfacesContext implementsInterfacesContext) {\n+        List<Type> implementz = new ArrayList<>();\n+        while (implementsInterfacesContext != null) {\n+            List<TypeName> typeNames = implementsInterfacesContext.typeName().stream().map(this::createTypeName).collect(toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODg3Mzc3OnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/schema/idl/SchemaTypeChecker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxNTo0N1rOGXJPWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwODoyOTowM1rOGXVd2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMTgxOA==", "bodyText": "please use the util function", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426921818", "createdAt": "2020-05-18T22:15:47Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/idl/SchemaTypeChecker.java", "diffHunk": "@@ -90,7 +85,7 @@\n \n     private void checkForMissingTypes(List<GraphQLError> errors, TypeDefinitionRegistry typeRegistry) {\n         // type extensions\n-        List<ObjectTypeExtensionDefinition> typeExtensions = typeRegistry.objectTypeExtensions().values().stream().flatMap(Collection::stream).collect(Collectors.toList());\n+        List<ObjectTypeExtensionDefinition> typeExtensions = typeRegistry.objectTypeExtensions().values().stream().flatMap(Collection::stream).collect(toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEyMjEzNw==", "bodyText": "FpKit#flatList applies to List<List<>> and we have a Collection<List<>> here.\nShould we create a more generic flatten method in FpKit?", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r427122137", "createdAt": "2020-05-19T08:29:03Z", "author": {"login": "felipe-gdr"}, "path": "src/main/java/graphql/schema/idl/SchemaTypeChecker.java", "diffHunk": "@@ -90,7 +85,7 @@\n \n     private void checkForMissingTypes(List<GraphQLError> errors, TypeDefinitionRegistry typeRegistry) {\n         // type extensions\n-        List<ObjectTypeExtensionDefinition> typeExtensions = typeRegistry.objectTypeExtensions().values().stream().flatMap(Collection::stream).collect(Collectors.toList());\n+        List<ObjectTypeExtensionDefinition> typeExtensions = typeRegistry.objectTypeExtensions().values().stream().flatMap(Collection::stream).collect(toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMTgxOA=="}, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODg3Njc0OnYy", "diffSide": "RIGHT", "path": "src/main/java/graphql/schema/idl/TypeDefinitionRegistry.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoxNzowNlrOGXJRLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwODozNDoxN1rOGXVrRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMjI4NQ==", "bodyText": "this is a breaking change. Should we consider adding another one and keeping this one for use object implementations?", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r426922285", "createdAt": "2020-05-18T22:17:06Z", "author": {"login": "andimarek"}, "path": "src/main/java/graphql/schema/idl/TypeDefinitionRegistry.java", "diffHunk": "@@ -453,13 +454,13 @@ public boolean isObjectType(Type type) {\n     }\n \n     /**\n-     * Returns the list of object types that implement the given interface type\n+     * Returns the list of object and interface types that implement the given interface type\n      *\n      * @param targetInterface the target to search for\n      * @return the list of object types that implement the given interface type\n      */\n-    public List<ObjectTypeDefinition> getImplementationsOf(InterfaceTypeDefinition targetInterface) {\n-        List<ObjectTypeDefinition> objectTypeDefinitions = getTypes(ObjectTypeDefinition.class);\n+    public List<ImplementingTypeDefinition> getImplementationsOf(InterfaceTypeDefinition targetInterface) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEyNTU3Mg==", "bodyText": "Yep, just noticed that this is public API. I'll create a new method.", "url": "https://github.com/graphql-java/graphql-java/pull/1884#discussion_r427125572", "createdAt": "2020-05-19T08:34:17Z", "author": {"login": "felipe-gdr"}, "path": "src/main/java/graphql/schema/idl/TypeDefinitionRegistry.java", "diffHunk": "@@ -453,13 +454,13 @@ public boolean isObjectType(Type type) {\n     }\n \n     /**\n-     * Returns the list of object types that implement the given interface type\n+     * Returns the list of object and interface types that implement the given interface type\n      *\n      * @param targetInterface the target to search for\n      * @return the list of object types that implement the given interface type\n      */\n-    public List<ObjectTypeDefinition> getImplementationsOf(InterfaceTypeDefinition targetInterface) {\n-        List<ObjectTypeDefinition> objectTypeDefinitions = getTypes(ObjectTypeDefinition.class);\n+    public List<ImplementingTypeDefinition> getImplementationsOf(InterfaceTypeDefinition targetInterface) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyMjI4NQ=="}, "originalCommit": {"oid": "4015f0d1ef7403a8ca96add2ac75c42aa98398ae"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4612, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}