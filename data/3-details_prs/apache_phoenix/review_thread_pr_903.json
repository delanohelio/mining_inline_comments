{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1MTk5ODgz", "number": 903, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNDowNToyN1rOEvHxTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNDowNToyN1rOEvHxTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3ODQ1ODM2OnYy", "diffSide": "RIGHT", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewMetadataIT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNDowNToyN1rOHj7E4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxNzo1NjoxOVrOHka6Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzQzMDExNA==", "bodyText": "Wondering whether you want to add a test -\nthat validates that the order of dropping does not matter, in other words dropping level1view2 first.\nAlso, wondering whether adding multiple global views(level1 views for a parent) would make for a more robust test suite?", "url": "https://github.com/apache/phoenix/pull/903#discussion_r507430114", "createdAt": "2020-10-19T04:05:27Z", "author": {"login": "jpisaac"}, "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewMetadataIT.java", "diffHunk": "@@ -294,7 +321,246 @@ public void testRecreateDroppedTableWithChildViews() throws Exception {\n         }\n     }\n \n-    private void runDropChildViewsTask() {\n+    @Test\n+    public void testAlterTableIsResilientToOrphanLinks() throws SQLException {\n+        final String parent1TableName = generateUniqueName();\n+        final String parent2TableName = generateUniqueName();\n+        final String viewName = \"V_\" + generateUniqueName();\n+        // Note that this column name is the same as the new column on the child view\n+        final String alterTableDDL = \"ALTER TABLE %s ADD NEW_COL1 VARCHAR\";\n+        createOrphanLink(SCHEMA1, parent1TableName, parent2TableName, SCHEMA2, viewName);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement()) {\n+            // Should not fail since this table is unrelated to the view in spite of\n+            // the orphan parent->child link\n+            stmt.execute(String.format(alterTableDDL,\n+                    SchemaUtil.getTableName(SCHEMA1, parent2TableName)));\n+            try {\n+                stmt.execute(String.format(alterTableDDL,\n+                        SchemaUtil.getTableName(SCHEMA1, parent1TableName)));\n+                fail(\"Adding column should be disallowed since there is a conflicting column type \"\n+                        + \"on the child view\");\n+            } catch (SQLException sqlEx) {\n+                assertEquals(CANNOT_MUTATE_TABLE.getErrorCode(), sqlEx.getErrorCode());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testDropTableIsResilientToOrphanLinks() throws SQLException {\n+        final String parent1TableName = generateUniqueName();\n+        final String parent2TableName = generateUniqueName();\n+        final String viewName = \"V_\" + generateUniqueName();\n+        final String dropTableNoCascadeDDL = \"DROP TABLE %s \";\n+        createOrphanLink(SCHEMA1, parent1TableName, parent2TableName, SCHEMA2, viewName);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement()) {\n+            // Should not fail since this table is unrelated to the view in spite of\n+            // the orphan parent->child link\n+            stmt.execute(String.format(dropTableNoCascadeDDL,\n+                    SchemaUtil.getTableName(SCHEMA1, parent2TableName)));\n+            try {\n+                stmt.execute(String.format(dropTableNoCascadeDDL,\n+                        SchemaUtil.getTableName(SCHEMA1, parent1TableName)));\n+                fail(\"Drop table without cascade should fail since there is a child view\");\n+            } catch (SQLException sqlEx) {\n+                assertEquals(CANNOT_MUTATE_TABLE.getErrorCode(), sqlEx.getErrorCode());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create a view hierarchy:\n+     *               parent1           parent2\n+     *                  |                 |\n+     *              level1view1      level1view2\n+     *                  |                 |\n+     *           t001.level2view1  t001.level2view2\n+     *                                    |\n+     *                             t001.level3view1\n+     *\n+     * We induce orphan links by recreating the same view names on top of different parents\n+     */\n+    @Test\n+    public void testViewHierarchyWithOrphanLinks() throws Exception {\n+        final List<TableInfo> expectedLegitChildViewsListForParent1 = new ArrayList<>();\n+        final List<TableInfo> expectedLegitChildViewsListForParent2 = new ArrayList<>();\n+        final String tenantId = \"t001\";\n+        final String parent1TableName = \"P1_\" + generateUniqueName();\n+        final String parent2TableName = \"P2_\" + generateUniqueName();\n+        final String level1ViewName1 = \"L1_V_1_\" + generateUniqueName();\n+        final String level1ViewName2 = \"L1_V_2_\" + generateUniqueName();\n+        final String level2ViewName1 = \"L2_V_1_\" + generateUniqueName();\n+        final String level2ViewName2 = \"L2_V_2_\" + generateUniqueName();\n+        final String level3ViewName1 = \"L3_V_1_\" + generateUniqueName();\n+        createOrphanLink(BASE_TABLE_SCHEMA, parent1TableName, parent2TableName,\n+                CHILD_VIEW_LEVEL_1_SCHEMA, level1ViewName1);\n+        expectedLegitChildViewsListForParent1.add(new TableInfo(\n+                null, CHILD_VIEW_LEVEL_1_SCHEMA.getBytes(), level1ViewName1.getBytes()));\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            // Create a legit view on top of parent2\n+            conn.createStatement().execute(String.format(CREATE_CHILD_VIEW_LEVEL_1_DDL,\n+                    CHILD_VIEW_LEVEL_1_SCHEMA, level1ViewName2,\n+                    BASE_TABLE_SCHEMA, parent2TableName));\n+            expectedLegitChildViewsListForParent2.add(new TableInfo(\n+                    null, CHILD_VIEW_LEVEL_1_SCHEMA.getBytes(), level1ViewName2.getBytes()));\n+        }\n+        Properties props = new Properties();\n+        props.put(TENANT_ID_ATTRIB, tenantId);\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(String.format(CREATE_CHILD_VIEW_LEVEL_2_DDL,\n+                    CHILD_VIEW_LEVEL_2_SCHEMA, level2ViewName1,\n+                    CHILD_VIEW_LEVEL_1_SCHEMA, level1ViewName1));\n+            expectedLegitChildViewsListForParent1.add(new TableInfo(tenantId.getBytes(),\n+                    CHILD_VIEW_LEVEL_2_SCHEMA.getBytes(), level2ViewName1.getBytes()));\n+\n+            conn.createStatement().execute(String.format(CREATE_CHILD_VIEW_LEVEL_2_DDL,\n+                    CHILD_VIEW_LEVEL_2_SCHEMA, level2ViewName2,\n+                    CHILD_VIEW_LEVEL_1_SCHEMA, level1ViewName2));\n+            expectedLegitChildViewsListForParent2.add(new TableInfo(tenantId.getBytes(),\n+                    CHILD_VIEW_LEVEL_2_SCHEMA.getBytes(), level2ViewName2.getBytes()));\n+\n+            // Try to recreate the same view on a different global view to create an orphan link\n+            try {\n+                conn.createStatement().execute(String.format(CREATE_CHILD_VIEW_LEVEL_2_DDL,\n+                        CHILD_VIEW_LEVEL_2_SCHEMA, level2ViewName2,\n+                        CHILD_VIEW_LEVEL_1_SCHEMA, level1ViewName1));\n+                fail(\"Creating the same view again should have failed\");\n+            } catch (TableAlreadyExistsException ignored) {\n+                // expected\n+            }\n+            // Create a third level view\n+            conn.createStatement().execute(String.format(CREATE_CHILD_VIEW_LEVEL_3_DDL,\n+                    CHILD_VIEW_LEVEL_3_SCHEMA, level3ViewName1,\n+                    CHILD_VIEW_LEVEL_2_SCHEMA, level2ViewName2));\n+            expectedLegitChildViewsListForParent2.add(new TableInfo(tenantId.getBytes(),\n+                    CHILD_VIEW_LEVEL_3_SCHEMA.getBytes(), level3ViewName1.getBytes()));\n+        }\n+        /*\n+            After this setup, SYSTEM.CHILD_LINK parent->child linking rows will look like this:\n+            parent1->level1view1\n+            parent2->level1view1 (orphan)\n+            parent2->level1view2\n+\n+            level1view1->t001.level2view1\n+            level1view1->t001.level2view2 (orphan)\n+            level1view2->t001.level2view2\n+\n+            t001.level2view2->t001.level3view1\n+         */\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            ConnectionQueryServices cqs = conn.unwrap(PhoenixConnection.class).getQueryServices();\n+            try (Table childLinkTable = cqs.getTable(SchemaUtil.getPhysicalName(\n+                    SYSTEM_LINK_HBASE_TABLE_NAME.toBytes(), cqs.getProps()).getName())) {\n+                Pair<List<PTable>, List<TableInfo>> allDescendants =\n+                        ViewUtil.findAllDescendantViews(childLinkTable, cqs.getConfiguration(),\n+                                EMPTY_BYTE_ARRAY, BASE_TABLE_SCHEMA.getBytes(),\n+                                parent1TableName.getBytes(), HConstants.LATEST_TIMESTAMP, false);\n+                List<PTable> legitChildViews = allDescendants.getFirst();\n+                List<TableInfo> orphanViews = allDescendants.getSecond();\n+                // All of the orphan links are legit views of the other parent so they don't count\n+                // as orphan views for this parent\n+                assertTrue(orphanViews.isEmpty());\n+                assertLegitChildViews(expectedLegitChildViewsListForParent1, legitChildViews);\n+\n+                allDescendants = ViewUtil.findAllDescendantViews(childLinkTable,\n+                        cqs.getConfiguration(), EMPTY_BYTE_ARRAY, BASE_TABLE_SCHEMA.getBytes(),\n+                        parent2TableName.getBytes(), HConstants.LATEST_TIMESTAMP, false);\n+                legitChildViews = allDescendants.getFirst();\n+                orphanViews = allDescendants.getSecond();\n+                // All of the orphan links are legit views of the other parent so they don't count\n+                // as orphan views for this parent\n+                assertTrue(orphanViews.isEmpty());\n+                assertLegitChildViews(expectedLegitChildViewsListForParent2, legitChildViews);\n+\n+                // Drop the legitimate level 1 view that was on top of parent1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d698b728b00ce6b3d6f461944c53727fac795fbc"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk1MTY5NA==", "bodyText": "Sure, I can add more global views.", "url": "https://github.com/apache/phoenix/pull/903#discussion_r507951694", "createdAt": "2020-10-19T17:56:19Z", "author": {"login": "ChinmaySKulkarni"}, "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/ViewMetadataIT.java", "diffHunk": "@@ -294,7 +321,246 @@ public void testRecreateDroppedTableWithChildViews() throws Exception {\n         }\n     }\n \n-    private void runDropChildViewsTask() {\n+    @Test\n+    public void testAlterTableIsResilientToOrphanLinks() throws SQLException {\n+        final String parent1TableName = generateUniqueName();\n+        final String parent2TableName = generateUniqueName();\n+        final String viewName = \"V_\" + generateUniqueName();\n+        // Note that this column name is the same as the new column on the child view\n+        final String alterTableDDL = \"ALTER TABLE %s ADD NEW_COL1 VARCHAR\";\n+        createOrphanLink(SCHEMA1, parent1TableName, parent2TableName, SCHEMA2, viewName);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement()) {\n+            // Should not fail since this table is unrelated to the view in spite of\n+            // the orphan parent->child link\n+            stmt.execute(String.format(alterTableDDL,\n+                    SchemaUtil.getTableName(SCHEMA1, parent2TableName)));\n+            try {\n+                stmt.execute(String.format(alterTableDDL,\n+                        SchemaUtil.getTableName(SCHEMA1, parent1TableName)));\n+                fail(\"Adding column should be disallowed since there is a conflicting column type \"\n+                        + \"on the child view\");\n+            } catch (SQLException sqlEx) {\n+                assertEquals(CANNOT_MUTATE_TABLE.getErrorCode(), sqlEx.getErrorCode());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testDropTableIsResilientToOrphanLinks() throws SQLException {\n+        final String parent1TableName = generateUniqueName();\n+        final String parent2TableName = generateUniqueName();\n+        final String viewName = \"V_\" + generateUniqueName();\n+        final String dropTableNoCascadeDDL = \"DROP TABLE %s \";\n+        createOrphanLink(SCHEMA1, parent1TableName, parent2TableName, SCHEMA2, viewName);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement()) {\n+            // Should not fail since this table is unrelated to the view in spite of\n+            // the orphan parent->child link\n+            stmt.execute(String.format(dropTableNoCascadeDDL,\n+                    SchemaUtil.getTableName(SCHEMA1, parent2TableName)));\n+            try {\n+                stmt.execute(String.format(dropTableNoCascadeDDL,\n+                        SchemaUtil.getTableName(SCHEMA1, parent1TableName)));\n+                fail(\"Drop table without cascade should fail since there is a child view\");\n+            } catch (SQLException sqlEx) {\n+                assertEquals(CANNOT_MUTATE_TABLE.getErrorCode(), sqlEx.getErrorCode());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create a view hierarchy:\n+     *               parent1           parent2\n+     *                  |                 |\n+     *              level1view1      level1view2\n+     *                  |                 |\n+     *           t001.level2view1  t001.level2view2\n+     *                                    |\n+     *                             t001.level3view1\n+     *\n+     * We induce orphan links by recreating the same view names on top of different parents\n+     */\n+    @Test\n+    public void testViewHierarchyWithOrphanLinks() throws Exception {\n+        final List<TableInfo> expectedLegitChildViewsListForParent1 = new ArrayList<>();\n+        final List<TableInfo> expectedLegitChildViewsListForParent2 = new ArrayList<>();\n+        final String tenantId = \"t001\";\n+        final String parent1TableName = \"P1_\" + generateUniqueName();\n+        final String parent2TableName = \"P2_\" + generateUniqueName();\n+        final String level1ViewName1 = \"L1_V_1_\" + generateUniqueName();\n+        final String level1ViewName2 = \"L1_V_2_\" + generateUniqueName();\n+        final String level2ViewName1 = \"L2_V_1_\" + generateUniqueName();\n+        final String level2ViewName2 = \"L2_V_2_\" + generateUniqueName();\n+        final String level3ViewName1 = \"L3_V_1_\" + generateUniqueName();\n+        createOrphanLink(BASE_TABLE_SCHEMA, parent1TableName, parent2TableName,\n+                CHILD_VIEW_LEVEL_1_SCHEMA, level1ViewName1);\n+        expectedLegitChildViewsListForParent1.add(new TableInfo(\n+                null, CHILD_VIEW_LEVEL_1_SCHEMA.getBytes(), level1ViewName1.getBytes()));\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            // Create a legit view on top of parent2\n+            conn.createStatement().execute(String.format(CREATE_CHILD_VIEW_LEVEL_1_DDL,\n+                    CHILD_VIEW_LEVEL_1_SCHEMA, level1ViewName2,\n+                    BASE_TABLE_SCHEMA, parent2TableName));\n+            expectedLegitChildViewsListForParent2.add(new TableInfo(\n+                    null, CHILD_VIEW_LEVEL_1_SCHEMA.getBytes(), level1ViewName2.getBytes()));\n+        }\n+        Properties props = new Properties();\n+        props.put(TENANT_ID_ATTRIB, tenantId);\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(String.format(CREATE_CHILD_VIEW_LEVEL_2_DDL,\n+                    CHILD_VIEW_LEVEL_2_SCHEMA, level2ViewName1,\n+                    CHILD_VIEW_LEVEL_1_SCHEMA, level1ViewName1));\n+            expectedLegitChildViewsListForParent1.add(new TableInfo(tenantId.getBytes(),\n+                    CHILD_VIEW_LEVEL_2_SCHEMA.getBytes(), level2ViewName1.getBytes()));\n+\n+            conn.createStatement().execute(String.format(CREATE_CHILD_VIEW_LEVEL_2_DDL,\n+                    CHILD_VIEW_LEVEL_2_SCHEMA, level2ViewName2,\n+                    CHILD_VIEW_LEVEL_1_SCHEMA, level1ViewName2));\n+            expectedLegitChildViewsListForParent2.add(new TableInfo(tenantId.getBytes(),\n+                    CHILD_VIEW_LEVEL_2_SCHEMA.getBytes(), level2ViewName2.getBytes()));\n+\n+            // Try to recreate the same view on a different global view to create an orphan link\n+            try {\n+                conn.createStatement().execute(String.format(CREATE_CHILD_VIEW_LEVEL_2_DDL,\n+                        CHILD_VIEW_LEVEL_2_SCHEMA, level2ViewName2,\n+                        CHILD_VIEW_LEVEL_1_SCHEMA, level1ViewName1));\n+                fail(\"Creating the same view again should have failed\");\n+            } catch (TableAlreadyExistsException ignored) {\n+                // expected\n+            }\n+            // Create a third level view\n+            conn.createStatement().execute(String.format(CREATE_CHILD_VIEW_LEVEL_3_DDL,\n+                    CHILD_VIEW_LEVEL_3_SCHEMA, level3ViewName1,\n+                    CHILD_VIEW_LEVEL_2_SCHEMA, level2ViewName2));\n+            expectedLegitChildViewsListForParent2.add(new TableInfo(tenantId.getBytes(),\n+                    CHILD_VIEW_LEVEL_3_SCHEMA.getBytes(), level3ViewName1.getBytes()));\n+        }\n+        /*\n+            After this setup, SYSTEM.CHILD_LINK parent->child linking rows will look like this:\n+            parent1->level1view1\n+            parent2->level1view1 (orphan)\n+            parent2->level1view2\n+\n+            level1view1->t001.level2view1\n+            level1view1->t001.level2view2 (orphan)\n+            level1view2->t001.level2view2\n+\n+            t001.level2view2->t001.level3view1\n+         */\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            ConnectionQueryServices cqs = conn.unwrap(PhoenixConnection.class).getQueryServices();\n+            try (Table childLinkTable = cqs.getTable(SchemaUtil.getPhysicalName(\n+                    SYSTEM_LINK_HBASE_TABLE_NAME.toBytes(), cqs.getProps()).getName())) {\n+                Pair<List<PTable>, List<TableInfo>> allDescendants =\n+                        ViewUtil.findAllDescendantViews(childLinkTable, cqs.getConfiguration(),\n+                                EMPTY_BYTE_ARRAY, BASE_TABLE_SCHEMA.getBytes(),\n+                                parent1TableName.getBytes(), HConstants.LATEST_TIMESTAMP, false);\n+                List<PTable> legitChildViews = allDescendants.getFirst();\n+                List<TableInfo> orphanViews = allDescendants.getSecond();\n+                // All of the orphan links are legit views of the other parent so they don't count\n+                // as orphan views for this parent\n+                assertTrue(orphanViews.isEmpty());\n+                assertLegitChildViews(expectedLegitChildViewsListForParent1, legitChildViews);\n+\n+                allDescendants = ViewUtil.findAllDescendantViews(childLinkTable,\n+                        cqs.getConfiguration(), EMPTY_BYTE_ARRAY, BASE_TABLE_SCHEMA.getBytes(),\n+                        parent2TableName.getBytes(), HConstants.LATEST_TIMESTAMP, false);\n+                legitChildViews = allDescendants.getFirst();\n+                orphanViews = allDescendants.getSecond();\n+                // All of the orphan links are legit views of the other parent so they don't count\n+                // as orphan views for this parent\n+                assertTrue(orphanViews.isEmpty());\n+                assertLegitChildViews(expectedLegitChildViewsListForParent2, legitChildViews);\n+\n+                // Drop the legitimate level 1 view that was on top of parent1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzQzMDExNA=="}, "originalCommit": {"oid": "d698b728b00ce6b3d6f461944c53727fac795fbc"}, "originalPosition": 243}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4604, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}