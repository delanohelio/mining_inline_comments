{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0MTM0Mjkw", "number": 789, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzoyODowOFrOEA-kMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMjowMToyMlrOEEHU-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDYwNTMxOnYy", "diffSide": "RIGHT", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionObserver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzoyODowOFrOGcl0Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzoyODowOFrOGcl0Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMjg4Mg==", "bodyText": "More comments please about why we're scanning through everything twice. I figured it out (grabbing the keys that existed at minTime, then doing a skip scan of just those keys), but I had to stare at it for a few min. :-)", "url": "https://github.com/apache/phoenix/pull/789#discussion_r432632882", "createdAt": "2020-05-29T17:28:08Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionObserver.java", "diffHunk": "@@ -1081,11 +1086,39 @@ private RegionScanner rebuildIndices(final RegionScanner innerScanner, final Reg\n             rawScan.setRaw(true);\n             rawScan.setMaxVersions();\n             rawScan.getFamilyMap().clear();\n-            rawScan.setFilter(null);\n             rawScan.setCacheBlocks(false);\n             for (byte[] family : scan.getFamilyMap().keySet()) {\n                 rawScan.addFamily(family);\n             }\n+            rawScan.setFilter(null);\n+            //override the filter to skip scan when lower bound of timerange is passed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6718fc2438df3ebcf733d8385b05341ddcadc15b"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDY4OTAyOnYy", "diffSide": "RIGHT", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/IndexToolForNonTxGlobalIndexIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzo1NDo1OVrOGcmqSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzo1NDo1OVrOGcmqSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0NjcyOQ==", "bodyText": "Is the edge manager injected somewhere? Otherwise this seems prone to flapping if the wall clock milliseconds don't act quite the way you're expecting. Suggest either injecting a manual edge, or picking fixed timestamps for each time variable.", "url": "https://github.com/apache/phoenix/pull/789#discussion_r432646729", "createdAt": "2020-05-29T17:54:59Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/IndexToolForNonTxGlobalIndexIT.java", "diffHunk": "@@ -588,9 +588,101 @@ public void testIndexToolForIncrementalRebuild() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testIndexToolForIncrementalVerify() throws Exception {\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            conn.createStatement().execute(\"CREATE TABLE \"+dataTableFullName+\" \"\n+                    + \"(key1 BIGINT NOT NULL, key2 BIGINT NOT NULL, val1 VARCHAR, val2 BIGINT, \"\n+                    + \"val3 BIGINT, val4 DOUBLE, val5 BIGINT, val6 VARCHAR \"\n+                    + \"CONSTRAINT my_pk PRIMARY KEY(key1, key2)) \"+tableDDLOptions);\n+            conn.createStatement().execute(String.format(\n+                    \"CREATE INDEX \"+indexTableName+\" ON \"+dataTableFullName+\" (val3) INCLUDE(val5)\"));\n+            long t0 = EnvironmentEdgeManager.currentTimeMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6718fc2438df3ebcf733d8385b05341ddcadc15b"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjQzNjEzOnYy", "diffSide": "RIGHT", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxODo1NDo0MVrOGhX9LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxODo1NDo0MVrOGhX9LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0ODY4NA==", "bodyText": "Looks like minTimestamp is just set once from the Scan (or 0 if no verify type), so can this be final?", "url": "https://github.com/apache/phoenix/pull/789#discussion_r437648684", "createdAt": "2020-06-09T18:54:41Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -118,6 +118,9 @@\n     private IndexVerificationOutputRepository verificationOutputRepository;\n     private boolean skipped = false;\n     private boolean shouldVerifyCheckDone = false;\n+    private byte[] nextStartKey;\n+    private boolean hasMoreIncr = false;\n+    private long minTimestamp = 0 ;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f0e940951de41f10d01418b5c4d8283487cd84b"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjQ0MTg4OnYy", "diffSide": "RIGHT", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxODo1NTo1N1rOGhYAbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMTo0NTowMFrOGhiB3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0OTUxOA==", "bodyText": "curious why we're clearing the families set by copying the original Scan and then adding them back?", "url": "https://github.com/apache/phoenix/pull/789#discussion_r437649518", "createdAt": "2020-06-09T18:55:57Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -1398,7 +1410,64 @@ public boolean next(List<Cell> results) throws IOException {\n                     SINGLE_COLUMN, AGG_TIMESTAMP, rowCountBytes, 0, rowCountBytes.length);\n         }\n         results.add(aggKeyValue);\n-        return hasMore;\n+        return hasMore || hasMoreIncr;\n+    }\n+\n+    private RegionScanner getLocalScanner() throws IOException {\n+        // override the filter to skip scan and open new scanner\n+        // when lower bound of timerange is passed or newStartKey was populated\n+        // from previous call to next()\n+        if(minTimestamp!= 0) {\n+            Scan incrScan = new Scan(scan);\n+            incrScan.setTimeRange(minTimestamp, scan.getTimeRange().getMax());\n+            incrScan.setRaw(true);\n+            incrScan.setMaxVersions();\n+            incrScan.getFamilyMap().clear();\n+            incrScan.setCacheBlocks(false);\n+            for (byte[] family : scan.getFamilyMap().keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f0e940951de41f10d01418b5c4d8283487cd84b"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxMzcyNA==", "bodyText": "We can have families in raw scans but not column qualifiers as HBase returns exception when columns are specified.", "url": "https://github.com/apache/phoenix/pull/789#discussion_r437813724", "createdAt": "2020-06-10T01:45:00Z", "author": {"login": "kadirozde"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -1398,7 +1410,64 @@ public boolean next(List<Cell> results) throws IOException {\n                     SINGLE_COLUMN, AGG_TIMESTAMP, rowCountBytes, 0, rowCountBytes.length);\n         }\n         results.add(aggKeyValue);\n-        return hasMore;\n+        return hasMore || hasMoreIncr;\n+    }\n+\n+    private RegionScanner getLocalScanner() throws IOException {\n+        // override the filter to skip scan and open new scanner\n+        // when lower bound of timerange is passed or newStartKey was populated\n+        // from previous call to next()\n+        if(minTimestamp!= 0) {\n+            Scan incrScan = new Scan(scan);\n+            incrScan.setTimeRange(minTimestamp, scan.getTimeRange().getMax());\n+            incrScan.setRaw(true);\n+            incrScan.setMaxVersions();\n+            incrScan.getFamilyMap().clear();\n+            incrScan.setCacheBlocks(false);\n+            for (byte[] family : scan.getFamilyMap().keySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0OTUxOA=="}, "originalCommit": {"oid": "9f0e940951de41f10d01418b5c4d8283487cd84b"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjQ0OTcyOnYy", "diffSide": "RIGHT", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxODo1ODowNVrOGhYFQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMTo0OTo0MVrOGhiGSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MDc1Mg==", "bodyText": "Even if a table is sorted DESC, it's ok to go from the start of the table down to the end so long as we're consistent about order and get every row we need, right? (I think so, but want to ask because we've had a lot of bugs over the years from hidden assumptions about sorting)", "url": "https://github.com/apache/phoenix/pull/789#discussion_r437650752", "createdAt": "2020-06-09T18:58:05Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -1398,7 +1410,64 @@ public boolean next(List<Cell> results) throws IOException {\n                     SINGLE_COLUMN, AGG_TIMESTAMP, rowCountBytes, 0, rowCountBytes.length);\n         }\n         results.add(aggKeyValue);\n-        return hasMore;\n+        return hasMore || hasMoreIncr;\n+    }\n+\n+    private RegionScanner getLocalScanner() throws IOException {\n+        // override the filter to skip scan and open new scanner\n+        // when lower bound of timerange is passed or newStartKey was populated\n+        // from previous call to next()\n+        if(minTimestamp!= 0) {\n+            Scan incrScan = new Scan(scan);\n+            incrScan.setTimeRange(minTimestamp, scan.getTimeRange().getMax());\n+            incrScan.setRaw(true);\n+            incrScan.setMaxVersions();\n+            incrScan.getFamilyMap().clear();\n+            incrScan.setCacheBlocks(false);\n+            for (byte[] family : scan.getFamilyMap().keySet()) {\n+                incrScan.addFamily(family);\n+            }\n+            if(nextStartKey != null) {\n+                incrScan.setStartRow(nextStartKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f0e940951de41f10d01418b5c4d8283487cd84b"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcxNDMyMg==", "bodyText": "If we don't have a test for index rebuild with a DESC pk, (incremental or not), we really should.", "url": "https://github.com/apache/phoenix/pull/789#discussion_r437714322", "createdAt": "2020-06-09T20:53:49Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -1398,7 +1410,64 @@ public boolean next(List<Cell> results) throws IOException {\n                     SINGLE_COLUMN, AGG_TIMESTAMP, rowCountBytes, 0, rowCountBytes.length);\n         }\n         results.add(aggKeyValue);\n-        return hasMore;\n+        return hasMore || hasMoreIncr;\n+    }\n+\n+    private RegionScanner getLocalScanner() throws IOException {\n+        // override the filter to skip scan and open new scanner\n+        // when lower bound of timerange is passed or newStartKey was populated\n+        // from previous call to next()\n+        if(minTimestamp!= 0) {\n+            Scan incrScan = new Scan(scan);\n+            incrScan.setTimeRange(minTimestamp, scan.getTimeRange().getMax());\n+            incrScan.setRaw(true);\n+            incrScan.setMaxVersions();\n+            incrScan.getFamilyMap().clear();\n+            incrScan.setCacheBlocks(false);\n+            for (byte[] family : scan.getFamilyMap().keySet()) {\n+                incrScan.addFamily(family);\n+            }\n+            if(nextStartKey != null) {\n+                incrScan.setStartRow(nextStartKey);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MDc1Mg=="}, "originalCommit": {"oid": "9f0e940951de41f10d01418b5c4d8283487cd84b"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc3ODc3NA==", "bodyText": "Yes, that's the idea.  Let me poke around if there is a test on DESC pk.", "url": "https://github.com/apache/phoenix/pull/789#discussion_r437778774", "createdAt": "2020-06-09T23:33:19Z", "author": {"login": "swaroopak"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -1398,7 +1410,64 @@ public boolean next(List<Cell> results) throws IOException {\n                     SINGLE_COLUMN, AGG_TIMESTAMP, rowCountBytes, 0, rowCountBytes.length);\n         }\n         results.add(aggKeyValue);\n-        return hasMore;\n+        return hasMore || hasMoreIncr;\n+    }\n+\n+    private RegionScanner getLocalScanner() throws IOException {\n+        // override the filter to skip scan and open new scanner\n+        // when lower bound of timerange is passed or newStartKey was populated\n+        // from previous call to next()\n+        if(minTimestamp!= 0) {\n+            Scan incrScan = new Scan(scan);\n+            incrScan.setTimeRange(minTimestamp, scan.getTimeRange().getMax());\n+            incrScan.setRaw(true);\n+            incrScan.setMaxVersions();\n+            incrScan.getFamilyMap().clear();\n+            incrScan.setCacheBlocks(false);\n+            for (byte[] family : scan.getFamilyMap().keySet()) {\n+                incrScan.addFamily(family);\n+            }\n+            if(nextStartKey != null) {\n+                incrScan.setStartRow(nextStartKey);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MDc1Mg=="}, "originalCommit": {"oid": "9f0e940951de41f10d01418b5c4d8283487cd84b"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxNDg1OA==", "bodyText": "This is at the HBase level and all row keys are sorted in the ascending order. Phoenix flips the bits in row keys for DESC pks. This should be a concern at the Phoenix level but not here.", "url": "https://github.com/apache/phoenix/pull/789#discussion_r437814858", "createdAt": "2020-06-10T01:49:41Z", "author": {"login": "kadirozde"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -1398,7 +1410,64 @@ public boolean next(List<Cell> results) throws IOException {\n                     SINGLE_COLUMN, AGG_TIMESTAMP, rowCountBytes, 0, rowCountBytes.length);\n         }\n         results.add(aggKeyValue);\n-        return hasMore;\n+        return hasMore || hasMoreIncr;\n+    }\n+\n+    private RegionScanner getLocalScanner() throws IOException {\n+        // override the filter to skip scan and open new scanner\n+        // when lower bound of timerange is passed or newStartKey was populated\n+        // from previous call to next()\n+        if(minTimestamp!= 0) {\n+            Scan incrScan = new Scan(scan);\n+            incrScan.setTimeRange(minTimestamp, scan.getTimeRange().getMax());\n+            incrScan.setRaw(true);\n+            incrScan.setMaxVersions();\n+            incrScan.getFamilyMap().clear();\n+            incrScan.setCacheBlocks(false);\n+            for (byte[] family : scan.getFamilyMap().keySet()) {\n+                incrScan.addFamily(family);\n+            }\n+            if(nextStartKey != null) {\n+                incrScan.setStartRow(nextStartKey);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MDc1Mg=="}, "originalCommit": {"oid": "9f0e940951de41f10d01418b5c4d8283487cd84b"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjQ2NTc2OnYy", "diffSide": "RIGHT", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/IndexToolForNonTxGlobalIndexIT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxOTowMjo1OFrOGhYP0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxOTowMjo1OFrOGhYP0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MzQ1Ng==", "bodyText": "Let's also have a test where we incrementally rebuild a view index. Since the copy-constructor of Scan also copies over filters, I expect they're OK, but better to test rather than assume. :-)", "url": "https://github.com/apache/phoenix/pull/789#discussion_r437653456", "createdAt": "2020-06-09T19:02:58Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/IndexToolForNonTxGlobalIndexIT.java", "diffHunk": "@@ -587,6 +589,113 @@ public void testIndexToolForIncrementalRebuild() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testIndexToolForIncrementalVerify() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f0e940951de41f10d01418b5c4d8283487cd84b"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNjQ4MjY2OnYy", "diffSide": "RIGHT", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxOTowNzo1OVrOGhYaiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMTo1NDoyN1rOGhdyag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1NjIwMQ==", "bodyText": "What if there's already a Filter on that scan (such as if we're rebuilding a view index). I think that's OK, because we generated our key list for the SkipScanFilter using the pre-existing view filter on incrScan which we got from the original rebuild Scan, but let's make sure we test and are really sure about that.", "url": "https://github.com/apache/phoenix/pull/789#discussion_r437656201", "createdAt": "2020-06-09T19:07:59Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -1398,7 +1410,64 @@ public boolean next(List<Cell> results) throws IOException {\n                     SINGLE_COLUMN, AGG_TIMESTAMP, rowCountBytes, 0, rowCountBytes.length);\n         }\n         results.add(aggKeyValue);\n-        return hasMore;\n+        return hasMore || hasMoreIncr;\n+    }\n+\n+    private RegionScanner getLocalScanner() throws IOException {\n+        // override the filter to skip scan and open new scanner\n+        // when lower bound of timerange is passed or newStartKey was populated\n+        // from previous call to next()\n+        if(minTimestamp!= 0) {\n+            Scan incrScan = new Scan(scan);\n+            incrScan.setTimeRange(minTimestamp, scan.getTimeRange().getMax());\n+            incrScan.setRaw(true);\n+            incrScan.setMaxVersions();\n+            incrScan.getFamilyMap().clear();\n+            incrScan.setCacheBlocks(false);\n+            for (byte[] family : scan.getFamilyMap().keySet()) {\n+                incrScan.addFamily(family);\n+            }\n+            if(nextStartKey != null) {\n+                incrScan.setStartRow(nextStartKey);\n+            }\n+            List<KeyRange> keys = new ArrayList<>();\n+            try(RegionScanner scanner = region.getScanner(incrScan)) {\n+                List<Cell> row = new ArrayList<>();\n+                int rowCount = 0;\n+                // collect row keys that have been modified in the given time-range\n+                // up to the size of page to build skip scan filter\n+                do {\n+                    hasMoreIncr = scanner.nextRaw(row);\n+                    if (!row.isEmpty()) {\n+                        keys.add(PVarbinary.INSTANCE.getKeyRange(CellUtil.cloneRow(row.get(0))));\n+                        rowCount++;\n+                    }\n+                    row.clear();\n+                } while (hasMoreIncr && rowCount < pageSizeInRows);\n+            }\n+            if (!hasMoreIncr && keys.isEmpty()) {\n+                return null;\n+            }\n+            if (!keys.isEmpty()) {\n+                nextStartKey = ByteUtil.calculateTheClosestNextRowKeyForPrefix(keys.get(keys.size() - 1).getLowerRange());\n+            }\n+            try {\n+                ScanRanges scanRanges = ScanRanges.createPointLookup(keys);\n+                scanRanges.initializeScan(incrScan);\n+                SkipScanFilter skipScanFilter = scanRanges.getSkipScanFilter();\n+                incrScan.setFilter(new SkipScanFilter(skipScanFilter, true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f0e940951de41f10d01418b5c4d8283487cd84b"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0NDIzNA==", "bodyText": "Yes, I will add a test for view index", "url": "https://github.com/apache/phoenix/pull/789#discussion_r437744234", "createdAt": "2020-06-09T21:54:27Z", "author": {"login": "swaroopak"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -1398,7 +1410,64 @@ public boolean next(List<Cell> results) throws IOException {\n                     SINGLE_COLUMN, AGG_TIMESTAMP, rowCountBytes, 0, rowCountBytes.length);\n         }\n         results.add(aggKeyValue);\n-        return hasMore;\n+        return hasMore || hasMoreIncr;\n+    }\n+\n+    private RegionScanner getLocalScanner() throws IOException {\n+        // override the filter to skip scan and open new scanner\n+        // when lower bound of timerange is passed or newStartKey was populated\n+        // from previous call to next()\n+        if(minTimestamp!= 0) {\n+            Scan incrScan = new Scan(scan);\n+            incrScan.setTimeRange(minTimestamp, scan.getTimeRange().getMax());\n+            incrScan.setRaw(true);\n+            incrScan.setMaxVersions();\n+            incrScan.getFamilyMap().clear();\n+            incrScan.setCacheBlocks(false);\n+            for (byte[] family : scan.getFamilyMap().keySet()) {\n+                incrScan.addFamily(family);\n+            }\n+            if(nextStartKey != null) {\n+                incrScan.setStartRow(nextStartKey);\n+            }\n+            List<KeyRange> keys = new ArrayList<>();\n+            try(RegionScanner scanner = region.getScanner(incrScan)) {\n+                List<Cell> row = new ArrayList<>();\n+                int rowCount = 0;\n+                // collect row keys that have been modified in the given time-range\n+                // up to the size of page to build skip scan filter\n+                do {\n+                    hasMoreIncr = scanner.nextRaw(row);\n+                    if (!row.isEmpty()) {\n+                        keys.add(PVarbinary.INSTANCE.getKeyRange(CellUtil.cloneRow(row.get(0))));\n+                        rowCount++;\n+                    }\n+                    row.clear();\n+                } while (hasMoreIncr && rowCount < pageSizeInRows);\n+            }\n+            if (!hasMoreIncr && keys.isEmpty()) {\n+                return null;\n+            }\n+            if (!keys.isEmpty()) {\n+                nextStartKey = ByteUtil.calculateTheClosestNextRowKeyForPrefix(keys.get(keys.size() - 1).getLowerRange());\n+            }\n+            try {\n+                ScanRanges scanRanges = ScanRanges.createPointLookup(keys);\n+                scanRanges.initializeScan(incrScan);\n+                SkipScanFilter skipScanFilter = scanRanges.getSkipScanFilter();\n+                incrScan.setFilter(new SkipScanFilter(skipScanFilter, true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1NjIwMQ=="}, "originalCommit": {"oid": "9f0e940951de41f10d01418b5c4d8283487cd84b"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzQ5ODE3OnYy", "diffSide": "RIGHT", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMjowMToyMlrOGhiSCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMjowMToyMlrOGhiSCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxNzg2Ng==", "bodyText": "You can eliminate IndexOutOfBoundsException by checking if key.size() == 0 and if so, returning innerScanner.", "url": "https://github.com/apache/phoenix/pull/789#discussion_r437817866", "createdAt": "2020-06-10T02:01:22Z", "author": {"login": "kadirozde"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -1398,7 +1410,64 @@ public boolean next(List<Cell> results) throws IOException {\n                     SINGLE_COLUMN, AGG_TIMESTAMP, rowCountBytes, 0, rowCountBytes.length);\n         }\n         results.add(aggKeyValue);\n-        return hasMore;\n+        return hasMore || hasMoreIncr;\n+    }\n+\n+    private RegionScanner getLocalScanner() throws IOException {\n+        // override the filter to skip scan and open new scanner\n+        // when lower bound of timerange is passed or newStartKey was populated\n+        // from previous call to next()\n+        if(minTimestamp!= 0) {\n+            Scan incrScan = new Scan(scan);\n+            incrScan.setTimeRange(minTimestamp, scan.getTimeRange().getMax());\n+            incrScan.setRaw(true);\n+            incrScan.setMaxVersions();\n+            incrScan.getFamilyMap().clear();\n+            incrScan.setCacheBlocks(false);\n+            for (byte[] family : scan.getFamilyMap().keySet()) {\n+                incrScan.addFamily(family);\n+            }\n+            if(nextStartKey != null) {\n+                incrScan.setStartRow(nextStartKey);\n+            }\n+            List<KeyRange> keys = new ArrayList<>();\n+            try(RegionScanner scanner = region.getScanner(incrScan)) {\n+                List<Cell> row = new ArrayList<>();\n+                int rowCount = 0;\n+                // collect row keys that have been modified in the given time-range\n+                // up to the size of page to build skip scan filter\n+                do {\n+                    hasMoreIncr = scanner.nextRaw(row);\n+                    if (!row.isEmpty()) {\n+                        keys.add(PVarbinary.INSTANCE.getKeyRange(CellUtil.cloneRow(row.get(0))));\n+                        rowCount++;\n+                    }\n+                    row.clear();\n+                } while (hasMoreIncr && rowCount < pageSizeInRows);\n+            }\n+            if (!hasMoreIncr && keys.isEmpty()) {\n+                return null;\n+            }\n+            if (!keys.isEmpty()) {\n+                nextStartKey = ByteUtil.calculateTheClosestNextRowKeyForPrefix(keys.get(keys.size() - 1).getLowerRange());\n+            }\n+            try {\n+                ScanRanges scanRanges = ScanRanges.createPointLookup(keys);\n+                scanRanges.initializeScan(incrScan);\n+                SkipScanFilter skipScanFilter = scanRanges.getSkipScanFilter();\n+                incrScan.setFilter(new SkipScanFilter(skipScanFilter, true));\n+                //putting back the min time to 0 for index and data reads\n+                incrScan.setTimeRange(0, scan.getTimeRange().getMax());\n+                scan.setTimeRange(0, scan.getTimeRange().getMax());\n+                return region.getScanner(incrScan);\n+            } catch (IndexOutOfBoundsException ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f0e940951de41f10d01418b5c4d8283487cd84b"}, "originalPosition": 144}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4661, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}