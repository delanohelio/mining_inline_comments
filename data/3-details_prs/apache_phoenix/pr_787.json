{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyMTcwNzIy", "number": 787, "title": "PHOENIX-5890: Port Phoenix-5799 to master", "bodyText": "", "createdAt": "2020-05-22T23:22:36Z", "url": "https://github.com/apache/phoenix/pull/787", "merged": true, "mergeCommit": {"oid": "5a9ec5552fb63fdf640e0c9adbb81eb6eec0ccae"}, "closed": true, "closedAt": "2020-05-26T23:59:54Z", "author": {"login": "swaroopak"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclKy4BAFqTQxODY1NzcyNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABclMC4IgFqTQxODcxMDc2Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NjU3NzI0", "url": "https://github.com/apache/phoenix/pull/787#pullrequestreview-418657724", "createdAt": "2020-05-26T20:33:09Z", "commit": {"oid": "e6b80c49fea2ee5c47253802ace5f446f745443c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMDozMzowOVrOGavTzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMDozMzowOVrOGavTzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY5MTI3Ng==", "bodyText": "@swaroopak - need to close indexHTable if not null as well. (The original 5799 did so too)", "url": "https://github.com/apache/phoenix/pull/787#discussion_r430691276", "createdAt": "2020-05-26T20:33:09Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationResultRepository.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.mapreduce.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.HColumnDescriptor;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HTableDescriptor;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.Admin;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.coprocessor.MetaDataProtocol;\n+import org.apache.phoenix.hbase.index.table.HTableFactory;\n+import org.apache.phoenix.hbase.index.util.ImmutableBytesPtr;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.mapreduce.index.IndexTool;\n+import org.apache.phoenix.query.ConnectionQueryServices;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.util.ByteUtil;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+public class IndexVerificationResultRepository {\n+    private Table resultHTable;\n+    private Table indexHTable;\n+    public static final byte[] ROW_KEY_SEPARATOR_BYTE = Bytes.toBytes(\"|\");\n+    public final static String RESULT_TABLE_NAME = \"PHOENIX_INDEX_TOOL_RESULT\";\n+    public final static byte[] RESULT_TABLE_NAME_BYTES = Bytes.toBytes(RESULT_TABLE_NAME);\n+    public final static byte[] RESULT_TABLE_COLUMN_FAMILY = QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES;\n+    public static String SCANNED_DATA_ROW_COUNT = \"ScannedDataRowCount\";\n+    public final static byte[] SCANNED_DATA_ROW_COUNT_BYTES = Bytes.toBytes(SCANNED_DATA_ROW_COUNT);\n+    public static String REBUILT_INDEX_ROW_COUNT = \"RebuiltIndexRowCount\";\n+    public final static byte[] REBUILT_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(REBUILT_INDEX_ROW_COUNT);\n+    public static String BEFORE_REBUILD_VALID_INDEX_ROW_COUNT = \"BeforeRebuildValidIndexRowCount\";\n+    public final static byte[] BEFORE_REBUILD_VALID_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(BEFORE_REBUILD_VALID_INDEX_ROW_COUNT);\n+    public static String BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT = \"BeforeRebuildExpiredIndexRowCount\";\n+    public final static byte[] BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT);\n+    public static String BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT = \"BeforeRebuildMissingIndexRowCount\";\n+    public final static byte[] BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT);\n+    public static String BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT = \"BeforeRebuildInvalidIndexRowCount\";\n+    public final static byte[] BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_VALID_INDEX_ROW_COUNT = \"AfterValidExpiredIndexRowCount\";\n+    public final static byte[] AFTER_REBUILD_VALID_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(AFTER_REBUILD_VALID_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT = \"AfterRebuildExpiredIndexRowCount\";\n+    public final static byte[] AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_MISSING_INDEX_ROW_COUNT = \"AfterRebuildMissingIndexRowCount\";\n+    public final static byte[] AFTER_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(AFTER_REBUILD_MISSING_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_INVALID_INDEX_ROW_COUNT = \"AfterRebuildInvalidIndexRowCount\";\n+    public final static byte[] AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(AFTER_REBUILD_INVALID_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_EXTRA_CELLS = \"AfterRebuildInvalidIndexRowCountCozExtraCells\";\n+    public final static byte[] AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_EXTRA_CELLS_BYTES = Bytes.toBytes(AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_EXTRA_CELLS);\n+    public static String AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_MISSING_CELLS = \"AfterRebuildInvalidIndexRowCountCozMissingCells\";\n+    public final static byte[] AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_MISSING_CELLS_BYTES = Bytes.toBytes(AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_MISSING_CELLS);\n+    public static String BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_EXTRA_CELLS = \"BeforeRebuildInvalidIndexRowCountCozExtraCells\";\n+    public final static byte[] BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_EXTRA_CELLS_BYTES = Bytes.toBytes(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_EXTRA_CELLS);\n+    public static String BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_MISSING_CELLS = \"BeforeRebuildInvalidIndexRowCountCozMissingCells\";\n+    public final static byte[] BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_MISSING_CELLS_BYTES = Bytes.toBytes(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_COZ_MISSING_CELLS);\n+\n+    /***\n+     * Only usable for read methods\n+     */\n+    public IndexVerificationResultRepository(){\n+\n+    }\n+\n+    public IndexVerificationResultRepository(Connection conn, byte[] indexNameBytes) throws SQLException {\n+        resultHTable = getTable(conn, RESULT_TABLE_NAME_BYTES);\n+        indexHTable = getTable(conn, indexNameBytes);\n+    }\n+\n+    public IndexVerificationResultRepository(byte[] indexName,\n+                                             HTableFactory hTableFactory) throws IOException {\n+        resultHTable = hTableFactory.getTable(new ImmutableBytesPtr(RESULT_TABLE_NAME_BYTES));\n+        indexHTable = hTableFactory.getTable(new ImmutableBytesPtr(indexName));\n+    }\n+\n+    public void createResultTable(Connection connection) throws IOException, SQLException {\n+        ConnectionQueryServices queryServices = connection.unwrap(PhoenixConnection.class).getQueryServices();\n+        Admin admin = queryServices.getAdmin();\n+\n+        if (!admin.tableExists(TableName.valueOf(RESULT_TABLE_NAME))) {\n+            HTableDescriptor tableDescriptor = new\n+                HTableDescriptor(TableName.valueOf(RESULT_TABLE_NAME));\n+            tableDescriptor.setValue(HColumnDescriptor.TTL, String.valueOf(MetaDataProtocol.DEFAULT_LOG_TTL));\n+            HColumnDescriptor columnDescriptor = new HColumnDescriptor(RESULT_TABLE_COLUMN_FAMILY);\n+            tableDescriptor.addFamily(columnDescriptor);\n+            admin.createTable(tableDescriptor);\n+        }\n+    }\n+    public static byte[] generateResultTableRowKey(long ts, byte[] indexTableName,  byte [] regionName,\n+                                                    byte[] startRow, byte[] stopRow) {\n+        byte[] keyPrefix = Bytes.toBytes(Long.toString(ts));\n+        int targetOffset = 0;\n+        // The row key for the result table : timestamp | index table name | datable table region name |\n+        //                                    scan start row | scan stop row\n+        byte[] rowKey = new byte[keyPrefix.length + ROW_KEY_SEPARATOR_BYTE.length + indexTableName.length +\n+            ROW_KEY_SEPARATOR_BYTE.length + regionName.length + ROW_KEY_SEPARATOR_BYTE.length +\n+            startRow.length + ROW_KEY_SEPARATOR_BYTE.length + stopRow.length];\n+        Bytes.putBytes(rowKey, targetOffset, keyPrefix, 0, keyPrefix.length);\n+        targetOffset += keyPrefix.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, indexTableName, 0, indexTableName.length);\n+        targetOffset += indexTableName.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, regionName, 0, regionName.length);\n+        targetOffset += regionName.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, startRow, 0, startRow.length);\n+        targetOffset += startRow.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, stopRow, 0, stopRow.length);\n+        return rowKey;\n+    }\n+\n+    public void logToIndexToolResultTable(IndexToolVerificationResult verificationResult,\n+                                          IndexTool.IndexVerifyType verifyType, byte[] region) throws IOException {\n+        long scanMaxTs = verificationResult.getScanMaxTs();\n+        byte[] rowKey = generateResultTableRowKey(scanMaxTs, indexHTable.getName().toBytes(),\n+            region, verificationResult.getStartRow(),\n+            verificationResult.getStopRow());\n+        Put put = new Put(rowKey);\n+        put.addColumn(RESULT_TABLE_COLUMN_FAMILY, SCANNED_DATA_ROW_COUNT_BYTES,\n+            scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getScannedDataRowCount())));\n+        put.addColumn(RESULT_TABLE_COLUMN_FAMILY, REBUILT_INDEX_ROW_COUNT_BYTES,\n+            scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getRebuiltIndexRowCount())));\n+        if (verifyType == IndexTool.IndexVerifyType.BEFORE || verifyType == IndexTool.IndexVerifyType.BOTH ||\n+            verifyType == IndexTool.IndexVerifyType.ONLY) {\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, BEFORE_REBUILD_VALID_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getBeforeRebuildValidIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getBeforeRebuildExpiredIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getBeforeRebuildMissingIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getBeforeRebuildInvalidIndexRowCount())));\n+        }\n+        if (verifyType == IndexTool.IndexVerifyType.AFTER || verifyType == IndexTool.IndexVerifyType.BOTH) {\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, AFTER_REBUILD_VALID_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getAfterRebuildValidIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getAfterRebuildExpiredIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, AFTER_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getAfterRebuildMissingIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getAfterRebuildInvalidIndexRowCount())));\n+        }\n+        resultHTable.put(put);\n+    }\n+\n+    public IndexToolVerificationResult getVerificationResult(Connection conn, long ts) throws IOException, SQLException {\n+        Table hTable = getTable(conn, RESULT_TABLE_NAME_BYTES);\n+        return getVerificationResult(hTable, ts);\n+    }\n+\n+    public Table getTable(Connection conn, byte[] tableName) throws SQLException {\n+        return conn.unwrap(PhoenixConnection.class).getQueryServices()\n+                .getTable(tableName);\n+    }\n+\n+    public IndexToolVerificationResult getVerificationResult(Table htable, long ts)\n+        throws IOException {\n+        byte[] startRowKey = Bytes.toBytes(Long.toString(ts));\n+        byte[] stopRowKey = ByteUtil.calculateTheClosestNextRowKeyForPrefix(startRowKey);\n+        IndexToolVerificationResult verificationResult = new IndexToolVerificationResult(ts);\n+        Scan scan = new Scan();\n+        scan.withStartRow(startRowKey);\n+        scan.withStopRow(stopRowKey);\n+        ResultScanner scanner = htable.getScanner(scan);\n+        for (Result result = scanner.next(); result != null; result = scanner.next()) {\n+            boolean isFirst = true;\n+            for (Cell cell : result.rawCells()) {\n+                if (isFirst){\n+                    byte[][] rowKeyParts = ByteUtil.splitArrayBySeparator(result.getRow(),\n+                        ROW_KEY_SEPARATOR_BYTE[0]);\n+                    verificationResult.setStartRow(rowKeyParts[3]);\n+                    verificationResult.setStopRow(rowKeyParts[4]);\n+                    isFirst = false;\n+                }\n+                verificationResult.update(cell);\n+            }\n+        }\n+        return verificationResult;\n+    }\n+\n+    public void close() throws IOException {\n+        if (resultHTable != null) {\n+            resultHTable.close();\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e6b80c49fea2ee5c47253802ace5f446f745443c"}, "originalPosition": 215}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2094d21aef12a3922bb59637695f2aca959e585", "author": {"user": null}, "url": "https://github.com/apache/phoenix/commit/d2094d21aef12a3922bb59637695f2aca959e585", "committedDate": "2020-05-26T20:57:19Z", "message": "PHOENIX-5890: Port Phoenix-5799 to master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e6b80c49fea2ee5c47253802ace5f446f745443c", "author": {"user": null}, "url": "https://github.com/apache/phoenix/commit/e6b80c49fea2ee5c47253802ace5f446f745443c", "committedDate": "2020-05-22T23:21:49Z", "message": "PHOENIX-5890: Port Phoenix-5799 to master"}, "afterCommit": {"oid": "d2094d21aef12a3922bb59637695f2aca959e585", "author": {"user": null}, "url": "https://github.com/apache/phoenix/commit/d2094d21aef12a3922bb59637695f2aca959e585", "committedDate": "2020-05-26T20:57:19Z", "message": "PHOENIX-5890: Port Phoenix-5799 to master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NzEwNzY3", "url": "https://github.com/apache/phoenix/pull/787#pullrequestreview-418710767", "createdAt": "2020-05-26T22:03:17Z", "commit": {"oid": "d2094d21aef12a3922bb59637695f2aca959e585"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2025, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}