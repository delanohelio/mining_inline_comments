{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1ODM2MDUw", "number": 728, "title": "PHOENIX-5765 Add unit test for PrepareIndexMutationsForRebuild", "bodyText": "", "createdAt": "2020-03-09T21:52:02Z", "url": "https://github.com/apache/phoenix/pull/728", "merged": true, "mergeCommit": {"oid": "d5a1d42c194fcea5bd1d6a5ab629a6ebea07392b"}, "closed": true, "closedAt": "2020-03-24T02:53:15Z", "author": {"login": "wangweiming800"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcMFAOugH2gAyMzg1ODM2MDUwOjJiMTllMDY1OWNhOThlMjE0MDhjYzljYWQ0NWUyMWQwZTUyOGM4ODg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPk7osAFqTM3ODcyNTc4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2b19e0659ca98e21408cc9cad45e21d0e528c888", "author": {"user": null}, "url": "https://github.com/apache/phoenix/commit/2b19e0659ca98e21408cc9cad45e21d0e528c888", "committedDate": "2020-03-09T21:42:57Z", "message": "Add unit test for PrepareIndexMutationsForRebuild"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a834787e3f9ee52470c423d8c9bf9b4e90399bec", "author": {"user": {"login": "wangweiming800", "name": "Weiming Wang"}}, "url": "https://github.com/apache/phoenix/commit/a834787e3f9ee52470c423d8c9bf9b4e90399bec", "committedDate": "2020-03-09T21:58:22Z", "message": "Add unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNjgwOTg4", "url": "https://github.com/apache/phoenix/pull/728#pullrequestreview-371680988", "createdAt": "2020-03-10T04:52:45Z", "commit": {"oid": "a834787e3f9ee52470c423d8c9bf9b4e90399bec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwNDo1Mjo0NVrOF0Be3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwNDo1Mjo0NVrOF0Be3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA5NDU1OA==", "bodyText": "@priyankporwal @kadirozde @gjacoby126 @swaroopak , can you help to review when you get a chance.\nFor some reason, it looks like I don't have permission to add reviewers.", "url": "https://github.com/apache/phoenix/pull/728#discussion_r390094558", "createdAt": "2020-03-10T04:52:45Z", "author": {"login": "wangweiming800"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,489 @@\n+package org.apache.phoenix.index;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a834787e3f9ee52470c423d8c9bf9b4e90399bec"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da3b677eae19643a4a9e55ee1a1008e4e081a391", "author": {"user": {"login": "wangweiming800", "name": "Weiming Wang"}}, "url": "https://github.com/apache/phoenix/commit/da3b677eae19643a4a9e55ee1a1008e4e081a391", "committedDate": "2020-03-10T23:01:43Z", "message": "Add more unit tests to cover more code paths"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczMTA3NTM3", "url": "https://github.com/apache/phoenix/pull/728#pullrequestreview-373107537", "createdAt": "2020-03-11T20:37:24Z", "commit": {"oid": "da3b677eae19643a4a9e55ee1a1008e4e081a391"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMDozNzoyNFrOF1IPbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMDozNzoyNFrOF1IPbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI1Mzg3MQ==", "bodyText": "I think it will be more readable and cleaner if you get the index maintainer object from the index table using getIndexMaintainer()", "url": "https://github.com/apache/phoenix/pull/728#discussion_r391253871", "createdAt": "2020-03-11T20:37:24Z", "author": {"login": "kadirozde"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,727 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.io.ImmutableBytesWritable;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.end2end.index.IndexTestUtil;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.hbase.index.util.GenericKeyValueBuilder;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PName;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PrepareIndexMutationsForRebuildTest.class);\n+\n+    class SetupInfo{\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setupIndexMaintainer(String tableName,\n+                                                 String indexName,\n+                                                 String columns,\n+                                                 String indexColumns,\n+                                                 String pk,\n+                                                 String includeColumns) throws Exception{\n+        Connection conn = DriverManager.getConnection(getUrl());\n+\n+        String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"),SchemaUtil.normalizeIdentifier(tableName));\n+        String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"),SchemaUtil.normalizeIdentifier(indexName));\n+\n+        String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",\n+                fullTableName,\n+                columns,\n+                pk);\n+        conn.createStatement().execute(str1);\n+\n+        String str2 = String.format(\"CREATE INDEX %1$s ON %2$s (%3$s)\",\n+                fullIndexName,\n+                fullTableName,\n+                indexColumns);\n+        if (!includeColumns.isEmpty())\n+            str2 += \" INCLUDE (\" + includeColumns + \")\";\n+        conn.createStatement().execute(str2);\n+\n+        PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+        PTable pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+        ImmutableBytesWritable ptr = new ImmutableBytesWritable();\n+        pDataTable.getIndexMaintainers(ptr, pconn);\n+        List<IndexMaintainer> indexMaintainers = IndexMaintainer.deserialize(ptr, GenericKeyValueBuilder.INSTANCE, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da3b677eae19643a4a9e55ee1a1008e4e081a391"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczMTIyODA0", "url": "https://github.com/apache/phoenix/pull/728#pullrequestreview-373122804", "createdAt": "2020-03-11T21:02:08Z", "commit": {"oid": "da3b677eae19643a4a9e55ee1a1008e4e081a391"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMTowMjowOFrOF1I-kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMTowMjowOFrOF1I-kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI2NTkzOQ==", "bodyText": "Should we return false here instead of assert?", "url": "https://github.com/apache/phoenix/pull/728#discussion_r391265939", "createdAt": "2020-03-11T21:02:08Z", "author": {"login": "kadirozde"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,727 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.io.ImmutableBytesWritable;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.end2end.index.IndexTestUtil;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.hbase.index.util.GenericKeyValueBuilder;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PName;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PrepareIndexMutationsForRebuildTest.class);\n+\n+    class SetupInfo{\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setupIndexMaintainer(String tableName,\n+                                                 String indexName,\n+                                                 String columns,\n+                                                 String indexColumns,\n+                                                 String pk,\n+                                                 String includeColumns) throws Exception{\n+        Connection conn = DriverManager.getConnection(getUrl());\n+\n+        String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"),SchemaUtil.normalizeIdentifier(tableName));\n+        String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"),SchemaUtil.normalizeIdentifier(indexName));\n+\n+        String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",\n+                fullTableName,\n+                columns,\n+                pk);\n+        conn.createStatement().execute(str1);\n+\n+        String str2 = String.format(\"CREATE INDEX %1$s ON %2$s (%3$s)\",\n+                fullIndexName,\n+                fullTableName,\n+                indexColumns);\n+        if (!includeColumns.isEmpty())\n+            str2 += \" INCLUDE (\" + includeColumns + \")\";\n+        conn.createStatement().execute(str2);\n+\n+        PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+        PTable pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+        ImmutableBytesWritable ptr = new ImmutableBytesWritable();\n+        pDataTable.getIndexMaintainers(ptr, pconn);\n+        List<IndexMaintainer> indexMaintainers = IndexMaintainer.deserialize(ptr, GenericKeyValueBuilder.INSTANCE, true);\n+        \n+        SetupInfo info = new SetupInfo();\n+        info.indexMaintainer = indexMaintainers.get(0);\n+        info.pDataTable = pDataTable;\n+        return info;\n+    }\n+\n+    @Test\n+    public void testSinglePutOnIndexColumn() throws Exception{\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        Put idxPut1 = new Put(com.google.common.primitives.Bytes.toArray(idxKey));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSinglePutOnNonIndexColumn() throws Exception{\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        Put idxPut1 = new Put(com.google.common.primitives.Bytes.toArray(idxKey));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnIndexColumn() throws Exception{\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes = com.google.common.primitives.Bytes.toArray(idxKey);\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        Put idxPut2 = new Put(com.google.common.primitives.Bytes.toArray(idxKey2));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnNonIndexColumn() throws Exception{\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes = com.google.common.primitives.Bytes.toArray(idxKey);\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDeleteAllVersions() throws Exception{\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 2);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        List<Byte> idxKey1 = new ArrayList<>();\n+        idxKey1.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey1.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey1.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes1 = com.google.common.primitives.Bytes.toArray(idxKey1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v2\")));\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes2 = com.google.common.primitives.Bytes.toArray(idxKey2);\n+\n+        Put idxPut1 = new Put(idxKeyBytes1);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel1 = new Delete(idxKeyBytes1);\n+        addCellToDelMutation(idxDel1,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel1);\n+\n+        Delete idxDel2 = new Delete(idxKeyBytes2);\n+        addCellToDelMutation(idxDel2,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testPutDeleteOnSameTimeStamp() throws Exception{\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable,1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes = com.google.common.primitives.Bytes.toArray(idxKey);\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testCoveredIndexColumns() throws Exception{\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"C2\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes = com.google.common.primitives.Bytes.toArray(idxKey);\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addCellToPutMutation(idxPut1,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                Bytes.toBytes(\"0:C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes2 = com.google.common.primitives.Bytes.toArray(idxKey2);\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addCellToPutMutation(idxPut2,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                Bytes.toBytes(\"0:C2\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testForMultipleFamilies() throws Exception {\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, CF1.C1 VARCHAR, CF2.C2 VARCHAR\",\n+                \"CF1.C1\",\n+                \"ROW_KEY\",\n+                \"CF2.C2\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                Bytes.toBytes(\"CF1\"),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                Bytes.toBytes(\"CF1\"),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes = com.google.common.primitives.Bytes.toArray(idxKey);\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addCellToPutMutation(idxPut1,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"CF2:C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        Put idxPut2 = new Put(com.google.common.primitives.Bytes.toArray(idxKey2));\n+        addCellToPutMutation(idxPut2,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"CF2:C2\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                Bytes.toBytes(\"CF2\"),\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSameTypeOfMutationWithDifferentTimeStamp() throws Exception{\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v3\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 2);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+\n+        Put idxPut1 = new Put(com.google.common.primitives.Bytes.toArray(idxKey));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        Put idxPut2 = new Put(com.google.common.primitives.Bytes.toArray(idxKey));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1, (Mutation)idxPut2), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDummy() throws Exception{\n+        Connection conn = DriverManager.getConnection(getUrl());\n+        String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"),SchemaUtil.normalizeIdentifier(\"dataTable\"));\n+        String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"),SchemaUtil.normalizeIdentifier(\"idx\"));\n+        String dataColumns = \"R_KEY VARCHAR, C1 VARCHAR\";\n+        String indexColumns = \"C1\" ;\n+        String pk = \"R_KEY\";\n+\n+        try {\n+            conn.setAutoCommit(false);\n+            String str1 = \"CREATE TABLE \" + fullTableName + \"(\" + dataColumns + \" CONSTRAINT pk PRIMARY KEY (\" + pk + \")) COLUMN_ENCODED_BYTES=0 \";\n+            conn.createStatement().execute(str1);\n+\n+            String str2 = \"CREATE INDEX idx ON \" + fullTableName + \"(\" + indexColumns + \") \";\n+            conn.createStatement().execute(str2);\n+            conn.commit();\n+\n+            Connection conn2 = DriverManager.getConnection(getUrl());\n+            String upsertStr = \"UPSERT INTO \" + fullTableName + \" VALUES('k1','v1')\";\n+            conn.createStatement().execute(upsertStr);\n+\n+            //String delStr = \"Delete FROM \" + fullTableName + \" WHERE R_KEY='k1'\";\n+            //conn.createStatement().execute(delStr);\n+\n+            conn.commit();\n+\n+            PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+            PTable table = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+            PTable index = pconn.getTable(new PTableKey(pconn.getTenantId(), fullIndexName));\n+\n+            Iterator<Pair<byte[],List<Mutation>>> itr = pconn.getMutationState().toMutations();\n+            Pair<byte[],List<Mutation>> pair = itr.next();\n+            Put dataPut = (Put)pair.getSecond().get(0);\n+            Delete dataDel = null;\n+\n+            ImmutableBytesWritable ptr = new ImmutableBytesWritable();\n+            table.getIndexMaintainers(ptr, pconn);\n+            List<IndexMaintainer> c1 = IndexMaintainer.deserialize(ptr, GenericKeyValueBuilder.INSTANCE, true);\n+            assertEquals(1,c1.size());\n+            IndexMaintainer im1 = c1.get(0);\n+\n+            List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(im1,\n+                    dataPut,\n+                    dataDel);\n+            List<Mutation> expectedIndexMutations = IndexTestUtil.generateIndexData(index, table, dataPut, ptr, GenericKeyValueBuilder.INSTANCE);\n+\n+        }\n+        catch(Exception ex){\n+            LOGGER.error(\"Failed to run TestOneColumnRowPut. ex={}\", ex);\n+        }\n+        finally {\n+            try {\n+                conn.createStatement().execute(\"DROP TABLE \" + fullTableName);\n+            } finally {\n+                conn.close();\n+            }\n+        }\n+    }\n+\n+    void addCellToPutMutation(Put put, byte[] family, byte[] column, long ts, byte[] value) throws Exception{\n+        byte[] rowKey = put.getRow();\n+        Cell cell = new KeyValue(rowKey, family, column, ts, KeyValue.Type.Put, value);\n+        put.add(cell);\n+    }\n+\n+    void addCellToDelMutation(Delete del, byte[] family, byte[] column, long ts, KeyValue.Type type) throws Exception{\n+        byte[] rowKey = del.getRow();\n+        Cell cell = new KeyValue(rowKey, family, column, ts, type);\n+        del.addDeleteMarker(cell);\n+    }\n+\n+    void addEmptyColumnToDataPutMutation(Put put, PTable ptable, long ts) throws Exception{\n+        PName pdefaultFamilyName = ptable.getDefaultFamilyName();\n+        addCellToPutMutation(put,\n+                pdefaultFamilyName == null ? QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES : pdefaultFamilyName.getBytes(),\n+                QueryConstants.EMPTY_COLUMN_BYTES,\n+                ts,\n+                QueryConstants.EMPTY_COLUMN_VALUE_BYTES);\n+    }\n+\n+    void addEmptyColumnToIndexPutMutation(Put put, IndexMaintainer im, long ts) throws Exception{\n+        addCellToPutMutation(put,\n+                im.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                QueryConstants.EMPTY_COLUMN_BYTES,\n+                ts,\n+                IndexRegionObserver.VERIFIED_BYTES);\n+    }\n+\n+    void assertEqualMutationList(List<Mutation> expectedMutations,\n+                                 List<Mutation> actualMutations){\n+        assertEquals(expectedMutations.size(), actualMutations.size());\n+        for (Mutation expected : expectedMutations){\n+            boolean found = false;\n+            for (Mutation actual: actualMutations){\n+                if (isEqualMutation(expected, actual)){\n+                    actualMutations.remove(actual);\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (!found)\n+                Assert.fail(String.format(\"Cannot find mutation:%s\", expected));\n+        }\n+    }\n+\n+    boolean isEqualMutation(Mutation expectedMutation, Mutation actualMutation){\n+        List<Cell> expectedCells = new ArrayList<>();\n+        for (List<Cell> cells : expectedMutation.getFamilyCellMap().values()) {\n+            expectedCells.addAll(cells);\n+        }\n+\n+        List<Cell> actualCells = new ArrayList<>();\n+        for (List<Cell> cells : actualMutation.getFamilyCellMap().values()) {\n+            actualCells.addAll(cells);\n+        }\n+\n+        assertEquals(expectedCells.size(), actualCells.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da3b677eae19643a4a9e55ee1a1008e4e081a391"}, "originalPosition": 703}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczMTQzMDMy", "url": "https://github.com/apache/phoenix/pull/728#pullrequestreview-373143032", "createdAt": "2020-03-11T21:37:28Z", "commit": {"oid": "da3b677eae19643a4a9e55ee1a1008e4e081a391"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMTozNzoyOFrOF1KAjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMTozNzoyOFrOF1KAjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI4MjgyOA==", "bodyText": "You can use SchemaUtil.getEmptyColumnFamily(table) here", "url": "https://github.com/apache/phoenix/pull/728#discussion_r391282828", "createdAt": "2020-03-11T21:37:28Z", "author": {"login": "kadirozde"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,727 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.io.ImmutableBytesWritable;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.end2end.index.IndexTestUtil;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.hbase.index.util.GenericKeyValueBuilder;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PName;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PrepareIndexMutationsForRebuildTest.class);\n+\n+    class SetupInfo{\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setupIndexMaintainer(String tableName,\n+                                                 String indexName,\n+                                                 String columns,\n+                                                 String indexColumns,\n+                                                 String pk,\n+                                                 String includeColumns) throws Exception{\n+        Connection conn = DriverManager.getConnection(getUrl());\n+\n+        String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"),SchemaUtil.normalizeIdentifier(tableName));\n+        String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"),SchemaUtil.normalizeIdentifier(indexName));\n+\n+        String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",\n+                fullTableName,\n+                columns,\n+                pk);\n+        conn.createStatement().execute(str1);\n+\n+        String str2 = String.format(\"CREATE INDEX %1$s ON %2$s (%3$s)\",\n+                fullIndexName,\n+                fullTableName,\n+                indexColumns);\n+        if (!includeColumns.isEmpty())\n+            str2 += \" INCLUDE (\" + includeColumns + \")\";\n+        conn.createStatement().execute(str2);\n+\n+        PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+        PTable pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+        ImmutableBytesWritable ptr = new ImmutableBytesWritable();\n+        pDataTable.getIndexMaintainers(ptr, pconn);\n+        List<IndexMaintainer> indexMaintainers = IndexMaintainer.deserialize(ptr, GenericKeyValueBuilder.INSTANCE, true);\n+        \n+        SetupInfo info = new SetupInfo();\n+        info.indexMaintainer = indexMaintainers.get(0);\n+        info.pDataTable = pDataTable;\n+        return info;\n+    }\n+\n+    @Test\n+    public void testSinglePutOnIndexColumn() throws Exception{\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        Put idxPut1 = new Put(com.google.common.primitives.Bytes.toArray(idxKey));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSinglePutOnNonIndexColumn() throws Exception{\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        Put idxPut1 = new Put(com.google.common.primitives.Bytes.toArray(idxKey));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnIndexColumn() throws Exception{\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes = com.google.common.primitives.Bytes.toArray(idxKey);\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        Put idxPut2 = new Put(com.google.common.primitives.Bytes.toArray(idxKey2));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnNonIndexColumn() throws Exception{\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes = com.google.common.primitives.Bytes.toArray(idxKey);\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDeleteAllVersions() throws Exception{\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 2);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        List<Byte> idxKey1 = new ArrayList<>();\n+        idxKey1.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey1.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey1.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes1 = com.google.common.primitives.Bytes.toArray(idxKey1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v2\")));\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes2 = com.google.common.primitives.Bytes.toArray(idxKey2);\n+\n+        Put idxPut1 = new Put(idxKeyBytes1);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel1 = new Delete(idxKeyBytes1);\n+        addCellToDelMutation(idxDel1,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel1);\n+\n+        Delete idxDel2 = new Delete(idxKeyBytes2);\n+        addCellToDelMutation(idxDel2,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testPutDeleteOnSameTimeStamp() throws Exception{\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable,1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes = com.google.common.primitives.Bytes.toArray(idxKey);\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testCoveredIndexColumns() throws Exception{\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"C2\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes = com.google.common.primitives.Bytes.toArray(idxKey);\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addCellToPutMutation(idxPut1,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                Bytes.toBytes(\"0:C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes2 = com.google.common.primitives.Bytes.toArray(idxKey2);\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addCellToPutMutation(idxPut2,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                Bytes.toBytes(\"0:C2\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testForMultipleFamilies() throws Exception {\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, CF1.C1 VARCHAR, CF2.C2 VARCHAR\",\n+                \"CF1.C1\",\n+                \"ROW_KEY\",\n+                \"CF2.C2\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                Bytes.toBytes(\"CF1\"),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                Bytes.toBytes(\"CF1\"),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes = com.google.common.primitives.Bytes.toArray(idxKey);\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addCellToPutMutation(idxPut1,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"CF2:C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        Put idxPut2 = new Put(com.google.common.primitives.Bytes.toArray(idxKey2));\n+        addCellToPutMutation(idxPut2,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"CF2:C2\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                Bytes.toBytes(\"CF2\"),\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSameTypeOfMutationWithDifferentTimeStamp() throws Exception{\n+        SetupInfo info = setupIndexMaintainer(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v3\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 2);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+\n+        Put idxPut1 = new Put(com.google.common.primitives.Bytes.toArray(idxKey));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        Put idxPut2 = new Put(com.google.common.primitives.Bytes.toArray(idxKey));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1, (Mutation)idxPut2), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDummy() throws Exception{\n+        Connection conn = DriverManager.getConnection(getUrl());\n+        String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"),SchemaUtil.normalizeIdentifier(\"dataTable\"));\n+        String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"),SchemaUtil.normalizeIdentifier(\"idx\"));\n+        String dataColumns = \"R_KEY VARCHAR, C1 VARCHAR\";\n+        String indexColumns = \"C1\" ;\n+        String pk = \"R_KEY\";\n+\n+        try {\n+            conn.setAutoCommit(false);\n+            String str1 = \"CREATE TABLE \" + fullTableName + \"(\" + dataColumns + \" CONSTRAINT pk PRIMARY KEY (\" + pk + \")) COLUMN_ENCODED_BYTES=0 \";\n+            conn.createStatement().execute(str1);\n+\n+            String str2 = \"CREATE INDEX idx ON \" + fullTableName + \"(\" + indexColumns + \") \";\n+            conn.createStatement().execute(str2);\n+            conn.commit();\n+\n+            Connection conn2 = DriverManager.getConnection(getUrl());\n+            String upsertStr = \"UPSERT INTO \" + fullTableName + \" VALUES('k1','v1')\";\n+            conn.createStatement().execute(upsertStr);\n+\n+            //String delStr = \"Delete FROM \" + fullTableName + \" WHERE R_KEY='k1'\";\n+            //conn.createStatement().execute(delStr);\n+\n+            conn.commit();\n+\n+            PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+            PTable table = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+            PTable index = pconn.getTable(new PTableKey(pconn.getTenantId(), fullIndexName));\n+\n+            Iterator<Pair<byte[],List<Mutation>>> itr = pconn.getMutationState().toMutations();\n+            Pair<byte[],List<Mutation>> pair = itr.next();\n+            Put dataPut = (Put)pair.getSecond().get(0);\n+            Delete dataDel = null;\n+\n+            ImmutableBytesWritable ptr = new ImmutableBytesWritable();\n+            table.getIndexMaintainers(ptr, pconn);\n+            List<IndexMaintainer> c1 = IndexMaintainer.deserialize(ptr, GenericKeyValueBuilder.INSTANCE, true);\n+            assertEquals(1,c1.size());\n+            IndexMaintainer im1 = c1.get(0);\n+\n+            List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(im1,\n+                    dataPut,\n+                    dataDel);\n+            List<Mutation> expectedIndexMutations = IndexTestUtil.generateIndexData(index, table, dataPut, ptr, GenericKeyValueBuilder.INSTANCE);\n+\n+        }\n+        catch(Exception ex){\n+            LOGGER.error(\"Failed to run TestOneColumnRowPut. ex={}\", ex);\n+        }\n+        finally {\n+            try {\n+                conn.createStatement().execute(\"DROP TABLE \" + fullTableName);\n+            } finally {\n+                conn.close();\n+            }\n+        }\n+    }\n+\n+    void addCellToPutMutation(Put put, byte[] family, byte[] column, long ts, byte[] value) throws Exception{\n+        byte[] rowKey = put.getRow();\n+        Cell cell = new KeyValue(rowKey, family, column, ts, KeyValue.Type.Put, value);\n+        put.add(cell);\n+    }\n+\n+    void addCellToDelMutation(Delete del, byte[] family, byte[] column, long ts, KeyValue.Type type) throws Exception{\n+        byte[] rowKey = del.getRow();\n+        Cell cell = new KeyValue(rowKey, family, column, ts, type);\n+        del.addDeleteMarker(cell);\n+    }\n+\n+    void addEmptyColumnToDataPutMutation(Put put, PTable ptable, long ts) throws Exception{\n+        PName pdefaultFamilyName = ptable.getDefaultFamilyName();\n+        addCellToPutMutation(put,\n+                pdefaultFamilyName == null ? QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES : pdefaultFamilyName.getBytes(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da3b677eae19643a4a9e55ee1a1008e4e081a391"}, "originalPosition": 661}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e17cfe7c95877bfe68213a25c04457208b037aba", "author": {"user": {"login": "wangweiming800", "name": "Weiming Wang"}}, "url": "https://github.com/apache/phoenix/commit/e17cfe7c95877bfe68213a25c04457208b037aba", "committedDate": "2020-03-12T04:56:21Z", "message": "Fix the comments of pull requests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczMjc4ODE3", "url": "https://github.com/apache/phoenix/pull/728#pullrequestreview-373278817", "createdAt": "2020-03-12T04:58:01Z", "commit": {"oid": "e17cfe7c95877bfe68213a25c04457208b037aba"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNDo1ODowMlrOF1RQnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwNTowMToyMFrOF1RTbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwMTYyOQ==", "bodyText": "nit: space before {", "url": "https://github.com/apache/phoenix/pull/728#discussion_r391401629", "createdAt": "2020-03-12T04:58:02Z", "author": {"login": "swaroopak"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PrepareIndexMutationsForRebuildTest.class);\n+\n+    class SetupInfo{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e17cfe7c95877bfe68213a25c04457208b037aba"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwMTczOA==", "bodyText": "try-with-resources while getting connection to avoid connection leaks", "url": "https://github.com/apache/phoenix/pull/728#discussion_r391401738", "createdAt": "2020-03-12T04:58:37Z", "author": {"login": "swaroopak"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PrepareIndexMutationsForRebuildTest.class);\n+\n+    class SetupInfo{\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setup(String tableName,\n+                            String indexName,\n+                            String columns,\n+                            String indexColumns,\n+                            String pk,\n+                            String includeColumns) throws Exception{\n+        Connection conn = DriverManager.getConnection(getUrl());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e17cfe7c95877bfe68213a25c04457208b037aba"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwMTg5MA==", "bodyText": "nit : extract query to static constant", "url": "https://github.com/apache/phoenix/pull/728#discussion_r391401890", "createdAt": "2020-03-12T04:59:10Z", "author": {"login": "swaroopak"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PrepareIndexMutationsForRebuildTest.class);\n+\n+    class SetupInfo{\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setup(String tableName,\n+                            String indexName,\n+                            String columns,\n+                            String indexColumns,\n+                            String pk,\n+                            String includeColumns) throws Exception{\n+        Connection conn = DriverManager.getConnection(getUrl());\n+\n+        String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"),SchemaUtil.normalizeIdentifier(tableName));\n+        String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"),SchemaUtil.normalizeIdentifier(indexName));\n+\n+        String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e17cfe7c95877bfe68213a25c04457208b037aba"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwMjI3NQ==", "bodyText": "can this be trimmed with import? is there any better way to create a key? or concatenating bytes? could be a helper function instead?", "url": "https://github.com/apache/phoenix/pull/728#discussion_r391402275", "createdAt": "2020-03-12T05:01:00Z", "author": {"login": "swaroopak"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PrepareIndexMutationsForRebuildTest.class);\n+\n+    class SetupInfo{\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setup(String tableName,\n+                            String indexName,\n+                            String columns,\n+                            String indexColumns,\n+                            String pk,\n+                            String includeColumns) throws Exception{\n+        Connection conn = DriverManager.getConnection(getUrl());\n+\n+        String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"),SchemaUtil.normalizeIdentifier(tableName));\n+        String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"),SchemaUtil.normalizeIdentifier(indexName));\n+\n+        String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",\n+                fullTableName,\n+                columns,\n+                pk);\n+        conn.createStatement().execute(str1);\n+\n+        String str2 = String.format(\"CREATE INDEX %1$s ON %2$s (%3$s)\",\n+                fullIndexName,\n+                fullTableName,\n+                indexColumns);\n+        if (!includeColumns.isEmpty())\n+            str2 += \" INCLUDE (\" + includeColumns + \")\";\n+        conn.createStatement().execute(str2);\n+\n+        PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+        PTable pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullIndexName));\n+        PTable pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+        IndexMaintainer im = pIndexTable.getIndexMaintainer(pDataTable,pconn);\n+\n+        SetupInfo info = new SetupInfo();\n+        info.indexMaintainer = im;\n+        info.pDataTable = pDataTable;\n+        return info;\n+    }\n+\n+    @Test\n+    public void testSinglePutOnIndexColumn() throws Exception{\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        Put idxPut1 = new Put(com.google.common.primitives.Bytes.toArray(idxKey));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSinglePutOnNonIndexColumn() throws Exception{\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        Put idxPut1 = new Put(com.google.common.primitives.Bytes.toArray(idxKey));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnIndexColumn() throws Exception{\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes = com.google.common.primitives.Bytes.toArray(idxKey);\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e17cfe7c95877bfe68213a25c04457208b037aba"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQwMjM1MA==", "bodyText": "nit: space before {", "url": "https://github.com/apache/phoenix/pull/728#discussion_r391402350", "createdAt": "2020-03-12T05:01:20Z", "author": {"login": "swaroopak"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PrepareIndexMutationsForRebuildTest.class);\n+\n+    class SetupInfo{\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setup(String tableName,\n+                            String indexName,\n+                            String columns,\n+                            String indexColumns,\n+                            String pk,\n+                            String includeColumns) throws Exception{\n+        Connection conn = DriverManager.getConnection(getUrl());\n+\n+        String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"),SchemaUtil.normalizeIdentifier(tableName));\n+        String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"),SchemaUtil.normalizeIdentifier(indexName));\n+\n+        String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",\n+                fullTableName,\n+                columns,\n+                pk);\n+        conn.createStatement().execute(str1);\n+\n+        String str2 = String.format(\"CREATE INDEX %1$s ON %2$s (%3$s)\",\n+                fullIndexName,\n+                fullTableName,\n+                indexColumns);\n+        if (!includeColumns.isEmpty())\n+            str2 += \" INCLUDE (\" + includeColumns + \")\";\n+        conn.createStatement().execute(str2);\n+\n+        PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+        PTable pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullIndexName));\n+        PTable pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+        IndexMaintainer im = pIndexTable.getIndexMaintainer(pDataTable,pconn);\n+\n+        SetupInfo info = new SetupInfo();\n+        info.indexMaintainer = im;\n+        info.pDataTable = pDataTable;\n+        return info;\n+    }\n+\n+    @Test\n+    public void testSinglePutOnIndexColumn() throws Exception{\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        Put idxPut1 = new Put(com.google.common.primitives.Bytes.toArray(idxKey));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSinglePutOnNonIndexColumn() throws Exception{\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        Put idxPut1 = new Put(com.google.common.primitives.Bytes.toArray(idxKey));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnIndexColumn() throws Exception{\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes = com.google.common.primitives.Bytes.toArray(idxKey);\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        Put idxPut2 = new Put(com.google.common.primitives.Bytes.toArray(idxKey2));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnNonIndexColumn() throws Exception{\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes = com.google.common.primitives.Bytes.toArray(idxKey);\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDeleteAllVersions() throws Exception{\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 2);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        List<Byte> idxKey1 = new ArrayList<>();\n+        idxKey1.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey1.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey1.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes1 = com.google.common.primitives.Bytes.toArray(idxKey1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v2\")));\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes2 = com.google.common.primitives.Bytes.toArray(idxKey2);\n+\n+        Put idxPut1 = new Put(idxKeyBytes1);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel1 = new Delete(idxKeyBytes1);\n+        addCellToDelMutation(idxDel1,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel1);\n+\n+        Delete idxDel2 = new Delete(idxKeyBytes2);\n+        addCellToDelMutation(idxDel2,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testPutDeleteOnSameTimeStamp() throws Exception{\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable,1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes = com.google.common.primitives.Bytes.toArray(idxKey);\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testCoveredIndexColumns() throws Exception{\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"C2\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes = com.google.common.primitives.Bytes.toArray(idxKey);\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addCellToPutMutation(idxPut1,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                Bytes.toBytes(\"0:C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes2 = com.google.common.primitives.Bytes.toArray(idxKey2);\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addCellToPutMutation(idxPut2,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                Bytes.toBytes(\"0:C2\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testForMultipleFamilies() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, CF1.C1 VARCHAR, CF2.C2 VARCHAR\",\n+                \"CF1.C1\",\n+                \"ROW_KEY\",\n+                \"CF2.C2\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                Bytes.toBytes(\"CF1\"),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                Bytes.toBytes(\"CF1\"),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(\"v1\")));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes = com.google.common.primitives.Bytes.toArray(idxKey);\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addCellToPutMutation(idxPut1,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"CF2:C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        Put idxPut2 = new Put(com.google.common.primitives.Bytes.toArray(idxKey2));\n+        addCellToPutMutation(idxPut2,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"CF2:C2\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                Bytes.toBytes(\"CF2\"),\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSameTypeOfMutationWithDifferentTimeStamp() throws Exception{\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v3\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 2);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        List<Byte> idxKey = new ArrayList<>();\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+\n+        Put idxPut1 = new Put(com.google.common.primitives.Bytes.toArray(idxKey));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        Put idxPut2 = new Put(com.google.common.primitives.Bytes.toArray(idxKey));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1, (Mutation)idxPut2), actualIndexMutations);\n+    }\n+\n+    void addCellToPutMutation(Put put, byte[] family, byte[] column, long ts, byte[] value) throws Exception{\n+        byte[] rowKey = put.getRow();\n+        Cell cell = new KeyValue(rowKey, family, column, ts, KeyValue.Type.Put, value);\n+        put.add(cell);\n+    }\n+\n+    void addCellToDelMutation(Delete del, byte[] family, byte[] column, long ts, KeyValue.Type type) throws Exception{\n+        byte[] rowKey = del.getRow();\n+        Cell cell = new KeyValue(rowKey, family, column, ts, type);\n+        del.addDeleteMarker(cell);\n+    }\n+\n+    void addEmptyColumnToDataPutMutation(Put put, PTable ptable, long ts) throws Exception{\n+        addCellToPutMutation(put,\n+                SchemaUtil.getEmptyColumnFamily(ptable),\n+                QueryConstants.EMPTY_COLUMN_BYTES,\n+                ts,\n+                QueryConstants.EMPTY_COLUMN_VALUE_BYTES);\n+    }\n+\n+    void addEmptyColumnToIndexPutMutation(Put put, IndexMaintainer im, long ts) throws Exception{\n+        addCellToPutMutation(put,\n+                im.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                QueryConstants.EMPTY_COLUMN_BYTES,\n+                ts,\n+                IndexRegionObserver.VERIFIED_BYTES);\n+    }\n+\n+    void assertEqualMutationList(List<Mutation> expectedMutations,\n+                                 List<Mutation> actualMutations){\n+        assertEquals(expectedMutations.size(), actualMutations.size());\n+        for (Mutation expected : expectedMutations){\n+            boolean found = false;\n+            for (Mutation actual: actualMutations){\n+                if (isEqualMutation(expected, actual)){\n+                    actualMutations.remove(actual);\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (!found)\n+                Assert.fail(String.format(\"Cannot find mutation:%s\", expected));\n+        }\n+    }\n+\n+    boolean isEqualMutation(Mutation expectedMutation, Mutation actualMutation){\n+        List<Cell> expectedCells = new ArrayList<>();\n+        for (List<Cell> cells : expectedMutation.getFamilyCellMap().values()) {\n+            expectedCells.addAll(cells);\n+        }\n+\n+        List<Cell> actualCells = new ArrayList<>();\n+        for (List<Cell> cells : actualMutation.getFamilyCellMap().values()) {\n+            actualCells.addAll(cells);\n+        }\n+\n+        if (expectedCells.size() != actualCells.size())\n+            return false;\n+        for(Cell expected : expectedCells){\n+            boolean found = false;\n+            for(Cell actual: actualCells){\n+                if (isEqualCell(expected, actual)){\n+                    actualCells.remove(actual);\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (!found)\n+                return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    boolean isEqualCell(Cell a, Cell b){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e17cfe7c95877bfe68213a25c04457208b037aba"}, "originalPosition": 653}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c11152bee3ce80897faaae2ae8e02f425436c8b", "author": {"user": {"login": "wangweiming800", "name": "Weiming Wang"}}, "url": "https://github.com/apache/phoenix/commit/3c11152bee3ce80897faaae2ae8e02f425436c8b", "committedDate": "2020-03-13T18:24:16Z", "message": "Fix the comments of pull requests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NjQ4NTcw", "url": "https://github.com/apache/phoenix/pull/728#pullrequestreview-375648570", "createdAt": "2020-03-16T23:29:21Z", "commit": {"oid": "3c11152bee3ce80897faaae2ae8e02f425436c8b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMzoyOToyMVrOF3JMsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDoxNTo0NlrOF3J9BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2NjcwNw==", "bodyText": "some comments explaining the exact test case and the expected results would be helpful.", "url": "https://github.com/apache/phoenix/pull/728#discussion_r393366707", "createdAt": "2020-03-16T23:29:21Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,626 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+\n+    class SetupInfo {\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setup(String tableName,\n+                            String indexName,\n+                            String columns,\n+                            String indexColumns,\n+                            String pk,\n+                            String includeColumns) throws Exception {\n+        try(Connection conn = DriverManager.getConnection(getUrl())) {\n+\n+            String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(tableName));\n+            String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(indexName));\n+\n+            String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",\n+                    fullTableName,\n+                    columns,\n+                    pk);\n+            conn.createStatement().execute(str1);\n+\n+            String str2 = String.format(\"CREATE INDEX %1$s ON %2$s (%3$s)\",\n+                    fullIndexName,\n+                    fullTableName,\n+                    indexColumns);\n+            if (!includeColumns.isEmpty())\n+                str2 += \" INCLUDE (\" + includeColumns + \")\";\n+            conn.createStatement().execute(str2);\n+\n+            PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+            PTable pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullIndexName));\n+            PTable pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+            IndexMaintainer im = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+\n+            SetupInfo info = new SetupInfo();\n+            info.indexMaintainer = im;\n+            info.pDataTable = pDataTable;\n+            return info;\n+        }\n+    }\n+\n+    @Test\n+    public void testSinglePutOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(\"v1\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSinglePutOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c11152bee3ce80897faaae2ae8e02f425436c8b"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2ODIxMA==", "bodyText": "Comment would be good explaining that no delete mutation is expected because index reads only return for a single timestamp so only the empty column is needed.\nRelatedly, I get the empty column at ts 2, but why the extra empty column at ts 1?", "url": "https://github.com/apache/phoenix/pull/728#discussion_r393368210", "createdAt": "2020-03-16T23:34:56Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,626 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+\n+    class SetupInfo {\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setup(String tableName,\n+                            String indexName,\n+                            String columns,\n+                            String indexColumns,\n+                            String pk,\n+                            String includeColumns) throws Exception {\n+        try(Connection conn = DriverManager.getConnection(getUrl())) {\n+\n+            String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(tableName));\n+            String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(indexName));\n+\n+            String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",\n+                    fullTableName,\n+                    columns,\n+                    pk);\n+            conn.createStatement().execute(str1);\n+\n+            String str2 = String.format(\"CREATE INDEX %1$s ON %2$s (%3$s)\",\n+                    fullIndexName,\n+                    fullTableName,\n+                    indexColumns);\n+            if (!includeColumns.isEmpty())\n+                str2 += \" INCLUDE (\" + includeColumns + \")\";\n+            conn.createStatement().execute(str2);\n+\n+            PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+            PTable pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullIndexName));\n+            PTable pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+            IndexMaintainer im = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+\n+            SetupInfo info = new SetupInfo();\n+            info.indexMaintainer = im;\n+            info.pDataTable = pDataTable;\n+            return info;\n+        }\n+    }\n+\n+    @Test\n+    public void testSinglePutOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(\"v1\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSinglePutOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        Put idxPut2 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c11152bee3ce80897faaae2ae8e02f425436c8b"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2ODc3MA==", "bodyText": "I understand the DeleteFamily marker at ts 3, but why the one at ts 2?", "url": "https://github.com/apache/phoenix/pull/728#discussion_r393368770", "createdAt": "2020-03-16T23:36:46Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,626 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+\n+    class SetupInfo {\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setup(String tableName,\n+                            String indexName,\n+                            String columns,\n+                            String indexColumns,\n+                            String pk,\n+                            String includeColumns) throws Exception {\n+        try(Connection conn = DriverManager.getConnection(getUrl())) {\n+\n+            String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(tableName));\n+            String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(indexName));\n+\n+            String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",\n+                    fullTableName,\n+                    columns,\n+                    pk);\n+            conn.createStatement().execute(str1);\n+\n+            String str2 = String.format(\"CREATE INDEX %1$s ON %2$s (%3$s)\",\n+                    fullIndexName,\n+                    fullTableName,\n+                    indexColumns);\n+            if (!includeColumns.isEmpty())\n+                str2 += \" INCLUDE (\" + includeColumns + \")\";\n+            conn.createStatement().execute(str2);\n+\n+            PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+            PTable pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullIndexName));\n+            PTable pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+            IndexMaintainer im = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+\n+            SetupInfo info = new SetupInfo();\n+            info.indexMaintainer = im;\n+            info.pDataTable = pDataTable;\n+            return info;\n+        }\n+    }\n+\n+    @Test\n+    public void testSinglePutOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(\"v1\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSinglePutOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        Put idxPut2 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDeleteAllVersions() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 2);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        byte[] idxKeyBytes1 = generateIndexRowKey(\"v1\");\n+        byte[] idxKeyBytes2 = generateIndexRowKey(\"v2\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes1);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel1 = new Delete(idxKeyBytes1);\n+        addCellToDelMutation(idxDel1,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c11152bee3ce80897faaae2ae8e02f425436c8b"}, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2OTAwNA==", "bodyText": "Keep in mind that a delete marker at a given timestamp always wins over a Put at the same timestamp, so the DeleteFamily marker at ts 2 \"erases\" the Put at ts 2 if we do a lookback / SCN query.", "url": "https://github.com/apache/phoenix/pull/728#discussion_r393369004", "createdAt": "2020-03-16T23:37:42Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,626 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+\n+    class SetupInfo {\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setup(String tableName,\n+                            String indexName,\n+                            String columns,\n+                            String indexColumns,\n+                            String pk,\n+                            String includeColumns) throws Exception {\n+        try(Connection conn = DriverManager.getConnection(getUrl())) {\n+\n+            String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(tableName));\n+            String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(indexName));\n+\n+            String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",\n+                    fullTableName,\n+                    columns,\n+                    pk);\n+            conn.createStatement().execute(str1);\n+\n+            String str2 = String.format(\"CREATE INDEX %1$s ON %2$s (%3$s)\",\n+                    fullIndexName,\n+                    fullTableName,\n+                    indexColumns);\n+            if (!includeColumns.isEmpty())\n+                str2 += \" INCLUDE (\" + includeColumns + \")\";\n+            conn.createStatement().execute(str2);\n+\n+            PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+            PTable pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullIndexName));\n+            PTable pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+            IndexMaintainer im = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+\n+            SetupInfo info = new SetupInfo();\n+            info.indexMaintainer = im;\n+            info.pDataTable = pDataTable;\n+            return info;\n+        }\n+    }\n+\n+    @Test\n+    public void testSinglePutOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(\"v1\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSinglePutOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        Put idxPut2 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDeleteAllVersions() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 2);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        byte[] idxKeyBytes1 = generateIndexRowKey(\"v1\");\n+        byte[] idxKeyBytes2 = generateIndexRowKey(\"v2\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes1);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel1 = new Delete(idxKeyBytes1);\n+        addCellToDelMutation(idxDel1,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2ODc3MA=="}, "originalCommit": {"oid": "3c11152bee3ce80897faaae2ae8e02f425436c8b"}, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2OTQyMg==", "bodyText": "A delete should beat a Put at the same timestamp, so why is the Put the expected index mutation?", "url": "https://github.com/apache/phoenix/pull/728#discussion_r393369422", "createdAt": "2020-03-16T23:39:12Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,626 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+\n+    class SetupInfo {\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setup(String tableName,\n+                            String indexName,\n+                            String columns,\n+                            String indexColumns,\n+                            String pk,\n+                            String includeColumns) throws Exception {\n+        try(Connection conn = DriverManager.getConnection(getUrl())) {\n+\n+            String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(tableName));\n+            String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(indexName));\n+\n+            String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",\n+                    fullTableName,\n+                    columns,\n+                    pk);\n+            conn.createStatement().execute(str1);\n+\n+            String str2 = String.format(\"CREATE INDEX %1$s ON %2$s (%3$s)\",\n+                    fullIndexName,\n+                    fullTableName,\n+                    indexColumns);\n+            if (!includeColumns.isEmpty())\n+                str2 += \" INCLUDE (\" + includeColumns + \")\";\n+            conn.createStatement().execute(str2);\n+\n+            PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+            PTable pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullIndexName));\n+            PTable pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+            IndexMaintainer im = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+\n+            SetupInfo info = new SetupInfo();\n+            info.indexMaintainer = im;\n+            info.pDataTable = pDataTable;\n+            return info;\n+        }\n+    }\n+\n+    @Test\n+    public void testSinglePutOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(\"v1\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSinglePutOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        Put idxPut2 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDeleteAllVersions() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 2);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        byte[] idxKeyBytes1 = generateIndexRowKey(\"v1\");\n+        byte[] idxKeyBytes2 = generateIndexRowKey(\"v2\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes1);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel1 = new Delete(idxKeyBytes1);\n+        addCellToDelMutation(idxDel1,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel1);\n+\n+        Delete idxDel2 = new Delete(idxKeyBytes2);\n+        addCellToDelMutation(idxDel2,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testPutDeleteOnSameTimeStamp() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable,1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c11152bee3ce80897faaae2ae8e02f425436c8b"}, "originalPosition": 356}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3MTA0NA==", "bodyText": "Comment here would also be helpful. I believe this is because you're deleting the only indexed column, so that translates into a delete of the whole row on the index side, which is fine, but I had to read it a couple of times to figure that out.", "url": "https://github.com/apache/phoenix/pull/728#discussion_r393371044", "createdAt": "2020-03-16T23:45:09Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,626 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+\n+    class SetupInfo {\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setup(String tableName,\n+                            String indexName,\n+                            String columns,\n+                            String indexColumns,\n+                            String pk,\n+                            String includeColumns) throws Exception {\n+        try(Connection conn = DriverManager.getConnection(getUrl())) {\n+\n+            String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(tableName));\n+            String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(indexName));\n+\n+            String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",\n+                    fullTableName,\n+                    columns,\n+                    pk);\n+            conn.createStatement().execute(str1);\n+\n+            String str2 = String.format(\"CREATE INDEX %1$s ON %2$s (%3$s)\",\n+                    fullIndexName,\n+                    fullTableName,\n+                    indexColumns);\n+            if (!includeColumns.isEmpty())\n+                str2 += \" INCLUDE (\" + includeColumns + \")\";\n+            conn.createStatement().execute(str2);\n+\n+            PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+            PTable pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullIndexName));\n+            PTable pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+            IndexMaintainer im = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+\n+            SetupInfo info = new SetupInfo();\n+            info.indexMaintainer = im;\n+            info.pDataTable = pDataTable;\n+            return info;\n+        }\n+    }\n+\n+    @Test\n+    public void testSinglePutOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(\"v1\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSinglePutOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        Put idxPut2 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDeleteAllVersions() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 2);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        byte[] idxKeyBytes1 = generateIndexRowKey(\"v1\");\n+        byte[] idxKeyBytes2 = generateIndexRowKey(\"v2\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes1);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel1 = new Delete(idxKeyBytes1);\n+        addCellToDelMutation(idxDel1,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel1);\n+\n+        Delete idxDel2 = new Delete(idxKeyBytes2);\n+        addCellToDelMutation(idxDel2,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testPutDeleteOnSameTimeStamp() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable,1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testCoveredIndexColumns() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"C2\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c11152bee3ce80897faaae2ae8e02f425436c8b"}, "originalPosition": 371}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3ODM3OA==", "bodyText": "Comment to explain that the DeleteColumn on CF1 removes the only indexed column and thus removes the covered column in CF2", "url": "https://github.com/apache/phoenix/pull/728#discussion_r393378378", "createdAt": "2020-03-17T00:12:29Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,626 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+\n+    class SetupInfo {\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setup(String tableName,\n+                            String indexName,\n+                            String columns,\n+                            String indexColumns,\n+                            String pk,\n+                            String includeColumns) throws Exception {\n+        try(Connection conn = DriverManager.getConnection(getUrl())) {\n+\n+            String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(tableName));\n+            String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(indexName));\n+\n+            String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",\n+                    fullTableName,\n+                    columns,\n+                    pk);\n+            conn.createStatement().execute(str1);\n+\n+            String str2 = String.format(\"CREATE INDEX %1$s ON %2$s (%3$s)\",\n+                    fullIndexName,\n+                    fullTableName,\n+                    indexColumns);\n+            if (!includeColumns.isEmpty())\n+                str2 += \" INCLUDE (\" + includeColumns + \")\";\n+            conn.createStatement().execute(str2);\n+\n+            PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+            PTable pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullIndexName));\n+            PTable pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+            IndexMaintainer im = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+\n+            SetupInfo info = new SetupInfo();\n+            info.indexMaintainer = im;\n+            info.pDataTable = pDataTable;\n+            return info;\n+        }\n+    }\n+\n+    @Test\n+    public void testSinglePutOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(\"v1\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSinglePutOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        Put idxPut2 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDeleteAllVersions() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 2);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        byte[] idxKeyBytes1 = generateIndexRowKey(\"v1\");\n+        byte[] idxKeyBytes2 = generateIndexRowKey(\"v2\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes1);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel1 = new Delete(idxKeyBytes1);\n+        addCellToDelMutation(idxDel1,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel1);\n+\n+        Delete idxDel2 = new Delete(idxKeyBytes2);\n+        addCellToDelMutation(idxDel2,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testPutDeleteOnSameTimeStamp() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable,1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testCoveredIndexColumns() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"C2\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addCellToPutMutation(idxPut1,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                Bytes.toBytes(\"0:C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes2 = com.google.common.primitives.Bytes.toArray(idxKey2);\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addCellToPutMutation(idxPut2,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                Bytes.toBytes(\"0:C2\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testForMultipleFamilies() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, CF1.C1 VARCHAR, CF2.C2 VARCHAR\",\n+                \"CF1.C1\",\n+                \"ROW_KEY\",\n+                \"CF2.C2\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                Bytes.toBytes(\"CF1\"),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                Bytes.toBytes(\"CF1\"),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addCellToPutMutation(idxPut1,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"CF2:C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        Put idxPut2 = new Put(generateIndexRowKey(null));\n+        addCellToPutMutation(idxPut2,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"CF2:C2\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c11152bee3ce80897faaae2ae8e02f425436c8b"}, "originalPosition": 487}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3ODQyMA==", "bodyText": "testDeleteForMultipleFamilies", "url": "https://github.com/apache/phoenix/pull/728#discussion_r393378420", "createdAt": "2020-03-17T00:12:42Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,626 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+\n+    class SetupInfo {\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setup(String tableName,\n+                            String indexName,\n+                            String columns,\n+                            String indexColumns,\n+                            String pk,\n+                            String includeColumns) throws Exception {\n+        try(Connection conn = DriverManager.getConnection(getUrl())) {\n+\n+            String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(tableName));\n+            String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(indexName));\n+\n+            String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",\n+                    fullTableName,\n+                    columns,\n+                    pk);\n+            conn.createStatement().execute(str1);\n+\n+            String str2 = String.format(\"CREATE INDEX %1$s ON %2$s (%3$s)\",\n+                    fullIndexName,\n+                    fullTableName,\n+                    indexColumns);\n+            if (!includeColumns.isEmpty())\n+                str2 += \" INCLUDE (\" + includeColumns + \")\";\n+            conn.createStatement().execute(str2);\n+\n+            PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+            PTable pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullIndexName));\n+            PTable pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+            IndexMaintainer im = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+\n+            SetupInfo info = new SetupInfo();\n+            info.indexMaintainer = im;\n+            info.pDataTable = pDataTable;\n+            return info;\n+        }\n+    }\n+\n+    @Test\n+    public void testSinglePutOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(\"v1\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSinglePutOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        Put idxPut2 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDeleteAllVersions() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 2);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        byte[] idxKeyBytes1 = generateIndexRowKey(\"v1\");\n+        byte[] idxKeyBytes2 = generateIndexRowKey(\"v2\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes1);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel1 = new Delete(idxKeyBytes1);\n+        addCellToDelMutation(idxDel1,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel1);\n+\n+        Delete idxDel2 = new Delete(idxKeyBytes2);\n+        addCellToDelMutation(idxDel2,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testPutDeleteOnSameTimeStamp() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable,1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testCoveredIndexColumns() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"C2\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addCellToPutMutation(idxPut1,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                Bytes.toBytes(\"0:C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes2 = com.google.common.primitives.Bytes.toArray(idxKey2);\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addCellToPutMutation(idxPut2,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                Bytes.toBytes(\"0:C2\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testForMultipleFamilies() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c11152bee3ce80897faaae2ae8e02f425436c8b"}, "originalPosition": 432}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3ODk3Ng==", "bodyText": "we should use CellUtil.createCell rather than making KeyValues directly. (KeyValues are InterfaceAudience.Private, which means that projects outside of HBase shouldn't refer to them.)", "url": "https://github.com/apache/phoenix/pull/728#discussion_r393378976", "createdAt": "2020-03-17T00:15:19Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,626 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+\n+    class SetupInfo {\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setup(String tableName,\n+                            String indexName,\n+                            String columns,\n+                            String indexColumns,\n+                            String pk,\n+                            String includeColumns) throws Exception {\n+        try(Connection conn = DriverManager.getConnection(getUrl())) {\n+\n+            String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(tableName));\n+            String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(indexName));\n+\n+            String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",\n+                    fullTableName,\n+                    columns,\n+                    pk);\n+            conn.createStatement().execute(str1);\n+\n+            String str2 = String.format(\"CREATE INDEX %1$s ON %2$s (%3$s)\",\n+                    fullIndexName,\n+                    fullTableName,\n+                    indexColumns);\n+            if (!includeColumns.isEmpty())\n+                str2 += \" INCLUDE (\" + includeColumns + \")\";\n+            conn.createStatement().execute(str2);\n+\n+            PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+            PTable pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullIndexName));\n+            PTable pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+            IndexMaintainer im = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+\n+            SetupInfo info = new SetupInfo();\n+            info.indexMaintainer = im;\n+            info.pDataTable = pDataTable;\n+            return info;\n+        }\n+    }\n+\n+    @Test\n+    public void testSinglePutOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(\"v1\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSinglePutOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        Put idxPut2 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDeleteAllVersions() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 2);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        byte[] idxKeyBytes1 = generateIndexRowKey(\"v1\");\n+        byte[] idxKeyBytes2 = generateIndexRowKey(\"v2\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes1);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel1 = new Delete(idxKeyBytes1);\n+        addCellToDelMutation(idxDel1,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel1);\n+\n+        Delete idxDel2 = new Delete(idxKeyBytes2);\n+        addCellToDelMutation(idxDel2,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testPutDeleteOnSameTimeStamp() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable,1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testCoveredIndexColumns() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"C2\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addCellToPutMutation(idxPut1,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                Bytes.toBytes(\"0:C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes2 = com.google.common.primitives.Bytes.toArray(idxKey2);\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addCellToPutMutation(idxPut2,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                Bytes.toBytes(\"0:C2\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testForMultipleFamilies() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, CF1.C1 VARCHAR, CF2.C2 VARCHAR\",\n+                \"CF1.C1\",\n+                \"ROW_KEY\",\n+                \"CF2.C2\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                Bytes.toBytes(\"CF1\"),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                Bytes.toBytes(\"CF1\"),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addCellToPutMutation(idxPut1,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"CF2:C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        Put idxPut2 = new Put(generateIndexRowKey(null));\n+        addCellToPutMutation(idxPut2,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"CF2:C2\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                Bytes.toBytes(\"CF2\"),\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSameTypeOfMutationWithDifferentTimeStamp() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v3\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 2);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(null);\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1, (Mutation)idxPut2), actualIndexMutations);\n+    }\n+\n+    byte[] generateIndexRowKey(String indexVal) {\n+        List<Byte> idxKey = new ArrayList<>();\n+        if (indexVal != null && !indexVal.isEmpty())\n+            idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(indexVal)));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        return com.google.common.primitives.Bytes.toArray(idxKey);\n+    }\n+\n+    void addCellToPutMutation(Put put, byte[] family, byte[] column, long ts, byte[] value) throws Exception {\n+        byte[] rowKey = put.getRow();\n+        Cell cell = new KeyValue(rowKey, family, column, ts, KeyValue.Type.Put, value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c11152bee3ce80897faaae2ae8e02f425436c8b"}, "originalPosition": 546}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3OTA3Nw==", "bodyText": "Ditto with the KeyValue usage here: should use Cell / CellUtil APIs.", "url": "https://github.com/apache/phoenix/pull/728#discussion_r393379077", "createdAt": "2020-03-17T00:15:46Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,626 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+\n+    class SetupInfo {\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    private SetupInfo setup(String tableName,\n+                            String indexName,\n+                            String columns,\n+                            String indexColumns,\n+                            String pk,\n+                            String includeColumns) throws Exception {\n+        try(Connection conn = DriverManager.getConnection(getUrl())) {\n+\n+            String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(tableName));\n+            String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(indexName));\n+\n+            String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",\n+                    fullTableName,\n+                    columns,\n+                    pk);\n+            conn.createStatement().execute(str1);\n+\n+            String str2 = String.format(\"CREATE INDEX %1$s ON %2$s (%3$s)\",\n+                    fullIndexName,\n+                    fullTableName,\n+                    indexColumns);\n+            if (!includeColumns.isEmpty())\n+                str2 += \" INCLUDE (\" + includeColumns + \")\";\n+            conn.createStatement().execute(str2);\n+\n+            PhoenixConnection pconn = conn.unwrap(PhoenixConnection.class);\n+            PTable pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullIndexName));\n+            PTable pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), fullTableName));\n+            IndexMaintainer im = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+\n+            SetupInfo info = new SetupInfo();\n+            info.indexMaintainer = im;\n+            info.pDataTable = pDataTable;\n+            return info;\n+        }\n+    }\n+\n+    @Test\n+    public void testSinglePutOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(\"v1\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSinglePutOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        Put idxPut2 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDelOnNonIndexColumn() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testDeleteAllVersions() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 2);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        byte[] idxKeyBytes1 = generateIndexRowKey(\"v1\");\n+        byte[] idxKeyBytes2 = generateIndexRowKey(\"v2\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes1);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel1 = new Delete(idxKeyBytes1);\n+        addCellToDelMutation(idxDel1,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel1);\n+\n+        Delete idxDel2 = new Delete(idxKeyBytes2);\n+        addCellToDelMutation(idxDel2,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                null,\n+                3,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel2);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testPutDeleteOnSameTimeStamp() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable,1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+\n+        Put idxPut1 = new Put(generateIndexRowKey(null));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1), actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testCoveredIndexColumns() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"C2\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutations = new ArrayList<>();\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addCellToPutMutation(idxPut1,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                Bytes.toBytes(\"0:C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutations.add(idxPut1);\n+\n+        List<Byte> idxKey2 = new ArrayList<>();\n+        idxKey2.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey2.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        byte[] idxKeyBytes2 = com.google.common.primitives.Bytes.toArray(idxKey2);\n+        Put idxPut2 = new Put(idxKeyBytes2);\n+        addCellToPutMutation(idxPut2,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                Bytes.toBytes(\"0:C2\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutations.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES,\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutations.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutations, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testForMultipleFamilies() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, CF1.C1 VARCHAR, CF2.C2 VARCHAR\",\n+                \"CF1.C1\",\n+                \"ROW_KEY\",\n+                \"CF2.C2\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                Bytes.toBytes(\"CF1\"),\n+                Bytes.toBytes(\"C1\"),\n+                1,\n+                Bytes.toBytes(\"v1\"));\n+        addCellToPutMutation(dataPut,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+\n+        Delete dataDel = new Delete(Bytes.toBytes(ROW_KEY));\n+        addCellToDelMutation(dataDel,\n+                Bytes.toBytes(\"CF1\"),\n+                Bytes.toBytes(\"C1\"),\n+                2,\n+                KeyValue.Type.DeleteColumn);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                dataDel);\n+\n+        List<Mutation> expectedIndexMutation = new ArrayList<>();\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(\"v1\");\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addCellToPutMutation(idxPut1,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"CF2:C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+        expectedIndexMutation.add(idxPut1);\n+\n+        Put idxPut2 = new Put(generateIndexRowKey(null));\n+        addCellToPutMutation(idxPut2,\n+                Bytes.toBytes(\"CF2\"),\n+                Bytes.toBytes(\"CF2:C2\"),\n+                2,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+        expectedIndexMutation.add(idxPut2);\n+\n+        Delete idxDel = new Delete(idxKeyBytes);\n+        addCellToDelMutation(idxDel,\n+                Bytes.toBytes(\"CF2\"),\n+                null,\n+                2,\n+                KeyValue.Type.DeleteFamily);\n+        expectedIndexMutation.add(idxDel);\n+\n+        assertEqualMutationList(expectedIndexMutation, actualIndexMutations);\n+    }\n+\n+    @Test\n+    public void testSameTypeOfMutationWithDifferentTimeStamp() throws Exception {\n+        SetupInfo info = setup(TABLE_NAME,\n+                INDEX_NAME,\n+                \"ROW_KEY VARCHAR, C1 VARCHAR, C2 VARCHAR\",\n+                \"C1\",\n+                \"ROW_KEY\",\n+                \"\");\n+\n+        Put dataPut = new Put(Bytes.toBytes(ROW_KEY));\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v2\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 1);\n+        addCellToPutMutation(dataPut,\n+                info.indexMaintainer.getEmptyKeyValueFamily().copyBytesIfNecessary(),\n+                Bytes.toBytes(\"C2\"),\n+                1,\n+                Bytes.toBytes(\"v3\"));\n+        addEmptyColumnToDataPutMutation(dataPut, info.pDataTable, 2);\n+\n+        List<Mutation> actualIndexMutations = IndexRebuildRegionScanner.prepareIndexMutationsForRebuild(info.indexMaintainer,\n+                dataPut,\n+                null);\n+\n+        byte[] idxKeyBytes = generateIndexRowKey(null);\n+\n+        Put idxPut1 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut1, info.indexMaintainer, 1);\n+\n+        Put idxPut2 = new Put(idxKeyBytes);\n+        addEmptyColumnToIndexPutMutation(idxPut2, info.indexMaintainer, 2);\n+\n+        assertEqualMutationList(Arrays.asList((Mutation)idxPut1, (Mutation)idxPut2), actualIndexMutations);\n+    }\n+\n+    byte[] generateIndexRowKey(String indexVal) {\n+        List<Byte> idxKey = new ArrayList<>();\n+        if (indexVal != null && !indexVal.isEmpty())\n+            idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(indexVal)));\n+        idxKey.add(QueryConstants.SEPARATOR_BYTE);\n+        idxKey.addAll(com.google.common.primitives.Bytes.asList(Bytes.toBytes(ROW_KEY)));\n+        return com.google.common.primitives.Bytes.toArray(idxKey);\n+    }\n+\n+    void addCellToPutMutation(Put put, byte[] family, byte[] column, long ts, byte[] value) throws Exception {\n+        byte[] rowKey = put.getRow();\n+        Cell cell = new KeyValue(rowKey, family, column, ts, KeyValue.Type.Put, value);\n+        put.add(cell);\n+    }\n+\n+    void addCellToDelMutation(Delete del, byte[] family, byte[] column, long ts, KeyValue.Type type) throws Exception {\n+        byte[] rowKey = del.getRow();\n+        Cell cell = new KeyValue(rowKey, family, column, ts, type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c11152bee3ce80897faaae2ae8e02f425436c8b"}, "originalPosition": 552}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fa32b216578c6922871e393983fa3caad981dfc", "author": {"user": {"login": "wangweiming800", "name": "Weiming Wang"}}, "url": "https://github.com/apache/phoenix/commit/6fa32b216578c6922871e393983fa3caad981dfc", "committedDate": "2020-03-18T02:43:53Z", "message": "Fix the comments from Geoffrey."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MTIzNzUw", "url": "https://github.com/apache/phoenix/pull/728#pullrequestreview-377123750", "createdAt": "2020-03-18T18:18:55Z", "commit": {"oid": "6fa32b216578c6922871e393983fa3caad981dfc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODoxODo1NVrOF4RdvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODoxODo1NVrOF4RdvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU1MDcxNw==", "bodyText": "why not use string buffer instead?", "url": "https://github.com/apache/phoenix/pull/728#discussion_r394550717", "createdAt": "2020-03-18T18:18:55Z", "author": {"login": "swaroopak"}, "path": "phoenix-core/src/test/java/org/apache/phoenix/index/PrepareIndexMutationsForRebuildTest.java", "diffHunk": "@@ -0,0 +1,732 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.phoenix.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.hbase.index.IndexRegionObserver;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class PrepareIndexMutationsForRebuildTest extends BaseConnectionlessQueryTest {\n+    private static String ROW_KEY = \"k1\";\n+    private static String TABLE_NAME = \"dataTable\";\n+    private static String INDEX_NAME = \"idx\";\n+\n+    class SetupInfo {\n+        public IndexMaintainer indexMaintainer;\n+        public PTable pDataTable;\n+    }\n+\n+    /**\n+     * Get the index maintainer and phoenix table definition of data table.\n+     * @param tableName\n+     * @param indexName\n+     * @param columns\n+     * @param indexColumns\n+     * @param pk\n+     * @param includeColumns\n+     * @return\n+     * @throws Exception\n+     */\n+    private SetupInfo setup(String tableName,\n+                            String indexName,\n+                            String columns,\n+                            String indexColumns,\n+                            String pk,\n+                            String includeColumns) throws Exception {\n+        try(Connection conn = DriverManager.getConnection(getUrl())) {\n+\n+            String fullTableName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(tableName));\n+            String fullIndexName = SchemaUtil.getTableName(SchemaUtil.normalizeIdentifier(\"\"), SchemaUtil.normalizeIdentifier(indexName));\n+\n+            // construct the data table and index based from the parameters\n+            String str1 = String.format(\"CREATE TABLE %1$s (%2$s CONSTRAINT pk PRIMARY KEY (%3$s)) COLUMN_ENCODED_BYTES=0\",\n+                    fullTableName,\n+                    columns,\n+                    pk);\n+            conn.createStatement().execute(str1);\n+\n+            String str2 = String.format(\"CREATE INDEX %1$s ON %2$s (%3$s)\",\n+                    fullIndexName,\n+                    fullTableName,\n+                    indexColumns);\n+            if (!includeColumns.isEmpty())\n+                str2 += \" INCLUDE (\" + includeColumns + \")\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6fa32b216578c6922871e393983fa3caad981dfc"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3OTgyMjQ2", "url": "https://github.com/apache/phoenix/pull/728#pullrequestreview-377982246", "createdAt": "2020-03-19T18:21:36Z", "commit": {"oid": "6fa32b216578c6922871e393983fa3caad981dfc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MTg0MjA5", "url": "https://github.com/apache/phoenix/pull/728#pullrequestreview-378184209", "createdAt": "2020-03-20T00:49:29Z", "commit": {"oid": "6fa32b216578c6922871e393983fa3caad981dfc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NzI1Nzg3", "url": "https://github.com/apache/phoenix/pull/728#pullrequestreview-378725787", "createdAt": "2020-03-20T18:36:40Z", "commit": {"oid": "6fa32b216578c6922871e393983fa3caad981dfc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1960, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}