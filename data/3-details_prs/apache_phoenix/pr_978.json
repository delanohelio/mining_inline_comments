{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0MzQxMzIw", "number": 978, "title": "[PHOENIX-6213] Extend Cell Tags to Delete object to store source of operation.", "bodyText": "Changes done in this PR:\n\nAdded a new property in ConnectionQueryServices phoenix.source.operation The client will set this in Properties object to create the connection. This indicates the metadata about what is the source of the operation. for e.g. customer-delete, internal-service-delete, etc.\nChanged MutationState and UngroupedAggregateRegionScanner to propagate the attribute from PhoenixConnection to mutation object\nAdded a method in  IndexRegionObserver to add the attribute from mutation object to cell as tags.", "createdAt": "2020-11-20T01:04:42Z", "url": "https://github.com/apache/phoenix/pull/978", "merged": true, "mergeCommit": {"oid": "8d0a02e25a5119b16dd0b1d8d1e001e3b46c102b"}, "closed": true, "closedAt": "2020-12-07T20:48:21Z", "author": {"login": "shahrs87"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdegHIhgFqTUzNTg0MDg5MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdj71SJgFqTU0NjUyMjYxMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1ODQwODkx", "url": "https://github.com/apache/phoenix/pull/978#pullrequestreview-535840891", "createdAt": "2020-11-20T23:27:17Z", "commit": {"oid": "fee9340821e47f2207399991359d7afa029b0fd4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMzoyNzoxOFrOH3j9Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMzozNzowMFrOH3kHjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyMjgyMw==", "bodyText": "See RawCell, which unlike the Cell tag methods, isn't deprecated, and is IA LimitedPrivate.COPROC. You'll probably have to downcast.", "url": "https://github.com/apache/phoenix/pull/978#discussion_r528022823", "createdAt": "2020-11-20T23:27:18Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/hbase/index/IndexRegionObserver.java", "diffHunk": "@@ -991,6 +999,46 @@ public void preBatchMutateWithExceptions(ObserverContext<RegionCoprocessorEnviro\n         }\n     }\n \n+    /*\n+        Set Cell Tags to delete markers with source of operation attribute.\n+     */\n+    private void setDeleteAttributes(MiniBatchOperationInProgress<Mutation> miniBatchOp)\n+            throws IOException {\n+        for (int i = 0; i < miniBatchOp.size(); i++) {\n+            Mutation m = miniBatchOp.getOperation(i);\n+            if (!(m instanceof  Delete)) {\n+                // Ignore if it is not Delete type.\n+                continue;\n+            }\n+            byte[] sourceOpAttr = m.getAttribute(QueryServices.SOURCE_OPERATION_ATTRIB);\n+            if (sourceOpAttr == null) {\n+                continue;\n+            }\n+\n+            // TODO: Which tag implementation to use ? ArrayBackedTag or ByteBufferTag ?\n+            Tag sourceOpTag = new ArrayBackedTag(PhoenixTagType.SOURCE_OPERATION_TAG_TYPE, sourceOpAttr);\n+            List<Cell> updatedCells = new ArrayList<>();\n+            for (CellScanner cellScanner = m.cellScanner(); cellScanner.advance();) {\n+                Cell cell = cellScanner.current();\n+                // TODO: Cell#getTagsArray, Cell#getTagsOffset, Cell#getTagsLength are deprecated.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee9340821e47f2207399991359d7afa029b0fd4"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyMzM4MA==", "bodyText": "I believe ArrayBackedTag is for Cells built on the heap, and ByteBufferTag is for Cells built off-heap. You're building Cells on-heap, so I assume you'd want ArrayBackedTag. That said, we need to be very careful we're not accidentally leaking memory here by swapping the provided Cells with new ones -- I'm not clear on when the underlying HBase is using on-heap vs off-heap Cells. Needs more research", "url": "https://github.com/apache/phoenix/pull/978#discussion_r528023380", "createdAt": "2020-11-20T23:29:36Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/hbase/index/IndexRegionObserver.java", "diffHunk": "@@ -991,6 +999,46 @@ public void preBatchMutateWithExceptions(ObserverContext<RegionCoprocessorEnviro\n         }\n     }\n \n+    /*\n+        Set Cell Tags to delete markers with source of operation attribute.\n+     */\n+    private void setDeleteAttributes(MiniBatchOperationInProgress<Mutation> miniBatchOp)\n+            throws IOException {\n+        for (int i = 0; i < miniBatchOp.size(); i++) {\n+            Mutation m = miniBatchOp.getOperation(i);\n+            if (!(m instanceof  Delete)) {\n+                // Ignore if it is not Delete type.\n+                continue;\n+            }\n+            byte[] sourceOpAttr = m.getAttribute(QueryServices.SOURCE_OPERATION_ATTRIB);\n+            if (sourceOpAttr == null) {\n+                continue;\n+            }\n+\n+            // TODO: Which tag implementation to use ? ArrayBackedTag or ByteBufferTag ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee9340821e47f2207399991359d7afa029b0fd4"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyMzg0Mw==", "bodyText": "See RawCellBuilder, which is IA LimitedPrivate.COPROC.", "url": "https://github.com/apache/phoenix/pull/978#discussion_r528023843", "createdAt": "2020-11-20T23:30:59Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/hbase/index/IndexRegionObserver.java", "diffHunk": "@@ -991,6 +999,46 @@ public void preBatchMutateWithExceptions(ObserverContext<RegionCoprocessorEnviro\n         }\n     }\n \n+    /*\n+        Set Cell Tags to delete markers with source of operation attribute.\n+     */\n+    private void setDeleteAttributes(MiniBatchOperationInProgress<Mutation> miniBatchOp)\n+            throws IOException {\n+        for (int i = 0; i < miniBatchOp.size(); i++) {\n+            Mutation m = miniBatchOp.getOperation(i);\n+            if (!(m instanceof  Delete)) {\n+                // Ignore if it is not Delete type.\n+                continue;\n+            }\n+            byte[] sourceOpAttr = m.getAttribute(QueryServices.SOURCE_OPERATION_ATTRIB);\n+            if (sourceOpAttr == null) {\n+                continue;\n+            }\n+\n+            // TODO: Which tag implementation to use ? ArrayBackedTag or ByteBufferTag ?\n+            Tag sourceOpTag = new ArrayBackedTag(PhoenixTagType.SOURCE_OPERATION_TAG_TYPE, sourceOpAttr);\n+            List<Cell> updatedCells = new ArrayList<>();\n+            for (CellScanner cellScanner = m.cellScanner(); cellScanner.advance();) {\n+                Cell cell = cellScanner.current();\n+                // TODO: Cell#getTagsArray, Cell#getTagsOffset, Cell#getTagsLength are deprecated.\n+                //TODO: Need to replace them with new methods.\n+                List<Tag> tags = TagUtil.asList(cell.getTagsArray(), cell.getTagsOffset(),\n+                        cell.getTagsLength());\n+                tags.add(sourceOpTag);\n+                // TODO: PrivateCellUtil's IA is Private. Need to change it to LP with\n+                // TODO: IA.COPROC.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee9340821e47f2207399991359d7afa029b0fd4"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNDUzMQ==", "bodyText": "PrivateCellUtil is IA.Private -- need to use one of the IA.LimitedPrivate or better classes such as RawCell", "url": "https://github.com/apache/phoenix/pull/978#discussion_r528024531", "createdAt": "2020-11-20T23:33:31Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +960,164 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, \"ClientSelectDeleteMutationPlan\", props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ServerSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteServerDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName;\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ServerSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, \"ServerSelectDeleteMutationPlan\", props);\n+        executeDelete(delete, props, 2);\n+\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        MultiRowDeleteMutationPlan.\n+    */\n+    @Test\n+    public void testDeleteMultiRowDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE k = 1\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+        // Don't create index table. We will use MultiRowDeleteMutationPlan\n+        // if there is no index present for a table.\n+        createAndUpsertTable(tableName, null, props);\n+        // Make sure that the plan creates is of MultiRowDeleteMutationPlan\n+        verifyDeletePlan(delete, \"MultiRowDeleteMutationPlan\", props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        // Make sure that Delete Marker has cell tag for base table.\n+        // We haven't created index table for this test case.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+    }\n+\n+    /*\n+        Verify whether plan that we create for delete statement is of planName\n+     */\n+    private void verifyDeletePlan(String delete, String planName, Properties props)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            PhoenixStatement stmt = conn.createStatement().unwrap(PhoenixStatement.class);\n+            SQLParser parser = new SQLParser(delete);\n+            DeleteStatement deleteStmt = (DeleteStatement) parser.parseStatement();\n+            DeleteCompiler compiler = new DeleteCompiler(stmt, null);\n+            MutationPlan plan = compiler.compile(deleteStmt);\n+            assertTrue(plan.getClass().getName().contains(planName));\n+        }\n+    }\n+    private void createAndUpsertTable(String tableName, String indexName, Properties props)\n+            throws SQLException {\n+        String ddl = \"CREATE TABLE \" + tableName +\n+                \" (k INTEGER NOT NULL PRIMARY KEY, v1 VARCHAR, v2 VARCHAR)\";\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                statement.execute(ddl);\n+                if (indexName != null) {\n+                    String indexDdl1 = \"CREATE INDEX \" + indexName + \" ON \" + tableName + \"(v1,v2)\";\n+                    statement.execute(indexDdl1);\n+                }\n+            }\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (1, 'foo', 'foo1')\");\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (2, 'bar', 'bar1')\");\n+            conn.commit();\n+        }\n+    }\n+\n+    private void executeDelete(String delete, Properties props, int deleteRowCount)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                int rs = statement.executeUpdate(delete);\n+                assertEquals( deleteRowCount, rs);\n+            }\n+        }\n+    }\n \n+    /*\n+        Verify whether we have tags present for base table and not present for\n+        index tables.\n+     */\n+    private void checkTagPresentInDeleteMarker(String tableName, String startRowKey,\n+            boolean tagPresent, String tagValue) throws IOException {\n+        List<Cell> values = new ArrayList<>();\n+        TableName table = TableName.valueOf(tableName);\n+        // Scan table with specified startRowKey\n+        for (HRegion region : getUtility().getHBaseCluster().getRegions(table)) {\n+            values.clear();\n+            Scan scan = new Scan();\n+            // Make sure to set rawScan to true so that we will get Delete Markers.\n+            scan.setRaw(true);\n+            scan.withStartRow(Bytes.toBytes(startRowKey));\n+            RegionScanner scanner = region.getScanner(scan);\n+            scanner.next(values);\n+            if (!values.isEmpty()) {\n+                break;\n+            }\n+        }\n+        assertTrue(\"Values shouldn't be empty\", !values.isEmpty());\n+        Cell first = values.get(0);\n+        assertTrue(\"First cell should be delete marker \",\n+                PrivateCellUtil.isDelete(first.getType().getCode()));\n+        List<Tag> tags = PrivateCellUtil.getTags(first);\n+        if (tagPresent) {\n+            assertEquals(1, tags.size());\n+            Optional<Tag> optional =\n+                    PrivateCellUtil.getTag(first, PhoenixTagType.SOURCE_OPERATION_TAG_TYPE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee9340821e47f2207399991359d7afa029b0fd4"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNDc4NA==", "bodyText": "rather than hardcode the string, can use the class name", "url": "https://github.com/apache/phoenix/pull/978#discussion_r528024784", "createdAt": "2020-11-20T23:34:23Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +960,164 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, \"ClientSelectDeleteMutationPlan\", props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ServerSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteServerDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName;\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ServerSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, \"ServerSelectDeleteMutationPlan\", props);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee9340821e47f2207399991359d7afa029b0fd4"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNDg3MA==", "bodyText": "Rather than hardcode the string, can use the classname", "url": "https://github.com/apache/phoenix/pull/978#discussion_r528024870", "createdAt": "2020-11-20T23:34:39Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +960,164 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, \"ClientSelectDeleteMutationPlan\", props);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee9340821e47f2207399991359d7afa029b0fd4"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNTQ4NA==", "bodyText": "Can use CellUtil.isDelete, which is IA.Public", "url": "https://github.com/apache/phoenix/pull/978#discussion_r528025484", "createdAt": "2020-11-20T23:37:00Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +960,164 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, \"ClientSelectDeleteMutationPlan\", props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ServerSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteServerDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName;\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ServerSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, \"ServerSelectDeleteMutationPlan\", props);\n+        executeDelete(delete, props, 2);\n+\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        MultiRowDeleteMutationPlan.\n+    */\n+    @Test\n+    public void testDeleteMultiRowDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE k = 1\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+        // Don't create index table. We will use MultiRowDeleteMutationPlan\n+        // if there is no index present for a table.\n+        createAndUpsertTable(tableName, null, props);\n+        // Make sure that the plan creates is of MultiRowDeleteMutationPlan\n+        verifyDeletePlan(delete, \"MultiRowDeleteMutationPlan\", props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        // Make sure that Delete Marker has cell tag for base table.\n+        // We haven't created index table for this test case.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+    }\n+\n+    /*\n+        Verify whether plan that we create for delete statement is of planName\n+     */\n+    private void verifyDeletePlan(String delete, String planName, Properties props)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            PhoenixStatement stmt = conn.createStatement().unwrap(PhoenixStatement.class);\n+            SQLParser parser = new SQLParser(delete);\n+            DeleteStatement deleteStmt = (DeleteStatement) parser.parseStatement();\n+            DeleteCompiler compiler = new DeleteCompiler(stmt, null);\n+            MutationPlan plan = compiler.compile(deleteStmt);\n+            assertTrue(plan.getClass().getName().contains(planName));\n+        }\n+    }\n+    private void createAndUpsertTable(String tableName, String indexName, Properties props)\n+            throws SQLException {\n+        String ddl = \"CREATE TABLE \" + tableName +\n+                \" (k INTEGER NOT NULL PRIMARY KEY, v1 VARCHAR, v2 VARCHAR)\";\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                statement.execute(ddl);\n+                if (indexName != null) {\n+                    String indexDdl1 = \"CREATE INDEX \" + indexName + \" ON \" + tableName + \"(v1,v2)\";\n+                    statement.execute(indexDdl1);\n+                }\n+            }\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (1, 'foo', 'foo1')\");\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (2, 'bar', 'bar1')\");\n+            conn.commit();\n+        }\n+    }\n+\n+    private void executeDelete(String delete, Properties props, int deleteRowCount)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                int rs = statement.executeUpdate(delete);\n+                assertEquals( deleteRowCount, rs);\n+            }\n+        }\n+    }\n \n+    /*\n+        Verify whether we have tags present for base table and not present for\n+        index tables.\n+     */\n+    private void checkTagPresentInDeleteMarker(String tableName, String startRowKey,\n+            boolean tagPresent, String tagValue) throws IOException {\n+        List<Cell> values = new ArrayList<>();\n+        TableName table = TableName.valueOf(tableName);\n+        // Scan table with specified startRowKey\n+        for (HRegion region : getUtility().getHBaseCluster().getRegions(table)) {\n+            values.clear();\n+            Scan scan = new Scan();\n+            // Make sure to set rawScan to true so that we will get Delete Markers.\n+            scan.setRaw(true);\n+            scan.withStartRow(Bytes.toBytes(startRowKey));\n+            RegionScanner scanner = region.getScanner(scan);\n+            scanner.next(values);\n+            if (!values.isEmpty()) {\n+                break;\n+            }\n+        }\n+        assertTrue(\"Values shouldn't be empty\", !values.isEmpty());\n+        Cell first = values.get(0);\n+        assertTrue(\"First cell should be delete marker \",\n+                PrivateCellUtil.isDelete(first.getType().getCode()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee9340821e47f2207399991359d7afa029b0fd4"}, "originalPosition": 195}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5OTg0NTI5", "url": "https://github.com/apache/phoenix/pull/978#pullrequestreview-539984529", "createdAt": "2020-11-27T13:35:14Z", "commit": {"oid": "36c8afe4dcaad08e866193f7d6ab917b87626705"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxMzozNToxNFrOH6-osA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNDoxMzozN1rOH6_0bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwNTY4MA==", "bodyText": "nit: both these statements can be included with above try (Statement statement = conn.createStatement())", "url": "https://github.com/apache/phoenix/pull/978#discussion_r531605680", "createdAt": "2020-11-27T13:35:14Z", "author": {"login": "virajjasani"}, "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +961,163 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ClientSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ServerSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteServerDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName;\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ServerSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ServerSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 2);\n+\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        MultiRowDeleteMutationPlan.\n+    */\n+    @Test\n+    public void testDeleteMultiRowDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE k = 1\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+        // Don't create index table. We will use MultiRowDeleteMutationPlan\n+        // if there is no index present for a table.\n+        createAndUpsertTable(tableName, null, props);\n+        // Make sure that the plan creates is of MultiRowDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.MultiRowDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        // Make sure that Delete Marker has cell tag for base table.\n+        // We haven't created index table for this test case.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+    }\n+\n+    /*\n+        Verify whether plan that we create for delete statement is of planClass\n+     */\n+    private void verifyDeletePlan(String delete, Class planClass, Properties props)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            PhoenixStatement stmt = conn.createStatement().unwrap(PhoenixStatement.class);\n+            SQLParser parser = new SQLParser(delete);\n+            DeleteStatement deleteStmt = (DeleteStatement) parser.parseStatement();\n+            DeleteCompiler compiler = new DeleteCompiler(stmt, null);\n+            MutationPlan plan = compiler.compile(deleteStmt);\n+            assertEquals(plan.getClass(), planClass);\n+        }\n+    }\n+    private void createAndUpsertTable(String tableName, String indexName, Properties props)\n+            throws SQLException {\n+        String ddl = \"CREATE TABLE \" + tableName +\n+                \" (k INTEGER NOT NULL PRIMARY KEY, v1 VARCHAR, v2 VARCHAR)\";\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                statement.execute(ddl);\n+                if (indexName != null) {\n+                    String indexDdl1 = \"CREATE INDEX \" + indexName + \" ON \" + tableName + \"(v1,v2)\";\n+                    statement.execute(indexDdl1);\n+                }\n+            }\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (1, 'foo', 'foo1')\");\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (2, 'bar', 'bar1')\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36c8afe4dcaad08e866193f7d6ab917b87626705"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYwNjk1MQ==", "bodyText": "nit: Class<? extends MutationPlan> planClass ?", "url": "https://github.com/apache/phoenix/pull/978#discussion_r531606951", "createdAt": "2020-11-27T13:37:46Z", "author": {"login": "virajjasani"}, "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +961,163 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ClientSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ServerSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteServerDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName;\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ServerSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ServerSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 2);\n+\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        MultiRowDeleteMutationPlan.\n+    */\n+    @Test\n+    public void testDeleteMultiRowDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE k = 1\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+        // Don't create index table. We will use MultiRowDeleteMutationPlan\n+        // if there is no index present for a table.\n+        createAndUpsertTable(tableName, null, props);\n+        // Make sure that the plan creates is of MultiRowDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.MultiRowDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        // Make sure that Delete Marker has cell tag for base table.\n+        // We haven't created index table for this test case.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+    }\n+\n+    /*\n+        Verify whether plan that we create for delete statement is of planClass\n+     */\n+    private void verifyDeletePlan(String delete, Class planClass, Properties props)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36c8afe4dcaad08e866193f7d6ab917b87626705"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYxMTAzNg==", "bodyText": "nit: cleaning up entries might not be needed. If values has any record, we will be out of this loop.", "url": "https://github.com/apache/phoenix/pull/978#discussion_r531611036", "createdAt": "2020-11-27T13:45:44Z", "author": {"login": "virajjasani"}, "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +961,163 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ClientSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ServerSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteServerDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName;\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ServerSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ServerSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 2);\n+\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        MultiRowDeleteMutationPlan.\n+    */\n+    @Test\n+    public void testDeleteMultiRowDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE k = 1\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+        // Don't create index table. We will use MultiRowDeleteMutationPlan\n+        // if there is no index present for a table.\n+        createAndUpsertTable(tableName, null, props);\n+        // Make sure that the plan creates is of MultiRowDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.MultiRowDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        // Make sure that Delete Marker has cell tag for base table.\n+        // We haven't created index table for this test case.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+    }\n+\n+    /*\n+        Verify whether plan that we create for delete statement is of planClass\n+     */\n+    private void verifyDeletePlan(String delete, Class planClass, Properties props)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            PhoenixStatement stmt = conn.createStatement().unwrap(PhoenixStatement.class);\n+            SQLParser parser = new SQLParser(delete);\n+            DeleteStatement deleteStmt = (DeleteStatement) parser.parseStatement();\n+            DeleteCompiler compiler = new DeleteCompiler(stmt, null);\n+            MutationPlan plan = compiler.compile(deleteStmt);\n+            assertEquals(plan.getClass(), planClass);\n+        }\n+    }\n+    private void createAndUpsertTable(String tableName, String indexName, Properties props)\n+            throws SQLException {\n+        String ddl = \"CREATE TABLE \" + tableName +\n+                \" (k INTEGER NOT NULL PRIMARY KEY, v1 VARCHAR, v2 VARCHAR)\";\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                statement.execute(ddl);\n+                if (indexName != null) {\n+                    String indexDdl1 = \"CREATE INDEX \" + indexName + \" ON \" + tableName + \"(v1,v2)\";\n+                    statement.execute(indexDdl1);\n+                }\n+            }\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (1, 'foo', 'foo1')\");\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (2, 'bar', 'bar1')\");\n+            conn.commit();\n+        }\n+    }\n+\n+    private void executeDelete(String delete, Properties props, int deleteRowCount)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                int rs = statement.executeUpdate(delete);\n+                assertEquals( deleteRowCount, rs);\n+            }\n+        }\n+    }\n \n+    /*\n+        Verify whether we have tags present for base table and not present for\n+        index tables.\n+     */\n+    private void checkTagPresentInDeleteMarker(String tableName, String startRowKey,\n+            boolean tagPresent, String tagValue) throws IOException {\n+        List<Cell> values = new ArrayList<>();\n+        TableName table = TableName.valueOf(tableName);\n+        // Scan table with specified startRowKey\n+        for (HRegion region : getUtility().getHBaseCluster().getRegions(table)) {\n+            values.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36c8afe4dcaad08e866193f7d6ab917b87626705"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYxMjEzNQ==", "bodyText": "nit: simplify to assertFalse(\"Values shouldn't be empty\", values.isEmpty()); ?", "url": "https://github.com/apache/phoenix/pull/978#discussion_r531612135", "createdAt": "2020-11-27T13:47:56Z", "author": {"login": "virajjasani"}, "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +961,163 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ClientSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ServerSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteServerDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName;\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ServerSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ServerSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 2);\n+\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        MultiRowDeleteMutationPlan.\n+    */\n+    @Test\n+    public void testDeleteMultiRowDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE k = 1\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+        // Don't create index table. We will use MultiRowDeleteMutationPlan\n+        // if there is no index present for a table.\n+        createAndUpsertTable(tableName, null, props);\n+        // Make sure that the plan creates is of MultiRowDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.MultiRowDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        // Make sure that Delete Marker has cell tag for base table.\n+        // We haven't created index table for this test case.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+    }\n+\n+    /*\n+        Verify whether plan that we create for delete statement is of planClass\n+     */\n+    private void verifyDeletePlan(String delete, Class planClass, Properties props)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            PhoenixStatement stmt = conn.createStatement().unwrap(PhoenixStatement.class);\n+            SQLParser parser = new SQLParser(delete);\n+            DeleteStatement deleteStmt = (DeleteStatement) parser.parseStatement();\n+            DeleteCompiler compiler = new DeleteCompiler(stmt, null);\n+            MutationPlan plan = compiler.compile(deleteStmt);\n+            assertEquals(plan.getClass(), planClass);\n+        }\n+    }\n+    private void createAndUpsertTable(String tableName, String indexName, Properties props)\n+            throws SQLException {\n+        String ddl = \"CREATE TABLE \" + tableName +\n+                \" (k INTEGER NOT NULL PRIMARY KEY, v1 VARCHAR, v2 VARCHAR)\";\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                statement.execute(ddl);\n+                if (indexName != null) {\n+                    String indexDdl1 = \"CREATE INDEX \" + indexName + \" ON \" + tableName + \"(v1,v2)\";\n+                    statement.execute(indexDdl1);\n+                }\n+            }\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (1, 'foo', 'foo1')\");\n+            conn.createStatement().execute(\n+                    \"upsert into \" + tableName + \" values (2, 'bar', 'bar1')\");\n+            conn.commit();\n+        }\n+    }\n+\n+    private void executeDelete(String delete, Properties props, int deleteRowCount)\n+            throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.setAutoCommit(true);\n+            try (Statement statement = conn.createStatement()) {\n+                int rs = statement.executeUpdate(delete);\n+                assertEquals( deleteRowCount, rs);\n+            }\n+        }\n+    }\n \n+    /*\n+        Verify whether we have tags present for base table and not present for\n+        index tables.\n+     */\n+    private void checkTagPresentInDeleteMarker(String tableName, String startRowKey,\n+            boolean tagPresent, String tagValue) throws IOException {\n+        List<Cell> values = new ArrayList<>();\n+        TableName table = TableName.valueOf(tableName);\n+        // Scan table with specified startRowKey\n+        for (HRegion region : getUtility().getHBaseCluster().getRegions(table)) {\n+            values.clear();\n+            Scan scan = new Scan();\n+            // Make sure to set rawScan to true so that we will get Delete Markers.\n+            scan.setRaw(true);\n+            scan.withStartRow(Bytes.toBytes(startRowKey));\n+            RegionScanner scanner = region.getScanner(scan);\n+            scanner.next(values);\n+            if (!values.isEmpty()) {\n+                break;\n+            }\n+        }\n+        assertTrue(\"Values shouldn't be empty\", !values.isEmpty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36c8afe4dcaad08e866193f7d6ab917b87626705"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyNTA3MA==", "bodyText": "ServerSelectDeleteMutationPlan is because DELETE query has no WHERE clause and we have index on base table which will be part of queryPlan?\n        boolean runOnServer = isAutoCommit && !hasPreOrPostProcessing && !table.isTransactional() && !hasClientSideIndexes && allowServerMutations;\n\n        runOnServer &= queryPlans.get(0).getTableRef().getTable().getType() != PTableType.INDEX;\n\n\nIs this the correct reference?", "url": "https://github.com/apache/phoenix/pull/978#discussion_r531625070", "createdAt": "2020-11-27T14:13:37Z", "author": {"login": "virajjasani"}, "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/DeleteIT.java", "diffHunk": "@@ -943,6 +961,163 @@ public void testDeleteFilterWithMultipleIndexes() throws Exception {\n             }\n         }\n     }\n-}\n \n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ClientSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteClientDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName + \" WHERE v1 = 'foo'\";\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        // Add tag \"customer-delete\" to delete marker.\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ClientSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ClientSelectDeleteMutationPlan.class, props);\n+        executeDelete(delete, props, 1);\n+        String startRowKeyForBaseTable = \"1\";\n+        String startRowKeyForIndexTable = \"foo\";\n+        // Make sure that Delete Marker has cell tag for base table\n+        // and has no cell tag for index table.\n+        checkTagPresentInDeleteMarker(tableName, startRowKeyForBaseTable, true, tagValue);\n+        checkTagPresentInDeleteMarker(indexName, startRowKeyForIndexTable, false, null);\n+    }\n+\n+    /*\n+        Tests whether we have cell tags in delete marker for\n+        ServerSelectDeleteMutationPlan.\n+     */\n+    @Test\n+    public void testDeleteServerDeleteMutationPlan() throws Exception {\n+        String tableName = generateUniqueName();\n+        String indexName = generateUniqueName();\n+        String tagValue = \"customer-delete\";\n+        String delete = \"DELETE FROM \" + tableName;\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+        props.setProperty(ConnectionQueryServices.SOURCE_OPERATION_ATTRIB, tagValue);\n+\n+        createAndUpsertTable(tableName, indexName, props);\n+        // Make sure that the plan creates is of ServerSelectDeleteMutationPlan\n+        verifyDeletePlan(delete, DeleteCompiler.ServerSelectDeleteMutationPlan.class, props);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36c8afe4dcaad08e866193f7d6ab917b87626705"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwMDU2MjMx", "url": "https://github.com/apache/phoenix/pull/978#pullrequestreview-540056231", "createdAt": "2020-11-27T15:27:21Z", "commit": {"oid": "36c8afe4dcaad08e866193f7d6ab917b87626705"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNToyNzoyMVrOH7CC5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QxNToyNzoyMVrOH7CC5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY2MTU0MQ==", "bodyText": "For now I think it's fine to perform this whole operation here, but eventually, do you think performing this entire cleanup + adding new delete markers could be done at HBase side using Mutation API? Not very strong point but keeping as much cell mutations to hbase side as possible might be better?\nOr maybe keeping this whole batch operation setDeleteAttributes() at hbase side as Public/LP API?\nWDYT @shahrs87 @gjacoby126 ? Apologies if this was already discussed, I know there have been few nice long discussions overall.", "url": "https://github.com/apache/phoenix/pull/978#discussion_r531661541", "createdAt": "2020-11-27T15:27:21Z", "author": {"login": "virajjasani"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/hbase/index/IndexRegionObserver.java", "diffHunk": "@@ -991,6 +999,47 @@ public void preBatchMutateWithExceptions(ObserverContext<RegionCoprocessorEnviro\n         }\n     }\n \n+    /**\n+     * Set Cell Tags to delete markers with source of operation attribute.\n+     * @param miniBatchOp\n+     * @throws IOException\n+     */\n+    private void setDeleteAttributes(MiniBatchOperationInProgress<Mutation> miniBatchOp)\n+            throws IOException {\n+        for (int i = 0; i < miniBatchOp.size(); i++) {\n+            Mutation m = miniBatchOp.getOperation(i);\n+            if (!(m instanceof  Delete)) {\n+                // Ignore if it is not Delete type.\n+                continue;\n+            }\n+            byte[] sourceOpAttr = m.getAttribute(QueryServices.SOURCE_OPERATION_ATTRIB);\n+            if (sourceOpAttr == null) {\n+                continue;\n+            }\n+\n+            Tag sourceOpTag = new ArrayBackedTag(PhoenixTagType.SOURCE_OPERATION_TAG_TYPE,\n+                    sourceOpAttr);\n+            List<Cell> updatedCells = new ArrayList<>();\n+            for (CellScanner cellScanner = m.cellScanner(); cellScanner.advance();) {\n+                Cell cell = cellScanner.current();\n+                // TODO: Cell#getTagsArray, Cell#getTagsOffset, Cell#getTagsLength are deprecated.\n+                //TODO: Need to replace them with new methods.\n+                List<Tag> tags = PrivateCellUtil.getTags(cell);\n+                tags.add(sourceOpTag);\n+                // TODO: PrivateCellUtil's IA is Private. Need to change it to LP with\n+                // TODO: IA.COPROC.\n+                Cell updatedCell = PrivateCellUtil.createCell(cell, tags);\n+                updatedCells.add(updatedCell);\n+            }\n+            m.getFamilyCellMap().clear();\n+            // Clear and add new Cells to the Mutation.\n+            for (Cell cell : updatedCells) {\n+                Delete d = (Delete) m;\n+                d.addDeleteMarker(cell);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36c8afe4dcaad08e866193f7d6ab917b87626705"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTQ3NDQ2", "url": "https://github.com/apache/phoenix/pull/978#pullrequestreview-541147446", "createdAt": "2020-11-30T17:45:44Z", "commit": {"oid": "c4297874671993afe355587259e30a962a52c4f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzo0NTo0NFrOH8GfJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzo0NTo0NFrOH8GfJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4Mjg4Nw==", "bodyText": "@gjacoby126  Could you please advise whether should we add the attribute here ? This codepath is used when we drop the column which will in turn generate Delete Marker.", "url": "https://github.com/apache/phoenix/pull/978#discussion_r532782887", "createdAt": "2020-11-30T17:45:44Z", "author": {"login": "shahrs87"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java", "diffHunk": "@@ -479,6 +486,8 @@ void deleteCForQ(Tuple result, List<Cell> results, UngroupedAggregateRegionObser\n             delete.addColumns(deleteCF,  deleteCQ, ts);\n             // force tephra to ignore this deletes\n             delete.setAttribute(PhoenixTransactionContext.TX_ROLLBACK_ATTRIBUTE_KEY, new byte[0]);\n+            // TODO: should we set the source of operation attribute here.\n+            // TODO: This will be true if we drop column or drop table", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4297874671993afe355587259e30a962a52c4f8"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMTQzMTI4", "url": "https://github.com/apache/phoenix/pull/978#pullrequestreview-543143128", "createdAt": "2020-12-02T18:54:56Z", "commit": {"oid": "c4297874671993afe355587259e30a962a52c4f8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxODo1NDo1NlrOH9pjaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxODo1Nzo0MlrOH9pqIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwNTk5Mg==", "bodyText": "Good question, @shahrs87 . I think we should set the attribute there.", "url": "https://github.com/apache/phoenix/pull/978#discussion_r534405992", "createdAt": "2020-12-02T18:54:56Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java", "diffHunk": "@@ -479,6 +486,8 @@ void deleteCForQ(Tuple result, List<Cell> results, UngroupedAggregateRegionObser\n             delete.addColumns(deleteCF,  deleteCQ, ts);\n             // force tephra to ignore this deletes\n             delete.setAttribute(PhoenixTransactionContext.TX_ROLLBACK_ATTRIBUTE_KEY, new byte[0]);\n+            // TODO: should we set the source of operation attribute here.\n+            // TODO: This will be true if we drop column or drop table", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4Mjg4Nw=="}, "originalCommit": {"oid": "c4297874671993afe355587259e30a962a52c4f8"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQwNzcxNQ==", "bodyText": "Can update the comment with a TODO pointing to the HBase JIRA introducing the new LP(COPROC) API you made.", "url": "https://github.com/apache/phoenix/pull/978#discussion_r534407715", "createdAt": "2020-12-02T18:57:42Z", "author": {"login": "gjacoby126"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/hbase/index/IndexRegionObserver.java", "diffHunk": "@@ -991,6 +1000,49 @@ public void preBatchMutateWithExceptions(ObserverContext<RegionCoprocessorEnviro\n         }\n     }\n \n+    /**\n+     * Set Cell Tags to delete markers with source of operation attribute.\n+     * @param miniBatchOp\n+     * @throws IOException\n+     */\n+    private void setDeleteAttributes(MiniBatchOperationInProgress<Mutation> miniBatchOp)\n+            throws IOException {\n+        for (int i = 0; i < miniBatchOp.size(); i++) {\n+            Mutation m = miniBatchOp.getOperation(i);\n+            if (!(m instanceof  Delete)) {\n+                // Ignore if it is not Delete type.\n+                continue;\n+            }\n+            byte[] sourceOpAttr = m.getAttribute(QueryServices.SOURCE_OPERATION_ATTRIB);\n+            if (sourceOpAttr == null) {\n+                continue;\n+            }\n+\n+            Tag sourceOpTag = new ArrayBackedTag(PhoenixTagType.SOURCE_OPERATION_TAG_TYPE,\n+                    sourceOpAttr);\n+            List<Cell> updatedCells = new ArrayList<>();\n+            for (CellScanner cellScanner = m.cellScanner(); cellScanner.advance();) {\n+                Cell cell = cellScanner.current();\n+                RawCell rawCell = (RawCell)cell;\n+                List<Tag> tags = new ArrayList<>();\n+                Iterator<Tag> tagsIterator = rawCell.getTags();\n+                while (tagsIterator.hasNext()) {\n+                    tags.add(tagsIterator.next());\n+                }\n+                tags.add(sourceOpTag);\n+                // TODO: PrivateCellUtil's IA is Private. Need to change it to LP with IA.COPROC.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4297874671993afe355587259e30a962a52c4f8"}, "originalPosition": 79}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4da62b62fcff6ffc2c1008b3e006cd0c41daecf8", "author": {"user": null}, "url": "https://github.com/apache/phoenix/commit/4da62b62fcff6ffc2c1008b3e006cd0c41daecf8", "committedDate": "2020-12-06T20:41:48Z", "message": "[PHOENIX-6213] Extend Cell Tags to Delete object to store source of operation."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c4297874671993afe355587259e30a962a52c4f8", "author": {"user": null}, "url": "https://github.com/apache/phoenix/commit/c4297874671993afe355587259e30a962a52c4f8", "committedDate": "2020-11-28T02:52:09Z", "message": "Merge branch 'master' of https://github.com/apache/phoenix into phoenix-6213"}, "afterCommit": {"oid": "4da62b62fcff6ffc2c1008b3e006cd0c41daecf8", "author": {"user": null}, "url": "https://github.com/apache/phoenix/commit/4da62b62fcff6ffc2c1008b3e006cd0c41daecf8", "committedDate": "2020-12-06T20:41:48Z", "message": "[PHOENIX-6213] Extend Cell Tags to Delete object to store source of operation."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NzQ2NDAy", "url": "https://github.com/apache/phoenix/pull/978#pullrequestreview-545746402", "createdAt": "2020-12-06T20:49:58Z", "commit": {"oid": "4da62b62fcff6ffc2c1008b3e006cd0c41daecf8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQyMDo0OTo1OFrOIAPPnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQyMDo0OTo1OFrOIAPPnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEyMDY3MQ==", "bodyText": "Good question, @shahrs87 . I think we should set the attribute there.\n\n@gjacoby126  I started doing changes for setting source operation attribute here. When we drop a column, we create delete markers with delete type \"DELETE_COLUMN\" for the base table and also we delete metadata for that column in SYSCAT table. Is it reasonable to have the feature first for just deleting rows from data table and then we can extend it for drop columns use case. Please advise. Thank you !", "url": "https://github.com/apache/phoenix/pull/978#discussion_r537120671", "createdAt": "2020-12-06T20:49:58Z", "author": {"login": "shahrs87"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/UngroupedAggregateRegionScanner.java", "diffHunk": "@@ -479,6 +486,10 @@ void deleteCForQ(Tuple result, List<Cell> results, UngroupedAggregateRegionObser\n             delete.addColumns(deleteCF,  deleteCQ, ts);\n             // force tephra to ignore this deletes\n             delete.setAttribute(PhoenixTransactionContext.TX_ROLLBACK_ATTRIBUTE_KEY, new byte[0]);\n+            // TODO: We need to set SOURCE_OPERATION_ATTRIB here also. The control will come here if", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4da62b62fcff6ffc2c1008b3e006cd0c41daecf8"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35a1a67324de60fa569f3f1c3d128db1b421b55e", "author": {"user": null}, "url": "https://github.com/apache/phoenix/commit/35a1a67324de60fa569f3f1c3d128db1b421b55e", "committedDate": "2020-12-07T17:29:43Z", "message": "Merge branch 'master' of https://github.com/apache/phoenix into phoenix-6213"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NTIyNjEy", "url": "https://github.com/apache/phoenix/pull/978#pullrequestreview-546522612", "createdAt": "2020-12-07T20:47:11Z", "commit": {"oid": "35a1a67324de60fa569f3f1c3d128db1b421b55e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1860, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}