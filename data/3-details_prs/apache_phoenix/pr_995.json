{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwNjIyNTEx", "number": 995, "title": "PHOENIX-6200 Add counters for extra index rows, log results to PIT and PIT_RESULT table", "bodyText": "For index verification when using index table as the source", "createdAt": "2020-12-01T22:48:25Z", "url": "https://github.com/apache/phoenix/pull/995", "merged": true, "mergeCommit": {"oid": "8af9cd8686d8692446f9b1c059246b6f403efa37"}, "closed": true, "closedAt": "2020-12-09T18:33:34Z", "author": {"login": "tkhurana"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdiBgE0AH2gAyNTMwNjIyNTExOjFjZGZhODgyMDAzYWZhYWYyMzY1MDIwZmJkNzQwNWQwMmNhNTU0MWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkjHfVAFqTU0ODQ4MzgwNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1cdfa882003afaaf2365020fbd7405d02ca5541b", "author": {"user": {"login": "tkhurana", "name": null}}, "url": "https://github.com/apache/phoenix/commit/1cdfa882003afaaf2365020fbd7405d02ca5541b", "committedDate": "2020-12-01T22:15:36Z", "message": "PHOENIX-6200 Add counters for extra index rows, log results to PIT and PIT_RESULT table"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMDc4MDg5", "url": "https://github.com/apache/phoenix/pull/995#pullrequestreview-543078089", "createdAt": "2020-12-02T17:34:16Z", "commit": {"oid": "1cdfa882003afaaf2365020fbd7405d02ca5541b"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNzozNDoxNlrOH9mXgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxODoyNzoyMlrOH9oetw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1Mzc5Mw==", "bodyText": "I recommend having a contains rather than equals here. Sometimes we enhance the error messages.", "url": "https://github.com/apache/phoenix/pull/995#discussion_r534353793", "createdAt": "2020-12-02T17:34:16Z", "author": {"login": "gokceni"}, "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/IndexRepairRegionScannerIT.java", "diffHunk": "@@ -163,35 +308,251 @@ public void testRepairExtraIndexRows() throws Exception {\n         String indexTableName = generateUniqueName();\n         String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n         Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            initTablesAndAddExtraRowsToIndex(conn, schemaName, dataTableName, indexTableName, NROWS);\n+\n+            // do index rebuild without -fi and check with scrutiny that index tool failed to fix the extra rows\n+            IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE);\n+\n+            boolean failed;\n+            try {\n+                IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+                failed = false;\n+            } catch (AssertionError e) {\n+                failed = true;\n+            }\n+            assertTrue(failed);\n+\n+            // now repair the index with -fi\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS, actualRowCount);\n+\n+            assertExtraCounters(indexTool, NROWS, 0, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_PostIndexUpdateFailure_overwrite() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 4;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n         try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n             conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n-                    + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \"\n-                    + tableDDLOptions);\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n+            conn.createStatement().execute(String.format(\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n+\n             PreparedStatement dataPreparedStatement =\n-                    conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n             for (int i = 1; i <= NROWS; i++) {\n                 dataPreparedStatement.setInt(1, i);\n                 dataPreparedStatement.setInt(2, i + 1);\n                 dataPreparedStatement.setInt(3, i * 2);\n                 dataPreparedStatement.execute();\n             }\n             conn.commit();\n+\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(true);\n+            conn.createStatement().execute(\"UPSERT INTO \" + dataTableFullName + \" VALUES(3, 100, 200)\");\n+            conn.commit();\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(false);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            CounterGroup mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+            assertEquals(2,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(2,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+            mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS, actualRowCount);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_PostIndexUpdateFailure_delete() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 4;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n             conn.createStatement().execute(String.format(\n-                    \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n-            // Add extra index rows\n-            PreparedStatement indexPreparedStatement =\n-                    conn.prepareStatement(\"UPSERT INTO \" + indexTableFullName + \" VALUES(?,?,?)\");\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n \n-            for (int i = NROWS + 1; i <= 2 * NROWS; i++) {\n-                indexPreparedStatement.setInt(1, i + 1); // the indexed column\n-                indexPreparedStatement.setInt(2, i); // the data pk column\n-                indexPreparedStatement.setInt(3, i * 2); // the included column\n-                indexPreparedStatement.execute();\n+            PreparedStatement dataPreparedStatement =\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+            for (int i = 1; i <= NROWS; i++) {\n+                dataPreparedStatement.setInt(1, i);\n+                dataPreparedStatement.setInt(2, i + 1);\n+                dataPreparedStatement.setInt(3, i * 2);\n+                dataPreparedStatement.execute();\n             }\n             conn.commit();\n-            // Set all index row statuses to verified so that read verify will not fix them. We want them to be fixed\n-            // by IndexRepairRegionScanner\n-            setIndexRowStatusesToVerified(conn, dataTableFullName, indexTableFullName);\n+\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(true);\n+            conn.createStatement().execute(\"DELETE FROM \" + dataTableFullName + \" WHERE ID = 3\");\n+            conn.commit();\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(false);\n+            TestUtil.doMajorCompaction(conn, dataTableFullName);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            CounterGroup mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(1,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+            mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS - 1, actualRowCount);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_DataTableUpdateFailure() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 20;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n+            conn.createStatement().execute(String.format(\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n+\n+            IndexRegionObserver.setFailDataTableUpdatesForTesting(true);\n+\n+            PreparedStatement dataPreparedStatement =\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+            for (int i = 1; i <= NROWS; i++) {\n+                dataPreparedStatement.setInt(1, i);\n+                dataPreparedStatement.setInt(2, i + 1);\n+                dataPreparedStatement.setInt(3, i * 2);\n+                dataPreparedStatement.execute();\n+            }\n+            commitWithException(conn);\n+            IndexRegionObserver.setFailDataTableUpdatesForTesting(true);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(0, actualRowCount);\n+\n+            assertExtraCounters(indexTool, 0, NROWS, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testPITRow() throws Exception {\n+        final int NROWS = 1;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            initTablesAndAddExtraRowsToIndex(conn, schemaName, dataTableName, indexTableName, NROWS);\n+\n+            IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+\n+            Cell cell = IndexToolIT.getErrorMessageFromIndexToolOutputTable(conn, dataTableFullName, indexTableFullName);\n+            try {\n+                String expectedErrorMsg = IndexRepairRegionScanner.ERROR_MESSAGE_EXTRA_INDEX_ROW;\n+                String actualErrorMsg = Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());\n+                assertTrue(expectedErrorMsg.equals(actualErrorMsg));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cdfa882003afaaf2365020fbd7405d02ca5541b"}, "originalPosition": 458}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1NDYxNA==", "bodyText": "nit: Do you need this? It will fail the test anyway without this assert right? It will be consistent with how we throw exceptions from test methods", "url": "https://github.com/apache/phoenix/pull/995#discussion_r534354614", "createdAt": "2020-12-02T17:35:31Z", "author": {"login": "gokceni"}, "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/IndexRepairRegionScannerIT.java", "diffHunk": "@@ -163,35 +308,251 @@ public void testRepairExtraIndexRows() throws Exception {\n         String indexTableName = generateUniqueName();\n         String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n         Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            initTablesAndAddExtraRowsToIndex(conn, schemaName, dataTableName, indexTableName, NROWS);\n+\n+            // do index rebuild without -fi and check with scrutiny that index tool failed to fix the extra rows\n+            IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE);\n+\n+            boolean failed;\n+            try {\n+                IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+                failed = false;\n+            } catch (AssertionError e) {\n+                failed = true;\n+            }\n+            assertTrue(failed);\n+\n+            // now repair the index with -fi\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS, actualRowCount);\n+\n+            assertExtraCounters(indexTool, NROWS, 0, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_PostIndexUpdateFailure_overwrite() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 4;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n         try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n             conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n-                    + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \"\n-                    + tableDDLOptions);\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n+            conn.createStatement().execute(String.format(\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n+\n             PreparedStatement dataPreparedStatement =\n-                    conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n             for (int i = 1; i <= NROWS; i++) {\n                 dataPreparedStatement.setInt(1, i);\n                 dataPreparedStatement.setInt(2, i + 1);\n                 dataPreparedStatement.setInt(3, i * 2);\n                 dataPreparedStatement.execute();\n             }\n             conn.commit();\n+\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(true);\n+            conn.createStatement().execute(\"UPSERT INTO \" + dataTableFullName + \" VALUES(3, 100, 200)\");\n+            conn.commit();\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(false);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            CounterGroup mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+            assertEquals(2,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(2,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+            mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS, actualRowCount);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_PostIndexUpdateFailure_delete() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 4;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n             conn.createStatement().execute(String.format(\n-                    \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n-            // Add extra index rows\n-            PreparedStatement indexPreparedStatement =\n-                    conn.prepareStatement(\"UPSERT INTO \" + indexTableFullName + \" VALUES(?,?,?)\");\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n \n-            for (int i = NROWS + 1; i <= 2 * NROWS; i++) {\n-                indexPreparedStatement.setInt(1, i + 1); // the indexed column\n-                indexPreparedStatement.setInt(2, i); // the data pk column\n-                indexPreparedStatement.setInt(3, i * 2); // the included column\n-                indexPreparedStatement.execute();\n+            PreparedStatement dataPreparedStatement =\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+            for (int i = 1; i <= NROWS; i++) {\n+                dataPreparedStatement.setInt(1, i);\n+                dataPreparedStatement.setInt(2, i + 1);\n+                dataPreparedStatement.setInt(3, i * 2);\n+                dataPreparedStatement.execute();\n             }\n             conn.commit();\n-            // Set all index row statuses to verified so that read verify will not fix them. We want them to be fixed\n-            // by IndexRepairRegionScanner\n-            setIndexRowStatusesToVerified(conn, dataTableFullName, indexTableFullName);\n+\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(true);\n+            conn.createStatement().execute(\"DELETE FROM \" + dataTableFullName + \" WHERE ID = 3\");\n+            conn.commit();\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(false);\n+            TestUtil.doMajorCompaction(conn, dataTableFullName);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            CounterGroup mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(1,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+            mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS - 1, actualRowCount);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_DataTableUpdateFailure() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 20;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n+            conn.createStatement().execute(String.format(\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n+\n+            IndexRegionObserver.setFailDataTableUpdatesForTesting(true);\n+\n+            PreparedStatement dataPreparedStatement =\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+            for (int i = 1; i <= NROWS; i++) {\n+                dataPreparedStatement.setInt(1, i);\n+                dataPreparedStatement.setInt(2, i + 1);\n+                dataPreparedStatement.setInt(3, i * 2);\n+                dataPreparedStatement.execute();\n+            }\n+            commitWithException(conn);\n+            IndexRegionObserver.setFailDataTableUpdatesForTesting(true);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(0, actualRowCount);\n+\n+            assertExtraCounters(indexTool, 0, NROWS, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testPITRow() throws Exception {\n+        final int NROWS = 1;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            initTablesAndAddExtraRowsToIndex(conn, schemaName, dataTableName, indexTableName, NROWS);\n+\n+            IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+\n+            Cell cell = IndexToolIT.getErrorMessageFromIndexToolOutputTable(conn, dataTableFullName, indexTableFullName);\n+            try {\n+                String expectedErrorMsg = IndexRepairRegionScanner.ERROR_MESSAGE_EXTRA_INDEX_ROW;\n+                String actualErrorMsg = Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());\n+                assertTrue(expectedErrorMsg.equals(actualErrorMsg));\n+            } catch(Exception ex) {\n+                Assert.fail(\"Fail to parsing the error message from IndexToolOutputTable\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cdfa882003afaaf2365020fbd7405d02ca5541b"}, "originalPosition": 460}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1NzQzMw==", "bodyText": "So this means -fi only works with BEFORE option is that correct?\nIs there any reason why it doesn't work with AFTER?\nI would expect it to build correctly independent of verify option and Verify is just verification not affecting how we build the index.", "url": "https://github.com/apache/phoenix/pull/995#discussion_r534357433", "createdAt": "2020-12-02T17:39:42Z", "author": {"login": "gokceni"}, "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/IndexRepairRegionScannerIT.java", "diffHunk": "@@ -163,35 +308,251 @@ public void testRepairExtraIndexRows() throws Exception {\n         String indexTableName = generateUniqueName();\n         String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n         Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            initTablesAndAddExtraRowsToIndex(conn, schemaName, dataTableName, indexTableName, NROWS);\n+\n+            // do index rebuild without -fi and check with scrutiny that index tool failed to fix the extra rows\n+            IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE);\n+\n+            boolean failed;\n+            try {\n+                IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+                failed = false;\n+            } catch (AssertionError e) {\n+                failed = true;\n+            }\n+            assertTrue(failed);\n+\n+            // now repair the index with -fi\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS, actualRowCount);\n+\n+            assertExtraCounters(indexTool, NROWS, 0, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_PostIndexUpdateFailure_overwrite() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 4;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n         try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n             conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n-                    + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \"\n-                    + tableDDLOptions);\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n+            conn.createStatement().execute(String.format(\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n+\n             PreparedStatement dataPreparedStatement =\n-                    conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n             for (int i = 1; i <= NROWS; i++) {\n                 dataPreparedStatement.setInt(1, i);\n                 dataPreparedStatement.setInt(2, i + 1);\n                 dataPreparedStatement.setInt(3, i * 2);\n                 dataPreparedStatement.execute();\n             }\n             conn.commit();\n+\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(true);\n+            conn.createStatement().execute(\"UPSERT INTO \" + dataTableFullName + \" VALUES(3, 100, 200)\");\n+            conn.commit();\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(false);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            CounterGroup mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+            assertEquals(2,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(2,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+            mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS, actualRowCount);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_PostIndexUpdateFailure_delete() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 4;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n             conn.createStatement().execute(String.format(\n-                    \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n-            // Add extra index rows\n-            PreparedStatement indexPreparedStatement =\n-                    conn.prepareStatement(\"UPSERT INTO \" + indexTableFullName + \" VALUES(?,?,?)\");\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n \n-            for (int i = NROWS + 1; i <= 2 * NROWS; i++) {\n-                indexPreparedStatement.setInt(1, i + 1); // the indexed column\n-                indexPreparedStatement.setInt(2, i); // the data pk column\n-                indexPreparedStatement.setInt(3, i * 2); // the included column\n-                indexPreparedStatement.execute();\n+            PreparedStatement dataPreparedStatement =\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+            for (int i = 1; i <= NROWS; i++) {\n+                dataPreparedStatement.setInt(1, i);\n+                dataPreparedStatement.setInt(2, i + 1);\n+                dataPreparedStatement.setInt(3, i * 2);\n+                dataPreparedStatement.execute();\n             }\n             conn.commit();\n-            // Set all index row statuses to verified so that read verify will not fix them. We want them to be fixed\n-            // by IndexRepairRegionScanner\n-            setIndexRowStatusesToVerified(conn, dataTableFullName, indexTableFullName);\n+\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(true);\n+            conn.createStatement().execute(\"DELETE FROM \" + dataTableFullName + \" WHERE ID = 3\");\n+            conn.commit();\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(false);\n+            TestUtil.doMajorCompaction(conn, dataTableFullName);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            CounterGroup mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(1,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+            mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS - 1, actualRowCount);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_DataTableUpdateFailure() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 20;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n+            conn.createStatement().execute(String.format(\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n+\n+            IndexRegionObserver.setFailDataTableUpdatesForTesting(true);\n+\n+            PreparedStatement dataPreparedStatement =\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+            for (int i = 1; i <= NROWS; i++) {\n+                dataPreparedStatement.setInt(1, i);\n+                dataPreparedStatement.setInt(2, i + 1);\n+                dataPreparedStatement.setInt(3, i * 2);\n+                dataPreparedStatement.execute();\n+            }\n+            commitWithException(conn);\n+            IndexRegionObserver.setFailDataTableUpdatesForTesting(true);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(0, actualRowCount);\n+\n+            assertExtraCounters(indexTool, 0, NROWS, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testPITRow() throws Exception {\n+        final int NROWS = 1;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            initTablesAndAddExtraRowsToIndex(conn, schemaName, dataTableName, indexTableName, NROWS);\n+\n+            IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+\n+            Cell cell = IndexToolIT.getErrorMessageFromIndexToolOutputTable(conn, dataTableFullName, indexTableFullName);\n+            try {\n+                String expectedErrorMsg = IndexRepairRegionScanner.ERROR_MESSAGE_EXTRA_INDEX_ROW;\n+                String actualErrorMsg = Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());\n+                assertTrue(expectedErrorMsg.equals(actualErrorMsg));\n+            } catch(Exception ex) {\n+                Assert.fail(\"Fail to parsing the error message from IndexToolOutputTable\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifyAfterExtraIndexRows() throws Exception {\n+        final int NROWS = 20;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            initTablesAndAddExtraRowsToIndex(conn, schemaName, dataTableName, indexTableName, NROWS);\n+\n+            // Run -v AFTER and check it doesn't fix the extra rows and the job fails\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, -1, IndexVerifyType.AFTER, \"-fi\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cdfa882003afaaf2365020fbd7405d02ca5541b"}, "originalPosition": 480}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4NjY2OA==", "bodyText": "I think adding a comment here would be nice. Something like this case happens when there is extra index rows", "url": "https://github.com/apache/phoenix/pull/995#discussion_r534386668", "createdAt": "2020-12-02T18:24:34Z", "author": {"login": "gokceni"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/GlobalIndexRegionScanner.java", "diffHunk": "@@ -883,6 +925,9 @@ public boolean verifySingleIndexRow(byte[] indexRowKey, List<Mutation> actualMut\n                 logMismatch(expected, actual, expectedIndex, verificationPhaseResult, isBeforeRebuild);\n             }\n             else {\n+                if (expected == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cdfa882003afaaf2365020fbd7405d02ca5541b"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4ODQwNw==", "bodyText": "Does the below code work if there is no index row?", "url": "https://github.com/apache/phoenix/pull/995#discussion_r534388407", "createdAt": "2020-12-02T18:27:22Z", "author": {"login": "gokceni"}, "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRepairRegionScanner.java", "diffHunk": "@@ -178,6 +183,28 @@ protected void repairIndexRows(Map<byte[], List<Mutation>> indexMutationMap,\n         return actualIndexMutationMap;\n     }\n \n+    private Map<byte[], List<Mutation>> populateActualIndexMutationMap() throws IOException {\n+        Map<byte[], List<Mutation>> actualIndexMutationMap = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n+        Scan indexScan = new Scan();\n+        indexScan.setTimeRange(scan.getTimeRange().getMin(), scan.getTimeRange().getMax());\n+        indexScan.setRaw(true);\n+        indexScan.setMaxVersions();\n+        indexScan.setCacheBlocks(false);\n+        try (RegionScanner regionScanner = region.getScanner(indexScan)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cdfa882003afaaf2365020fbd7405d02ca5541b"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "534c2646e9377b977056310cc9ec4737e8769ae1", "author": {"user": {"login": "tkhurana", "name": null}}, "url": "https://github.com/apache/phoenix/commit/534c2646e9377b977056310cc9ec4737e8769ae1", "committedDate": "2020-12-04T20:26:23Z", "message": "Address feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NTYyNTEz", "url": "https://github.com/apache/phoenix/pull/995#pullrequestreview-546562513", "createdAt": "2020-12-07T21:45:18Z", "commit": {"oid": "534c2646e9377b977056310cc9ec4737e8769ae1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NDgzODA0", "url": "https://github.com/apache/phoenix/pull/995#pullrequestreview-548483804", "createdAt": "2020-12-09T18:33:22Z", "commit": {"oid": "534c2646e9377b977056310cc9ec4737e8769ae1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1868, "cost": 1, "resetAt": "2021-10-29T19:57:52Z"}}}