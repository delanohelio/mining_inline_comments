{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxNTcwNTI4", "number": 4693, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMToyNzo1MlrOFW3-Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxNDoyODoxNVrOFXKIqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5NTMwMDcxOnYy", "diffSide": "RIGHT", "path": "app/src/androidTest/java/de/test/antennapod/storage/ExceptFavoriteCleanupAlgorithmTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMToyNzo1MlrOIgH6ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMToyNzo1MlrOIgH6ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1NTA3NQ==", "bodyText": "Could you please rebase the PR and migrate this to Roboelectric? See #4820 for details.", "url": "https://github.com/AntennaPod/AntennaPod/pull/4693#discussion_r570555075", "createdAt": "2021-02-04T21:27:52Z", "author": {"login": "ByteHamster"}, "path": "app/src/androidTest/java/de/test/antennapod/storage/ExceptFavoriteCleanupAlgorithmTest.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package de.test.antennapod.storage;\n+\n+import androidx.test.filters.SmallTest;\n+\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import de.danoeh.antennapod.core.feed.Feed;\n+import de.danoeh.antennapod.core.feed.FeedItem;\n+import de.danoeh.antennapod.core.preferences.UserPreferences;\n+import de.danoeh.antennapod.core.storage.DBTasks;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * Tests that the APFavoriteCleanupAlgorithm is working correctly.\n+ */\n+@SmallTest", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec764a9ff7b6824ba2ac9a7d35fd050abdc6f9bb"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5NTMyNDMyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/de/danoeh/antennapod/core/storage/ExceptFavoriteCleanupAlgorithm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMTozNDozNlrOIgIJNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMTozNDozNlrOIgIJNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU1ODc3Mw==", "bodyText": "I think this might lead to problems when both do not have a date and then some time passes during the algorithm. (something like Comparison method violates its general contract). So for consistency, I would just use the IDs as tie breaker.", "url": "https://github.com/AntennaPod/AntennaPod/pull/4693#discussion_r570558773", "createdAt": "2021-02-04T21:34:36Z", "author": {"login": "ByteHamster"}, "path": "core/src/main/java/de/danoeh/antennapod/core/storage/ExceptFavoriteCleanupAlgorithm.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package de.danoeh.antennapod.core.storage;\n+\n+import android.content.Context;\n+import android.util.Log;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.ExecutionException;\n+\n+import de.danoeh.antennapod.core.feed.FeedItem;\n+\n+/**\n+ * A cleanup algorithm that removes any item that isn't a favorite but only if space is needed.\n+ */\n+public class ExceptFavoriteCleanupAlgorithm extends EpisodeCleanupAlgorithm {\n+\n+    private static final String TAG = \"ExceptFavCleanupAlgo\";\n+\n+    /**\n+     * The maximum number of episodes that could be cleaned up.\n+     *\n+     * @return the number of episodes that *could* be cleaned up, if needed\n+     */\n+    public int getReclaimableItems() {\n+        return getCandidates().size();\n+    }\n+\n+    @Override\n+    public int performCleanup(Context context, int numberOfEpisodesToDelete) {\n+        List<FeedItem> candidates = getCandidates();\n+        List<FeedItem> delete;\n+\n+        // in the absence of better data, we'll sort by item publication date\n+        Collections.sort(candidates, (lhs, rhs) -> {\n+            Date l = lhs.getPubDate();\n+            Date r = rhs.getPubDate();\n+\n+            if (l == null) {\n+                l = new Date();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec764a9ff7b6824ba2ac9a7d35fd050abdc6f9bb"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5ODI3MTc1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/de/danoeh/antennapod/core/storage/ExceptFavoriteCleanupAlgorithm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxNDoyNzoyN1rOIgjUPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxNDoyNzoyN1rOIgjUPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTAwMzk2NQ==", "bodyText": "This is the same as writing return 0; here. I don't really understand what this is for, to be honest...\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return getNumEpisodesToCleanup(0);\n          \n          \n            \n                    return 0;", "url": "https://github.com/AntennaPod/AntennaPod/pull/4693#discussion_r571003965", "createdAt": "2021-02-05T14:27:27Z", "author": {"login": "ByteHamster"}, "path": "core/src/main/java/de/danoeh/antennapod/core/storage/ExceptFavoriteCleanupAlgorithm.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package de.danoeh.antennapod.core.storage;\n+\n+import android.content.Context;\n+import android.util.Log;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.ExecutionException;\n+\n+import de.danoeh.antennapod.core.feed.FeedItem;\n+\n+/**\n+ * A cleanup algorithm that removes any item that isn't a favorite but only if space is needed.\n+ */\n+public class ExceptFavoriteCleanupAlgorithm extends EpisodeCleanupAlgorithm {\n+\n+    private static final String TAG = \"ExceptFavCleanupAlgo\";\n+\n+    /**\n+     * The maximum number of episodes that could be cleaned up.\n+     *\n+     * @return the number of episodes that *could* be cleaned up, if needed\n+     */\n+    public int getReclaimableItems() {\n+        return getCandidates().size();\n+    }\n+\n+    @Override\n+    public int performCleanup(Context context, int numberOfEpisodesToDelete) {\n+        List<FeedItem> candidates = getCandidates();\n+        List<FeedItem> delete;\n+\n+        // in the absence of better data, we'll sort by item publication date\n+        Collections.sort(candidates, (lhs, rhs) -> {\n+            Date l = lhs.getPubDate();\n+            Date r = rhs.getPubDate();\n+\n+            if (l != null && r != null) {\n+                return l.compareTo(r);\n+            } else {\n+                // No date - compare by id which should be always incremented\n+                return Long.compare(lhs.getId(), rhs.getId());\n+            }\n+        });\n+\n+        if (candidates.size() > numberOfEpisodesToDelete) {\n+            delete = candidates.subList(0, numberOfEpisodesToDelete);\n+        } else {\n+            delete = candidates;\n+        }\n+\n+        for (FeedItem item : delete) {\n+            try {\n+                DBWriter.deleteFeedMediaOfItem(context, item.getMedia().getId()).get();\n+            } catch (InterruptedException | ExecutionException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+        int counter = delete.size();\n+\n+\n+        Log.i(TAG, String.format(Locale.US,\n+                \"Auto-delete deleted %d episodes (%d requested)\", counter,\n+                numberOfEpisodesToDelete));\n+\n+        return counter;\n+    }\n+\n+    @NonNull\n+    private List<FeedItem> getCandidates() {\n+        List<FeedItem> candidates = new ArrayList<>();\n+        List<FeedItem> downloadedItems = DBReader.getDownloadedItems();\n+        for (FeedItem item : downloadedItems) {\n+            if (item.hasMedia()\n+                    && item.getMedia().isDownloaded()\n+                    && !item.isTagged(FeedItem.TAG_FAVORITE)) {\n+                candidates.add(item);\n+            }\n+        }\n+        return candidates;\n+    }\n+\n+    @Override\n+    public int getDefaultCleanupParameter() {\n+        return getNumEpisodesToCleanup(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08edd151f9bc01873128fa97c948841b65b6455c"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5ODI3NjI0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/de/danoeh/antennapod/core/storage/ExceptFavoriteCleanupAlgorithm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxNDoyODoxNVrOIgjWyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxNDoyODoxNVrOIgjWyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTAwNDYxOA==", "bodyText": "Please remove the newlines\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int counter = delete.size();\n          \n          \n            \n            \n          \n          \n            \n            \n          \n          \n            \n                    Log.i(TAG, String.format(Locale.US,\n          \n          \n            \n                    int counter = delete.size();\n          \n          \n            \n                    Log.i(TAG, String.format(Locale.US,", "url": "https://github.com/AntennaPod/AntennaPod/pull/4693#discussion_r571004618", "createdAt": "2021-02-05T14:28:15Z", "author": {"login": "ByteHamster"}, "path": "core/src/main/java/de/danoeh/antennapod/core/storage/ExceptFavoriteCleanupAlgorithm.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package de.danoeh.antennapod.core.storage;\n+\n+import android.content.Context;\n+import android.util.Log;\n+\n+import androidx.annotation.NonNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.concurrent.ExecutionException;\n+\n+import de.danoeh.antennapod.core.feed.FeedItem;\n+\n+/**\n+ * A cleanup algorithm that removes any item that isn't a favorite but only if space is needed.\n+ */\n+public class ExceptFavoriteCleanupAlgorithm extends EpisodeCleanupAlgorithm {\n+\n+    private static final String TAG = \"ExceptFavCleanupAlgo\";\n+\n+    /**\n+     * The maximum number of episodes that could be cleaned up.\n+     *\n+     * @return the number of episodes that *could* be cleaned up, if needed\n+     */\n+    public int getReclaimableItems() {\n+        return getCandidates().size();\n+    }\n+\n+    @Override\n+    public int performCleanup(Context context, int numberOfEpisodesToDelete) {\n+        List<FeedItem> candidates = getCandidates();\n+        List<FeedItem> delete;\n+\n+        // in the absence of better data, we'll sort by item publication date\n+        Collections.sort(candidates, (lhs, rhs) -> {\n+            Date l = lhs.getPubDate();\n+            Date r = rhs.getPubDate();\n+\n+            if (l != null && r != null) {\n+                return l.compareTo(r);\n+            } else {\n+                // No date - compare by id which should be always incremented\n+                return Long.compare(lhs.getId(), rhs.getId());\n+            }\n+        });\n+\n+        if (candidates.size() > numberOfEpisodesToDelete) {\n+            delete = candidates.subList(0, numberOfEpisodesToDelete);\n+        } else {\n+            delete = candidates;\n+        }\n+\n+        for (FeedItem item : delete) {\n+            try {\n+                DBWriter.deleteFeedMediaOfItem(context, item.getMedia().getId()).get();\n+            } catch (InterruptedException | ExecutionException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+        int counter = delete.size();\n+\n+\n+        Log.i(TAG, String.format(Locale.US,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08edd151f9bc01873128fa97c948841b65b6455c"}, "originalPosition": 68}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4604, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}