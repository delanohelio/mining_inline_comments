{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5NjQ2NDIw", "number": 7337, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMTozOTozNVrOEZq1Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMTo0Nzo1NVrOEZq-_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzUxNjQ2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/RetriableStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMTozOTozNVrOHCnosQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMzozMzowNFrOHCqK6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwODU5Mw==", "bodyText": "No longer using \"fatal\" here, this is \"else isHedgeable=false\"", "url": "https://github.com/grpc/grpc-java/pull/7337#discussion_r472508593", "createdAt": "2020-08-18T21:39:35Z", "author": {"login": "ericgribkoff"}, "path": "core/src/main/java/io/grpc/internal/RetriableStream.java", "diffHunk": "@@ -837,51 +836,54 @@ public void run() {\n             nextBackoffIntervalNanos = retryPolicy.initialBackoffNanos;\n           }\n \n-          RetryPlan retryPlan = makeRetryDecision(status, trailers);\n-          if (retryPlan.shouldRetry) {\n-            // The check state.winningSubstream == null, checking if is not already committed, is\n-            // racy, but is still safe b/c the retry will also handle committed/cancellation\n-            FutureCanceller scheduledRetryCopy;\n+          if (!isHedging) {\n+            RetryPlan retryPlan = makeRetryDecision(status, trailers);\n+            if (retryPlan.shouldRetry) {\n+              // The check state.winningSubstream == null, checking if is not already committed, is\n+              // racy, but is still safe b/c the retry will also handle committed/cancellation\n+              FutureCanceller scheduledRetryCopy;\n+              synchronized (lock) {\n+                scheduledRetry = scheduledRetryCopy = new FutureCanceller(lock);\n+              }\n+              scheduledRetryCopy.setFuture(\n+                  scheduledExecutorService.schedule(\n+                      new Runnable() {\n+                        @Override\n+                        public void run() {\n+                          callExecutor.execute(\n+                              new Runnable() {\n+                                @Override\n+                                public void run() {\n+                                  // retry\n+                                  Substream newSubstream =\n+                                      createSubstream(substream.previousAttemptCount + 1);\n+                                  drain(newSubstream);\n+                                }\n+                              });\n+                        }\n+                      },\n+                      retryPlan.backoffNanos,\n+                      TimeUnit.NANOSECONDS));\n+              return;\n+            }\n+          } else {\n+            HedgingPlan hedgingPlan = makeHedgingDecision(status, trailers);\n+            if (hedgingPlan.isHedgeable) {\n+              pushbackHedging(hedgingPlan.hedgingPushbackMillis);\n+            }\n             synchronized (lock) {\n-              scheduledRetry = scheduledRetryCopy = new FutureCanceller(lock);\n+              state = state.removeActiveHedge(substream);\n+              // The invariant is whether or not #(Potential Hedge + active hedges) > 0.\n+              // Once hasPotentialHedging(state) is false, it will always be false, and then\n+              // #(state.activeHedges) will be decreasing. This guarantees that even there may be\n+              // multiple concurrent hedges, one of the hedges will end up committed.\n+              if (hedgingPlan.isHedgeable) {\n+                if (hasPotentialHedging(state) || !state.activeHedges.isEmpty()) {\n+                  return;\n+                }\n+                // else, no activeHedges, no new hedges possible, try to commit\n+              } // else, fatal, try to commit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "010f00a3bec28fc4be18d9c3cc093f70b2aa49d6"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1MDEyMg==", "bodyText": "Fixed.", "url": "https://github.com/grpc/grpc-java/pull/7337#discussion_r472550122", "createdAt": "2020-08-18T23:33:04Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/RetriableStream.java", "diffHunk": "@@ -837,51 +836,54 @@ public void run() {\n             nextBackoffIntervalNanos = retryPolicy.initialBackoffNanos;\n           }\n \n-          RetryPlan retryPlan = makeRetryDecision(status, trailers);\n-          if (retryPlan.shouldRetry) {\n-            // The check state.winningSubstream == null, checking if is not already committed, is\n-            // racy, but is still safe b/c the retry will also handle committed/cancellation\n-            FutureCanceller scheduledRetryCopy;\n+          if (!isHedging) {\n+            RetryPlan retryPlan = makeRetryDecision(status, trailers);\n+            if (retryPlan.shouldRetry) {\n+              // The check state.winningSubstream == null, checking if is not already committed, is\n+              // racy, but is still safe b/c the retry will also handle committed/cancellation\n+              FutureCanceller scheduledRetryCopy;\n+              synchronized (lock) {\n+                scheduledRetry = scheduledRetryCopy = new FutureCanceller(lock);\n+              }\n+              scheduledRetryCopy.setFuture(\n+                  scheduledExecutorService.schedule(\n+                      new Runnable() {\n+                        @Override\n+                        public void run() {\n+                          callExecutor.execute(\n+                              new Runnable() {\n+                                @Override\n+                                public void run() {\n+                                  // retry\n+                                  Substream newSubstream =\n+                                      createSubstream(substream.previousAttemptCount + 1);\n+                                  drain(newSubstream);\n+                                }\n+                              });\n+                        }\n+                      },\n+                      retryPlan.backoffNanos,\n+                      TimeUnit.NANOSECONDS));\n+              return;\n+            }\n+          } else {\n+            HedgingPlan hedgingPlan = makeHedgingDecision(status, trailers);\n+            if (hedgingPlan.isHedgeable) {\n+              pushbackHedging(hedgingPlan.hedgingPushbackMillis);\n+            }\n             synchronized (lock) {\n-              scheduledRetry = scheduledRetryCopy = new FutureCanceller(lock);\n+              state = state.removeActiveHedge(substream);\n+              // The invariant is whether or not #(Potential Hedge + active hedges) > 0.\n+              // Once hasPotentialHedging(state) is false, it will always be false, and then\n+              // #(state.activeHedges) will be decreasing. This guarantees that even there may be\n+              // multiple concurrent hedges, one of the hedges will end up committed.\n+              if (hedgingPlan.isHedgeable) {\n+                if (hasPotentialHedging(state) || !state.activeHedges.isEmpty()) {\n+                  return;\n+                }\n+                // else, no activeHedges, no new hedges possible, try to commit\n+              } // else, fatal, try to commit", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwODU5Mw=="}, "originalCommit": {"oid": "010f00a3bec28fc4be18d9c3cc093f70b2aa49d6"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzUyNDU5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/RetriableStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMTo0MjoxM1rOHCnthQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMzozMjo1OFrOHCqK1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwOTgyOQ==", "bodyText": "This looks identical to lines 906-914 in makeRetryDecision. Can it be extracted out?", "url": "https://github.com/grpc/grpc-java/pull/7337#discussion_r472509829", "createdAt": "2020-08-18T21:42:13Z", "author": {"login": "ericgribkoff"}, "path": "core/src/main/java/io/grpc/internal/RetriableStream.java", "diffHunk": "@@ -942,8 +935,27 @@ private RetryPlan makeRetryDecision(Status status, Metadata trailer) {\n         } // else no retry\n       } // else no retry\n \n-      return new RetryPlan(\n-          shouldRetry, /* isFatal = */ false, backoffNanos, isHedging ? pushbackMillis : null);\n+      return new RetryPlan(shouldRetry, backoffNanos);\n+    }\n+\n+    private HedgingPlan makeHedgingDecision(Status status, Metadata trailer) {\n+      String pushbackStr = trailer.get(GRPC_RETRY_PUSHBACK_MS);\n+      Integer pushbackMillis = null;\n+      if (pushbackStr != null) {\n+        try {\n+          pushbackMillis = Integer.valueOf(pushbackStr);\n+        } catch (NumberFormatException e) {\n+          pushbackMillis = -1;\n+        }\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "010f00a3bec28fc4be18d9c3cc093f70b2aa49d6"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1MDEwMA==", "bodyText": "Done.", "url": "https://github.com/grpc/grpc-java/pull/7337#discussion_r472550100", "createdAt": "2020-08-18T23:32:58Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/RetriableStream.java", "diffHunk": "@@ -942,8 +935,27 @@ private RetryPlan makeRetryDecision(Status status, Metadata trailer) {\n         } // else no retry\n       } // else no retry\n \n-      return new RetryPlan(\n-          shouldRetry, /* isFatal = */ false, backoffNanos, isHedging ? pushbackMillis : null);\n+      return new RetryPlan(shouldRetry, backoffNanos);\n+    }\n+\n+    private HedgingPlan makeHedgingDecision(Status status, Metadata trailer) {\n+      String pushbackStr = trailer.get(GRPC_RETRY_PUSHBACK_MS);\n+      Integer pushbackMillis = null;\n+      if (pushbackStr != null) {\n+        try {\n+          pushbackMillis = Integer.valueOf(pushbackStr);\n+        } catch (NumberFormatException e) {\n+          pushbackMillis = -1;\n+        }\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwOTgyOQ=="}, "originalCommit": {"oid": "010f00a3bec28fc4be18d9c3cc093f70b2aa49d6"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzUyOTk0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/RetriableStream.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMTo0NDoxNVrOHCnw0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMzozMzo1M1rOHCqMAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxMDY3NA==", "bodyText": "Can this be && instead of ||? Or, even better, make line 953 if (!isFatal && throttle != null)? If isFatal=true, the return statement below will always be equivalent to return new HedgingPlan(false, pushbackMillis).", "url": "https://github.com/grpc/grpc-java/pull/7337#discussion_r472510674", "createdAt": "2020-08-18T21:44:15Z", "author": {"login": "ericgribkoff"}, "path": "core/src/main/java/io/grpc/internal/RetriableStream.java", "diffHunk": "@@ -942,8 +935,27 @@ private RetryPlan makeRetryDecision(Status status, Metadata trailer) {\n         } // else no retry\n       } // else no retry\n \n-      return new RetryPlan(\n-          shouldRetry, /* isFatal = */ false, backoffNanos, isHedging ? pushbackMillis : null);\n+      return new RetryPlan(shouldRetry, backoffNanos);\n+    }\n+\n+    private HedgingPlan makeHedgingDecision(Status status, Metadata trailer) {\n+      String pushbackStr = trailer.get(GRPC_RETRY_PUSHBACK_MS);\n+      Integer pushbackMillis = null;\n+      if (pushbackStr != null) {\n+        try {\n+          pushbackMillis = Integer.valueOf(pushbackStr);\n+        } catch (NumberFormatException e) {\n+          pushbackMillis = -1;\n+        }\n+      }\n+      boolean isFatal = !hedgingPolicy.nonFatalStatusCodes.contains(status.getCode());\n+      boolean isThrottled = false;\n+      if (throttle != null) {\n+        if (!isFatal || (pushbackMillis != null && pushbackMillis < 0)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "010f00a3bec28fc4be18d9c3cc093f70b2aa49d6"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU0NjUwMA==", "bodyText": "I don't quite follow. throttle.onQualifiedFailure() must be called if !isFatal || (pushbackMillis != null && pushbackMillis < 0) regardless what HedgingPlan will be returned.", "url": "https://github.com/grpc/grpc-java/pull/7337#discussion_r472546500", "createdAt": "2020-08-18T23:22:08Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/RetriableStream.java", "diffHunk": "@@ -942,8 +935,27 @@ private RetryPlan makeRetryDecision(Status status, Metadata trailer) {\n         } // else no retry\n       } // else no retry\n \n-      return new RetryPlan(\n-          shouldRetry, /* isFatal = */ false, backoffNanos, isHedging ? pushbackMillis : null);\n+      return new RetryPlan(shouldRetry, backoffNanos);\n+    }\n+\n+    private HedgingPlan makeHedgingDecision(Status status, Metadata trailer) {\n+      String pushbackStr = trailer.get(GRPC_RETRY_PUSHBACK_MS);\n+      Integer pushbackMillis = null;\n+      if (pushbackStr != null) {\n+        try {\n+          pushbackMillis = Integer.valueOf(pushbackStr);\n+        } catch (NumberFormatException e) {\n+          pushbackMillis = -1;\n+        }\n+      }\n+      boolean isFatal = !hedgingPolicy.nonFatalStatusCodes.contains(status.getCode());\n+      boolean isThrottled = false;\n+      if (throttle != null) {\n+        if (!isFatal || (pushbackMillis != null && pushbackMillis < 0)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxMDY3NA=="}, "originalCommit": {"oid": "010f00a3bec28fc4be18d9c3cc093f70b2aa49d6"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1MDQwMw==", "bodyText": "Ah, didn't realize that method had side effects", "url": "https://github.com/grpc/grpc-java/pull/7337#discussion_r472550403", "createdAt": "2020-08-18T23:33:53Z", "author": {"login": "ericgribkoff"}, "path": "core/src/main/java/io/grpc/internal/RetriableStream.java", "diffHunk": "@@ -942,8 +935,27 @@ private RetryPlan makeRetryDecision(Status status, Metadata trailer) {\n         } // else no retry\n       } // else no retry\n \n-      return new RetryPlan(\n-          shouldRetry, /* isFatal = */ false, backoffNanos, isHedging ? pushbackMillis : null);\n+      return new RetryPlan(shouldRetry, backoffNanos);\n+    }\n+\n+    private HedgingPlan makeHedgingDecision(Status status, Metadata trailer) {\n+      String pushbackStr = trailer.get(GRPC_RETRY_PUSHBACK_MS);\n+      Integer pushbackMillis = null;\n+      if (pushbackStr != null) {\n+        try {\n+          pushbackMillis = Integer.valueOf(pushbackStr);\n+        } catch (NumberFormatException e) {\n+          pushbackMillis = -1;\n+        }\n+      }\n+      boolean isFatal = !hedgingPolicy.nonFatalStatusCodes.contains(status.getCode());\n+      boolean isThrottled = false;\n+      if (throttle != null) {\n+        if (!isFatal || (pushbackMillis != null && pushbackMillis < 0)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxMDY3NA=="}, "originalCommit": {"oid": "010f00a3bec28fc4be18d9c3cc093f70b2aa49d6"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzU0MTExOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/RetriableStream.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMTo0Nzo1NVrOHCn3bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMzozMjo1MlrOHCqKtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxMjM2NA==", "bodyText": "Nit: Swap the blocks here to avoid the negation, so that this can be if (isHedging) { /* handle hedging */ } else { /* handle retry */ }?", "url": "https://github.com/grpc/grpc-java/pull/7337#discussion_r472512364", "createdAt": "2020-08-18T21:47:55Z", "author": {"login": "ericgribkoff"}, "path": "core/src/main/java/io/grpc/internal/RetriableStream.java", "diffHunk": "@@ -837,51 +836,54 @@ public void run() {\n             nextBackoffIntervalNanos = retryPolicy.initialBackoffNanos;\n           }\n \n-          RetryPlan retryPlan = makeRetryDecision(status, trailers);\n-          if (retryPlan.shouldRetry) {\n-            // The check state.winningSubstream == null, checking if is not already committed, is\n-            // racy, but is still safe b/c the retry will also handle committed/cancellation\n-            FutureCanceller scheduledRetryCopy;\n+          if (!isHedging) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "010f00a3bec28fc4be18d9c3cc093f70b2aa49d6"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1MDA3MA==", "bodyText": "Done.", "url": "https://github.com/grpc/grpc-java/pull/7337#discussion_r472550070", "createdAt": "2020-08-18T23:32:52Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/RetriableStream.java", "diffHunk": "@@ -837,51 +836,54 @@ public void run() {\n             nextBackoffIntervalNanos = retryPolicy.initialBackoffNanos;\n           }\n \n-          RetryPlan retryPlan = makeRetryDecision(status, trailers);\n-          if (retryPlan.shouldRetry) {\n-            // The check state.winningSubstream == null, checking if is not already committed, is\n-            // racy, but is still safe b/c the retry will also handle committed/cancellation\n-            FutureCanceller scheduledRetryCopy;\n+          if (!isHedging) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUxMjM2NA=="}, "originalCommit": {"oid": "010f00a3bec28fc4be18d9c3cc093f70b2aa49d6"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2470, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}