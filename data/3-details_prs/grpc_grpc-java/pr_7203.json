{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4MTEyOTIw", "number": 7203, "title": "xds: implement the top-level LB policy", "bodyText": "The top-level LB policy, which is an aggregator for CDS policies. It maintains the lifecycle of CDS LB policy instances. The pick argument taken from the Channel contains the information to determine which child CDS policy instance should the picking operation be delegated to.\nThe implementation is similar to the action part of what we currently have in the routing policy. The existing routing policy will be refactored to two parts, with the route match part moved into ConfigSelector and action part being this top-level LB policy.", "createdAt": "2020-07-13T09:01:06Z", "url": "https://github.com/grpc/grpc-java/pull/7203", "merged": true, "mergeCommit": {"oid": "b9d067677cdeacfb93d8654f8e267b8837c976cc"}, "closed": true, "closedAt": "2020-07-20T19:13:00Z", "author": {"login": "voidzcy"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc0dgNFAH2gAyNDQ4MTEyOTIwOmUzNTIxYjVkNjYwZjA3NTdmZjY2YTE4N2FhNzgxNTYxZGRmNjRhNzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc13kuxAFqTQ1MDg0Nzg5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e3521b5d660f0757ff66a187aa781561ddf64a77", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/e3521b5d660f0757ff66a187aa781561ddf64a77", "committedDate": "2020-07-13T08:52:34Z", "message": "Implement provider for the top-level LB policy, define config format and implement the config parser."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b12839b895c671603117e932a95fbf6a7e252992", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/b12839b895c671603117e932a95fbf6a7e252992", "committedDate": "2020-07-13T08:53:15Z", "message": "Add the top-level LB policy provider to the service provider resource"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c54dfc73a8b80cef92143afb95bcc280676d446b", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/c54dfc73a8b80cef92143afb95bcc280676d446b", "committedDate": "2020-07-13T08:54:01Z", "message": "Add tests for parsing top-level LB policy config"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f328b4ba5733dccae85281b931ba1951cf3ed12d", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/f328b4ba5733dccae85281b931ba1951cf3ed12d", "committedDate": "2020-07-13T08:54:30Z", "message": "Implement the top-level LB policy."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91af118465460bc0c8ef10d03297dd175ad58b58", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/91af118465460bc0c8ef10d03297dd175ad58b58", "committedDate": "2020-07-13T08:54:49Z", "message": "Add tests for the top-level LB policy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MzkzNzUy", "url": "https://github.com/grpc/grpc-java/pull/7203#pullrequestreview-448393752", "createdAt": "2020-07-14T19:17:40Z", "commit": {"oid": "91af118465460bc0c8ef10d03297dd175ad58b58"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxOToxNzo0MVrOGxhwDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxOToxNzo0MVrOGxhwDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4NjM4Mg==", "bodyText": "From our last discussion, we seemed to agree on updating the picker immediately if the list of clusters is changed, otherwise new RPCs may be routed to a new cluster but the picker does not include that cluster and will end up with failure.", "url": "https://github.com/grpc/grpc-java/pull/7203#discussion_r454586382", "createdAt": "2020-07-14T19:17:41Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/ClusterManagerLoadBalancer.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.CallOptions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterManagerLoadBalancerProvider.ClusterManagerConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The top-level load balancing policy.\n+ */\n+class ClusterManagerLoadBalancer extends LoadBalancer {\n+\n+  @VisibleForTesting\n+  static final int DELAYED_ACTION_DELETION_TIME_MINUTES = 15;\n+  @VisibleForTesting\n+  static final CallOptions.Key<String> ROUTING_CLUSTER_NAME_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.ROUTING_CLUSTER_NAME_KEY\");\n+\n+  private final Map<String, ChildLbState> childLbStates = new HashMap<>();\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final XdsLogger logger;\n+\n+  ClusterManagerLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.timeService = checkNotNull(helper.getScheduledExecutorService(), \"timeService\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    ClusterManagerConfig config = (ClusterManagerConfig)\n+        resolvedAddresses.getLoadBalancingPolicyConfig();\n+    Map<String, PolicySelection> newChildPolicies = config.childPolicies;\n+    logger.log(\n+        XdsLogLevel.INFO,\n+        \"Received cluster_manager lb config: child names={0}\", newChildPolicies.keySet());\n+    for (Map.Entry<String, PolicySelection> entry : newChildPolicies.entrySet()) {\n+      final String name = entry.getKey();\n+      LoadBalancerProvider childPolicyProvider = entry.getValue().getProvider();\n+      Object childConfig = entry.getValue().getConfig();\n+      if (!childLbStates.containsKey(name)) {\n+        childLbStates.put(name, new ChildLbState(name, childPolicyProvider));\n+      } else {\n+        childLbStates.get(name).reactivate(childPolicyProvider);\n+      }\n+      final ResolvedAddresses childAddresses =\n+          resolvedAddresses.toBuilder().setLoadBalancingPolicyConfig(childConfig).build();\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          childLbStates.get(name).lb.handleResolvedAddresses(childAddresses);\n+        }\n+      });\n+    }\n+    for (String name : childLbStates.keySet()) {\n+      if (!newChildPolicies.containsKey(name)) {\n+        childLbStates.get(name).deactivate();\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91af118465460bc0c8ef10d03297dd175ad58b58"}, "originalPosition": 103}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e72a07f6e230014f361fbc3b043210a909d08fb5", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/e72a07f6e230014f361fbc3b043210a909d08fb5", "committedDate": "2020-07-15T21:08:04Z", "message": "typo: used the wrong contant from a different class in unit test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7b3fd26849d4825efb3144d3c7adc081e699901", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/b7b3fd26849d4825efb3144d3c7adc081e699901", "committedDate": "2020-07-15T23:52:05Z", "message": "Immediately propagate a picker that makes picking from the updated group of child balancers to the Channel when handleResolvedAddresses is invoked."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af54f24ea510bb41439ccb12afa3fa34022f3402", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/af54f24ea510bb41439ccb12afa3fa34022f3402", "committedDate": "2020-07-15T23:52:19Z", "message": "Improve unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b9c5c67d9146f21c9a9b528c1a4184a1ae64c55", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/3b9c5c67d9146f21c9a9b528c1a4184a1ae64c55", "committedDate": "2020-07-15T23:56:14Z", "message": "Picking a Subchannel for a removed cluster should result in UNAVAILABLE instead of INTERNAL error."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bcabf09e0eba9842493358bbeb15eba7be768059", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/bcabf09e0eba9842493358bbeb15eba7be768059", "committedDate": "2020-07-16T17:36:58Z", "message": "formatting."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a0960a82a1e71751c1ae1202e622414a2e3875c", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/0a0960a82a1e71751c1ae1202e622414a2e3875c", "committedDate": "2020-07-16T17:36:21Z", "message": "formatting."}, "afterCommit": {"oid": "bcabf09e0eba9842493358bbeb15eba7be768059", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/bcabf09e0eba9842493358bbeb15eba7be768059", "committedDate": "2020-07-16T17:36:58Z", "message": "formatting."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwMTc4MDAz", "url": "https://github.com/grpc/grpc-java/pull/7203#pullrequestreview-450178003", "createdAt": "2020-07-16T20:07:13Z", "commit": {"oid": "bcabf09e0eba9842493358bbeb15eba7be768059"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMDowNzoxM1rOGy66CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMDozOTowM1rOGy77XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA0NzExMw==", "bodyText": "_ACTION_?", "url": "https://github.com/grpc/grpc-java/pull/7203#discussion_r456047113", "createdAt": "2020-07-16T20:07:13Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/ClusterManagerLoadBalancer.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.CallOptions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterManagerLoadBalancerProvider.ClusterManagerConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The top-level load balancing policy.\n+ */\n+class ClusterManagerLoadBalancer extends LoadBalancer {\n+\n+  @VisibleForTesting\n+  static final int DELAYED_ACTION_DELETION_TIME_MINUTES = 15;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcabf09e0eba9842493358bbeb15eba7be768059"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA1ODAxOQ==", "bodyText": "Even if deactivated, should still update currentState and currentPicker, just not updateOverallBalancingState() (already guaranteed). The XdsRoutingLoadBalancer has the same issue.", "url": "https://github.com/grpc/grpc-java/pull/7203#discussion_r456058019", "createdAt": "2020-07-16T20:28:18Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/ClusterManagerLoadBalancer.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.CallOptions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterManagerLoadBalancerProvider.ClusterManagerConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The top-level load balancing policy.\n+ */\n+class ClusterManagerLoadBalancer extends LoadBalancer {\n+\n+  @VisibleForTesting\n+  static final int DELAYED_ACTION_DELETION_TIME_MINUTES = 15;\n+  @VisibleForTesting\n+  static final CallOptions.Key<String> ROUTING_CLUSTER_NAME_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.ROUTING_CLUSTER_NAME_KEY\");\n+\n+  private final Map<String, ChildLbState> childLbStates = new HashMap<>();\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final XdsLogger logger;\n+\n+  ClusterManagerLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.timeService = checkNotNull(helper.getScheduledExecutorService(), \"timeService\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    ClusterManagerConfig config = (ClusterManagerConfig)\n+        resolvedAddresses.getLoadBalancingPolicyConfig();\n+    Map<String, PolicySelection> newChildPolicies = config.childPolicies;\n+    logger.log(\n+        XdsLogLevel.INFO,\n+        \"Received cluster_manager lb config: child names={0}\", newChildPolicies.keySet());\n+    for (Map.Entry<String, PolicySelection> entry : newChildPolicies.entrySet()) {\n+      final String name = entry.getKey();\n+      LoadBalancerProvider childPolicyProvider = entry.getValue().getProvider();\n+      Object childConfig = entry.getValue().getConfig();\n+      if (!childLbStates.containsKey(name)) {\n+        childLbStates.put(name, new ChildLbState(name, childPolicyProvider));\n+      } else {\n+        childLbStates.get(name).reactivate(childPolicyProvider);\n+      }\n+      final ResolvedAddresses childAddresses =\n+          resolvedAddresses.toBuilder().setLoadBalancingPolicyConfig(childConfig).build();\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          childLbStates.get(name).lb.handleResolvedAddresses(childAddresses);\n+        }\n+      });\n+    }\n+    for (String name : childLbStates.keySet()) {\n+      if (!newChildPolicies.containsKey(name)) {\n+        childLbStates.get(name).deactivate();\n+      }\n+    }\n+    updateOverallBalancingState();\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    boolean gotoTransientFailure = true;\n+    for (ChildLbState state : childLbStates.values()) {\n+      if (!state.deactivated) {\n+        gotoTransientFailure = false;\n+        state.lb.handleNameResolutionError(error);\n+      }\n+    }\n+    if (gotoTransientFailure) {\n+      helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    for (ChildLbState state : childLbStates.values()) {\n+      state.shutdown();\n+    }\n+  }\n+\n+  private void updateOverallBalancingState() {\n+    ConnectivityState overallState = null;\n+    final Map<String, SubchannelPicker> childPickers = new HashMap<>();\n+    for (ChildLbState childLbState : childLbStates.values()) {\n+      if (childLbState.deactivated) {\n+        continue;\n+      }\n+      childPickers.put(childLbState.name, childLbState.currentPicker);\n+      overallState = aggregateState(overallState, childLbState.currentState);\n+    }\n+    if (overallState != null) {\n+      SubchannelPicker picker = new SubchannelPicker() {\n+        @Override\n+        public PickResult pickSubchannel(PickSubchannelArgs args) {\n+          String clusterName = args.getCallOptions().getOption(ROUTING_CLUSTER_NAME_KEY);\n+          SubchannelPicker delegate = childPickers.get(clusterName);\n+          if (delegate == null) {\n+            return\n+                PickResult.withError(\n+                    Status.UNAVAILABLE.withDescription(\"Unable to find cluster \" + clusterName));\n+          }\n+          return delegate.pickSubchannel(args);\n+        }\n+      };\n+      helper.updateBalancingState(overallState, picker);\n+    }\n+  }\n+\n+  @Nullable\n+  private static ConnectivityState aggregateState(\n+      @Nullable ConnectivityState overallState, ConnectivityState childState) {\n+    if (overallState == null) {\n+      return childState;\n+    }\n+    if (overallState == READY || childState == READY) {\n+      return READY;\n+    }\n+    if (overallState == CONNECTING || childState == CONNECTING) {\n+      return CONNECTING;\n+    }\n+    if (overallState == IDLE || childState == IDLE) {\n+      return IDLE;\n+    }\n+    return overallState;\n+  }\n+\n+  private final class ChildLbState {\n+    private final String name;\n+    private final GracefulSwitchLoadBalancer lb;\n+    private LoadBalancerProvider policyProvider;\n+    private ConnectivityState currentState = CONNECTING;\n+    private SubchannelPicker currentPicker = BUFFER_PICKER;\n+    private boolean deactivated;\n+    @Nullable\n+    ScheduledHandle deletionTimer;\n+\n+    ChildLbState(String name, LoadBalancerProvider policyProvider) {\n+      this.name = name;\n+      this.policyProvider = policyProvider;\n+      lb = new GracefulSwitchLoadBalancer(new ChildLbStateHelper());\n+      lb.switchTo(policyProvider);\n+    }\n+\n+    void deactivate() {\n+      if (deactivated) {\n+        return;\n+      }\n+\n+      class DeletionTask implements Runnable {\n+        @Override\n+        public void run() {\n+          shutdown();\n+          childLbStates.remove(name);\n+        }\n+      }\n+\n+      deletionTimer =\n+          syncContext.schedule(\n+              new DeletionTask(),\n+              DELAYED_ACTION_DELETION_TIME_MINUTES,\n+              TimeUnit.MINUTES,\n+              timeService);\n+      deactivated = true;\n+      logger.log(XdsLogLevel.DEBUG, \"Child balancer {0} deactivated\", name);\n+    }\n+\n+    void reactivate(LoadBalancerProvider policyProvider) {\n+      if (deletionTimer != null && deletionTimer.isPending()) {\n+        deletionTimer.cancel();\n+        deactivated = false;\n+        logger.log(XdsLogLevel.DEBUG, \"Child balancer {0} reactivated\", name);\n+      }\n+      if (!this.policyProvider.getPolicyName().equals(policyProvider.getPolicyName())) {\n+        logger.log(\n+            XdsLogLevel.DEBUG,\n+            \"Child balancer {0} switching policy from {1} to {2}\",\n+            name, this.policyProvider.getPolicyName(), policyProvider.getPolicyName());\n+        lb.switchTo(policyProvider);\n+        this.policyProvider = policyProvider;\n+      }\n+    }\n+\n+    void shutdown() {\n+      deactivated = true;\n+      if (deletionTimer != null && deletionTimer.isPending()) {\n+        deletionTimer.cancel();\n+      }\n+      lb.shutdown();\n+      logger.log(XdsLogLevel.DEBUG, \"Child balancer {0} deleted\", name);\n+    }\n+\n+    private final class ChildLbStateHelper extends ForwardingLoadBalancerHelper {\n+\n+      @Override\n+      public void updateBalancingState(ConnectivityState newState, SubchannelPicker newPicker) {\n+        if (deactivated) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcabf09e0eba9842493358bbeb15eba7be768059"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA1ODkzNA==", "bodyText": "cds-lb?", "url": "https://github.com/grpc/grpc-java/pull/7203#discussion_r456058934", "createdAt": "2020-07-16T20:30:00Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/ClusterManagerLoadBalancer.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.CallOptions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterManagerLoadBalancerProvider.ClusterManagerConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The top-level load balancing policy.\n+ */\n+class ClusterManagerLoadBalancer extends LoadBalancer {\n+\n+  @VisibleForTesting\n+  static final int DELAYED_ACTION_DELETION_TIME_MINUTES = 15;\n+  @VisibleForTesting\n+  static final CallOptions.Key<String> ROUTING_CLUSTER_NAME_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.ROUTING_CLUSTER_NAME_KEY\");\n+\n+  private final Map<String, ChildLbState> childLbStates = new HashMap<>();\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final XdsLogger logger;\n+\n+  ClusterManagerLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.timeService = checkNotNull(helper.getScheduledExecutorService(), \"timeService\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcabf09e0eba9842493358bbeb15eba7be768059"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA2MzgzNg==", "bodyText": "Declare variable for childLbStates.get(name) ahead of syncContext.execute(), otherwise childLbStates might have been mutated when `syncContext.execute() in extreme case.\nOr just run childLbStates.get(name).lb.handleResolvedAddresses(childAddresses) inline at the end of this method.", "url": "https://github.com/grpc/grpc-java/pull/7203#discussion_r456063836", "createdAt": "2020-07-16T20:39:03Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/ClusterManagerLoadBalancer.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.CallOptions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.ClusterManagerLoadBalancerProvider.ClusterManagerConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The top-level load balancing policy.\n+ */\n+class ClusterManagerLoadBalancer extends LoadBalancer {\n+\n+  @VisibleForTesting\n+  static final int DELAYED_ACTION_DELETION_TIME_MINUTES = 15;\n+  @VisibleForTesting\n+  static final CallOptions.Key<String> ROUTING_CLUSTER_NAME_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.ROUTING_CLUSTER_NAME_KEY\");\n+\n+  private final Map<String, ChildLbState> childLbStates = new HashMap<>();\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService timeService;\n+  private final XdsLogger logger;\n+\n+  ClusterManagerLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.timeService = checkNotNull(helper.getScheduledExecutorService(), \"timeService\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    ClusterManagerConfig config = (ClusterManagerConfig)\n+        resolvedAddresses.getLoadBalancingPolicyConfig();\n+    Map<String, PolicySelection> newChildPolicies = config.childPolicies;\n+    logger.log(\n+        XdsLogLevel.INFO,\n+        \"Received cluster_manager lb config: child names={0}\", newChildPolicies.keySet());\n+    for (Map.Entry<String, PolicySelection> entry : newChildPolicies.entrySet()) {\n+      final String name = entry.getKey();\n+      LoadBalancerProvider childPolicyProvider = entry.getValue().getProvider();\n+      Object childConfig = entry.getValue().getConfig();\n+      if (!childLbStates.containsKey(name)) {\n+        childLbStates.put(name, new ChildLbState(name, childPolicyProvider));\n+      } else {\n+        childLbStates.get(name).reactivate(childPolicyProvider);\n+      }\n+      final ResolvedAddresses childAddresses =\n+          resolvedAddresses.toBuilder().setLoadBalancingPolicyConfig(childConfig).build();\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          childLbStates.get(name).lb.handleResolvedAddresses(childAddresses);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcabf09e0eba9842493358bbeb15eba7be768059"}, "originalPosition": 95}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dea91462e48209d1abe46f45a9c9a783e3bfe304", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/dea91462e48209d1abe46f45a9c9a783e3bfe304", "committedDate": "2020-07-16T23:09:24Z", "message": "Fix typos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77717f12c887b8f4b1ae80f32fd498978c70f5a1", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/77717f12c887b8f4b1ae80f32fd498978c70f5a1", "committedDate": "2020-07-16T23:30:07Z", "message": "Preserve updated picker/subchannel for deactivated child balancers."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57cefab223cd7d5575749e187601d21912050062", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/57cefab223cd7d5575749e187601d21912050062", "committedDate": "2020-07-16T23:32:07Z", "message": "Should call Update on the specific child balancer based on the time its config is updated in the parent balancer."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwODQ3ODkw", "url": "https://github.com/grpc/grpc-java/pull/7203#pullrequestreview-450847890", "createdAt": "2020-07-17T17:48:58Z", "commit": {"oid": "57cefab223cd7d5575749e187601d21912050062"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4312, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}