{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwNjAyMzYx", "number": 7446, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMjoxMjo1MFrOEoR0Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMjoxMjo1MFrOEoR0Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNjcwNDM4OnYy", "diffSide": "RIGHT", "path": "netty/src/main/java/io/grpc/netty/NettyClientHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMjoxMjo1MFrOHZRoGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMjoyMjo0NVrOHZR2Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2NTI0Mg==", "bodyText": "Why checking isReadable() while the old implementation did not?", "url": "https://github.com/grpc/grpc-java/pull/7446#discussion_r496265242", "createdAt": "2020-09-28T22:12:50Z", "author": {"login": "dapengzhang0"}, "path": "netty/src/main/java/io/grpc/netty/NettyClientHandler.java", "diffHunk": "@@ -912,4 +917,63 @@ public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Excepti\n       }\n     }\n   }\n+\n+  private static class PingCountingFrameWriter extends DecoratingHttp2FrameWriter\n+      implements AbstractNettyHandler.PingLimiter {\n+    private int pingCount;\n+\n+    public PingCountingFrameWriter(Http2FrameWriter delegate) {\n+      super(delegate);\n+    }\n+\n+    @Override\n+    public boolean isPingAllowed() {\n+      // \"3 strikes\" may cause the server to complain, so we limit ourselves to 2 or below.\n+      return pingCount < 2;\n+    }\n+\n+    @Override\n+    public ChannelFuture writeHeaders(\n+        ChannelHandlerContext ctx, int streamId, Http2Headers headers,\n+        int padding, boolean endStream, ChannelPromise promise) {\n+      pingCount = 0;\n+      return super.writeHeaders(ctx, streamId, headers, padding, endStream, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writeHeaders(\n+        ChannelHandlerContext ctx, int streamId, Http2Headers headers,\n+        int streamDependency, short weight, boolean exclusive,\n+        int padding, boolean endStream, ChannelPromise promise) {\n+      pingCount = 0;\n+      return super.writeHeaders(ctx, streamId, headers, streamDependency, weight, exclusive,\n+          padding, endStream, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writeWindowUpdate(\n+        ChannelHandlerContext ctx, int streamId, int windowSizeIncrement, ChannelPromise promise) {\n+      pingCount = 0;\n+      return super.writeWindowUpdate(ctx, streamId, windowSizeIncrement, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writePing(\n+        ChannelHandlerContext ctx, boolean ack, long data, ChannelPromise promise) {\n+      if (!ack) {\n+        pingCount++;\n+      }\n+      return super.writePing(ctx, ack, data, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writeData(\n+        ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endStream,\n+        ChannelPromise promise) {\n+      if (data.isReadable()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60454e5bc276a52be680ca9846cf000d127b1548"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2ODA1NQ==", "bodyText": "I mentioned I did this in the description: \"This change also avoids resetting the ping count for empty data frames (which shouldn't really happen with gRPC).\"\nIt was a subtle difference with the server's behavior that I noticed when debugging. While I don't think isReadable() will ever be false for gRPC, it seemed good to add the condition to avoid a surprise.", "url": "https://github.com/grpc/grpc-java/pull/7446#discussion_r496268055", "createdAt": "2020-09-28T22:20:25Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyClientHandler.java", "diffHunk": "@@ -912,4 +917,63 @@ public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Excepti\n       }\n     }\n   }\n+\n+  private static class PingCountingFrameWriter extends DecoratingHttp2FrameWriter\n+      implements AbstractNettyHandler.PingLimiter {\n+    private int pingCount;\n+\n+    public PingCountingFrameWriter(Http2FrameWriter delegate) {\n+      super(delegate);\n+    }\n+\n+    @Override\n+    public boolean isPingAllowed() {\n+      // \"3 strikes\" may cause the server to complain, so we limit ourselves to 2 or below.\n+      return pingCount < 2;\n+    }\n+\n+    @Override\n+    public ChannelFuture writeHeaders(\n+        ChannelHandlerContext ctx, int streamId, Http2Headers headers,\n+        int padding, boolean endStream, ChannelPromise promise) {\n+      pingCount = 0;\n+      return super.writeHeaders(ctx, streamId, headers, padding, endStream, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writeHeaders(\n+        ChannelHandlerContext ctx, int streamId, Http2Headers headers,\n+        int streamDependency, short weight, boolean exclusive,\n+        int padding, boolean endStream, ChannelPromise promise) {\n+      pingCount = 0;\n+      return super.writeHeaders(ctx, streamId, headers, streamDependency, weight, exclusive,\n+          padding, endStream, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writeWindowUpdate(\n+        ChannelHandlerContext ctx, int streamId, int windowSizeIncrement, ChannelPromise promise) {\n+      pingCount = 0;\n+      return super.writeWindowUpdate(ctx, streamId, windowSizeIncrement, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writePing(\n+        ChannelHandlerContext ctx, boolean ack, long data, ChannelPromise promise) {\n+      if (!ack) {\n+        pingCount++;\n+      }\n+      return super.writePing(ctx, ack, data, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writeData(\n+        ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endStream,\n+        ChannelPromise promise) {\n+      if (data.isReadable()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2NTI0Mg=="}, "originalCommit": {"oid": "60454e5bc276a52be680ca9846cf000d127b1548"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2ODg1OA==", "bodyText": "In short: the server does not reset the ping counter when it receives an empty data frame. It seemed we should do the same in our accounting.", "url": "https://github.com/grpc/grpc-java/pull/7446#discussion_r496268858", "createdAt": "2020-09-28T22:22:45Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyClientHandler.java", "diffHunk": "@@ -912,4 +917,63 @@ public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Excepti\n       }\n     }\n   }\n+\n+  private static class PingCountingFrameWriter extends DecoratingHttp2FrameWriter\n+      implements AbstractNettyHandler.PingLimiter {\n+    private int pingCount;\n+\n+    public PingCountingFrameWriter(Http2FrameWriter delegate) {\n+      super(delegate);\n+    }\n+\n+    @Override\n+    public boolean isPingAllowed() {\n+      // \"3 strikes\" may cause the server to complain, so we limit ourselves to 2 or below.\n+      return pingCount < 2;\n+    }\n+\n+    @Override\n+    public ChannelFuture writeHeaders(\n+        ChannelHandlerContext ctx, int streamId, Http2Headers headers,\n+        int padding, boolean endStream, ChannelPromise promise) {\n+      pingCount = 0;\n+      return super.writeHeaders(ctx, streamId, headers, padding, endStream, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writeHeaders(\n+        ChannelHandlerContext ctx, int streamId, Http2Headers headers,\n+        int streamDependency, short weight, boolean exclusive,\n+        int padding, boolean endStream, ChannelPromise promise) {\n+      pingCount = 0;\n+      return super.writeHeaders(ctx, streamId, headers, streamDependency, weight, exclusive,\n+          padding, endStream, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writeWindowUpdate(\n+        ChannelHandlerContext ctx, int streamId, int windowSizeIncrement, ChannelPromise promise) {\n+      pingCount = 0;\n+      return super.writeWindowUpdate(ctx, streamId, windowSizeIncrement, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writePing(\n+        ChannelHandlerContext ctx, boolean ack, long data, ChannelPromise promise) {\n+      if (!ack) {\n+        pingCount++;\n+      }\n+      return super.writePing(ctx, ack, data, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writeData(\n+        ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endStream,\n+        ChannelPromise promise) {\n+      if (data.isReadable()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2NTI0Mg=="}, "originalCommit": {"oid": "60454e5bc276a52be680ca9846cf000d127b1548"}, "originalPosition": 108}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2355, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}