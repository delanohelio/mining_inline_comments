{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3NTQ2Njk3", "number": 6823, "title": "rls: rls request factory (aka key builder map)", "bodyText": "", "createdAt": "2020-03-13T01:27:18Z", "url": "https://github.com/grpc/grpc-java/pull/6823", "merged": true, "mergeCommit": {"oid": "1686d703e62ce6231c6e516fed303b7dbe132c63"}, "closed": true, "closedAt": "2020-04-10T22:56:41Z", "author": {"login": "creamsoup"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcNGAYugH2gAyMzg3NTQ2Njk3OjA2YTNlZjVhNDhjZWRjOTg2MmMyNDI3NDhjZTc0YjFiZjY1N2JhYzk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcWY81TgFqTM5MTY5MzMzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "06a3ef5a48cedc9862c242748ce74b1bf657bac9", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/06a3ef5a48cedc9862c242748ce74b1bf657bac9", "committedDate": "2020-03-13T01:26:57Z", "message": "rls: rls request factory (aka key builder map)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b5b77d0ab18c79ab6fc99d7261647c31ed947aa", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/4b5b77d0ab18c79ab6fc99d7261647c31ed947aa", "committedDate": "2020-03-13T18:19:15Z", "message": "check null for name"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTc5MjMz", "url": "https://github.com/grpc/grpc-java/pull/6823#pullrequestreview-391179233", "createdAt": "2020-04-09T22:45:22Z", "commit": {"oid": "4b5b77d0ab18c79ab6fc99d7261647c31ed947aa"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMjo0NToyMlrOGDr3zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMTozMDo1MFrOGEGZQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxNzcwOQ==", "bodyText": "s/A/An/", "url": "https://github.com/grpc/grpc-java/pull/6823#discussion_r406517709", "createdAt": "2020-04-09T22:45:22Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/RlsRequestFactory.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.Table;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.rls.internal.RlsProtoData.GrpcKeyBuilder;\n+import io.grpc.rls.internal.RlsProtoData.GrpcKeyBuilder.Name;\n+import io.grpc.rls.internal.RlsProtoData.NameMatcher;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.CheckReturnValue;\n+\n+/**\n+ * A RlsRequestFactory creates {@link RouteLookupRequest} using key builder map from {@link", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5b77d0ab18c79ab6fc99d7261647c31ed947aa"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxNzg1Nw==", "bodyText": "nit: empty line to be consistent.", "url": "https://github.com/grpc/grpc-java/pull/6823#discussion_r406517857", "createdAt": "2020-04-09T22:45:50Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/RlsRequestFactoryTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.junit.Assert.fail;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.grpc.Metadata;\n+import io.grpc.Status.Code;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.rls.internal.RlsProtoData.GrpcKeyBuilder;\n+import io.grpc.rls.internal.RlsProtoData.GrpcKeyBuilder.Name;\n+import io.grpc.rls.internal.RlsProtoData.NameMatcher;\n+import io.grpc.rls.internal.RlsProtoData.RequestProcessingStrategy;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class RlsRequestFactoryTest {\n+\n+  private static final RouteLookupConfig RLS_CONFIG =\n+      new RouteLookupConfig(\n+          ImmutableList.of(\n+              new GrpcKeyBuilder(\n+                  ImmutableList.of(new Name(\"com.google.service1\", \"Create\")),\n+                  ImmutableList.of(\n+                      new NameMatcher(\"user\", ImmutableList.of(\"User\", \"Parent\"), true),\n+                      new NameMatcher(\"id\", ImmutableList.of(\"X-Google-Id\"), true))),\n+              new GrpcKeyBuilder(\n+                  ImmutableList.of(new Name(\"com.google.service1\")),\n+                  ImmutableList.of(\n+                      new NameMatcher(\"user\", ImmutableList.of(\"User\", \"Parent\"), true),\n+                      new NameMatcher(\"password\", ImmutableList.of(\"Password\"), true))),\n+              new GrpcKeyBuilder(\n+                  ImmutableList.of(new Name(\"com.google.service2\")),\n+                  ImmutableList.of(\n+                      new NameMatcher(\"user\", ImmutableList.of(\"User\", \"Parent\"), false),\n+                      new NameMatcher(\"password\", ImmutableList.of(\"Password\"), true))),\n+              new GrpcKeyBuilder(\n+                  ImmutableList.of(new Name(\"com.google.service3\")),\n+                  ImmutableList.of(\n+                      new NameMatcher(\"user\", ImmutableList.of(\"User\", \"Parent\"), true)))),\n+          /* lookupService= */ \"foo.google.com\",\n+          /* lookupServiceTimeoutInMillis= */ TimeUnit.SECONDS.toMillis(2),\n+          /* maxAgeInMillis= */ TimeUnit.SECONDS.toMillis(300),\n+          /* staleAgeInMillis= */ TimeUnit.SECONDS.toMillis(240),\n+          /* cacheSize= */ 1000,\n+          /* validTargets= */ ImmutableList.of(\"a valid target\"),\n+          /* defaultTarget= */ \"us_east_1.cloudbigtable.googleapis.com\",\n+          RequestProcessingStrategy.ASYNC_LOOKUP_DEFAULT_TARGET_ON_MISS);\n+\n+  private final RlsRequestFactory factory = new RlsRequestFactory(RLS_CONFIG);\n+\n+  @Test\n+  public void create_pathMatches() {\n+    Metadata metadata = new Metadata();\n+    metadata.put(Metadata.Key.of(\"User\", Metadata.ASCII_STRING_MARSHALLER), \"test\");\n+    metadata.put(Metadata.Key.of(\"X-Google-Id\", Metadata.ASCII_STRING_MARSHALLER), \"123\");\n+    metadata.put(Metadata.Key.of(\"foo\", Metadata.ASCII_STRING_MARSHALLER), \"bar\");\n+\n+    RouteLookupRequest request = factory.create(\"com.google.service1\", \"Create\", metadata);\n+    assertThat(request.getTargetType()).isEqualTo(\"grpc\");\n+    assertThat(request.getPath()).isEqualTo(\"com.google.service1/Create\");\n+    assertThat(request.getServer()).isEqualTo(\"foo.google.com\");\n+    assertThat(request.getKeyMap()).containsExactly(\"user\", \"test\", \"id\", \"123\");\n+  }\n+\n+  @Test\n+  public void create_missingRequiredHeader() {\n+    Metadata metadata = new Metadata();\n+\n+    try {\n+      RouteLookupRequest unused = factory.create(\"com.google.service2\", \"Create\", metadata);\n+      fail();\n+    } catch (StatusRuntimeException e) {\n+      assertThat(e.getStatus().getCode()).isEqualTo(Code.INVALID_ARGUMENT);\n+      assertThat(e.getStatus().getDescription())\n+          .isEqualTo(\"Missing mandatory metadata(user) not found\");\n+    }\n+  }\n+\n+  @Test\n+  public void create_pathFallbackMatches() {\n+    Metadata metadata = new Metadata();\n+    metadata.put(Metadata.Key.of(\"Parent\", Metadata.ASCII_STRING_MARSHALLER), \"test\");\n+    metadata.put(Metadata.Key.of(\"Password\", Metadata.ASCII_STRING_MARSHALLER), \"hunter2\");\n+    metadata.put(Metadata.Key.of(\"foo\", Metadata.ASCII_STRING_MARSHALLER), \"bar\");\n+\n+    RouteLookupRequest request = factory.create(\"com.google.service1\" , \"Update\", metadata);\n+\n+    assertThat(request.getTargetType()).isEqualTo(\"grpc\");\n+    assertThat(request.getPath()).isEqualTo(\"com.google.service1/Update\");\n+    assertThat(request.getServer()).isEqualTo(\"foo.google.com\");\n+    assertThat(request.getKeyMap()).containsExactly(\"user\", \"test\", \"password\", \"hunter2\");\n+  }\n+\n+  @Test\n+  public void create_pathFallbackMatches_optionalHeaderMissing() {\n+    Metadata metadata = new Metadata();\n+    metadata.put(Metadata.Key.of(\"User\", Metadata.ASCII_STRING_MARSHALLER), \"test\");\n+    metadata.put(Metadata.Key.of(\"X-Google-Id\", Metadata.ASCII_STRING_MARSHALLER), \"123\");\n+    metadata.put(Metadata.Key.of(\"foo\", Metadata.ASCII_STRING_MARSHALLER), \"bar\");\n+\n+    RouteLookupRequest request = factory.create(\"com.google.service1\", \"Update\", metadata);\n+\n+    assertThat(request.getTargetType()).isEqualTo(\"grpc\");\n+    assertThat(request.getPath()).isEqualTo(\"com.google.service1/Update\");\n+    assertThat(request.getServer()).isEqualTo(\"foo.google.com\");\n+    assertThat(request.getKeyMap()).containsExactly(\"user\", \"test\");\n+  }\n+\n+  @Test\n+  public void create_unknownPath() {\n+    Metadata metadata = new Metadata();\n+    metadata.put(Metadata.Key.of(\"User\", Metadata.ASCII_STRING_MARSHALLER), \"test\");\n+    metadata.put(Metadata.Key.of(\"X-Google-Id\", Metadata.ASCII_STRING_MARSHALLER), \"123\");\n+    metadata.put(Metadata.Key.of(\"foo\", Metadata.ASCII_STRING_MARSHALLER), \"bar\");\n+\n+    RouteLookupRequest request = factory.create(\"abc.def.service999\", \"Update\", metadata);\n+\n+    assertThat(request.getTargetType()).isEqualTo(\"grpc\");\n+    assertThat(request.getPath()).isEqualTo(\"abc.def.service999/Update\");\n+    assertThat(request.getServer()).isEqualTo(\"foo.google.com\");\n+    assertThat(request.getKeyMap()).isEmpty();\n+  }\n+\n+  @Test\n+  public void create_noMethodInRlsConfig() {\n+    Metadata metadata = new Metadata();\n+    metadata.put(Metadata.Key.of(\"User\", Metadata.ASCII_STRING_MARSHALLER), \"test\");\n+    metadata.put(Metadata.Key.of(\"X-Google-Id\", Metadata.ASCII_STRING_MARSHALLER), \"123\");\n+    metadata.put(Metadata.Key.of(\"foo\", Metadata.ASCII_STRING_MARSHALLER), \"bar\");\n+\n+    RouteLookupRequest request = factory.create(\"com.google.service3\", \"Update\", metadata);\n+\n+    assertThat(request.getTargetType()).isEqualTo(\"grpc\");\n+    assertThat(request.getPath()).isEqualTo(\"com.google.service3/Update\");\n+    assertThat(request.getServer()).isEqualTo(\"foo.google.com\");\n+    assertThat(request.getKeyMap()).containsExactly(\"user\", \"test\");\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5b77d0ab18c79ab6fc99d7261647c31ed947aa"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxNzkyOQ==", "bodyText": "nit: empty line to be consistent.", "url": "https://github.com/grpc/grpc-java/pull/6823#discussion_r406517929", "createdAt": "2020-04-09T22:46:05Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/RlsRequestFactory.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.Table;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.rls.internal.RlsProtoData.GrpcKeyBuilder;\n+import io.grpc.rls.internal.RlsProtoData.GrpcKeyBuilder.Name;\n+import io.grpc.rls.internal.RlsProtoData.NameMatcher;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.CheckReturnValue;\n+\n+/**\n+ * A RlsRequestFactory creates {@link RouteLookupRequest} using key builder map from {@link\n+ * RouteLookupConfig}.\n+ */\n+final class RlsRequestFactory {\n+\n+  private final String target;\n+  /**\n+   * schema: Path(serviceName/methodName or serviceName/*), rls request headerName, header fields.\n+   */\n+  private final Table<String, String, NameMatcher> keyBuilderTable;\n+\n+  /** Constructor. */\n+  public RlsRequestFactory(RouteLookupConfig rlsConfig) {\n+    checkNotNull(rlsConfig, \"rlsConfig\");\n+    this.target = rlsConfig.getLookupService();\n+    this.keyBuilderTable = createKeyBuilderTable(rlsConfig);\n+  }\n+\n+  private static Table<String, String, NameMatcher> createKeyBuilderTable(\n+      RouteLookupConfig config) {\n+    Table<String, String, NameMatcher> table = HashBasedTable.create();\n+    for (GrpcKeyBuilder grpcKeyBuilder : config.getGrpcKeyBuilders()) {\n+      for (NameMatcher nameMatcher : grpcKeyBuilder.getHeaders()) {\n+        List<String> requestHeaders = nameMatcher.names();\n+        for (Name name : grpcKeyBuilder.getNames()) {\n+          String method =\n+              name.getMethod() == null || name.getMethod().isEmpty()\n+                  ? \"*\" : name.getMethod();\n+          String path = name.getService() + \"/\" + method;\n+          table.put(\n+              path,\n+              nameMatcher.getKey(),\n+              new NameMatcher(nameMatcher.getKey(), requestHeaders, nameMatcher.isOptional()));\n+        }\n+      }\n+    }\n+    return table;\n+  }\n+\n+  /** Creates an {@link RouteLookupRequest} for given request's metadata. */\n+  @CheckReturnValue\n+  public RouteLookupRequest create(String service, String method, Metadata metadata) {\n+    checkNotNull(service, \"service\");\n+    checkNotNull(method, \"method\");\n+    String path = service + \"/\" + method;\n+    Map<String, NameMatcher> keyBuilder = keyBuilderTable.row(path);\n+    // if no matching keyBuilder found, fall back to wildcard match (ServiceName/*)\n+    if (keyBuilder.isEmpty()) {\n+      keyBuilder = keyBuilderTable.row(service + \"/*\");\n+    }\n+    Map<String, String> rlsRequestHeaders = createRequestHeaders(metadata, keyBuilder);\n+    return new RouteLookupRequest(target, path, \"grpc\", rlsRequestHeaders);\n+  }\n+\n+  private Map<String, String> createRequestHeaders(\n+      Metadata metadata, Map<String, NameMatcher> keyBuilder) {\n+    Map<String, String> rlsRequestHeaders = new HashMap<>();\n+    for (Map.Entry<String, NameMatcher> entry : keyBuilder.entrySet()) {\n+      NameMatcher nameMatcher = entry.getValue();\n+      String value = null;\n+      for (String requestHeaderName : nameMatcher.names()) {\n+        value = metadata.get(Metadata.Key.of(requestHeaderName, Metadata.ASCII_STRING_MARSHALLER));\n+        if (value != null) {\n+          break;\n+        }\n+      }\n+      if (value != null) {\n+        rlsRequestHeaders.put(entry.getKey(), value);\n+      } else if (!nameMatcher.isOptional()) {\n+        throw new StatusRuntimeException(\n+            Status.INVALID_ARGUMENT.withDescription(\n+                String.format(\"Missing mandatory metadata(%s) not found\", entry.getKey())));\n+      }\n+    }\n+    return rlsRequestHeaders;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return MoreObjects.toStringHelper(this)\n+        .add(\"lookupService\", target)\n+        .add(\"keyBuilderTable\", keyBuilderTable)\n+        .toString();\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5b77d0ab18c79ab6fc99d7261647c31ed947aa"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjkxNjYyMw==", "bodyText": "Why making a new copy here, not just nameMatcher?", "url": "https://github.com/grpc/grpc-java/pull/6823#discussion_r406916623", "createdAt": "2020-04-10T19:54:19Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/RlsRequestFactory.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.Table;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.rls.internal.RlsProtoData.GrpcKeyBuilder;\n+import io.grpc.rls.internal.RlsProtoData.GrpcKeyBuilder.Name;\n+import io.grpc.rls.internal.RlsProtoData.NameMatcher;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.CheckReturnValue;\n+\n+/**\n+ * A RlsRequestFactory creates {@link RouteLookupRequest} using key builder map from {@link\n+ * RouteLookupConfig}.\n+ */\n+final class RlsRequestFactory {\n+\n+  private final String target;\n+  /**\n+   * schema: Path(serviceName/methodName or serviceName/*), rls request headerName, header fields.\n+   */\n+  private final Table<String, String, NameMatcher> keyBuilderTable;\n+\n+  /** Constructor. */\n+  public RlsRequestFactory(RouteLookupConfig rlsConfig) {\n+    checkNotNull(rlsConfig, \"rlsConfig\");\n+    this.target = rlsConfig.getLookupService();\n+    this.keyBuilderTable = createKeyBuilderTable(rlsConfig);\n+  }\n+\n+  private static Table<String, String, NameMatcher> createKeyBuilderTable(\n+      RouteLookupConfig config) {\n+    Table<String, String, NameMatcher> table = HashBasedTable.create();\n+    for (GrpcKeyBuilder grpcKeyBuilder : config.getGrpcKeyBuilders()) {\n+      for (NameMatcher nameMatcher : grpcKeyBuilder.getHeaders()) {\n+        List<String> requestHeaders = nameMatcher.names();\n+        for (Name name : grpcKeyBuilder.getNames()) {\n+          String method =\n+              name.getMethod() == null || name.getMethod().isEmpty()\n+                  ? \"*\" : name.getMethod();\n+          String path = name.getService() + \"/\" + method;\n+          table.put(\n+              path,\n+              nameMatcher.getKey(),\n+              new NameMatcher(nameMatcher.getKey(), requestHeaders, nameMatcher.isOptional()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5b77d0ab18c79ab6fc99d7261647c31ed947aa"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk1MjI1OA==", "bodyText": "s/an/a/", "url": "https://github.com/grpc/grpc-java/pull/6823#discussion_r406952258", "createdAt": "2020-04-10T21:30:50Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/RlsRequestFactory.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.Table;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.rls.internal.RlsProtoData.GrpcKeyBuilder;\n+import io.grpc.rls.internal.RlsProtoData.GrpcKeyBuilder.Name;\n+import io.grpc.rls.internal.RlsProtoData.NameMatcher;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.CheckReturnValue;\n+\n+/**\n+ * A RlsRequestFactory creates {@link RouteLookupRequest} using key builder map from {@link\n+ * RouteLookupConfig}.\n+ */\n+final class RlsRequestFactory {\n+\n+  private final String target;\n+  /**\n+   * schema: Path(serviceName/methodName or serviceName/*), rls request headerName, header fields.\n+   */\n+  private final Table<String, String, NameMatcher> keyBuilderTable;\n+\n+  /** Constructor. */\n+  public RlsRequestFactory(RouteLookupConfig rlsConfig) {\n+    checkNotNull(rlsConfig, \"rlsConfig\");\n+    this.target = rlsConfig.getLookupService();\n+    this.keyBuilderTable = createKeyBuilderTable(rlsConfig);\n+  }\n+\n+  private static Table<String, String, NameMatcher> createKeyBuilderTable(\n+      RouteLookupConfig config) {\n+    Table<String, String, NameMatcher> table = HashBasedTable.create();\n+    for (GrpcKeyBuilder grpcKeyBuilder : config.getGrpcKeyBuilders()) {\n+      for (NameMatcher nameMatcher : grpcKeyBuilder.getHeaders()) {\n+        List<String> requestHeaders = nameMatcher.names();\n+        for (Name name : grpcKeyBuilder.getNames()) {\n+          String method =\n+              name.getMethod() == null || name.getMethod().isEmpty()\n+                  ? \"*\" : name.getMethod();\n+          String path = name.getService() + \"/\" + method;\n+          table.put(\n+              path,\n+              nameMatcher.getKey(),\n+              new NameMatcher(nameMatcher.getKey(), requestHeaders, nameMatcher.isOptional()));\n+        }\n+      }\n+    }\n+    return table;\n+  }\n+\n+  /** Creates an {@link RouteLookupRequest} for given request's metadata. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b5b77d0ab18c79ab6fc99d7261647c31ed947aa"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64c51747b7e79e74d3e8b448c7f6ee9518e645a0", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/64c51747b7e79e74d3e8b448c7f6ee9518e645a0", "committedDate": "2020-04-10T22:27:10Z", "message": "address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4944494ab7cc54756842c65fb901488e6d9fbf5", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/a4944494ab7cc54756842c65fb901488e6d9fbf5", "committedDate": "2020-04-10T22:28:45Z", "message": "Update RlsRequestFactory.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd4900ccc9bfe0e36b2ca3911aac6d02d71f684b", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/dd4900ccc9bfe0e36b2ca3911aac6d02d71f684b", "committedDate": "2020-04-10T22:29:11Z", "message": "Update RlsRequestFactoryTest.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNjkzMzM1", "url": "https://github.com/grpc/grpc-java/pull/6823#pullrequestreview-391693335", "createdAt": "2020-04-10T22:36:27Z", "commit": {"oid": "4b5b77d0ab18c79ab6fc99d7261647c31ed947aa"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMjozNjoyOFrOGEHg3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQyMjozNjoyOFrOGEHg3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MDU5MQ==", "bodyText": "Well, not a big deal.", "url": "https://github.com/grpc/grpc-java/pull/6823#discussion_r406970591", "createdAt": "2020-04-10T22:36:28Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/RlsRequestFactory.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.HashBasedTable;\n+import com.google.common.collect.Table;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.rls.internal.RlsProtoData.GrpcKeyBuilder;\n+import io.grpc.rls.internal.RlsProtoData.GrpcKeyBuilder.Name;\n+import io.grpc.rls.internal.RlsProtoData.NameMatcher;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupConfig;\n+import io.grpc.rls.internal.RlsProtoData.RouteLookupRequest;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.CheckReturnValue;\n+\n+/**\n+ * A RlsRequestFactory creates {@link RouteLookupRequest} using key builder map from {@link", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxNzcwOQ=="}, "originalCommit": {"oid": "4b5b77d0ab18c79ab6fc99d7261647c31ed947aa"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4646, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}