{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4MjI3MjE3", "number": 7432, "title": "core: Inline AbstractServerImplBuilder", "bodyText": "A part of #7211.\nNote to reviewers\nCompare AbstractServerImplBuilder in ServerImplBuilder:\ngit diff f04f33efe:core/src/main/java/io/grpc/internal/AbstractServerImplBuilder.java 98a944d:core/src/main/java/io/grpc/internal/ServerImplBuilder.java\nCompare AbstractServerImplBuilderTest in ServerImplBuilderTest:\ngit diff f04f33efe:core/src/test/java/io/grpc/internal/AbstractServerImplBuilderTest.java 98a944d:core/src/test/java/io/grpc/internal/ServerImplBuilderTest.java", "createdAt": "2020-09-16T20:27:29Z", "url": "https://github.com/grpc/grpc-java/pull/7432", "merged": true, "mergeCommit": {"oid": "b571f23ad255884fc1bfebb1ab8eea4c849ea697"}, "closed": true, "closedAt": "2020-09-18T20:31:09Z", "author": {"login": "sergiitk"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdJiWrnAH2gAyNDg4MjI3MjE3Ojk4YTk0NGQ2YjBhNDllMDRhZjBjODBhN2FmNTk3NTA1MmFkNDliNzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdKH87nAH2gAyNDg4MjI3MjE3OmNkYjgxODMzNzk2ODUwMmI3YzE1NTM3MmMxNjUyMjlmZjVlN2Q4M2I=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "98a944d6b0a49e04af0c80a7af5975052ad49b75", "author": {"user": {"login": "sergiitk", "name": "Sergii Tkachenko"}}, "url": "https://github.com/grpc/grpc-java/commit/98a944d6b0a49e04af0c80a7af5975052ad49b75", "committedDate": "2020-09-16T20:24:06Z", "message": "core: Inline AbstractServerImplBuilder"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxMDE3Nzcw", "url": "https://github.com/grpc/grpc-java/pull/7432#pullrequestreview-491017770", "createdAt": "2020-09-17T21:58:26Z", "commit": {"oid": "98a944d6b0a49e04af0c80a7af5975052ad49b75"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMTo1ODoyNlrOHT29cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMjowMzozM1rOHT3FXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NTQ1OA==", "bodyText": "s/mean/meant/", "url": "https://github.com/grpc/grpc-java/pull/7432#discussion_r490585458", "createdAt": "2020-09-17T21:58:26Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ServerImplBuilder.java", "diffHunk": "@@ -44,62 +105,234 @@\n    * Creates a new server builder with given transport servers provider.\n    */\n   public ServerImplBuilder(ClientTransportServersBuilder clientTransportServersBuilder) {\n-    this.clientTransportServersBuilder = Preconditions\n-        .checkNotNull(clientTransportServersBuilder, \"clientTransportServersBuilder\");\n+    this.clientTransportServersBuilder = checkNotNull(clientTransportServersBuilder,\n+        \"clientTransportServersBuilder\");\n   }\n \n   @Override\n-  protected List<? extends InternalServer> buildTransportServers(\n-      List<? extends ServerStreamTracer.Factory> streamTracerFactories) {\n-    return clientTransportServersBuilder.buildClientTransportServers(streamTracerFactories);\n+  public ServerImplBuilder directExecutor() {\n+    return executor(MoreExecutors.directExecutor());\n   }\n \n   @Override\n-  public void setDeadlineTicker(Deadline.Ticker ticker) {\n-    super.setDeadlineTicker(ticker);\n+  public ServerImplBuilder executor(@Nullable Executor executor) {\n+    this.executorPool = executor != null ? new FixedObjectPool<>(executor) : DEFAULT_EXECUTOR_POOL;\n+    return this;\n   }\n \n   @Override\n-  public void setTracingEnabled(boolean value) {\n-    super.setTracingEnabled(value);\n+  public ServerImplBuilder addService(ServerServiceDefinition service) {\n+    registryBuilder.addService(checkNotNull(service, \"service\"));\n+    return this;\n   }\n \n   @Override\n-  public void setStatsEnabled(boolean value) {\n-    super.setStatsEnabled(value);\n+  public ServerImplBuilder addService(BindableService bindableService) {\n+    return addService(checkNotNull(bindableService, \"bindableService\").bindService());\n   }\n \n   @Override\n-  public void setStatsRecordStartedRpcs(boolean value) {\n-    super.setStatsRecordStartedRpcs(value);\n+  public ServerImplBuilder addTransportFilter(ServerTransportFilter filter) {\n+    transportFilters.add(checkNotNull(filter, \"filter\"));\n+    return this;\n   }\n \n   @Override\n-  public void setStatsRecordFinishedRpcs(boolean value) {\n-    super.setStatsRecordFinishedRpcs(value);\n+  public ServerImplBuilder intercept(ServerInterceptor interceptor) {\n+    interceptors.add(checkNotNull(interceptor, \"interceptor\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder addStreamTracerFactory(ServerStreamTracer.Factory factory) {\n+    streamTracerFactories.add(checkNotNull(factory, \"factory\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder fallbackHandlerRegistry(@Nullable HandlerRegistry registry) {\n+    this.fallbackRegistry = registry != null ? registry : DEFAULT_FALLBACK_REGISTRY;\n+    return this;\n   }\n \n   @Override\n+  public ServerImplBuilder decompressorRegistry(@Nullable DecompressorRegistry registry) {\n+    this.decompressorRegistry = registry != null ? registry : DEFAULT_DECOMPRESSOR_REGISTRY;\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder compressorRegistry(@Nullable CompressorRegistry registry) {\n+    this.compressorRegistry = registry != null ? registry : DEFAULT_COMPRESSOR_REGISTRY;\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder handshakeTimeout(long timeout, TimeUnit unit) {\n+    checkArgument(timeout > 0, \"handshake timeout is %s, but must be positive\", timeout);\n+    this.handshakeTimeoutMillis = checkNotNull(unit, \"unit\").toMillis(timeout);\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder setBinaryLog(@Nullable BinaryLog binaryLog) {\n+    this.binlog = binaryLog;\n+    return this;\n+  }\n+\n+  /**\n+   * Disable or enable stats features.  Enabled by default.\n+   */\n+  public void setStatsEnabled(boolean value) {\n+    this.statsEnabled = value;\n+  }\n+\n+  /**\n+   * Disable or enable stats recording for RPC upstarts.  Effective only if {@link\n+   * #setStatsEnabled} is set to true.  Enabled by default.\n+   */\n+  public void setStatsRecordStartedRpcs(boolean value) {\n+    recordStartedRpcs = value;\n+  }\n+\n+  /**\n+   * Disable or enable stats recording for RPC completions.  Effective only if {@link\n+   * #setStatsEnabled} is set to true.  Enabled by default.\n+   */\n+  public void setStatsRecordFinishedRpcs(boolean value) {\n+    recordFinishedRpcs = value;\n+  }\n+\n+  /**\n+   * Disable or enable real-time metrics recording.  Effective only if {@link #setStatsEnabled} is\n+   * set to true.  Disabled by default.\n+   */\n   public void setStatsRecordRealTimeMetrics(boolean value) {\n-    super.setStatsRecordRealTimeMetrics(value);\n+    recordRealTimeMetrics = value;\n+  }\n+\n+  /**\n+   * Disable or enable tracing features.  Enabled by default.\n+   */\n+  public void setTracingEnabled(boolean value) {\n+    tracingEnabled = value;\n+  }\n+\n+  /**\n+   * Sets a custom deadline ticker.  This should only be called from InProcessServerBuilder.\n+   */\n+  public void setDeadlineTicker(Deadline.Ticker ticker) {\n+    this.ticker = checkNotNull(ticker, \"ticker\");\n   }\n \n   @Override\n+  public Server build() {\n+    return new ServerImpl(this, buildTransportServers(getTracerFactories()), Context.ROOT);\n+  }\n+\n+  @VisibleForTesting\n+  List<? extends ServerStreamTracer.Factory> getTracerFactories() {\n+    ArrayList<ServerStreamTracer.Factory> tracerFactories = new ArrayList<>();\n+    if (statsEnabled) {\n+      ServerStreamTracer.Factory censusStatsTracerFactory = null;\n+      try {\n+        Class<?> censusStatsAccessor =\n+            Class.forName(\"io.grpc.census.InternalCensusStatsAccessor\");\n+        Method getServerStreamTracerFactoryMethod =\n+            censusStatsAccessor.getDeclaredMethod(\n+                \"getServerStreamTracerFactory\",\n+                boolean.class,\n+                boolean.class,\n+                boolean.class);\n+        censusStatsTracerFactory =\n+            (ServerStreamTracer.Factory) getServerStreamTracerFactoryMethod\n+                .invoke(\n+                    null,\n+                    recordStartedRpcs,\n+                    recordFinishedRpcs,\n+                    recordRealTimeMetrics);\n+      } catch (ClassNotFoundException e) {\n+        // Replace these separate catch statements with multicatch when Android min-API >= 19\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (NoSuchMethodException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (IllegalAccessException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (InvocationTargetException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      }\n+      if (censusStatsTracerFactory != null) {\n+        tracerFactories.add(censusStatsTracerFactory);\n+      }\n+    }\n+    if (tracingEnabled) {\n+      ServerStreamTracer.Factory tracingStreamTracerFactory = null;\n+      try {\n+        Class<?> censusTracingAccessor =\n+            Class.forName(\"io.grpc.census.InternalCensusTracingAccessor\");\n+        Method getServerStreamTracerFactoryMethod =\n+            censusTracingAccessor.getDeclaredMethod(\"getServerStreamTracerFactory\");\n+        tracingStreamTracerFactory =\n+            (ServerStreamTracer.Factory) getServerStreamTracerFactoryMethod.invoke(null);\n+      } catch (ClassNotFoundException e) {\n+        // Replace these separate catch statements with multicatch when Android min-API >= 19\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (NoSuchMethodException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (IllegalAccessException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (InvocationTargetException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      }\n+      if (tracingStreamTracerFactory != null) {\n+        tracerFactories.add(tracingStreamTracerFactory);\n+      }\n+    }\n+    tracerFactories.addAll(streamTracerFactories);\n+    tracerFactories.trimToSize();\n+    return Collections.unmodifiableList(tracerFactories);\n+  }\n+\n   public InternalChannelz getChannelz() {\n-    return super.getChannelz();\n+    return channelz;\n   }\n \n-  @Override\n+  /**\n+   * Transport implementors must implement {@link ClientTransportServersBuilder} to transport\n+   * specific information for the server. This method is mean for Transport implementors and should", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98a944d6b0a49e04af0c80a7af5975052ad49b75"}, "originalPosition": 300}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NzQ4Ng==", "bodyText": "I wouldn't expect any transports to need this method and I don't see any references. It seems it could be made private or inlined into build(). If you want to keep it for ServerImplBuilderTest, then the javadoc comment isn't really appropriate.", "url": "https://github.com/grpc/grpc-java/pull/7432#discussion_r490587486", "createdAt": "2020-09-17T22:03:33Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ServerImplBuilder.java", "diffHunk": "@@ -44,62 +105,234 @@\n    * Creates a new server builder with given transport servers provider.\n    */\n   public ServerImplBuilder(ClientTransportServersBuilder clientTransportServersBuilder) {\n-    this.clientTransportServersBuilder = Preconditions\n-        .checkNotNull(clientTransportServersBuilder, \"clientTransportServersBuilder\");\n+    this.clientTransportServersBuilder = checkNotNull(clientTransportServersBuilder,\n+        \"clientTransportServersBuilder\");\n   }\n \n   @Override\n-  protected List<? extends InternalServer> buildTransportServers(\n-      List<? extends ServerStreamTracer.Factory> streamTracerFactories) {\n-    return clientTransportServersBuilder.buildClientTransportServers(streamTracerFactories);\n+  public ServerImplBuilder directExecutor() {\n+    return executor(MoreExecutors.directExecutor());\n   }\n \n   @Override\n-  public void setDeadlineTicker(Deadline.Ticker ticker) {\n-    super.setDeadlineTicker(ticker);\n+  public ServerImplBuilder executor(@Nullable Executor executor) {\n+    this.executorPool = executor != null ? new FixedObjectPool<>(executor) : DEFAULT_EXECUTOR_POOL;\n+    return this;\n   }\n \n   @Override\n-  public void setTracingEnabled(boolean value) {\n-    super.setTracingEnabled(value);\n+  public ServerImplBuilder addService(ServerServiceDefinition service) {\n+    registryBuilder.addService(checkNotNull(service, \"service\"));\n+    return this;\n   }\n \n   @Override\n-  public void setStatsEnabled(boolean value) {\n-    super.setStatsEnabled(value);\n+  public ServerImplBuilder addService(BindableService bindableService) {\n+    return addService(checkNotNull(bindableService, \"bindableService\").bindService());\n   }\n \n   @Override\n-  public void setStatsRecordStartedRpcs(boolean value) {\n-    super.setStatsRecordStartedRpcs(value);\n+  public ServerImplBuilder addTransportFilter(ServerTransportFilter filter) {\n+    transportFilters.add(checkNotNull(filter, \"filter\"));\n+    return this;\n   }\n \n   @Override\n-  public void setStatsRecordFinishedRpcs(boolean value) {\n-    super.setStatsRecordFinishedRpcs(value);\n+  public ServerImplBuilder intercept(ServerInterceptor interceptor) {\n+    interceptors.add(checkNotNull(interceptor, \"interceptor\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder addStreamTracerFactory(ServerStreamTracer.Factory factory) {\n+    streamTracerFactories.add(checkNotNull(factory, \"factory\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder fallbackHandlerRegistry(@Nullable HandlerRegistry registry) {\n+    this.fallbackRegistry = registry != null ? registry : DEFAULT_FALLBACK_REGISTRY;\n+    return this;\n   }\n \n   @Override\n+  public ServerImplBuilder decompressorRegistry(@Nullable DecompressorRegistry registry) {\n+    this.decompressorRegistry = registry != null ? registry : DEFAULT_DECOMPRESSOR_REGISTRY;\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder compressorRegistry(@Nullable CompressorRegistry registry) {\n+    this.compressorRegistry = registry != null ? registry : DEFAULT_COMPRESSOR_REGISTRY;\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder handshakeTimeout(long timeout, TimeUnit unit) {\n+    checkArgument(timeout > 0, \"handshake timeout is %s, but must be positive\", timeout);\n+    this.handshakeTimeoutMillis = checkNotNull(unit, \"unit\").toMillis(timeout);\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder setBinaryLog(@Nullable BinaryLog binaryLog) {\n+    this.binlog = binaryLog;\n+    return this;\n+  }\n+\n+  /**\n+   * Disable or enable stats features.  Enabled by default.\n+   */\n+  public void setStatsEnabled(boolean value) {\n+    this.statsEnabled = value;\n+  }\n+\n+  /**\n+   * Disable or enable stats recording for RPC upstarts.  Effective only if {@link\n+   * #setStatsEnabled} is set to true.  Enabled by default.\n+   */\n+  public void setStatsRecordStartedRpcs(boolean value) {\n+    recordStartedRpcs = value;\n+  }\n+\n+  /**\n+   * Disable or enable stats recording for RPC completions.  Effective only if {@link\n+   * #setStatsEnabled} is set to true.  Enabled by default.\n+   */\n+  public void setStatsRecordFinishedRpcs(boolean value) {\n+    recordFinishedRpcs = value;\n+  }\n+\n+  /**\n+   * Disable or enable real-time metrics recording.  Effective only if {@link #setStatsEnabled} is\n+   * set to true.  Disabled by default.\n+   */\n   public void setStatsRecordRealTimeMetrics(boolean value) {\n-    super.setStatsRecordRealTimeMetrics(value);\n+    recordRealTimeMetrics = value;\n+  }\n+\n+  /**\n+   * Disable or enable tracing features.  Enabled by default.\n+   */\n+  public void setTracingEnabled(boolean value) {\n+    tracingEnabled = value;\n+  }\n+\n+  /**\n+   * Sets a custom deadline ticker.  This should only be called from InProcessServerBuilder.\n+   */\n+  public void setDeadlineTicker(Deadline.Ticker ticker) {\n+    this.ticker = checkNotNull(ticker, \"ticker\");\n   }\n \n   @Override\n+  public Server build() {\n+    return new ServerImpl(this, buildTransportServers(getTracerFactories()), Context.ROOT);\n+  }\n+\n+  @VisibleForTesting\n+  List<? extends ServerStreamTracer.Factory> getTracerFactories() {\n+    ArrayList<ServerStreamTracer.Factory> tracerFactories = new ArrayList<>();\n+    if (statsEnabled) {\n+      ServerStreamTracer.Factory censusStatsTracerFactory = null;\n+      try {\n+        Class<?> censusStatsAccessor =\n+            Class.forName(\"io.grpc.census.InternalCensusStatsAccessor\");\n+        Method getServerStreamTracerFactoryMethod =\n+            censusStatsAccessor.getDeclaredMethod(\n+                \"getServerStreamTracerFactory\",\n+                boolean.class,\n+                boolean.class,\n+                boolean.class);\n+        censusStatsTracerFactory =\n+            (ServerStreamTracer.Factory) getServerStreamTracerFactoryMethod\n+                .invoke(\n+                    null,\n+                    recordStartedRpcs,\n+                    recordFinishedRpcs,\n+                    recordRealTimeMetrics);\n+      } catch (ClassNotFoundException e) {\n+        // Replace these separate catch statements with multicatch when Android min-API >= 19\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (NoSuchMethodException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (IllegalAccessException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (InvocationTargetException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      }\n+      if (censusStatsTracerFactory != null) {\n+        tracerFactories.add(censusStatsTracerFactory);\n+      }\n+    }\n+    if (tracingEnabled) {\n+      ServerStreamTracer.Factory tracingStreamTracerFactory = null;\n+      try {\n+        Class<?> censusTracingAccessor =\n+            Class.forName(\"io.grpc.census.InternalCensusTracingAccessor\");\n+        Method getServerStreamTracerFactoryMethod =\n+            censusTracingAccessor.getDeclaredMethod(\"getServerStreamTracerFactory\");\n+        tracingStreamTracerFactory =\n+            (ServerStreamTracer.Factory) getServerStreamTracerFactoryMethod.invoke(null);\n+      } catch (ClassNotFoundException e) {\n+        // Replace these separate catch statements with multicatch when Android min-API >= 19\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (NoSuchMethodException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (IllegalAccessException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (InvocationTargetException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      }\n+      if (tracingStreamTracerFactory != null) {\n+        tracerFactories.add(tracingStreamTracerFactory);\n+      }\n+    }\n+    tracerFactories.addAll(streamTracerFactories);\n+    tracerFactories.trimToSize();\n+    return Collections.unmodifiableList(tracerFactories);\n+  }\n+\n   public InternalChannelz getChannelz() {\n-    return super.getChannelz();\n+    return channelz;\n   }\n \n-  @Override\n+  /**\n+   * Transport implementors must implement {@link ClientTransportServersBuilder} to transport\n+   * specific information for the server. This method is mean for Transport implementors and should\n+   * not be used by normal users.\n+   *\n+   * @param streamTracerFactories an immutable list of stream tracer factories\n+   */\n+  @VisibleForTesting\n+  List<? extends InternalServer> buildTransportServers(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98a944d6b0a49e04af0c80a7af5975052ad49b75"}, "originalPosition": 306}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb2b307b09e03c21711cb19773c35dec2ebda25a", "author": {"user": {"login": "sergiitk", "name": "Sergii Tkachenko"}}, "url": "https://github.com/grpc/grpc-java/commit/fb2b307b09e03c21711cb19773c35dec2ebda25a", "committedDate": "2020-09-18T15:41:38Z", "message": "fixup! core: Inline AbstractServerImplBuilder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdb818337968502b7c155372c165229ff5e7d83b", "author": {"user": {"login": "sergiitk", "name": "Sergii Tkachenko"}}, "url": "https://github.com/grpc/grpc-java/commit/cdb818337968502b7c155372c165229ff5e7d83b", "committedDate": "2020-09-18T16:12:22Z", "message": "fixup! error prone suggestions"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4046, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}