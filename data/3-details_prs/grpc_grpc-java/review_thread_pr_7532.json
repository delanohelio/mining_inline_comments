{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MDY1NjIz", "number": 7532, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo0OToyNlrOE0lOnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjozODoxN1rOE6Q8jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNTcxMzU3OnYy", "diffSide": "RIGHT", "path": "netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo0OToyNlrOHsYyog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMjo0OToyNlrOHsYyog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwNTU3MA==", "bodyText": "Why duplicate, and then unwrap?", "url": "https://github.com/grpc/grpc-java/pull/7532#discussion_r516305570", "createdAt": "2020-11-02T22:49:26Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyAdaptiveCumulator.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.netty;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.CompositeByteBuf;\n+\n+class NettyAdaptiveCumulator implements io.netty.handler.codec.ByteToMessageDecoder.Cumulator {\n+  private final int composeMinSize;\n+\n+  NettyAdaptiveCumulator(int composeMinSize) {\n+    Preconditions.checkArgument(composeMinSize >= 0, \"composeMinSize must be non-negative\");\n+    this.composeMinSize = composeMinSize;\n+  }\n+\n+  /**\n+   * \"Adaptive\" cumulator: cumulate {@link ByteBuf}s by dynamically switching between merge and\n+   * compose strategies.\n+   *\n+   * <p>This cumulator applies a heuristic to make a decision whether to track a reference to the\n+   * buffer with bytes received from the network stack in an array (\"zero-copy\"), or to merge into\n+   * the last component (the tail) by performing a memory copy.\n+   *\n+   * <p>It is necessary as a protection from a potential attack on the {@link\n+   * io.netty.handler.codec.ByteToMessageDecoder#COMPOSITE_CUMULATOR}. Consider a pathological case\n+   * when an attacker sends TCP packages containing a single byte of data, and forcing the cumulator\n+   * to track each one in a separate buffer. The cost is memory overhead for each buffer, and extra\n+   * compute to read the cumulation.\n+   *\n+   * <p>Implemented heuristic establishes a minimal threshold for the total size of the tail and\n+   * incoming buffer, below which they are merged. The sum of the tail and the incoming buffer is\n+   * used to avoid a case where attacker alternates the size of data packets to trick the cumulator\n+   * into always selecting compose strategy.\n+   *\n+   * <p>Merging strategy attempts to minimize unnecessary memory writes. When possible, it expands\n+   * the tail capacity and only copies the incoming buffer into available memory. Otherwise, when\n+   * both tail and the buffer must be copied, the tail is reallocated (or fully replaced) with a new\n+   * buffer of exponentially increasing capacity (bounded to {@link #composeMinSize}) to ensure\n+   * runtime {@code O(n^2)} is amortized to {@code O(n)}.\n+   */\n+  @Override\n+  @SuppressWarnings(\"ReferenceEquality\")\n+  public final ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {\n+    if (!cumulation.isReadable()) {\n+      cumulation.release();\n+      return in;\n+    }\n+    CompositeByteBuf composite = null;\n+    try {\n+      if (cumulation instanceof CompositeByteBuf && cumulation.refCnt() == 1) {\n+        composite = (CompositeByteBuf) cumulation;\n+        // Writer index must equal capacity if we are going to \"write\"\n+        // new components to the end\n+        if (composite.writerIndex() != composite.capacity()) {\n+          composite.capacity(composite.writerIndex());\n+        }\n+      } else {\n+        composite = alloc.compositeBuffer(Integer.MAX_VALUE)\n+            .addFlattenedComponents(true, cumulation);\n+      }\n+      addInput(alloc, composite, in);\n+      in = null;\n+      return composite;\n+    } finally {\n+      if (in != null) {\n+        // We must release if the ownership was not transferred as otherwise it may produce a leak\n+        in.release();\n+        // Also release any new buffer allocated if we're not returning it\n+        if (composite != null && composite != cumulation) {\n+          composite.release();\n+        }\n+      }\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  void addInput(ByteBufAllocator alloc, CompositeByteBuf composite, ByteBuf in) {\n+    if (shouldCompose(composite, in, composeMinSize)) {\n+      composite.addFlattenedComponents(true, in);\n+    } else {\n+      // The total size of the new data and the last component are below the threshold. Merge them.\n+      mergeWithCompositeTail(alloc, composite, in);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  static boolean shouldCompose(CompositeByteBuf composite, ByteBuf in, int composeMinSize) {\n+    int componentCount = composite.numComponents();\n+    if (composite.numComponents() == 0) {\n+      return true;\n+    }\n+    int tailSize = composite.capacity() - composite.toByteIndex(componentCount - 1);\n+    return tailSize + in.readableBytes() >= composeMinSize;\n+  }\n+\n+  /**\n+   * Append the given {@link ByteBuf} {@code in} to {@link CompositeByteBuf} {@code composite} by\n+   * expanding or replacing the tail component of the {@link CompositeByteBuf}.\n+   *\n+   * <p>The goal is to prevent {@code O(n^2)} runtime in a pathological case, that forces copying\n+   * the tail component into a new buffer, for each incoming single-byte buffer. We append the new\n+   * bytes to the tail, when a write (or a fast write) is possible.\n+   *\n+   * <p>Otherwise, the tail is replaced with a new buffer, with the capacity increased enough to\n+   * achieve runtime amortization.\n+   *\n+   * <p>We assume that implementations of {@link ByteBufAllocator#calculateNewCapacity(int, int)},\n+   * are similar to {@link io.netty.buffer.AbstractByteBufAllocator#calculateNewCapacity(int, int)},\n+   * which doubles buffer capacity by normalizing it to the closest power of two. This assumption\n+   * is verified in unit tests for this method.\n+   */\n+  @VisibleForTesting\n+  static void mergeWithCompositeTail(ByteBufAllocator alloc, CompositeByteBuf composite,\n+      ByteBuf in) {\n+\n+    int newBytes = in.readableBytes();\n+    int tailIndex = composite.numComponents() - 1;\n+    int tailStart = composite.toByteIndex(tailIndex);\n+    int tailBytes = composite.capacity() - tailStart;\n+    int totalBytes = newBytes + tailBytes;\n+\n+    ByteBuf tail = composite.component(tailIndex);\n+    ByteBuf merged = null;\n+\n+    try {\n+      if (tail.refCnt() == 1 && !tail.isReadOnly() && totalBytes <= tail.maxCapacity()) {\n+        // Ideal case: the tail isn't shared, and can be expanded to the required capacity.\n+        // Take ownership of the tail.\n+        merged = tail.retainedDuplicate();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "169c94d49d72e4f485ff28b671e33199b5a57e0a"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NDczNzY5OnYy", "diffSide": "RIGHT", "path": "netty/src/test/java/io/grpc/netty/NettyTestUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODoxMTowNVrOHwpLxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODoxMTowNVrOHwpLxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2ODQ1Mw==", "bodyText": "No, please no. This is asking to be misused, and I don't think it is appropriate even in the test. I do think we should clean up the buffers, but if the reference counting is wrong the test should fail.", "url": "https://github.com/grpc/grpc-java/pull/7532#discussion_r520768453", "createdAt": "2020-11-10T18:11:05Z", "author": {"login": "ejona86"}, "path": "netty/src/test/java/io/grpc/netty/NettyTestUtil.java", "diffHunk": "@@ -56,6 +57,13 @@ static ByteBuf compressionFrame(byte[] data) {\n     return buf;\n   }\n \n+  // Buffer safe release: release until it's free.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "265b0f6976857e5648477307a13ab26e02dbbecb"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTMwNTA5OnYy", "diffSide": "RIGHT", "path": "netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMjozODoxN1rOH1OXtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzowNDo0NFrOH1PHLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MjAyMg==", "bodyText": "nit: normally this sort of thing we'd just do inline at the declaration and not in the @Before. This is fine though.", "url": "https://github.com/grpc/grpc-java/pull/7532#discussion_r525572022", "createdAt": "2020-11-17T22:38:17Z", "author": {"login": "ejona86"}, "path": "netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java", "diffHunk": "@@ -84,6 +86,14 @@ void addInput(ByteBufAllocator alloc, CompositeByteBuf composite, ByteBuf in) {\n           composite.addFlattenedComponents(true, in);\n         }\n       };\n+\n+      // Throws an error on adding incoming buffer.\n+      throwingCumulator = new NettyAdaptiveCumulator(0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bfa0c317e388ca8d4e60c82270064e32dd58548"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4NDE3Mg==", "bodyText": "I'll get it fixed separately to not delay this.", "url": "https://github.com/grpc/grpc-java/pull/7532#discussion_r525584172", "createdAt": "2020-11-17T23:04:44Z", "author": {"login": "sergiitk"}, "path": "netty/src/test/java/io/grpc/netty/NettyAdaptiveCumulatorTest.java", "diffHunk": "@@ -84,6 +86,14 @@ void addInput(ByteBufAllocator alloc, CompositeByteBuf composite, ByteBuf in) {\n           composite.addFlattenedComponents(true, in);\n         }\n       };\n+\n+      // Throws an error on adding incoming buffer.\n+      throwingCumulator = new NettyAdaptiveCumulator(0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MjAyMg=="}, "originalCommit": {"oid": "0bfa0c317e388ca8d4e60c82270064e32dd58548"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2224, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}