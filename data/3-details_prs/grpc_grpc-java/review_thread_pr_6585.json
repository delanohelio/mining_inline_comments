{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5NjYwNDUx", "number": 6585, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQyMzoxMjo0MVrODWsmXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QyMDo1MzowNFrODXpxjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTI1OTgzOnYy", "diffSide": "RIGHT", "path": "interop-testing/build.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQyMzoxMjo0MVrOFbmtHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxODozNzoxMFrOFb_lDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5MDAxNQ==", "bodyText": "Not aligned.", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r364490015", "createdAt": "2020-01-08T23:12:41Z", "author": {"login": "dapengzhang0"}, "path": "interop-testing/build.gradle", "diffHunk": "@@ -24,6 +24,7 @@ dependencies {\n             project(':grpc-protobuf'),\n             project(':grpc-stub'),\n             project(':grpc-testing'),\n+\t    project(':grpc-xds'),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca483af07cf554fc5fd4ccbfa2659640b2419dc3"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5NzU0OQ==", "bodyText": "Fixed", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r364897549", "createdAt": "2020-01-09T18:37:10Z", "author": {"login": "ericgribkoff"}, "path": "interop-testing/build.gradle", "diffHunk": "@@ -24,6 +24,7 @@ dependencies {\n             project(':grpc-protobuf'),\n             project(':grpc-stub'),\n             project(':grpc-testing'),\n+\t    project(':grpc-xds'),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5MDAxNQ=="}, "originalCommit": {"oid": "ca483af07cf554fc5fd4ccbfa2659640b2419dc3"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTI3MTEwOnYy", "diffSide": "RIGHT", "path": "interop-testing/src/main/proto/grpc/testing/messages.proto", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQyMzoxODozNlrOFbmz5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQxOTowNzoxNlrOFcdZFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5MTc1MQ==", "bodyText": "What does this field mean?", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r364491751", "createdAt": "2020-01-08T23:18:36Z", "author": {"login": "dapengzhang0"}, "path": "interop-testing/src/main/proto/grpc/testing/messages.proto", "diffHunk": "@@ -160,3 +162,13 @@ message ReconnectInfo {\n   bool passed = 1;\n   repeated int32 backoff_ms = 2;\n }\n+\n+message LoadBalancerStatsRequest {\n+  int32 num_rpcs = 1;\n+  int32 timeout_sec = 2;\n+}\n+\n+message LoadBalancerStatsResponse {\n+  map<string, int32> rpcs_by_peer = 1;\n+  int32 num_without_peer = 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca483af07cf554fc5fd4ccbfa2659640b2419dc3"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5ODM3OA==", "bodyText": "Renamed to num_failures (it doesn't exactly correspond with failed RPCs, but for the purpose of the load balancer stats request these are rpcs which failed to produce stats)", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r364898378", "createdAt": "2020-01-09T18:39:15Z", "author": {"login": "ericgribkoff"}, "path": "interop-testing/src/main/proto/grpc/testing/messages.proto", "diffHunk": "@@ -160,3 +162,13 @@ message ReconnectInfo {\n   bool passed = 1;\n   repeated int32 backoff_ms = 2;\n }\n+\n+message LoadBalancerStatsRequest {\n+  int32 num_rpcs = 1;\n+  int32 timeout_sec = 2;\n+}\n+\n+message LoadBalancerStatsResponse {\n+  map<string, int32> rpcs_by_peer = 1;\n+  int32 num_without_peer = 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5MTc1MQ=="}, "originalCommit": {"oid": "ca483af07cf554fc5fd4ccbfa2659640b2419dc3"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM4MDU3MA==", "bodyText": "I don't care too much about choosing the name of the field. As there is always subtleties, it's worth a protodoc to clarify any subtleties that the user should be aware of.", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r365380570", "createdAt": "2020-01-10T18:54:37Z", "author": {"login": "dapengzhang0"}, "path": "interop-testing/src/main/proto/grpc/testing/messages.proto", "diffHunk": "@@ -160,3 +162,13 @@ message ReconnectInfo {\n   bool passed = 1;\n   repeated int32 backoff_ms = 2;\n }\n+\n+message LoadBalancerStatsRequest {\n+  int32 num_rpcs = 1;\n+  int32 timeout_sec = 2;\n+}\n+\n+message LoadBalancerStatsResponse {\n+  map<string, int32> rpcs_by_peer = 1;\n+  int32 num_without_peer = 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5MTc1MQ=="}, "originalCommit": {"oid": "ca483af07cf554fc5fd4ccbfa2659640b2419dc3"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM4NjAwNg==", "bodyText": "Ok, done.", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r365386006", "createdAt": "2020-01-10T19:07:16Z", "author": {"login": "ericgribkoff"}, "path": "interop-testing/src/main/proto/grpc/testing/messages.proto", "diffHunk": "@@ -160,3 +162,13 @@ message ReconnectInfo {\n   bool passed = 1;\n   repeated int32 backoff_ms = 2;\n }\n+\n+message LoadBalancerStatsRequest {\n+  int32 num_rpcs = 1;\n+  int32 timeout_sec = 2;\n+}\n+\n+message LoadBalancerStatsResponse {\n+  map<string, int32> rpcs_by_peer = 1;\n+  int32 num_without_peer = 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5MTc1MQ=="}, "originalCommit": {"oid": "ca483af07cf554fc5fd4ccbfa2659640b2419dc3"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTI3OTQ0OnYy", "diffSide": "RIGHT", "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestServer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQyMzoyMjoyNFrOFbm4lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxODozNzozMFrOFb_lkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5Mjk1MQ==", "bodyText": "Why not fail the entire test immediately? Or just log the error and let host name be empty.", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r364492951", "createdAt": "2020-01-08T23:22:24Z", "author": {"login": "dapengzhang0"}, "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestServer.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.testing.integration;\n+\n+import io.grpc.Server;\n+import io.grpc.netty.NettyServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.integration.Messages.SimpleRequest;\n+import io.grpc.testing.integration.Messages.SimpleResponse;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.TimeUnit;\n+\n+/** Interop test server that implements the xDS testing service. */\n+public final class XdsTestServer {\n+  private int port = 8080;\n+  private String serverId = \"java_server\";\n+  private Server server;\n+\n+  /**\n+   * The main application allowing this client to be launched from the command line.\n+   */\n+  public static void main(String[] args) throws Exception {\n+    final XdsTestServer server = new XdsTestServer();\n+    server.parseArgs(args);\n+    Runtime.getRuntime()\n+        .addShutdownHook(\n+            new Thread() {\n+              @Override\n+              @SuppressWarnings(\"CatchAndPrintStackTrace\")\n+              public void run() {\n+                try {\n+                  System.out.println(\"Shutting down\");\n+                  server.stop();\n+                } catch (Exception e) {\n+                  e.printStackTrace();\n+                }\n+              }\n+            });\n+    server.start();\n+    System.out.println(\"Server started on port \" + server.port);\n+    server.blockUntilShutdown();\n+  }\n+\n+  private void parseArgs(String[] args) {\n+    boolean usage = false;\n+    for (String arg : args) {\n+      if (!arg.startsWith(\"--\")) {\n+        System.err.println(\"All arguments must start with '--': \" + arg);\n+        usage = true;\n+        break;\n+      }\n+      String[] parts = arg.substring(2).split(\"=\", 2);\n+      String key = parts[0];\n+      if (\"help\".equals(key)) {\n+        usage = true;\n+        break;\n+      }\n+      if (parts.length != 2) {\n+        System.err.println(\"All arguments must be of the form --arg=value\");\n+        usage = true;\n+        break;\n+      }\n+      String value = parts[1];\n+      if (\"port\".equals(key)) {\n+        port = Integer.valueOf(value);\n+      } else if (\"server_id\".equals(key)) {\n+        serverId = value;\n+      } else {\n+        System.err.println(\"Unknown argument: \" + key);\n+        usage = true;\n+        break;\n+      }\n+    }\n+\n+    if (usage) {\n+      XdsTestServer s = new XdsTestServer();\n+      System.err.println(\n+          \"Usage: [ARGS...]\"\n+              + \"\\n\"\n+              + \"\\n  --port=INT          listening port for server.\"\n+              + \"\\n                      Default: \"\n+              + s.port\n+              + \"\\n  --server_id=STRING  server ID for response.\"\n+              + \"\\n                      Default: \"\n+              + s.serverId);\n+      System.exit(1);\n+    }\n+  }\n+\n+  private void start() throws Exception {\n+    server = NettyServerBuilder.forPort(port).addService(new TestServiceImpl()).build().start();\n+  }\n+\n+  private void stop() throws Exception {\n+    server.shutdownNow();\n+    if (!server.awaitTermination(5, TimeUnit.SECONDS)) {\n+      System.err.println(\"Timed out waiting for server shutdown\");\n+    }\n+  }\n+\n+  private void blockUntilShutdown() throws InterruptedException {\n+    if (server != null) {\n+      server.awaitTermination();\n+    }\n+  }\n+\n+  private class TestServiceImpl extends TestServiceGrpc.TestServiceImplBase {\n+    private final String host;\n+\n+    private TestServiceImpl() {\n+      String tmpHost;\n+      try {\n+        tmpHost = InetAddress.getLocalHost().getHostName();\n+      } catch (UnknownHostException e) {\n+        tmpHost = \"failed to get host \" + e;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca483af07cf554fc5fd4ccbfa2659640b2419dc3"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5NzY4MQ==", "bodyText": "Done", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r364897681", "createdAt": "2020-01-09T18:37:30Z", "author": {"login": "ericgribkoff"}, "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestServer.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.testing.integration;\n+\n+import io.grpc.Server;\n+import io.grpc.netty.NettyServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.integration.Messages.SimpleRequest;\n+import io.grpc.testing.integration.Messages.SimpleResponse;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.TimeUnit;\n+\n+/** Interop test server that implements the xDS testing service. */\n+public final class XdsTestServer {\n+  private int port = 8080;\n+  private String serverId = \"java_server\";\n+  private Server server;\n+\n+  /**\n+   * The main application allowing this client to be launched from the command line.\n+   */\n+  public static void main(String[] args) throws Exception {\n+    final XdsTestServer server = new XdsTestServer();\n+    server.parseArgs(args);\n+    Runtime.getRuntime()\n+        .addShutdownHook(\n+            new Thread() {\n+              @Override\n+              @SuppressWarnings(\"CatchAndPrintStackTrace\")\n+              public void run() {\n+                try {\n+                  System.out.println(\"Shutting down\");\n+                  server.stop();\n+                } catch (Exception e) {\n+                  e.printStackTrace();\n+                }\n+              }\n+            });\n+    server.start();\n+    System.out.println(\"Server started on port \" + server.port);\n+    server.blockUntilShutdown();\n+  }\n+\n+  private void parseArgs(String[] args) {\n+    boolean usage = false;\n+    for (String arg : args) {\n+      if (!arg.startsWith(\"--\")) {\n+        System.err.println(\"All arguments must start with '--': \" + arg);\n+        usage = true;\n+        break;\n+      }\n+      String[] parts = arg.substring(2).split(\"=\", 2);\n+      String key = parts[0];\n+      if (\"help\".equals(key)) {\n+        usage = true;\n+        break;\n+      }\n+      if (parts.length != 2) {\n+        System.err.println(\"All arguments must be of the form --arg=value\");\n+        usage = true;\n+        break;\n+      }\n+      String value = parts[1];\n+      if (\"port\".equals(key)) {\n+        port = Integer.valueOf(value);\n+      } else if (\"server_id\".equals(key)) {\n+        serverId = value;\n+      } else {\n+        System.err.println(\"Unknown argument: \" + key);\n+        usage = true;\n+        break;\n+      }\n+    }\n+\n+    if (usage) {\n+      XdsTestServer s = new XdsTestServer();\n+      System.err.println(\n+          \"Usage: [ARGS...]\"\n+              + \"\\n\"\n+              + \"\\n  --port=INT          listening port for server.\"\n+              + \"\\n                      Default: \"\n+              + s.port\n+              + \"\\n  --server_id=STRING  server ID for response.\"\n+              + \"\\n                      Default: \"\n+              + s.serverId);\n+      System.exit(1);\n+    }\n+  }\n+\n+  private void start() throws Exception {\n+    server = NettyServerBuilder.forPort(port).addService(new TestServiceImpl()).build().start();\n+  }\n+\n+  private void stop() throws Exception {\n+    server.shutdownNow();\n+    if (!server.awaitTermination(5, TimeUnit.SECONDS)) {\n+      System.err.println(\"Timed out waiting for server shutdown\");\n+    }\n+  }\n+\n+  private void blockUntilShutdown() throws InterruptedException {\n+    if (server != null) {\n+      server.awaitTermination();\n+    }\n+  }\n+\n+  private class TestServiceImpl extends TestServiceGrpc.TestServiceImplBase {\n+    private final String host;\n+\n+    private TestServiceImpl() {\n+      String tmpHost;\n+      try {\n+        tmpHost = InetAddress.getLocalHost().getHostName();\n+      } catch (UnknownHostException e) {\n+        tmpHost = \"failed to get host \" + e;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5Mjk1MQ=="}, "originalCommit": {"oid": "ca483af07cf554fc5fd4ccbfa2659640b2419dc3"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1MTMwNjE2OnYy", "diffSide": "RIGHT", "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQyMzozNzoyMVrOFbnJEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQwMDozODoxNFrOFboEFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5NzE3MQ==", "bodyText": "Why not just call the rpc method with stub?", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r364497171", "createdAt": "2020-01-08T23:37:21Z", "author": {"login": "dapengzhang0"}, "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.testing.integration;\n+\n+import com.google.common.primitives.Ints;\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableScheduledFuture;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.CallOptions;\n+import io.grpc.ClientCall;\n+import io.grpc.Grpc;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.Server;\n+import io.grpc.Status;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.NettyServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsRequest;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsResponse;\n+import io.grpc.testing.integration.Messages.SimpleRequest;\n+import io.grpc.testing.integration.Messages.SimpleResponse;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/** Client for xDS interop tests. */\n+public final class XdsTestClient {\n+  private static Logger logger = Logger.getLogger(XdsTestClient.class.getName());\n+\n+  private int numChannels = 1;\n+  private boolean printResponse = false;\n+  private int qps = 1;\n+  private int rpcTimeoutSec = 2;\n+  private String server = \"localhost:8080\";\n+  private int statsPort = 8081;\n+  private Server statsServer;\n+\n+  /**\n+   * The main application allowing this client to be launched from the command line.\n+   */\n+  public static void main(String[] args) {\n+    final XdsTestClient client = new XdsTestClient();\n+    client.parseArgs(args);\n+    Runtime.getRuntime()\n+        .addShutdownHook(\n+            new Thread() {\n+              @Override\n+              @SuppressWarnings(\"CatchAndPrintStackTrace\")\n+              public void run() {\n+                try {\n+                  client.stop();\n+                } catch (Exception e) {\n+                  e.printStackTrace();\n+                }\n+              }\n+            });\n+    client.run();\n+  }\n+\n+  private void parseArgs(String[] args) {\n+    boolean usage = false;\n+    for (String arg : args) {\n+      if (!arg.startsWith(\"--\")) {\n+        System.err.println(\"All arguments must start with '--': \" + arg);\n+        usage = true;\n+        break;\n+      }\n+      String[] parts = arg.substring(2).split(\"=\", 2);\n+      String key = parts[0];\n+      if (\"help\".equals(key)) {\n+        usage = true;\n+        break;\n+      }\n+      if (parts.length != 2) {\n+        System.err.println(\"All arguments must be of the form --arg=value\");\n+        usage = true;\n+        break;\n+      }\n+      String value = parts[1];\n+      if (\"num_channels\".equals(key)) {\n+        numChannels = Integer.valueOf(value);\n+      } else if (\"print_response\".equals(key)) {\n+        printResponse = Boolean.valueOf(value);\n+      } else if (\"qps\".equals(key)) {\n+        qps = Integer.valueOf(value);\n+      } else if (\"rpc_timeout_sec\".equals(key)) {\n+        rpcTimeoutSec = Integer.valueOf(value);\n+      } else if (\"server\".equals(key)) {\n+        server = value;\n+      } else if (\"stats_port\".equals(key)) {\n+        statsPort = Integer.valueOf(value);\n+      } else {\n+        System.err.println(\"Unknown argument: \" + key);\n+        usage = true;\n+        break;\n+      }\n+    }\n+\n+    if (usage) {\n+      XdsTestClient c = new XdsTestClient();\n+      System.err.println(\n+          \"Usage: [ARGS...]\"\n+              + \"\\n\"\n+              + \"\\n  --num_channels=INT     Default: \"\n+              + c.numChannels\n+              + \"\\n  --print_response=BOOL  Write RPC response to stdout. Default: \"\n+              + c.printResponse\n+              + \"\\n  --qps=INT              Qps per channel. Default: \"\n+              + c.qps\n+              + \"\\n  --rpc_timeout_sec=INT  Per RPC timeout seconds. Default: \"\n+              + c.rpcTimeoutSec\n+              + \"\\n  --server=host:port     Address of server. Default: \"\n+              + c.server\n+              + \"\\n  --stats_port=INT       Port to expose peer distribution stats service. \"\n+              + \"Default: \"\n+              + c.statsPort);\n+      System.exit(1);\n+    }\n+  }\n+\n+  private void run() {\n+    statsServer = NettyServerBuilder.forPort(statsPort).addService(new XdsStatsImpl()).build();\n+    boolean success = false;\n+    try {\n+      statsServer.start();\n+      List<ManagedChannel> chans = new ArrayList<>();\n+      for (int i = 0; i < numChannels; i++) {\n+        chans.add(NettyChannelBuilder.forTarget(server).usePlaintext().build());\n+      }\n+      ListeningScheduledExecutorService exec =\n+          MoreExecutors.listeningDecorator(Executors.newSingleThreadScheduledExecutor());\n+      try {\n+        runQps(chans, exec);\n+        success = true;\n+      } finally {\n+        exec.shutdownNow();\n+        for (ManagedChannel chan : chans) {\n+          chan.shutdownNow();\n+        }\n+      }\n+    } catch (Throwable t) {\n+      logger.log(Level.SEVERE, \"Error running client\", t);\n+    }\n+\n+    statsServer.shutdownNow();\n+    System.exit(success ? 0 : 1);\n+  }\n+\n+  private void stop() throws Exception {\n+    statsServer.shutdownNow();\n+    if (!statsServer.awaitTermination(5, TimeUnit.SECONDS)) {\n+      System.err.println(\"Timed out waiting for server shutdown\");\n+    }\n+  }\n+\n+  private final Set<XdsStatsWatcher> watchers = new HashSet<>();\n+  private final Object lock = new Object();\n+  private long currentRequestId;\n+\n+  private void runQps(final List<ManagedChannel> chans, ListeningScheduledExecutorService exec)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    final SettableFuture<Void> failure = SettableFuture.create();\n+    final class PeriodicRpc implements Runnable {\n+      final AtomicLong messageIds = new AtomicLong();\n+\n+      @Override\n+      public void run() {\n+        final long requestId;\n+        final Set<XdsStatsWatcher> savedWatchers = new HashSet<>();\n+        synchronized (lock) {\n+          currentRequestId += 1;\n+          requestId = currentRequestId;\n+          savedWatchers.addAll(watchers);\n+        }\n+\n+        SimpleRequest request = SimpleRequest.newBuilder().setFillServerId(true).build();\n+        ManagedChannel channel = chans.get((int) (requestId % chans.size()));\n+        final ClientCall<SimpleRequest, SimpleResponse> call =\n+            channel.newCall(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca483af07cf554fc5fd4ccbfa2659640b2419dc3"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUwMDczOQ==", "bodyText": "To be able to invoke call.getAttributes().get(Grpc.TRANSPORT_ATTR_REMOTE_ADDR). If there's a simpler way to get access to the call attributes I'd be happy to change this.", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r364500739", "createdAt": "2020-01-08T23:51:20Z", "author": {"login": "ericgribkoff"}, "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.testing.integration;\n+\n+import com.google.common.primitives.Ints;\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableScheduledFuture;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.CallOptions;\n+import io.grpc.ClientCall;\n+import io.grpc.Grpc;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.Server;\n+import io.grpc.Status;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.NettyServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsRequest;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsResponse;\n+import io.grpc.testing.integration.Messages.SimpleRequest;\n+import io.grpc.testing.integration.Messages.SimpleResponse;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/** Client for xDS interop tests. */\n+public final class XdsTestClient {\n+  private static Logger logger = Logger.getLogger(XdsTestClient.class.getName());\n+\n+  private int numChannels = 1;\n+  private boolean printResponse = false;\n+  private int qps = 1;\n+  private int rpcTimeoutSec = 2;\n+  private String server = \"localhost:8080\";\n+  private int statsPort = 8081;\n+  private Server statsServer;\n+\n+  /**\n+   * The main application allowing this client to be launched from the command line.\n+   */\n+  public static void main(String[] args) {\n+    final XdsTestClient client = new XdsTestClient();\n+    client.parseArgs(args);\n+    Runtime.getRuntime()\n+        .addShutdownHook(\n+            new Thread() {\n+              @Override\n+              @SuppressWarnings(\"CatchAndPrintStackTrace\")\n+              public void run() {\n+                try {\n+                  client.stop();\n+                } catch (Exception e) {\n+                  e.printStackTrace();\n+                }\n+              }\n+            });\n+    client.run();\n+  }\n+\n+  private void parseArgs(String[] args) {\n+    boolean usage = false;\n+    for (String arg : args) {\n+      if (!arg.startsWith(\"--\")) {\n+        System.err.println(\"All arguments must start with '--': \" + arg);\n+        usage = true;\n+        break;\n+      }\n+      String[] parts = arg.substring(2).split(\"=\", 2);\n+      String key = parts[0];\n+      if (\"help\".equals(key)) {\n+        usage = true;\n+        break;\n+      }\n+      if (parts.length != 2) {\n+        System.err.println(\"All arguments must be of the form --arg=value\");\n+        usage = true;\n+        break;\n+      }\n+      String value = parts[1];\n+      if (\"num_channels\".equals(key)) {\n+        numChannels = Integer.valueOf(value);\n+      } else if (\"print_response\".equals(key)) {\n+        printResponse = Boolean.valueOf(value);\n+      } else if (\"qps\".equals(key)) {\n+        qps = Integer.valueOf(value);\n+      } else if (\"rpc_timeout_sec\".equals(key)) {\n+        rpcTimeoutSec = Integer.valueOf(value);\n+      } else if (\"server\".equals(key)) {\n+        server = value;\n+      } else if (\"stats_port\".equals(key)) {\n+        statsPort = Integer.valueOf(value);\n+      } else {\n+        System.err.println(\"Unknown argument: \" + key);\n+        usage = true;\n+        break;\n+      }\n+    }\n+\n+    if (usage) {\n+      XdsTestClient c = new XdsTestClient();\n+      System.err.println(\n+          \"Usage: [ARGS...]\"\n+              + \"\\n\"\n+              + \"\\n  --num_channels=INT     Default: \"\n+              + c.numChannels\n+              + \"\\n  --print_response=BOOL  Write RPC response to stdout. Default: \"\n+              + c.printResponse\n+              + \"\\n  --qps=INT              Qps per channel. Default: \"\n+              + c.qps\n+              + \"\\n  --rpc_timeout_sec=INT  Per RPC timeout seconds. Default: \"\n+              + c.rpcTimeoutSec\n+              + \"\\n  --server=host:port     Address of server. Default: \"\n+              + c.server\n+              + \"\\n  --stats_port=INT       Port to expose peer distribution stats service. \"\n+              + \"Default: \"\n+              + c.statsPort);\n+      System.exit(1);\n+    }\n+  }\n+\n+  private void run() {\n+    statsServer = NettyServerBuilder.forPort(statsPort).addService(new XdsStatsImpl()).build();\n+    boolean success = false;\n+    try {\n+      statsServer.start();\n+      List<ManagedChannel> chans = new ArrayList<>();\n+      for (int i = 0; i < numChannels; i++) {\n+        chans.add(NettyChannelBuilder.forTarget(server).usePlaintext().build());\n+      }\n+      ListeningScheduledExecutorService exec =\n+          MoreExecutors.listeningDecorator(Executors.newSingleThreadScheduledExecutor());\n+      try {\n+        runQps(chans, exec);\n+        success = true;\n+      } finally {\n+        exec.shutdownNow();\n+        for (ManagedChannel chan : chans) {\n+          chan.shutdownNow();\n+        }\n+      }\n+    } catch (Throwable t) {\n+      logger.log(Level.SEVERE, \"Error running client\", t);\n+    }\n+\n+    statsServer.shutdownNow();\n+    System.exit(success ? 0 : 1);\n+  }\n+\n+  private void stop() throws Exception {\n+    statsServer.shutdownNow();\n+    if (!statsServer.awaitTermination(5, TimeUnit.SECONDS)) {\n+      System.err.println(\"Timed out waiting for server shutdown\");\n+    }\n+  }\n+\n+  private final Set<XdsStatsWatcher> watchers = new HashSet<>();\n+  private final Object lock = new Object();\n+  private long currentRequestId;\n+\n+  private void runQps(final List<ManagedChannel> chans, ListeningScheduledExecutorService exec)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    final SettableFuture<Void> failure = SettableFuture.create();\n+    final class PeriodicRpc implements Runnable {\n+      final AtomicLong messageIds = new AtomicLong();\n+\n+      @Override\n+      public void run() {\n+        final long requestId;\n+        final Set<XdsStatsWatcher> savedWatchers = new HashSet<>();\n+        synchronized (lock) {\n+          currentRequestId += 1;\n+          requestId = currentRequestId;\n+          savedWatchers.addAll(watchers);\n+        }\n+\n+        SimpleRequest request = SimpleRequest.newBuilder().setFillServerId(true).build();\n+        ManagedChannel channel = chans.get((int) (requestId % chans.size()));\n+        final ClientCall<SimpleRequest, SimpleResponse> call =\n+            channel.newCall(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5NzE3MQ=="}, "originalCommit": {"oid": "ca483af07cf554fc5fd4ccbfa2659640b2419dc3"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUxMDA2Ng==", "bodyText": "An alternative is using interceptor, it may not be much simpler though.\nAtomicReference<ClientCall> clientCallRef = new AtomicReference<>();\nstub = stub.withDeadlineAfter().withInterceptors(\n  new ClientInterceptor() {\n      @Override\n      public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(\n          MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, Channel next) {\n        ClientCall<ReqT, RespT> call = next.newCall(method,callOptions);\n        clientCallRef.set(call);\n        return call;\n  });\n\ntry {\n  SimpleResponse response = stub.unaryCall(request);\n  serverId = response.getServerId();\n  if (printResponse) {\n    System.out.println(\n       \"Greeting: Hello world, this is \"\n          + response.getHostname()\n          + \", from \"\n          + clientCallRef.get().getAttributes().get(Grpc.TRANSPORT_ATTR_REMOTE_ADDR));\n  }\n} catch(RuntimeException e) {\n} finally {\n  for (XdsStatsWatcher watcher : savedWatchers) {\n    watcher.rpcCompleted(requestId, serverId);\n  }\n}", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r364510066", "createdAt": "2020-01-09T00:29:13Z", "author": {"login": "dapengzhang0"}, "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.testing.integration;\n+\n+import com.google.common.primitives.Ints;\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableScheduledFuture;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.CallOptions;\n+import io.grpc.ClientCall;\n+import io.grpc.Grpc;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.Server;\n+import io.grpc.Status;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.NettyServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsRequest;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsResponse;\n+import io.grpc.testing.integration.Messages.SimpleRequest;\n+import io.grpc.testing.integration.Messages.SimpleResponse;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/** Client for xDS interop tests. */\n+public final class XdsTestClient {\n+  private static Logger logger = Logger.getLogger(XdsTestClient.class.getName());\n+\n+  private int numChannels = 1;\n+  private boolean printResponse = false;\n+  private int qps = 1;\n+  private int rpcTimeoutSec = 2;\n+  private String server = \"localhost:8080\";\n+  private int statsPort = 8081;\n+  private Server statsServer;\n+\n+  /**\n+   * The main application allowing this client to be launched from the command line.\n+   */\n+  public static void main(String[] args) {\n+    final XdsTestClient client = new XdsTestClient();\n+    client.parseArgs(args);\n+    Runtime.getRuntime()\n+        .addShutdownHook(\n+            new Thread() {\n+              @Override\n+              @SuppressWarnings(\"CatchAndPrintStackTrace\")\n+              public void run() {\n+                try {\n+                  client.stop();\n+                } catch (Exception e) {\n+                  e.printStackTrace();\n+                }\n+              }\n+            });\n+    client.run();\n+  }\n+\n+  private void parseArgs(String[] args) {\n+    boolean usage = false;\n+    for (String arg : args) {\n+      if (!arg.startsWith(\"--\")) {\n+        System.err.println(\"All arguments must start with '--': \" + arg);\n+        usage = true;\n+        break;\n+      }\n+      String[] parts = arg.substring(2).split(\"=\", 2);\n+      String key = parts[0];\n+      if (\"help\".equals(key)) {\n+        usage = true;\n+        break;\n+      }\n+      if (parts.length != 2) {\n+        System.err.println(\"All arguments must be of the form --arg=value\");\n+        usage = true;\n+        break;\n+      }\n+      String value = parts[1];\n+      if (\"num_channels\".equals(key)) {\n+        numChannels = Integer.valueOf(value);\n+      } else if (\"print_response\".equals(key)) {\n+        printResponse = Boolean.valueOf(value);\n+      } else if (\"qps\".equals(key)) {\n+        qps = Integer.valueOf(value);\n+      } else if (\"rpc_timeout_sec\".equals(key)) {\n+        rpcTimeoutSec = Integer.valueOf(value);\n+      } else if (\"server\".equals(key)) {\n+        server = value;\n+      } else if (\"stats_port\".equals(key)) {\n+        statsPort = Integer.valueOf(value);\n+      } else {\n+        System.err.println(\"Unknown argument: \" + key);\n+        usage = true;\n+        break;\n+      }\n+    }\n+\n+    if (usage) {\n+      XdsTestClient c = new XdsTestClient();\n+      System.err.println(\n+          \"Usage: [ARGS...]\"\n+              + \"\\n\"\n+              + \"\\n  --num_channels=INT     Default: \"\n+              + c.numChannels\n+              + \"\\n  --print_response=BOOL  Write RPC response to stdout. Default: \"\n+              + c.printResponse\n+              + \"\\n  --qps=INT              Qps per channel. Default: \"\n+              + c.qps\n+              + \"\\n  --rpc_timeout_sec=INT  Per RPC timeout seconds. Default: \"\n+              + c.rpcTimeoutSec\n+              + \"\\n  --server=host:port     Address of server. Default: \"\n+              + c.server\n+              + \"\\n  --stats_port=INT       Port to expose peer distribution stats service. \"\n+              + \"Default: \"\n+              + c.statsPort);\n+      System.exit(1);\n+    }\n+  }\n+\n+  private void run() {\n+    statsServer = NettyServerBuilder.forPort(statsPort).addService(new XdsStatsImpl()).build();\n+    boolean success = false;\n+    try {\n+      statsServer.start();\n+      List<ManagedChannel> chans = new ArrayList<>();\n+      for (int i = 0; i < numChannels; i++) {\n+        chans.add(NettyChannelBuilder.forTarget(server).usePlaintext().build());\n+      }\n+      ListeningScheduledExecutorService exec =\n+          MoreExecutors.listeningDecorator(Executors.newSingleThreadScheduledExecutor());\n+      try {\n+        runQps(chans, exec);\n+        success = true;\n+      } finally {\n+        exec.shutdownNow();\n+        for (ManagedChannel chan : chans) {\n+          chan.shutdownNow();\n+        }\n+      }\n+    } catch (Throwable t) {\n+      logger.log(Level.SEVERE, \"Error running client\", t);\n+    }\n+\n+    statsServer.shutdownNow();\n+    System.exit(success ? 0 : 1);\n+  }\n+\n+  private void stop() throws Exception {\n+    statsServer.shutdownNow();\n+    if (!statsServer.awaitTermination(5, TimeUnit.SECONDS)) {\n+      System.err.println(\"Timed out waiting for server shutdown\");\n+    }\n+  }\n+\n+  private final Set<XdsStatsWatcher> watchers = new HashSet<>();\n+  private final Object lock = new Object();\n+  private long currentRequestId;\n+\n+  private void runQps(final List<ManagedChannel> chans, ListeningScheduledExecutorService exec)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    final SettableFuture<Void> failure = SettableFuture.create();\n+    final class PeriodicRpc implements Runnable {\n+      final AtomicLong messageIds = new AtomicLong();\n+\n+      @Override\n+      public void run() {\n+        final long requestId;\n+        final Set<XdsStatsWatcher> savedWatchers = new HashSet<>();\n+        synchronized (lock) {\n+          currentRequestId += 1;\n+          requestId = currentRequestId;\n+          savedWatchers.addAll(watchers);\n+        }\n+\n+        SimpleRequest request = SimpleRequest.newBuilder().setFillServerId(true).build();\n+        ManagedChannel channel = chans.get((int) (requestId % chans.size()));\n+        final ClientCall<SimpleRequest, SimpleResponse> call =\n+            channel.newCall(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5NzE3MQ=="}, "originalCommit": {"oid": "ca483af07cf554fc5fd4ccbfa2659640b2419dc3"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUxMjI3Ng==", "bodyText": "Yeah I'm not sure that's simpler either :) I think it's \"equally\" valid to directly interact with the ClientCall API as opposed to using an interceptor (there are at least examples of how do so in the ClientCall javadoc)?", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r364512276", "createdAt": "2020-01-09T00:38:14Z", "author": {"login": "ericgribkoff"}, "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.testing.integration;\n+\n+import com.google.common.primitives.Ints;\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableScheduledFuture;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.CallOptions;\n+import io.grpc.ClientCall;\n+import io.grpc.Grpc;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.Server;\n+import io.grpc.Status;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.NettyServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsRequest;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsResponse;\n+import io.grpc.testing.integration.Messages.SimpleRequest;\n+import io.grpc.testing.integration.Messages.SimpleResponse;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/** Client for xDS interop tests. */\n+public final class XdsTestClient {\n+  private static Logger logger = Logger.getLogger(XdsTestClient.class.getName());\n+\n+  private int numChannels = 1;\n+  private boolean printResponse = false;\n+  private int qps = 1;\n+  private int rpcTimeoutSec = 2;\n+  private String server = \"localhost:8080\";\n+  private int statsPort = 8081;\n+  private Server statsServer;\n+\n+  /**\n+   * The main application allowing this client to be launched from the command line.\n+   */\n+  public static void main(String[] args) {\n+    final XdsTestClient client = new XdsTestClient();\n+    client.parseArgs(args);\n+    Runtime.getRuntime()\n+        .addShutdownHook(\n+            new Thread() {\n+              @Override\n+              @SuppressWarnings(\"CatchAndPrintStackTrace\")\n+              public void run() {\n+                try {\n+                  client.stop();\n+                } catch (Exception e) {\n+                  e.printStackTrace();\n+                }\n+              }\n+            });\n+    client.run();\n+  }\n+\n+  private void parseArgs(String[] args) {\n+    boolean usage = false;\n+    for (String arg : args) {\n+      if (!arg.startsWith(\"--\")) {\n+        System.err.println(\"All arguments must start with '--': \" + arg);\n+        usage = true;\n+        break;\n+      }\n+      String[] parts = arg.substring(2).split(\"=\", 2);\n+      String key = parts[0];\n+      if (\"help\".equals(key)) {\n+        usage = true;\n+        break;\n+      }\n+      if (parts.length != 2) {\n+        System.err.println(\"All arguments must be of the form --arg=value\");\n+        usage = true;\n+        break;\n+      }\n+      String value = parts[1];\n+      if (\"num_channels\".equals(key)) {\n+        numChannels = Integer.valueOf(value);\n+      } else if (\"print_response\".equals(key)) {\n+        printResponse = Boolean.valueOf(value);\n+      } else if (\"qps\".equals(key)) {\n+        qps = Integer.valueOf(value);\n+      } else if (\"rpc_timeout_sec\".equals(key)) {\n+        rpcTimeoutSec = Integer.valueOf(value);\n+      } else if (\"server\".equals(key)) {\n+        server = value;\n+      } else if (\"stats_port\".equals(key)) {\n+        statsPort = Integer.valueOf(value);\n+      } else {\n+        System.err.println(\"Unknown argument: \" + key);\n+        usage = true;\n+        break;\n+      }\n+    }\n+\n+    if (usage) {\n+      XdsTestClient c = new XdsTestClient();\n+      System.err.println(\n+          \"Usage: [ARGS...]\"\n+              + \"\\n\"\n+              + \"\\n  --num_channels=INT     Default: \"\n+              + c.numChannels\n+              + \"\\n  --print_response=BOOL  Write RPC response to stdout. Default: \"\n+              + c.printResponse\n+              + \"\\n  --qps=INT              Qps per channel. Default: \"\n+              + c.qps\n+              + \"\\n  --rpc_timeout_sec=INT  Per RPC timeout seconds. Default: \"\n+              + c.rpcTimeoutSec\n+              + \"\\n  --server=host:port     Address of server. Default: \"\n+              + c.server\n+              + \"\\n  --stats_port=INT       Port to expose peer distribution stats service. \"\n+              + \"Default: \"\n+              + c.statsPort);\n+      System.exit(1);\n+    }\n+  }\n+\n+  private void run() {\n+    statsServer = NettyServerBuilder.forPort(statsPort).addService(new XdsStatsImpl()).build();\n+    boolean success = false;\n+    try {\n+      statsServer.start();\n+      List<ManagedChannel> chans = new ArrayList<>();\n+      for (int i = 0; i < numChannels; i++) {\n+        chans.add(NettyChannelBuilder.forTarget(server).usePlaintext().build());\n+      }\n+      ListeningScheduledExecutorService exec =\n+          MoreExecutors.listeningDecorator(Executors.newSingleThreadScheduledExecutor());\n+      try {\n+        runQps(chans, exec);\n+        success = true;\n+      } finally {\n+        exec.shutdownNow();\n+        for (ManagedChannel chan : chans) {\n+          chan.shutdownNow();\n+        }\n+      }\n+    } catch (Throwable t) {\n+      logger.log(Level.SEVERE, \"Error running client\", t);\n+    }\n+\n+    statsServer.shutdownNow();\n+    System.exit(success ? 0 : 1);\n+  }\n+\n+  private void stop() throws Exception {\n+    statsServer.shutdownNow();\n+    if (!statsServer.awaitTermination(5, TimeUnit.SECONDS)) {\n+      System.err.println(\"Timed out waiting for server shutdown\");\n+    }\n+  }\n+\n+  private final Set<XdsStatsWatcher> watchers = new HashSet<>();\n+  private final Object lock = new Object();\n+  private long currentRequestId;\n+\n+  private void runQps(final List<ManagedChannel> chans, ListeningScheduledExecutorService exec)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    final SettableFuture<Void> failure = SettableFuture.create();\n+    final class PeriodicRpc implements Runnable {\n+      final AtomicLong messageIds = new AtomicLong();\n+\n+      @Override\n+      public void run() {\n+        final long requestId;\n+        final Set<XdsStatsWatcher> savedWatchers = new HashSet<>();\n+        synchronized (lock) {\n+          currentRequestId += 1;\n+          requestId = currentRequestId;\n+          savedWatchers.addAll(watchers);\n+        }\n+\n+        SimpleRequest request = SimpleRequest.newBuilder().setFillServerId(true).build();\n+        ManagedChannel channel = chans.get((int) (requestId % chans.size()));\n+        final ClientCall<SimpleRequest, SimpleResponse> call =\n+            channel.newCall(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ5NzE3MQ=="}, "originalCommit": {"oid": "ca483af07cf554fc5fd4ccbfa2659640b2419dc3"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1NzYxNTQ3OnYy", "diffSide": "RIGHT", "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQwMDo0NDo1NlrOFcjTZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxOTo1OTowMlrOFdC2hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4Mjg1NQ==", "bodyText": "nit: This should also be done in ShutdownHook, otherwise it may not be triggered if you press Ctrl-C.", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r365482855", "createdAt": "2020-01-11T00:44:56Z", "author": {"login": "dapengzhang0"}, "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.testing.integration;\n+\n+import com.google.common.primitives.Ints;\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableScheduledFuture;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.CallOptions;\n+import io.grpc.ClientCall;\n+import io.grpc.Grpc;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.Server;\n+import io.grpc.Status;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.NettyServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsRequest;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsResponse;\n+import io.grpc.testing.integration.Messages.SimpleRequest;\n+import io.grpc.testing.integration.Messages.SimpleResponse;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/** Client for xDS interop tests. */\n+public final class XdsTestClient {\n+  private static Logger logger = Logger.getLogger(XdsTestClient.class.getName());\n+\n+  private final Set<XdsStatsWatcher> watchers = new HashSet<>();\n+  private final Object lock = new Object();\n+\n+  private int numChannels = 1;\n+  private boolean printResponse = false;\n+  private int qps = 1;\n+  private int rpcTimeoutSec = 2;\n+  private String server = \"localhost:8080\";\n+  private int statsPort = 8081;\n+  private Server statsServer;\n+  private long currentRequestId;\n+  private ListeningScheduledExecutorService exec;\n+\n+  /**\n+   * The main application allowing this client to be launched from the command line.\n+   */\n+  public static void main(String[] args) {\n+    final XdsTestClient client = new XdsTestClient();\n+    client.parseArgs(args);\n+    Runtime.getRuntime()\n+        .addShutdownHook(\n+            new Thread() {\n+              @Override\n+              @SuppressWarnings(\"CatchAndPrintStackTrace\")\n+              public void run() {\n+                try {\n+                  client.stop();\n+                } catch (Exception e) {\n+                  e.printStackTrace();\n+                }\n+              }\n+            });\n+    client.run();\n+  }\n+\n+  private void parseArgs(String[] args) {\n+    boolean usage = false;\n+    for (String arg : args) {\n+      if (!arg.startsWith(\"--\")) {\n+        System.err.println(\"All arguments must start with '--': \" + arg);\n+        usage = true;\n+        break;\n+      }\n+      String[] parts = arg.substring(2).split(\"=\", 2);\n+      String key = parts[0];\n+      if (\"help\".equals(key)) {\n+        usage = true;\n+        break;\n+      }\n+      if (parts.length != 2) {\n+        System.err.println(\"All arguments must be of the form --arg=value\");\n+        usage = true;\n+        break;\n+      }\n+      String value = parts[1];\n+      if (\"num_channels\".equals(key)) {\n+        numChannels = Integer.valueOf(value);\n+      } else if (\"print_response\".equals(key)) {\n+        printResponse = Boolean.valueOf(value);\n+      } else if (\"qps\".equals(key)) {\n+        qps = Integer.valueOf(value);\n+      } else if (\"rpc_timeout_sec\".equals(key)) {\n+        rpcTimeoutSec = Integer.valueOf(value);\n+      } else if (\"server\".equals(key)) {\n+        server = value;\n+      } else if (\"stats_port\".equals(key)) {\n+        statsPort = Integer.valueOf(value);\n+      } else {\n+        System.err.println(\"Unknown argument: \" + key);\n+        usage = true;\n+        break;\n+      }\n+    }\n+\n+    if (usage) {\n+      XdsTestClient c = new XdsTestClient();\n+      System.err.println(\n+          \"Usage: [ARGS...]\"\n+              + \"\\n\"\n+              + \"\\n  --num_channels=INT     Default: \"\n+              + c.numChannels\n+              + \"\\n  --print_response=BOOL  Write RPC response to stdout. Default: \"\n+              + c.printResponse\n+              + \"\\n  --qps=INT              Qps per channel. Default: \"\n+              + c.qps\n+              + \"\\n  --rpc_timeout_sec=INT  Per RPC timeout seconds. Default: \"\n+              + c.rpcTimeoutSec\n+              + \"\\n  --server=host:port     Address of server. Default: \"\n+              + c.server\n+              + \"\\n  --stats_port=INT       Port to expose peer distribution stats service. \"\n+              + \"Default: \"\n+              + c.statsPort);\n+      System.exit(1);\n+    }\n+  }\n+\n+  private void run() {\n+    statsServer = NettyServerBuilder.forPort(statsPort).addService(new XdsStatsImpl()).build();\n+    boolean success = false;\n+    try {\n+      statsServer.start();\n+      List<ManagedChannel> chans = new ArrayList<>();\n+      for (int i = 0; i < numChannels; i++) {\n+        chans.add(NettyChannelBuilder.forTarget(server).usePlaintext().build());\n+      }\n+      exec = MoreExecutors.listeningDecorator(Executors.newSingleThreadScheduledExecutor());\n+      try {\n+        runQps(chans, exec);\n+        success = true;\n+      } finally {\n+        for (ManagedChannel chan : chans) {\n+          chan.shutdownNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db6bce61f5b9342f2225278a5dede6245b9a8c8"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk5OTc1MQ==", "bodyText": "done", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r365999751", "createdAt": "2020-01-13T19:59:02Z", "author": {"login": "ericgribkoff"}, "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.testing.integration;\n+\n+import com.google.common.primitives.Ints;\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableScheduledFuture;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.CallOptions;\n+import io.grpc.ClientCall;\n+import io.grpc.Grpc;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.Server;\n+import io.grpc.Status;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.NettyServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsRequest;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsResponse;\n+import io.grpc.testing.integration.Messages.SimpleRequest;\n+import io.grpc.testing.integration.Messages.SimpleResponse;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/** Client for xDS interop tests. */\n+public final class XdsTestClient {\n+  private static Logger logger = Logger.getLogger(XdsTestClient.class.getName());\n+\n+  private final Set<XdsStatsWatcher> watchers = new HashSet<>();\n+  private final Object lock = new Object();\n+\n+  private int numChannels = 1;\n+  private boolean printResponse = false;\n+  private int qps = 1;\n+  private int rpcTimeoutSec = 2;\n+  private String server = \"localhost:8080\";\n+  private int statsPort = 8081;\n+  private Server statsServer;\n+  private long currentRequestId;\n+  private ListeningScheduledExecutorService exec;\n+\n+  /**\n+   * The main application allowing this client to be launched from the command line.\n+   */\n+  public static void main(String[] args) {\n+    final XdsTestClient client = new XdsTestClient();\n+    client.parseArgs(args);\n+    Runtime.getRuntime()\n+        .addShutdownHook(\n+            new Thread() {\n+              @Override\n+              @SuppressWarnings(\"CatchAndPrintStackTrace\")\n+              public void run() {\n+                try {\n+                  client.stop();\n+                } catch (Exception e) {\n+                  e.printStackTrace();\n+                }\n+              }\n+            });\n+    client.run();\n+  }\n+\n+  private void parseArgs(String[] args) {\n+    boolean usage = false;\n+    for (String arg : args) {\n+      if (!arg.startsWith(\"--\")) {\n+        System.err.println(\"All arguments must start with '--': \" + arg);\n+        usage = true;\n+        break;\n+      }\n+      String[] parts = arg.substring(2).split(\"=\", 2);\n+      String key = parts[0];\n+      if (\"help\".equals(key)) {\n+        usage = true;\n+        break;\n+      }\n+      if (parts.length != 2) {\n+        System.err.println(\"All arguments must be of the form --arg=value\");\n+        usage = true;\n+        break;\n+      }\n+      String value = parts[1];\n+      if (\"num_channels\".equals(key)) {\n+        numChannels = Integer.valueOf(value);\n+      } else if (\"print_response\".equals(key)) {\n+        printResponse = Boolean.valueOf(value);\n+      } else if (\"qps\".equals(key)) {\n+        qps = Integer.valueOf(value);\n+      } else if (\"rpc_timeout_sec\".equals(key)) {\n+        rpcTimeoutSec = Integer.valueOf(value);\n+      } else if (\"server\".equals(key)) {\n+        server = value;\n+      } else if (\"stats_port\".equals(key)) {\n+        statsPort = Integer.valueOf(value);\n+      } else {\n+        System.err.println(\"Unknown argument: \" + key);\n+        usage = true;\n+        break;\n+      }\n+    }\n+\n+    if (usage) {\n+      XdsTestClient c = new XdsTestClient();\n+      System.err.println(\n+          \"Usage: [ARGS...]\"\n+              + \"\\n\"\n+              + \"\\n  --num_channels=INT     Default: \"\n+              + c.numChannels\n+              + \"\\n  --print_response=BOOL  Write RPC response to stdout. Default: \"\n+              + c.printResponse\n+              + \"\\n  --qps=INT              Qps per channel. Default: \"\n+              + c.qps\n+              + \"\\n  --rpc_timeout_sec=INT  Per RPC timeout seconds. Default: \"\n+              + c.rpcTimeoutSec\n+              + \"\\n  --server=host:port     Address of server. Default: \"\n+              + c.server\n+              + \"\\n  --stats_port=INT       Port to expose peer distribution stats service. \"\n+              + \"Default: \"\n+              + c.statsPort);\n+      System.exit(1);\n+    }\n+  }\n+\n+  private void run() {\n+    statsServer = NettyServerBuilder.forPort(statsPort).addService(new XdsStatsImpl()).build();\n+    boolean success = false;\n+    try {\n+      statsServer.start();\n+      List<ManagedChannel> chans = new ArrayList<>();\n+      for (int i = 0; i < numChannels; i++) {\n+        chans.add(NettyChannelBuilder.forTarget(server).usePlaintext().build());\n+      }\n+      exec = MoreExecutors.listeningDecorator(Executors.newSingleThreadScheduledExecutor());\n+      try {\n+        runQps(chans, exec);\n+        success = true;\n+      } finally {\n+        for (ManagedChannel chan : chans) {\n+          chan.shutdownNow();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4Mjg1NQ=="}, "originalCommit": {"oid": "1db6bce61f5b9342f2225278a5dede6245b9a8c8"}, "originalPosition": 171}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MTI4MjcxOnYy", "diffSide": "RIGHT", "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QyMDo1MzowNFrOFdEN2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QyMjowMToyM1rOFdGC-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAyMjEwNw==", "bodyText": "Should we always System.exit(1)?", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r366022107", "createdAt": "2020-01-13T20:53:04Z", "author": {"login": "dapengzhang0"}, "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.testing.integration;\n+\n+import com.google.common.primitives.Ints;\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableScheduledFuture;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.CallOptions;\n+import io.grpc.ClientCall;\n+import io.grpc.Grpc;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.Server;\n+import io.grpc.Status;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.NettyServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsRequest;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsResponse;\n+import io.grpc.testing.integration.Messages.SimpleRequest;\n+import io.grpc.testing.integration.Messages.SimpleResponse;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/** Client for xDS interop tests. */\n+public final class XdsTestClient {\n+  private static Logger logger = Logger.getLogger(XdsTestClient.class.getName());\n+\n+  private final Set<XdsStatsWatcher> watchers = new HashSet<>();\n+  private final Object lock = new Object();\n+  private final List<ManagedChannel> channels = new ArrayList<>();\n+\n+  private int numChannels = 1;\n+  private boolean printResponse = false;\n+  private int qps = 1;\n+  private int rpcTimeoutSec = 2;\n+  private String server = \"localhost:8080\";\n+  private int statsPort = 8081;\n+  private Server statsServer;\n+  private long currentRequestId;\n+  private ListeningScheduledExecutorService exec;\n+\n+  /**\n+   * The main application allowing this client to be launched from the command line.\n+   */\n+  public static void main(String[] args) {\n+    final XdsTestClient client = new XdsTestClient();\n+    client.parseArgs(args);\n+    Runtime.getRuntime()\n+        .addShutdownHook(\n+            new Thread() {\n+              @Override\n+              @SuppressWarnings(\"CatchAndPrintStackTrace\")\n+              public void run() {\n+                try {\n+                  client.stop();\n+                } catch (Exception e) {\n+                  e.printStackTrace();\n+                }\n+              }\n+            });\n+    client.run();\n+  }\n+\n+  private void parseArgs(String[] args) {\n+    boolean usage = false;\n+    for (String arg : args) {\n+      if (!arg.startsWith(\"--\")) {\n+        System.err.println(\"All arguments must start with '--': \" + arg);\n+        usage = true;\n+        break;\n+      }\n+      String[] parts = arg.substring(2).split(\"=\", 2);\n+      String key = parts[0];\n+      if (\"help\".equals(key)) {\n+        usage = true;\n+        break;\n+      }\n+      if (parts.length != 2) {\n+        System.err.println(\"All arguments must be of the form --arg=value\");\n+        usage = true;\n+        break;\n+      }\n+      String value = parts[1];\n+      if (\"num_channels\".equals(key)) {\n+        numChannels = Integer.valueOf(value);\n+      } else if (\"print_response\".equals(key)) {\n+        printResponse = Boolean.valueOf(value);\n+      } else if (\"qps\".equals(key)) {\n+        qps = Integer.valueOf(value);\n+      } else if (\"rpc_timeout_sec\".equals(key)) {\n+        rpcTimeoutSec = Integer.valueOf(value);\n+      } else if (\"server\".equals(key)) {\n+        server = value;\n+      } else if (\"stats_port\".equals(key)) {\n+        statsPort = Integer.valueOf(value);\n+      } else {\n+        System.err.println(\"Unknown argument: \" + key);\n+        usage = true;\n+        break;\n+      }\n+    }\n+\n+    if (usage) {\n+      XdsTestClient c = new XdsTestClient();\n+      System.err.println(\n+          \"Usage: [ARGS...]\"\n+              + \"\\n\"\n+              + \"\\n  --num_channels=INT     Default: \"\n+              + c.numChannels\n+              + \"\\n  --print_response=BOOL  Write RPC response to stdout. Default: \"\n+              + c.printResponse\n+              + \"\\n  --qps=INT              Qps per channel. Default: \"\n+              + c.qps\n+              + \"\\n  --rpc_timeout_sec=INT  Per RPC timeout seconds. Default: \"\n+              + c.rpcTimeoutSec\n+              + \"\\n  --server=host:port     Address of server. Default: \"\n+              + c.server\n+              + \"\\n  --stats_port=INT       Port to expose peer distribution stats service. \"\n+              + \"Default: \"\n+              + c.statsPort);\n+      System.exit(1);\n+    }\n+  }\n+\n+  private void run() {\n+    statsServer = NettyServerBuilder.forPort(statsPort).addService(new XdsStatsImpl()).build();\n+    boolean success = false;\n+    try {\n+      statsServer.start();\n+      for (int i = 0; i < numChannels; i++) {\n+        channels.add(NettyChannelBuilder.forTarget(server).usePlaintext().build());\n+      }\n+      exec = MoreExecutors.listeningDecorator(Executors.newSingleThreadScheduledExecutor());\n+      runQps();\n+      success = true;\n+    } catch (Throwable t) {\n+      logger.log(Level.SEVERE, \"Error running client\", t);\n+    }\n+    System.exit(success ? 0 : 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "897a0dd24f4f1773745463a2a65497682e92dc3f"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA1MjA5MA==", "bodyText": "yep, done", "url": "https://github.com/grpc/grpc-java/pull/6585#discussion_r366052090", "createdAt": "2020-01-13T22:01:23Z", "author": {"login": "ericgribkoff"}, "path": "interop-testing/src/main/java/io/grpc/testing/integration/XdsTestClient.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.testing.integration;\n+\n+import com.google.common.primitives.Ints;\n+import com.google.common.util.concurrent.FutureCallback;\n+import com.google.common.util.concurrent.Futures;\n+import com.google.common.util.concurrent.ListenableScheduledFuture;\n+import com.google.common.util.concurrent.ListeningScheduledExecutorService;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import com.google.common.util.concurrent.SettableFuture;\n+import io.grpc.CallOptions;\n+import io.grpc.ClientCall;\n+import io.grpc.Grpc;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.Server;\n+import io.grpc.Status;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.grpc.netty.NettyServerBuilder;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsRequest;\n+import io.grpc.testing.integration.Messages.LoadBalancerStatsResponse;\n+import io.grpc.testing.integration.Messages.SimpleRequest;\n+import io.grpc.testing.integration.Messages.SimpleResponse;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/** Client for xDS interop tests. */\n+public final class XdsTestClient {\n+  private static Logger logger = Logger.getLogger(XdsTestClient.class.getName());\n+\n+  private final Set<XdsStatsWatcher> watchers = new HashSet<>();\n+  private final Object lock = new Object();\n+  private final List<ManagedChannel> channels = new ArrayList<>();\n+\n+  private int numChannels = 1;\n+  private boolean printResponse = false;\n+  private int qps = 1;\n+  private int rpcTimeoutSec = 2;\n+  private String server = \"localhost:8080\";\n+  private int statsPort = 8081;\n+  private Server statsServer;\n+  private long currentRequestId;\n+  private ListeningScheduledExecutorService exec;\n+\n+  /**\n+   * The main application allowing this client to be launched from the command line.\n+   */\n+  public static void main(String[] args) {\n+    final XdsTestClient client = new XdsTestClient();\n+    client.parseArgs(args);\n+    Runtime.getRuntime()\n+        .addShutdownHook(\n+            new Thread() {\n+              @Override\n+              @SuppressWarnings(\"CatchAndPrintStackTrace\")\n+              public void run() {\n+                try {\n+                  client.stop();\n+                } catch (Exception e) {\n+                  e.printStackTrace();\n+                }\n+              }\n+            });\n+    client.run();\n+  }\n+\n+  private void parseArgs(String[] args) {\n+    boolean usage = false;\n+    for (String arg : args) {\n+      if (!arg.startsWith(\"--\")) {\n+        System.err.println(\"All arguments must start with '--': \" + arg);\n+        usage = true;\n+        break;\n+      }\n+      String[] parts = arg.substring(2).split(\"=\", 2);\n+      String key = parts[0];\n+      if (\"help\".equals(key)) {\n+        usage = true;\n+        break;\n+      }\n+      if (parts.length != 2) {\n+        System.err.println(\"All arguments must be of the form --arg=value\");\n+        usage = true;\n+        break;\n+      }\n+      String value = parts[1];\n+      if (\"num_channels\".equals(key)) {\n+        numChannels = Integer.valueOf(value);\n+      } else if (\"print_response\".equals(key)) {\n+        printResponse = Boolean.valueOf(value);\n+      } else if (\"qps\".equals(key)) {\n+        qps = Integer.valueOf(value);\n+      } else if (\"rpc_timeout_sec\".equals(key)) {\n+        rpcTimeoutSec = Integer.valueOf(value);\n+      } else if (\"server\".equals(key)) {\n+        server = value;\n+      } else if (\"stats_port\".equals(key)) {\n+        statsPort = Integer.valueOf(value);\n+      } else {\n+        System.err.println(\"Unknown argument: \" + key);\n+        usage = true;\n+        break;\n+      }\n+    }\n+\n+    if (usage) {\n+      XdsTestClient c = new XdsTestClient();\n+      System.err.println(\n+          \"Usage: [ARGS...]\"\n+              + \"\\n\"\n+              + \"\\n  --num_channels=INT     Default: \"\n+              + c.numChannels\n+              + \"\\n  --print_response=BOOL  Write RPC response to stdout. Default: \"\n+              + c.printResponse\n+              + \"\\n  --qps=INT              Qps per channel. Default: \"\n+              + c.qps\n+              + \"\\n  --rpc_timeout_sec=INT  Per RPC timeout seconds. Default: \"\n+              + c.rpcTimeoutSec\n+              + \"\\n  --server=host:port     Address of server. Default: \"\n+              + c.server\n+              + \"\\n  --stats_port=INT       Port to expose peer distribution stats service. \"\n+              + \"Default: \"\n+              + c.statsPort);\n+      System.exit(1);\n+    }\n+  }\n+\n+  private void run() {\n+    statsServer = NettyServerBuilder.forPort(statsPort).addService(new XdsStatsImpl()).build();\n+    boolean success = false;\n+    try {\n+      statsServer.start();\n+      for (int i = 0; i < numChannels; i++) {\n+        channels.add(NettyChannelBuilder.forTarget(server).usePlaintext().build());\n+      }\n+      exec = MoreExecutors.listeningDecorator(Executors.newSingleThreadScheduledExecutor());\n+      runQps();\n+      success = true;\n+    } catch (Throwable t) {\n+      logger.log(Level.SEVERE, \"Error running client\", t);\n+    }\n+    System.exit(success ? 0 : 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjAyMjEwNw=="}, "originalCommit": {"oid": "897a0dd24f4f1773745463a2a65497682e92dc3f"}, "originalPosition": 171}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3038, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}