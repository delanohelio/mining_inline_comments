{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2ODc1NDk3", "number": 6957, "title": "rls: fake direct scheduled executor supports schedule", "bodyText": "FYI. the schedule method is not used in this test, but will be used in other test.", "createdAt": "2020-04-21T19:55:17Z", "url": "https://github.com/grpc/grpc-java/pull/6957", "merged": true, "mergeCommit": {"oid": "4a644cb8764afc946ff8325992d1bab1e0360ed3"}, "closed": true, "closedAt": "2020-04-22T19:04:27Z", "author": {"login": "creamsoup"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZ5UsjgH2gAyNDA2ODc1NDk3OmM2ZTQyODViOTdiZjZkMjg3OTBmMThkYWNkNjBiNTdhYWE2ZDdlODY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcaMjj8gH2gAyNDA2ODc1NDk3OjI5NWRiYWNjZTliMjJhNjdhNDdjNzVjYzhiMWQ1NmVmNzM2NjIxYjE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c6e4285b97bf6d28790f18dacd60b57aaa6d7e86", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/c6e4285b97bf6d28790f18dacd60b57aaa6d7e86", "committedDate": "2020-04-21T20:01:23Z", "message": "rls: add invalidate(Key,Value), move out fake direct scheduled executor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "444a471f34dd53059ea4a5be724f555b7d3b9049", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/444a471f34dd53059ea4a5be724f555b7d3b9049", "committedDate": "2020-04-21T20:03:56Z", "message": "check return value"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3Nzc0Mzc3", "url": "https://github.com/grpc/grpc-java/pull/6957#pullrequestreview-397774377", "createdAt": "2020-04-22T01:06:15Z", "commit": {"oid": "444a471f34dd53059ea4a5be724f555b7d3b9049"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMTowNjoxNlrOGJeyrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMTowNjoxNlrOGJeyrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5NDg2MA==", "bodyText": "get() will trigger LinkedHashMap's access ordering. If the existing value is not the one to be deleted, it will be re-inserted to the tail of the linked list. Maybe\nboolean replaced = delegate.replace(key, new SizedValue(0, value), null);\nif (replaced) {\n  delegate.remove(key);\n  evictionListener.onEviction(key, value, EvictionType.EXPLICIT);\n  return true;\n}\n\nEdited: it's tricky to replace a sized value.", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r412594860", "createdAt": "2020-04-22T01:06:16Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/LinkedHashLruCache.java", "diffHunk": "@@ -191,6 +191,22 @@ private V invalidate(K key, EvictionType cause) {\n     }\n   }\n \n+  @Override\n+  public final boolean invalidate(K key, V value) {\n+    checkNotNull(key, \"key\");\n+    checkNotNull(value, \"value\");\n+    synchronized (lock) {\n+      SizedValue existing = delegate.get(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "444a471f34dd53059ea4a5be724f555b7d3b9049"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3Nzc5NjUx", "url": "https://github.com/grpc/grpc-java/pull/6957#pullrequestreview-397779651", "createdAt": "2020-04-22T01:24:43Z", "commit": {"oid": "444a471f34dd53059ea4a5be724f555b7d3b9049"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMToyNDo0M1rOGJfKEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMToyNDo0M1rOGJfKEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwMDg0OA==", "bodyText": "Seems every method of DoNotUseDirectScheduledExecutorService calls maybeInit(), why not just init these fields directly at their declaration and remove maybeInit().", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r412600848", "createdAt": "2020-04-22T01:24:43Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized = false;\n+\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "444a471f34dd53059ea4a5be724f555b7d3b9049"}, "originalPosition": 70}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e333ef027cf2bc98ba09e2d98f040e5d42910464", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/e333ef027cf2bc98ba09e2d98f040e5d42910464", "committedDate": "2020-04-22T02:19:08Z", "message": "add justification comment for maybeInit"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4Mzc3ODk2", "url": "https://github.com/grpc/grpc-java/pull/6957#pullrequestreview-398377896", "createdAt": "2020-04-22T16:43:11Z", "commit": {"oid": "e333ef027cf2bc98ba09e2d98f040e5d42910464"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjo0MzoxMVrOGKALXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjo0MzoxMVrOGKALXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE0MTg1Mw==", "bodyText": "Don't set initial value here.", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413141853", "createdAt": "2020-04-22T16:43:11Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e333ef027cf2bc98ba09e2d98f040e5d42910464"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "612441862ad8d53fa9bac23c90352e1aa37d5080", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/612441862ad8d53fa9bac23c90352e1aa37d5080", "committedDate": "2020-04-22T16:58:15Z", "message": "remove invalidate key value"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "847b8e88976b9949f44f061fb40e393245b799cd", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/847b8e88976b9949f44f061fb40e393245b799cd", "committedDate": "2020-04-22T17:01:27Z", "message": "prevent instantiation for fake scheduled executor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NDA0NDk1", "url": "https://github.com/grpc/grpc-java/pull/6957#pullrequestreview-398404495", "createdAt": "2020-04-22T17:14:30Z", "commit": {"oid": "847b8e88976b9949f44f061fb40e393245b799cd"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzoxNDozMVrOGKBpkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzozMTozNlrOGKCbig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE2NTk2OQ==", "bodyText": "Why set running = true?", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413165969", "createdAt": "2020-04-22T17:14:31Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {\n+    maybeInit();\n+    return new FakeTimeProvider();\n+  }\n+\n+  void forwardTime(long delta, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delta > 0, \"delta must be positive\");\n+    long finalTime = currTimeNanos + unit.toNanos(delta);\n+\n+    if (repeatedCommand.get() != null) {\n+      while (finalTime >= nextRun) {\n+        scheduledCommands.add(new ScheduledRunnable(nextRun, repeatedCommand.get()));\n+        nextRun += period;\n+      }\n+    }\n+\n+    while (!scheduledCommands.isEmpty()\n+        && scheduledCommands.peek().scheduledTimeNanos <= finalTime) {\n+      ScheduledRunnable scheduledCommand = scheduledCommands.poll();\n+      try {\n+        // pretend to run at the scheduled time\n+        currTimeNanos = scheduledCommand.scheduledTimeNanos;\n+        scheduledCommand.run();\n+      } catch (Throwable t) {\n+        throw new RuntimeException(\"failed to run scheduled command: \" + scheduledCommand, t);\n+      }\n+    }\n+\n+    this.currTimeNanos = finalTime;\n+  }\n+\n+  private final class ScheduledRunnable implements Runnable {\n+    private final long scheduledTimeNanos;\n+    private final Runnable command;\n+    private final ScheduledFuture<?> scheduledFuture = new ScheduledRunnable.FakeScheduledFuture();\n+    private final Object lock = new Object();\n+    private boolean running = false;\n+    private boolean done = false;\n+\n+    public ScheduledRunnable(long scheduledTimeNanos, Runnable command) {\n+      this.scheduledTimeNanos = scheduledTimeNanos;\n+      this.command = checkNotNull(command, \"command\");\n+    }\n+\n+    @Override\n+    public void run() {\n+      synchronized (lock) {\n+        if (!scheduledFuture.isCancelled()) {\n+          running = true;\n+          command.run();\n+          done = true;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"scheduledTimeNanos\", scheduledTimeNanos)\n+          .add(\"command\", command)\n+          .add(\"scheduledFuture\", scheduledFuture)\n+          .add(\"running\", running)\n+          .add(\"done\", done)\n+          .toString();\n+    }\n+\n+    private class FakeScheduledFuture implements ScheduledFuture<Object> {\n+      boolean cancelled = false;\n+\n+      @Override\n+      public long getDelay(TimeUnit unit) {\n+        return unit.convert(scheduledTimeNanos - currTimeNanos, TimeUnit.NANOSECONDS);\n+      }\n+\n+      @Override\n+      public int compareTo(Delayed unused) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      @Override\n+      public synchronized boolean cancel(boolean mayInterruptIfRunning) {\n+        if (running) {\n+          return false;\n+        }\n+        running = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "847b8e88976b9949f44f061fb40e393245b799cd"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3NDA4NQ==", "bodyText": "If you really want ThreadSafe, isCancelled() and isDone() also need synchronized.", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413174085", "createdAt": "2020-04-22T17:25:53Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {\n+    maybeInit();\n+    return new FakeTimeProvider();\n+  }\n+\n+  void forwardTime(long delta, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delta > 0, \"delta must be positive\");\n+    long finalTime = currTimeNanos + unit.toNanos(delta);\n+\n+    if (repeatedCommand.get() != null) {\n+      while (finalTime >= nextRun) {\n+        scheduledCommands.add(new ScheduledRunnable(nextRun, repeatedCommand.get()));\n+        nextRun += period;\n+      }\n+    }\n+\n+    while (!scheduledCommands.isEmpty()\n+        && scheduledCommands.peek().scheduledTimeNanos <= finalTime) {\n+      ScheduledRunnable scheduledCommand = scheduledCommands.poll();\n+      try {\n+        // pretend to run at the scheduled time\n+        currTimeNanos = scheduledCommand.scheduledTimeNanos;\n+        scheduledCommand.run();\n+      } catch (Throwable t) {\n+        throw new RuntimeException(\"failed to run scheduled command: \" + scheduledCommand, t);\n+      }\n+    }\n+\n+    this.currTimeNanos = finalTime;\n+  }\n+\n+  private final class ScheduledRunnable implements Runnable {\n+    private final long scheduledTimeNanos;\n+    private final Runnable command;\n+    private final ScheduledFuture<?> scheduledFuture = new ScheduledRunnable.FakeScheduledFuture();\n+    private final Object lock = new Object();\n+    private boolean running = false;\n+    private boolean done = false;\n+\n+    public ScheduledRunnable(long scheduledTimeNanos, Runnable command) {\n+      this.scheduledTimeNanos = scheduledTimeNanos;\n+      this.command = checkNotNull(command, \"command\");\n+    }\n+\n+    @Override\n+    public void run() {\n+      synchronized (lock) {\n+        if (!scheduledFuture.isCancelled()) {\n+          running = true;\n+          command.run();\n+          done = true;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"scheduledTimeNanos\", scheduledTimeNanos)\n+          .add(\"command\", command)\n+          .add(\"scheduledFuture\", scheduledFuture)\n+          .add(\"running\", running)\n+          .add(\"done\", done)\n+          .toString();\n+    }\n+\n+    private class FakeScheduledFuture implements ScheduledFuture<Object> {\n+      boolean cancelled = false;\n+\n+      @Override\n+      public long getDelay(TimeUnit unit) {\n+        return unit.convert(scheduledTimeNanos - currTimeNanos, TimeUnit.NANOSECONDS);\n+      }\n+\n+      @Override\n+      public int compareTo(Delayed unused) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      @Override\n+      public synchronized boolean cancel(boolean mayInterruptIfRunning) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "847b8e88976b9949f44f061fb40e393245b799cd"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3NTcyNQ==", "bodyText": "If you really want to support callers from multiple threads without caller's synchronization, other methods also need synchronized. As javadoc says implementation is not thread-safe,  so synchronized is not necessary.", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413175725", "createdAt": "2020-04-22T17:28:06Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "847b8e88976b9949f44f061fb40e393245b799cd"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3NzM0OQ==", "bodyText": "nit: final?", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413177349", "createdAt": "2020-04-22T17:30:19Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "847b8e88976b9949f44f061fb40e393245b799cd"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3ODc2Mg==", "bodyText": "nit: private?", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413178762", "createdAt": "2020-04-22T17:31:36Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {\n+    maybeInit();\n+    return new FakeTimeProvider();\n+  }\n+\n+  void forwardTime(long delta, TimeUnit unit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "847b8e88976b9949f44f061fb40e393245b799cd"}, "originalPosition": 115}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "579ed15197c282b83d6aaed3e0479f361a0aec0f", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/579ed15197c282b83d6aaed3e0479f361a0aec0f", "committedDate": "2020-04-22T18:11:56Z", "message": "remove half baked synchronizations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NDU0MjYx", "url": "https://github.com/grpc/grpc-java/pull/6957#pullrequestreview-398454261", "createdAt": "2020-04-22T18:15:05Z", "commit": {"oid": "579ed15197c282b83d6aaed3e0479f361a0aec0f"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxODoxNTowNVrOGKEVvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxODoxNTozMVrOGKEW-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIxMDA0NA==", "bodyText": "nit: final", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413210044", "createdAt": "2020-04-22T18:15:05Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {\n+    maybeInit();\n+    return new FakeTimeProvider();\n+  }\n+\n+  private void forwardTime(long delta, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delta > 0, \"delta must be positive\");\n+    long finalTime = currTimeNanos + unit.toNanos(delta);\n+\n+    if (repeatedCommand.get() != null) {\n+      while (finalTime >= nextRun) {\n+        scheduledCommands.add(new ScheduledRunnable(nextRun, repeatedCommand.get()));\n+        nextRun += period;\n+      }\n+    }\n+\n+    while (!scheduledCommands.isEmpty()\n+        && scheduledCommands.peek().scheduledTimeNanos <= finalTime) {\n+      ScheduledRunnable scheduledCommand = scheduledCommands.poll();\n+      try {\n+        // pretend to run at the scheduled time\n+        currTimeNanos = scheduledCommand.scheduledTimeNanos;\n+        scheduledCommand.run();\n+      } catch (Throwable t) {\n+        throw new RuntimeException(\"failed to run scheduled command: \" + scheduledCommand, t);\n+      }\n+    }\n+\n+    this.currTimeNanos = finalTime;\n+  }\n+\n+  private final class ScheduledRunnable implements Runnable {\n+    private final long scheduledTimeNanos;\n+    private final Runnable command;\n+    private final ScheduledFuture<?> scheduledFuture = new ScheduledRunnable.FakeScheduledFuture();\n+    private boolean running = false;\n+    private boolean done = false;\n+\n+    public ScheduledRunnable(long scheduledTimeNanos, Runnable command) {\n+      this.scheduledTimeNanos = scheduledTimeNanos;\n+      this.command = checkNotNull(command, \"command\");\n+    }\n+\n+    @Override\n+    public void run() {\n+      if (!scheduledFuture.isCancelled()) {\n+        running = true;\n+        command.run();\n+        done = true;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"scheduledTimeNanos\", scheduledTimeNanos)\n+          .add(\"command\", command)\n+          .add(\"scheduledFuture\", scheduledFuture)\n+          .add(\"running\", running)\n+          .add(\"done\", done)\n+          .toString();\n+    }\n+\n+    private class FakeScheduledFuture implements ScheduledFuture<Object> {\n+      boolean cancelled = false;\n+\n+      @Override\n+      public long getDelay(TimeUnit unit) {\n+        return unit.convert(scheduledTimeNanos - currTimeNanos, TimeUnit.NANOSECONDS);\n+      }\n+\n+      @Override\n+      public int compareTo(Delayed unused) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      @Override\n+      public boolean cancel(boolean mayInterruptIfRunning) {\n+        if (running) {\n+          return false;\n+        }\n+        cancelled = true;\n+        return true;\n+      }\n+\n+      @Override\n+      public boolean isCancelled() {\n+        return cancelled;\n+      }\n+\n+      @Override\n+      public boolean isDone() {\n+        return done;\n+      }\n+\n+      @Override\n+      public Object get() throws InterruptedException, ExecutionException {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      @Override\n+      public Object get(long timeout, TimeUnit unit)\n+          throws InterruptedException, ExecutionException, TimeoutException {\n+        throw new UnsupportedOperationException();\n+      }\n+    }\n+  }\n+\n+  private static final class ScheduledRunnableComparator\n+      implements Comparator<ScheduledRunnable> {\n+    @Override\n+    public int compare(ScheduledRunnable o1, ScheduledRunnable o2) {\n+      return Long.compare(o1.scheduledTimeNanos, o2.scheduledTimeNanos);\n+    }\n+  }\n+\n+  class FakeTimeProvider implements TimeProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "579ed15197c282b83d6aaed3e0479f361a0aec0f"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIxMDM2Mw==", "bodyText": "nit: final", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413210363", "createdAt": "2020-04-22T18:15:31Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "579ed15197c282b83d6aaed3e0479f361a0aec0f"}, "originalPosition": 110}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "295dbacce9b22a67a47c75cc8b1d56ef736621b1", "author": {"user": {"login": "creamsoup", "name": "Jihun Cho"}}, "url": "https://github.com/grpc/grpc-java/commit/295dbacce9b22a67a47c75cc8b1d56ef736621b1", "committedDate": "2020-04-22T18:25:49Z", "message": "add final keywords"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4557, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}