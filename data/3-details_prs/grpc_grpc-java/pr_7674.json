{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4MjYyOTI3", "number": 7674, "title": "Move multiple-port ServerImpl to NettyServer", "bodyText": "This is the first step towards #6641 , a deadlock issue at ServerImpl.start().\nIt makes ServerImpl to have a single transport server, and this single transport server (NettyServer) will bind to all listening addresses during bootstrap, as supported by Netty 4.x.", "createdAt": "2020-11-26T20:51:10Z", "url": "https://github.com/grpc/grpc-java/pull/7674", "merged": true, "mergeCommit": {"oid": "53da588dd1b1ee5d660558962de5cfe6ad590f46"}, "closed": true, "closedAt": "2021-01-05T21:24:17Z", "author": {"login": "YifeiZhuang"}, "timelineItems": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdgY8TYAH2gAyNTI4MjYyOTI3Ojc0NGZmZGViN2I0OGJmMzRkYjU2ZTk3NGZkZjZjNjlhNmJiMmYxYTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdrWDSigFqTU2MDIwMTUyMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "744ffdeb7b48bf34db56e974fdf6c69a6bb2f1a1", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/744ffdeb7b48bf34db56e974fdf6c69a6bb2f1a1", "committedDate": "2020-11-26T20:26:24Z", "message": "Move multiple port transport servers to NettyServer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/bacd52da6abc099b1bc52b25a0bb3470ad38c6a3", "committedDate": "2020-11-28T00:30:25Z", "message": "execute bind in bossExecutor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxMTU1OTg2", "url": "https://github.com/grpc/grpc-java/pull/7674#pullrequestreview-541155986", "createdAt": "2020-11-30T17:56:31Z", "commit": {"oid": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxNzo1NjozMVrOH8G64g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxODozNzoyNlrOH8IcXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc4OTk4Ng==", "bodyText": "I would prefer either passing a single InternalServer instead of a List in the constructor or not adding checkArgument(transportServers.size() == 1) here.", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r532789986", "createdAt": "2020-11-30T17:56:31Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ServerImpl.java", "diffHunk": "@@ -143,8 +142,9 @@\n     this.fallbackRegistry =\n         Preconditions.checkNotNull(builder.fallbackRegistry, \"fallbackRegistry\");\n     Preconditions.checkNotNull(transportServers, \"transportServers\");\n-    Preconditions.checkArgument(!transportServers.isEmpty(), \"no servers provided\");\n-    this.transportServers = new ArrayList<>(transportServers);\n+    // Supporting multiple listening socket address function is moved to a single transport server.\n+    Preconditions.checkArgument(transportServers.size() == 1, \"One and only one server\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc5NTI0Mg==", "bodyText": "Maybe if(serverShutdownCallbackInvoked)?", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r532795242", "createdAt": "2020-11-30T18:04:52Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ServerImpl.java", "diffHunk": "@@ -388,8 +378,7 @@ public void serverShutdown() {\n       ArrayList<ServerTransport> copiedTransports;\n       Status shutdownNowStatusCopy;\n       synchronized (lock) {\n-        activeTransportServers--;\n-        if (activeTransportServers != 0) {\n+        if (transportServersTerminated) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMTg0OA==", "bodyText": "Why is this not consistent with getListenSocketAddress() for the case \"server is not listening/bound yet\"", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r532801848", "createdAt": "2020-11-30T18:15:50Z", "author": {"login": "dapengzhang0"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -144,32 +157,49 @@\n     this.permitKeepAliveTimeInNanos = permitKeepAliveTimeInNanos;\n     this.eagAttributes = checkNotNull(eagAttributes, \"eagAttributes\");\n     this.channelz = Preconditions.checkNotNull(channelz);\n-    this.logId =\n-        InternalLogId.allocate(getClass(), address != null ? address.toString() : \"No address\");\n+    this.logId = InternalLogId.allocate(getClass(), addresses.isEmpty() ? \"No address\" :\n+        String.valueOf(addresses));\n+    this.bossExecutor = bossGroup.next();\n   }\n \n   @Override\n   public SocketAddress getListenSocketAddress() {\n-    if (channel == null) {\n+    Iterator<Channel> it = channelGroup.iterator();\n+    if (it.hasNext()) {\n+      return it.next().localAddress();\n+    } else {\n       // server is not listening/bound yet, just return the original port.\n-      return address;\n+      return addresses.isEmpty() ? null : addresses.get(0);\n     }\n-    return channel.localAddress();\n+  }\n+\n+  @Override\n+  public List<SocketAddress> getListenSocketAddresses() {\n+    List<SocketAddress> listenSocketAddresses = new ArrayList<>();\n+    for (Channel c: channelGroup) {\n+      listenSocketAddresses.add(c.localAddress());\n+    }\n+    return listenSocketAddresses;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwMzEzMw==", "bodyText": "What's the reason for this change?", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r532803133", "createdAt": "2020-11-30T18:18:03Z", "author": {"login": "dapengzhang0"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -144,32 +157,49 @@\n     this.permitKeepAliveTimeInNanos = permitKeepAliveTimeInNanos;\n     this.eagAttributes = checkNotNull(eagAttributes, \"eagAttributes\");\n     this.channelz = Preconditions.checkNotNull(channelz);\n-    this.logId =\n-        InternalLogId.allocate(getClass(), address != null ? address.toString() : \"No address\");\n+    this.logId = InternalLogId.allocate(getClass(), addresses.isEmpty() ? \"No address\" :\n+        String.valueOf(addresses));\n+    this.bossExecutor = bossGroup.next();\n   }\n \n   @Override\n   public SocketAddress getListenSocketAddress() {\n-    if (channel == null) {\n+    Iterator<Channel> it = channelGroup.iterator();\n+    if (it.hasNext()) {\n+      return it.next().localAddress();\n+    } else {\n       // server is not listening/bound yet, just return the original port.\n-      return address;\n+      return addresses.isEmpty() ? null : addresses.get(0);\n     }\n-    return channel.localAddress();\n+  }\n+\n+  @Override\n+  public List<SocketAddress> getListenSocketAddresses() {\n+    List<SocketAddress> listenSocketAddresses = new ArrayList<>();\n+    for (Channel c: channelGroup) {\n+      listenSocketAddresses.add(c.localAddress());\n+    }\n+    return listenSocketAddresses;\n   }\n \n   @Override\n   public InternalInstrumented<SocketStats> getListenSocketStats() {\n-    return listenSocketStats;\n+    return listenSocketStatsList.isEmpty() ? null : listenSocketStatsList.get(0);\n+  }\n+\n+  @Override\n+  public List<InternalInstrumented<SocketStats>> getListenSocketStatsList() {\n+    return listenSocketStatsList;\n   }\n \n   @Override\n   public void start(ServerListener serverListener) throws IOException {\n     listener = checkNotNull(serverListener, \"serverListener\");\n \n-    ServerBootstrap b = new ServerBootstrap();\n+    final ServerBootstrap b = new ServerBootstrap();\n     b.option(ALLOCATOR, Utils.getByteBufAllocator(forceHeapBuffer));\n     b.childOption(ALLOCATOR, Utils.getByteBufAllocator(forceHeapBuffer));\n-    b.group(bossGroup, workerGroup);\n+    b.group(bossExecutor, workerGroup);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwODM5Ng==", "bodyText": "Why not just throw bindCallResult.cause()?", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r532808396", "createdAt": "2020-11-30T18:26:33Z", "author": {"login": "dapengzhang0"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +288,88 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures;\n+    try {\n+      Future<Map<ChannelFuture, SocketAddress>> bindCallResult =\n+          bindCallFuture.awaitUninterruptibly();\n+      if (!bindCallResult.isSuccess()) {\n+        throw new IllegalStateException(bindCallResult.cause());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwODY5Mg==", "bodyText": "Why not just ex rather than ex.getCause()?", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r532808692", "createdAt": "2020-11-30T18:27:04Z", "author": {"login": "dapengzhang0"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +288,88 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures;\n+    try {\n+      Future<Map<ChannelFuture, SocketAddress>> bindCallResult =\n+          bindCallFuture.awaitUninterruptibly();\n+      if (!bindCallResult.isSuccess()) {\n+        throw new IllegalStateException(bindCallResult.cause());\n+      }\n+      channelFutures = bindCallResult.get();\n+    } catch (Exception ex) {\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), ex.getCause());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNDk0Mg==", "bodyText": "terminated is slightly different from shutdown. shutdown means no more new stream is allowed but the existing streams can still be active until they finish. terminated is once shutdown and all streams are closed.  Here the comment // Server already shutdown seems to have been not accurate, whereas the old comment here L283 // Already closed seems to be correct.", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r532814942", "createdAt": "2020-11-30T18:37:26Z", "author": {"login": "dapengzhang0"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -226,7 +256,7 @@ public void initChannel(Channel ch) {\n         ServerTransportListener transportListener;\n         // This is to order callbacks on the listener, not to guard access to channel.\n         synchronized (NettyServer.this) {\n-          if (channel != null && !channel.isOpen()) {\n+          if (terminated) {\n             // Server already shutdown.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bacd52da6abc099b1bc52b25a0bb3470ad38c6a3"}, "originalPosition": 135}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8042444c97ec89294d442273036858952b476c3", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/e8042444c97ec89294d442273036858952b476c3", "committedDate": "2020-12-01T18:08:36Z", "message": "Revert \"netty: create adaptive cumulator\" (#7669)\n\nThis reverts commit 729175c783b3d565d6aee21b456bf494f3d6c530."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac92d19e6e895fa1a0dcd8054292d4f871cfd205", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/ac92d19e6e895fa1a0dcd8054292d4f871cfd205", "committedDate": "2020-12-01T18:08:36Z", "message": "xds: fix the new server API for ServerXdsClient (#7666)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67bef1457e9e7d629b42fdf1fecf34d443f1cc9b", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/67bef1457e9e7d629b42fdf1fecf34d443f1cc9b", "committedDate": "2020-12-01T18:08:36Z", "message": "api,core: interceptor-based config selector (#7610)\n\n Interceptor-based config selector will be needed for fault injection.\r\n\r\nAdd `interceptor` field to `InternalConfigSelector.Result`. Keep `callOptions` and `committedCallback` fields for the moment, because it needs a refactoring to migrate the existing xds config selector implementation to the new API."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1afcc4889d2e26ae5bef3eec81f39a51349e55f", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/e1afcc4889d2e26ae5bef3eec81f39a51349e55f", "committedDate": "2020-12-01T18:08:36Z", "message": "xds: fix text in the readme and the comment about the --secure flag (#7676)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be578f49ef6fa5b78256a0ce127da9a2572519cd", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/be578f49ef6fa5b78256a0ce127da9a2572519cd", "committedDate": "2020-12-01T18:08:36Z", "message": "interop-testing: update proto generated service files (#7682)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e190675a9a656a5bf3dd83691aa7a45468168fec", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/e190675a9a656a5bf3dd83691aa7a45468168fec", "committedDate": "2020-12-01T18:08:36Z", "message": "Fix nettyServer get listen addresses when not bound, bind exception cause, and serverImpl shutdown"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a9db907c2550f966f6f57b6aa325dffb5bee638", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/2a9db907c2550f966f6f57b6aa325dffb5bee638", "committedDate": "2020-12-01T18:29:51Z", "message": "Revert \"interop-testing: update proto generated service files (#7682)\"\n\nThis reverts commit be578f49ef6fa5b78256a0ce127da9a2572519cd."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6887f49d730aa2315edee8b3b075d530f45817cb", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/6887f49d730aa2315edee8b3b075d530f45817cb", "committedDate": "2020-12-01T18:29:56Z", "message": "Revert \"xds: fix text in the readme and the comment about the --secure flag (#7676)\"\n\nThis reverts commit e1afcc4889d2e26ae5bef3eec81f39a51349e55f."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03a487c59e731d201c505fab4e99f906e882a08f", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/03a487c59e731d201c505fab4e99f906e882a08f", "committedDate": "2020-12-01T18:30:34Z", "message": "Revert \"api,core: interceptor-based config selector (#7610)\"\n\nThis reverts commit 67bef1457e9e7d629b42fdf1fecf34d443f1cc9b."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dbceb46a8de0a76663dc67b0ff75aabf8bcf558", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/8dbceb46a8de0a76663dc67b0ff75aabf8bcf558", "committedDate": "2020-12-01T18:30:36Z", "message": "Revert \"xds: fix the new server API for ServerXdsClient (#7666)\"\n\nThis reverts commit ac92d19e6e895fa1a0dcd8054292d4f871cfd205."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9b2985ffe9a55295bc02e97f77f6d6c7378ffec", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/f9b2985ffe9a55295bc02e97f77f6d6c7378ffec", "committedDate": "2020-12-01T18:30:38Z", "message": "Revert \"Revert \"netty: create adaptive cumulator\" (#7669)\"\n\nThis reverts commit e8042444c97ec89294d442273036858952b476c3."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/364fbac3ef70706cc70b5c30c9b9c994fc7b79b0", "committedDate": "2020-12-01T18:37:19Z", "message": "Merge branch 'master' of https://github.com/grpc/grpc-java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NTgzNTMy", "url": "https://github.com/grpc/grpc-java/pull/7674#pullrequestreview-549583532", "createdAt": "2020-12-10T20:40:09Z", "commit": {"oid": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMDo0MDowOVrOIDcXdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwMDoyOTo1MlrOIDjrzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4MTM5Nw==", "bodyText": "I think we shouldn't change the return type here, compared to the base class. Use List<? extends SocketAddress>. Ditto above.\nUsing the different type here doesn't help anybody, and I don't think we should get into a habit of doing so. We've just suffered some with our Forwarding builders because of the return type being too specific.", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r540481397", "createdAt": "2020-12-10T20:40:09Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/inprocess/InProcessServer.java", "diffHunk": "@@ -78,15 +77,25 @@ public void start(ServerListener serverListener) throws IOException {\n   }\n \n   @Override\n-  public SocketAddress getListenSocketAddress() {\n+  public InProcessSocketAddress getListenSocketAddress() {\n     return new InProcessSocketAddress(name);\n   }\n \n+  @Override\n+  public List<InProcessSocketAddress> getListenSocketAddresses() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4NDE0MQ==", "bodyText": "These additions will also require some changes to internal code. You should check to see how many updates will need to be made and should at least coordinate with the person on sync duty.", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r540484141", "createdAt": "2020-12-10T20:44:52Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/InternalServer.java", "diffHunk": "@@ -49,13 +50,25 @@\n   void shutdown();\n \n   /**\n-   * Returns the listening socket address.  May change after {@link start(ServerListener)} is\n+   * Returns the first listening socket address.  May change after {@link start(ServerListener)} is\n    * called.\n    */\n   SocketAddress getListenSocketAddress();\n \n   /**\n-   * Returns the listen socket stats of this server. May return {@code null}.\n+   * Returns the first listen socket stats of this server. May return {@code null}.\n    */\n   @Nullable InternalInstrumented<SocketStats> getListenSocketStats();\n+\n+  /**\n+   * Returns a list of listening socket addresses.  May change after {@link start(ServerListener)}\n+   * is called.\n+   */\n+  List<? extends SocketAddress> getListenSocketAddresses();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ4NDYzOQ==", "bodyText": "Why not change the constructor to only pass in one server?", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r540484639", "createdAt": "2020-12-10T20:45:46Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ServerImpl.java", "diffHunk": "@@ -144,7 +143,7 @@\n         Preconditions.checkNotNull(builder.fallbackRegistry, \"fallbackRegistry\");\n     Preconditions.checkNotNull(transportServers, \"transportServers\");\n     Preconditions.checkArgument(!transportServers.isEmpty(), \"no servers provided\");\n-    this.transportServers = new ArrayList<>(transportServers);\n+    this.transportServer = transportServers.get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUwMDcyMw==", "bodyText": "We should not be using GlobalEventExecutor. It looks like you should use the bossExecutor", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r540500723", "createdAt": "2020-12-10T21:13:20Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -78,7 +87,7 @@\n   private EventLoopGroup bossGroup;\n   private EventLoopGroup workerGroup;\n   private ServerListener listener;\n-  private Channel channel;\n+  private final ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU5MTAwMA==", "bodyText": "Why is this a field? It looks like it should be a local variable in start()", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r540591000", "createdAt": "2020-12-11T00:02:51Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -97,10 +106,14 @@\n   private final TransportTracer.Factory transportTracerFactory;\n   private final InternalChannelz channelz;\n   // Only modified in event loop but safe to read any time.\n-  private volatile InternalInstrumented<SocketStats> listenSocketStats;\n+  private volatile List<InternalInstrumented<SocketStats>> listenSocketStatsList =\n+      new ArrayList<>();\n+  private volatile boolean terminated;\n+  private final EventLoop bossExecutor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU5Njc1Mg==", "bodyText": "Catching Throwable is generally wrong, unless it is being re-thrown unchanged. Certainly here where we wrap it in an IOException is probably a bad idea. Errors should generally propagate.\nI think the bindCallResult.cause() should just be wrapped in an IOException immediately. The get() should be replaced with getNow() to avoid potential exceptions. At that point, there's no need for the catch.", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r540596752", "createdAt": "2020-12-11T00:17:26Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +292,88 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures;\n+    try {\n+      Future<Map<ChannelFuture, SocketAddress>> bindCallResult =\n+          bindCallFuture.awaitUninterruptibly();\n+      if (!bindCallResult.isSuccess()) {\n+        throw bindCallResult.cause();\n+      }\n+      channelFutures = bindCallResult.get();\n+    } catch (Throwable ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU5NzU5Ng==", "bodyText": "This leaks all the other ports. When any one bind fails, we should close all the channels. Note that the channelz registration may also be impacted.\nChannelz is probably easiest handled by two listeners added immediately after bind. A listener on the bindFuture would register the new socket. A listener on bindFuture.channel().closeFuture() would deregister the socket. I'll note that while closeFuture() may look really useful, you have to be careful with it, and it runs at an awkward time. I suggest only using it when the execution time doesn't matter. closeFuture() is different than \"the future returned from close()\".", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r540597596", "createdAt": "2020-12-11T00:19:45Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +292,88 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures;\n+    try {\n+      Future<Map<ChannelFuture, SocketAddress>> bindCallResult =\n+          bindCallFuture.awaitUninterruptibly();\n+      if (!bindCallResult.isSuccess()) {\n+        throw bindCallResult.cause();\n+      }\n+      channelFutures = bindCallResult.get();\n+    } catch (Throwable ex) {\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), ex);\n     }\n-    channel = future.channel();\n-    channel.eventLoop().execute(new Runnable() {\n-      @Override\n-      public void run() {\n-        listenSocketStats = new ListenSocket(channel);\n-        channelz.addListenSocket(listenSocketStats);\n+\n+    for (Map.Entry<ChannelFuture, SocketAddress> channelFutureEntry: channelFutures.entrySet()) {\n+      // We'd love to observe interruption, but if interrupted we will need to close the channel,\n+      // which itself would need an await() to guarantee the port is not used when the method\n+      // returns. See #6850\n+      ChannelFuture future  = channelFutureEntry.getKey().awaitUninterruptibly();\n+      if (!future.isSuccess()) {\n+        throw new IOException(String.format(\"Failed to bind to address %s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDYwMTI5NA==", "bodyText": "What does this comment mean by \"making it worse\"?", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r540601294", "createdAt": "2020-12-11T00:29:52Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +292,88 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures;\n+    try {\n+      Future<Map<ChannelFuture, SocketAddress>> bindCallResult =\n+          bindCallFuture.awaitUninterruptibly();\n+      if (!bindCallResult.isSuccess()) {\n+        throw bindCallResult.cause();\n+      }\n+      channelFutures = bindCallResult.get();\n+    } catch (Throwable ex) {\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), ex);\n     }\n-    channel = future.channel();\n-    channel.eventLoop().execute(new Runnable() {\n-      @Override\n-      public void run() {\n-        listenSocketStats = new ListenSocket(channel);\n-        channelz.addListenSocket(listenSocketStats);\n+\n+    for (Map.Entry<ChannelFuture, SocketAddress> channelFutureEntry: channelFutures.entrySet()) {\n+      // We'd love to observe interruption, but if interrupted we will need to close the channel,\n+      // which itself would need an await() to guarantee the port is not used when the method\n+      // returns. See #6850\n+      ChannelFuture future  = channelFutureEntry.getKey().awaitUninterruptibly();\n+      if (!future.isSuccess()) {\n+        throw new IOException(String.format(\"Failed to bind to address %s\",\n+            channelFutureEntry.getValue()), future.cause());\n       }\n-    });\n+      final Channel channel = future.channel();\n+      channel.eventLoop().execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          InternalInstrumented<SocketStats> listenSocketStats = new ListenSocket(channel);\n+          channelz.addListenSocket(listenSocketStats);\n+          listenSocketStatsList.add(listenSocketStats);\n+        }\n+      });\n+      channelGroup.add(channel);\n+    }\n   }\n \n   @Override\n   public void shutdown() {\n-    if (channel == null || !channel.isOpen()) {\n-      // Already closed.\n+    if (terminated) {\n+      // Already closed. Not thread safe but we are not making it worse for now.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "364fbac3ef70706cc70b5c30c9b9c994fc7b79b0"}, "originalPosition": 217}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "315bd5df062c42aea361b252b95a69ffe2efbd49", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/315bd5df062c42aea361b252b95a69ffe2efbd49", "committedDate": "2020-12-11T19:59:46Z", "message": "Merge branch 'master' of https://github.com/grpc/grpc-java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5d98a69c8d2c5c64614d5684b41c64d139ef4c7", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/e5d98a69c8d2c5c64614d5684b41c64d139ef4c7", "committedDate": "2020-12-14T05:09:34Z", "message": "bind multiple partial failure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15c61a9a1be04d33146a4f757706168f791545d4", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/15c61a9a1be04d33146a4f757706168f791545d4", "committedDate": "2020-12-16T22:26:37Z", "message": "use single transportServer in ServerImpl instead of a list"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8e243a35b19bd760f94c344ab94f924fa61d18b", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/e8e243a35b19bd760f94c344ab94f924fa61d18b", "committedDate": "2020-12-16T22:26:50Z", "message": "Merge branch 'master' of https://github.com/grpc/grpc-java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4MjI2ODU5", "url": "https://github.com/grpc/grpc-java/pull/7674#pullrequestreview-558226859", "createdAt": "2020-12-23T21:00:58Z", "commit": {"oid": "e8e243a35b19bd760f94c344ab94f924fa61d18b"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMTowMDo1OFrOIK1iwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QyMTozMjo1OVrOIK296A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIzMzkyMg==", "bodyText": "s/;;/;/", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r548233922", "createdAt": "2020-12-23T21:00:58Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -144,32 +158,57 @@\n     this.permitKeepAliveTimeInNanos = permitKeepAliveTimeInNanos;\n     this.eagAttributes = checkNotNull(eagAttributes, \"eagAttributes\");\n     this.channelz = Preconditions.checkNotNull(channelz);\n-    this.logId =\n-        InternalLogId.allocate(getClass(), address != null ? address.toString() : \"No address\");\n+    this.logId = InternalLogId.allocate(getClass(), addresses.isEmpty() ? \"No address\" :\n+        String.valueOf(addresses));\n   }\n \n   @Override\n   public SocketAddress getListenSocketAddress() {\n-    if (channel == null) {\n+    Iterator<Channel> it = channelGroup.iterator();\n+    if (it.hasNext()) {\n+      return it.next().localAddress();\n+    } else {\n       // server is not listening/bound yet, just return the original port.\n-      return address;\n+      return addresses.isEmpty() ? null : addresses.get(0);\n     }\n-    return channel.localAddress();\n+  }\n+\n+  @Override\n+  public List<SocketAddress> getListenSocketAddresses() {\n+    List<SocketAddress> listenSocketAddresses = new ArrayList<>();\n+    for (Channel c: channelGroup) {\n+      listenSocketAddresses.add(c.localAddress());\n+    }\n+    // server is not listening/bound yet, just return the original ports.\n+    if (listenSocketAddresses.isEmpty())  {\n+      listenSocketAddresses.addAll(addresses);\n+    }\n+    return listenSocketAddresses;\n   }\n \n   @Override\n   public InternalInstrumented<SocketStats> getListenSocketStats() {\n-    return listenSocketStats;\n+    if (listenSocketStatsList == null || listenSocketStatsList.isEmpty()) {\n+      return null;\n+    } else {\n+      return listenSocketStatsList.get(0);\n+    }\n+  }\n+\n+  @Override\n+  public List<InternalInstrumented<SocketStats>> getListenSocketStatsList() {\n+    return listenSocketStatsList;\n   }\n \n   @Override\n   public void start(ServerListener serverListener) throws IOException {\n     listener = checkNotNull(serverListener, \"serverListener\");\n \n-    ServerBootstrap b = new ServerBootstrap();\n+    final ServerBootstrap b = new ServerBootstrap();\n+    final EventLoop bossExecutor = bossGroup.next();;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8e243a35b19bd760f94c344ab94f924fa61d18b"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODIzNTYzOA==", "bodyText": "We should use the same event loop for the channels and the channelGroup. It's super-easy to and it means there are less threads involved for debugging/understanding the system.", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r548235638", "createdAt": "2020-12-23T21:03:47Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -144,32 +158,57 @@\n     this.permitKeepAliveTimeInNanos = permitKeepAliveTimeInNanos;\n     this.eagAttributes = checkNotNull(eagAttributes, \"eagAttributes\");\n     this.channelz = Preconditions.checkNotNull(channelz);\n-    this.logId =\n-        InternalLogId.allocate(getClass(), address != null ? address.toString() : \"No address\");\n+    this.logId = InternalLogId.allocate(getClass(), addresses.isEmpty() ? \"No address\" :\n+        String.valueOf(addresses));\n   }\n \n   @Override\n   public SocketAddress getListenSocketAddress() {\n-    if (channel == null) {\n+    Iterator<Channel> it = channelGroup.iterator();\n+    if (it.hasNext()) {\n+      return it.next().localAddress();\n+    } else {\n       // server is not listening/bound yet, just return the original port.\n-      return address;\n+      return addresses.isEmpty() ? null : addresses.get(0);\n     }\n-    return channel.localAddress();\n+  }\n+\n+  @Override\n+  public List<SocketAddress> getListenSocketAddresses() {\n+    List<SocketAddress> listenSocketAddresses = new ArrayList<>();\n+    for (Channel c: channelGroup) {\n+      listenSocketAddresses.add(c.localAddress());\n+    }\n+    // server is not listening/bound yet, just return the original ports.\n+    if (listenSocketAddresses.isEmpty())  {\n+      listenSocketAddresses.addAll(addresses);\n+    }\n+    return listenSocketAddresses;\n   }\n \n   @Override\n   public InternalInstrumented<SocketStats> getListenSocketStats() {\n-    return listenSocketStats;\n+    if (listenSocketStatsList == null || listenSocketStatsList.isEmpty()) {\n+      return null;\n+    } else {\n+      return listenSocketStatsList.get(0);\n+    }\n+  }\n+\n+  @Override\n+  public List<InternalInstrumented<SocketStats>> getListenSocketStatsList() {\n+    return listenSocketStatsList;\n   }\n \n   @Override\n   public void start(ServerListener serverListener) throws IOException {\n     listener = checkNotNull(serverListener, \"serverListener\");\n \n-    ServerBootstrap b = new ServerBootstrap();\n+    final ServerBootstrap b = new ServerBootstrap();\n+    final EventLoop bossExecutor = bossGroup.next();;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8e243a35b19bd760f94c344ab94f924fa61d18b"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI0MTIyNA==", "bodyText": "Just inline the list and Throwable here, and get rid of the class? It seems the class only hides one if statement checking for null that could be inlined here (or simply be removed; there's nothing special about the first or last throwable).\nI don't mind helpers like this. It just seems this helper isn't really helping and the indirection makes the code harder to read.\nI think this loop would be simpler if you pre-added add the channels to the channelGroup; the channels exist as soon as the future is created. Then, if any future fails you close the channelGroup and throw immediately. That would remove the need for BindResult completely.", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r548241224", "createdAt": "2020-12-23T21:11:16Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +297,132 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures =\n+        bindCallFuture.awaitUninterruptibly().getNow();\n+    if (channelFutures == null) {\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), bindCallFuture.cause());\n     }\n-    channel = future.channel();\n-    channel.eventLoop().execute(new Runnable() {\n-      @Override\n-      public void run() {\n-        listenSocketStats = new ListenSocket(channel);\n-        channelz.addListenSocket(listenSocketStats);\n+    BindResult bindResult = new BindResult();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8e243a35b19bd760f94c344ab94f924fa61d18b"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI0NjQ3OQ==", "bodyText": "This management of the listenSocketStatsList seems quite a bit more involved and error-prone than my suggestion of doing the equivalent of channel.closeFuture().addListener(() -> channelz.removeListenSocket(listenSocketStats)) right here. (The code is just a sketch, we can't use lambdas.)", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r548246479", "createdAt": "2020-12-23T21:18:10Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +297,132 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures =\n+        bindCallFuture.awaitUninterruptibly().getNow();\n+    if (channelFutures == null) {\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), bindCallFuture.cause());\n     }\n-    channel = future.channel();\n-    channel.eventLoop().execute(new Runnable() {\n-      @Override\n-      public void run() {\n-        listenSocketStats = new ListenSocket(channel);\n-        channelz.addListenSocket(listenSocketStats);\n+    BindResult bindResult = new BindResult();\n+    for (Map.Entry<ChannelFuture, SocketAddress> entry: channelFutures.entrySet()) {\n+      // We'd love to observe interruption, but if interrupted we will need to close the channel,\n+      // which itself would need an await() to guarantee the port is not used when the method\n+      // returns. See #6850\n+      ChannelFuture future = entry.getKey().awaitUninterruptibly();\n+      if (!future.isSuccess()) {\n+        bindResult.failAddress(entry.getValue()).causedBy(future.cause());\n+      } else {\n+        final Channel channel = future.channel();\n+        channel.eventLoop().execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            InternalInstrumented<SocketStats> listenSocketStats = new ListenSocket(channel);\n+            channelz.addListenSocket(listenSocketStats);\n+            listenSocketStatsList.add(listenSocketStats);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8e243a35b19bd760f94c344ab94f924fa61d18b"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI1NDUyNw==", "bodyText": "I see that closeChannelGroup() was split out to be reused here, but it doesn't seem safe to call. It does inappropriate things in this context like sharedResourceReferenceCounter.release() and protocolNegotiator.close(). (There's pre-existing issues already surrounding sharedResourceReferenceCounter, but this change doesn't fix them so it seems better to leave it alone.)\nIf listenSocketStatsList is removed by my other suggestion, I think this just becomes channelGroup.close().awaitUninterruptibly().", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r548254527", "createdAt": "2020-12-23T21:28:57Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +297,132 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures =\n+        bindCallFuture.awaitUninterruptibly().getNow();\n+    if (channelFutures == null) {\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), bindCallFuture.cause());\n     }\n-    channel = future.channel();\n-    channel.eventLoop().execute(new Runnable() {\n-      @Override\n-      public void run() {\n-        listenSocketStats = new ListenSocket(channel);\n-        channelz.addListenSocket(listenSocketStats);\n+    BindResult bindResult = new BindResult();\n+    for (Map.Entry<ChannelFuture, SocketAddress> entry: channelFutures.entrySet()) {\n+      // We'd love to observe interruption, but if interrupted we will need to close the channel,\n+      // which itself would need an await() to guarantee the port is not used when the method\n+      // returns. See #6850\n+      ChannelFuture future = entry.getKey().awaitUninterruptibly();\n+      if (!future.isSuccess()) {\n+        bindResult.failAddress(entry.getValue()).causedBy(future.cause());\n+      } else {\n+        final Channel channel = future.channel();\n+        channel.eventLoop().execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            InternalInstrumented<SocketStats> listenSocketStats = new ListenSocket(channel);\n+            channelz.addListenSocket(listenSocketStats);\n+            listenSocketStatsList.add(listenSocketStats);\n+          }\n+        });\n+        channelGroup.add(channel);\n       }\n-    });\n+    }\n+\n+    if (!bindResult.isSuccess()) {\n+      if (!channelGroup.isEmpty()) {\n+        closeChannelGroup().awaitUninterruptibly();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8e243a35b19bd760f94c344ab94f924fa61d18b"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODI1NzI1Ng==", "bodyText": "This produces the wrong results if the future hasn't failed and just hasn't completed yet.", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r548257256", "createdAt": "2020-12-23T21:32:59Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +297,132 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> map = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                map.put(future, address);\n+            }\n+            return map;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures =\n+        bindCallFuture.awaitUninterruptibly().getNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8e243a35b19bd760f94c344ab94f924fa61d18b"}, "originalPosition": 190}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecac9055e0ff95796c8e15827a527885cf0b1763", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/ecac9055e0ff95796c8e15827a527885cf0b1763", "committedDate": "2020-12-28T17:40:58Z", "message": "fix close channel group on paritial failures"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MjY1MzUz", "url": "https://github.com/grpc/grpc-java/pull/7674#pullrequestreview-559265353", "createdAt": "2020-12-28T19:00:14Z", "commit": {"oid": "ecac9055e0ff95796c8e15827a527885cf0b1763"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxOTowMDoxNFrOIMAAqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxOToxMjowOVrOIMAM0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1Mzk5NQ==", "bodyText": "Why is this volatile? It actually looks like it could be final", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549453995", "createdAt": "2020-12-28T19:00:14Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -78,7 +87,7 @@\n   private EventLoopGroup bossGroup;\n   private EventLoopGroup workerGroup;\n   private ServerListener listener;\n-  private Channel channel;\n+  private volatile ChannelGroup channelGroup;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecac9055e0ff95796c8e15827a527885cf0b1763"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NTczMw==", "bodyText": "Drop this. This listener isn't responsible for closing, just interested to know when it happens. The code that actually closes should be handling this error.", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549455733", "createdAt": "2020-12-28T19:06:45Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +297,101 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+    Future<Map<SocketAddress, Map<ChannelFuture,ChannelFutureListener>>> bindCallFuture =\n+        bossExecutor.submit(\n+            new Callable<Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>>>() {\n+          @Override\n+          public Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>> call() {\n+            Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>> bindFutures =\n+                new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                channelGroup.add(future.channel());\n+                final InternalInstrumented<SocketStats> listenSocketStats =\n+                    new ListenSocket(future.channel());\n+                future.addListener(new ChannelFutureListener() {\n+                  @Override\n+                  public void operationComplete(ChannelFuture future) throws Exception {\n+                    channelz.addListenSocket(listenSocketStats);\n+                    listenSocketStatsList.add(listenSocketStats);\n+                  }\n+                });\n+                ChannelFutureListener closeListener = new ChannelFutureListener() {\n+                  @Override\n+                  public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (!future.isSuccess()) {\n+                      log.log(Level.WARNING, \"Error closing server channel\", future.cause());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecac9055e0ff95796c8e15827a527885cf0b1763"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NzEwNg==", "bodyText": "Why do this? If you just leave the listener in-place, then you don't have to communicate it back to this thread (in the awkward map) and you don't need to call removeListenSocket within shutdown().", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549457106", "createdAt": "2020-12-28T19:12:09Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +297,101 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+    Future<Map<SocketAddress, Map<ChannelFuture,ChannelFutureListener>>> bindCallFuture =\n+        bossExecutor.submit(\n+            new Callable<Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>>>() {\n+          @Override\n+          public Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>> call() {\n+            Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>> bindFutures =\n+                new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                channelGroup.add(future.channel());\n+                final InternalInstrumented<SocketStats> listenSocketStats =\n+                    new ListenSocket(future.channel());\n+                future.addListener(new ChannelFutureListener() {\n+                  @Override\n+                  public void operationComplete(ChannelFuture future) throws Exception {\n+                    channelz.addListenSocket(listenSocketStats);\n+                    listenSocketStatsList.add(listenSocketStats);\n+                  }\n+                });\n+                ChannelFutureListener closeListener = new ChannelFutureListener() {\n+                  @Override\n+                  public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (!future.isSuccess()) {\n+                      log.log(Level.WARNING, \"Error closing server channel\", future.cause());\n+                    }\n+                    channelz.removeListenSocket(listenSocketStats);\n+                    listenSocketStatsList.remove(listenSocketStats);\n+                  }\n+                };\n+                future.channel().closeFuture().addListener(closeListener);\n+                bindFutures.put(address, ImmutableMap.of(future, closeListener));\n+            }\n+            return bindFutures;\n+          }\n+        }\n+    );\n+    Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>> channelFutures =\n+        bindCallFuture.awaitUninterruptibly().getNow();\n+\n+    if (!bindCallFuture.isSuccess()) {\n+      channelGroup.close().awaitUninterruptibly();\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), bindCallFuture.cause());\n     }\n-    channel = future.channel();\n-    channel.eventLoop().execute(new Runnable() {\n-      @Override\n-      public void run() {\n-        listenSocketStats = new ListenSocket(channel);\n-        channelz.addListenSocket(listenSocketStats);\n+    for (Map.Entry<SocketAddress, Map<ChannelFuture, ChannelFutureListener>> entry:\n+        channelFutures.entrySet()) {\n+      // We'd love to observe interruption, but if interrupted we will need to close the channel,\n+      // which itself would need an await() to guarantee the port is not used when the method\n+      // returns. See #6850\n+      for (ChannelFuture future: entry.getValue().keySet()) {\n+        if (!future.awaitUninterruptibly().isSuccess()) {\n+          channelGroup.close().awaitUninterruptibly();\n+          throw new IOException(String.format(\"Failed to bind to address %s\",\n+              entry.getKey()), future.cause());\n+        }\n       }\n-    });\n+    }\n+    for (Map<ChannelFuture, ChannelFutureListener> channelListener: channelFutures.values()) {\n+      for (Map.Entry<ChannelFuture, ChannelFutureListener> entry: channelListener.entrySet()) {\n+        entry.getKey().channel().closeFuture().removeListener(entry.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecac9055e0ff95796c8e15827a527885cf0b1763"}, "originalPosition": 241}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0ced0f2696b87252858cb871134cc38fcaae9fd", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/d0ced0f2696b87252858cb871134cc38fcaae9fd", "committedDate": "2020-12-28T20:22:24Z", "message": "fix remove channel group channel close listener"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20bbb9bb6a2455577019cf58567e650f221172c2", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/20bbb9bb6a2455577019cf58567e650f221172c2", "committedDate": "2020-12-28T21:04:50Z", "message": "fix indentation, add listenSocketStatsList null check"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzEyNzQx", "url": "https://github.com/grpc/grpc-java/pull/7674#pullrequestreview-559312741", "createdAt": "2020-12-28T21:46:51Z", "commit": {"oid": "20bbb9bb6a2455577019cf58567e650f221172c2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzI3MTAw", "url": "https://github.com/grpc/grpc-java/pull/7674#pullrequestreview-559327100", "createdAt": "2020-12-28T22:54:07Z", "commit": {"oid": "20bbb9bb6a2455577019cf58567e650f221172c2"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMjo1NDowN1rOIMDfYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzowMjo0NFrOIMDltw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMTAwOQ==", "bodyText": "ArrayList is not thread-safe, but this is used from multiple threads.", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549511009", "createdAt": "2020-12-28T22:54:07Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -97,10 +105,14 @@\n   private final TransportTracer.Factory transportTracerFactory;\n   private final InternalChannelz channelz;\n   // Only modified in event loop but safe to read any time.\n-  private volatile InternalInstrumented<SocketStats> listenSocketStats;\n+  private volatile List<InternalInstrumented<SocketStats>> listenSocketStatsList =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20bbb9bb6a2455577019cf58567e650f221172c2"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMTMxMw==", "bodyText": "This is not a thread-safe usage of a volatile reference as the value can change between each access. You need to copy it to a local variable to have a stable value.\nList<InternalInstrumented<SocketStats>> savedListenSocketStatsList = listenSocketStatsList;\nif (savedListenSocketSatsList == null || ...)", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549511313", "createdAt": "2020-12-28T22:55:41Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -144,32 +158,56 @@\n     this.permitKeepAliveTimeInNanos = permitKeepAliveTimeInNanos;\n     this.eagAttributes = checkNotNull(eagAttributes, \"eagAttributes\");\n     this.channelz = Preconditions.checkNotNull(channelz);\n-    this.logId =\n-        InternalLogId.allocate(getClass(), address != null ? address.toString() : \"No address\");\n+    this.logId = InternalLogId.allocate(getClass(), addresses.isEmpty() ? \"No address\" :\n+        String.valueOf(addresses));\n   }\n \n   @Override\n   public SocketAddress getListenSocketAddress() {\n-    if (channel == null) {\n+    Iterator<Channel> it = channelGroup.iterator();\n+    if (it.hasNext()) {\n+      return it.next().localAddress();\n+    } else {\n       // server is not listening/bound yet, just return the original port.\n-      return address;\n+      return addresses.isEmpty() ? null : addresses.get(0);\n     }\n-    return channel.localAddress();\n+  }\n+\n+  @Override\n+  public List<SocketAddress> getListenSocketAddresses() {\n+    List<SocketAddress> listenSocketAddresses = new ArrayList<>();\n+    for (Channel c: channelGroup) {\n+      listenSocketAddresses.add(c.localAddress());\n+    }\n+    // server is not listening/bound yet, just return the original ports.\n+    if (listenSocketAddresses.isEmpty())  {\n+      listenSocketAddresses.addAll(addresses);\n+    }\n+    return listenSocketAddresses;\n   }\n \n   @Override\n   public InternalInstrumented<SocketStats> getListenSocketStats() {\n-    return listenSocketStats;\n+    if (listenSocketStatsList == null || listenSocketStatsList.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20bbb9bb6a2455577019cf58567e650f221172c2"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMjA4MQ==", "bodyText": "listenSocketStatsList could be null here, as it can race with the code in shutdown().\nThis is not actually a thread-safety risk as both listeners will run from the event loop, but just a normal \"that other operation may happen first.\" We shouldn't unnecessarily depend on the closeListener() completing and running the listeners before the future returned from close() completes.", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549512081", "createdAt": "2020-12-28T22:59:32Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +296,92 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+    Future<Map<SocketAddress, ChannelFuture>> bindCallFuture =\n+        bossExecutor.submit(\n+            new Callable<Map<SocketAddress, ChannelFuture>>() {\n+          @Override\n+          public Map<SocketAddress, ChannelFuture> call() {\n+            Map<SocketAddress, ChannelFuture> bindFutures = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                channelGroup.add(future.channel());\n+                final InternalInstrumented<SocketStats> listenSocketStats =\n+                    new ListenSocket(future.channel());\n+                future.addListener(new ChannelFutureListener() {\n+                  @Override\n+                  public void operationComplete(ChannelFuture future) throws Exception {\n+                    channelz.addListenSocket(listenSocketStats);\n+                    listenSocketStatsList.add(listenSocketStats);\n+                  }\n+                });\n+                ChannelFutureListener closeListener = new ChannelFutureListener() {\n+                  @Override\n+                  public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (listenSocketStatsList != null) {\n+                      channelz.removeListenSocket(listenSocketStats);\n+                      listenSocketStatsList.remove(listenSocketStats);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20bbb9bb6a2455577019cf58567e650f221172c2"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMjYzMQ==", "bodyText": "But you don't need the group close listener removal! And setting listenSocketStatsList = null doesn't add much value and makes the code more complex. Why should this code even exist if the other code will handle the cleanup?", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r549512631", "createdAt": "2020-12-28T23:02:44Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +297,101 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+    Future<Map<SocketAddress, Map<ChannelFuture,ChannelFutureListener>>> bindCallFuture =\n+        bossExecutor.submit(\n+            new Callable<Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>>>() {\n+          @Override\n+          public Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>> call() {\n+            Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>> bindFutures =\n+                new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                channelGroup.add(future.channel());\n+                final InternalInstrumented<SocketStats> listenSocketStats =\n+                    new ListenSocket(future.channel());\n+                future.addListener(new ChannelFutureListener() {\n+                  @Override\n+                  public void operationComplete(ChannelFuture future) throws Exception {\n+                    channelz.addListenSocket(listenSocketStats);\n+                    listenSocketStatsList.add(listenSocketStats);\n+                  }\n+                });\n+                ChannelFutureListener closeListener = new ChannelFutureListener() {\n+                  @Override\n+                  public void operationComplete(ChannelFuture future) throws Exception {\n+                    if (!future.isSuccess()) {\n+                      log.log(Level.WARNING, \"Error closing server channel\", future.cause());\n+                    }\n+                    channelz.removeListenSocket(listenSocketStats);\n+                    listenSocketStatsList.remove(listenSocketStats);\n+                  }\n+                };\n+                future.channel().closeFuture().addListener(closeListener);\n+                bindFutures.put(address, ImmutableMap.of(future, closeListener));\n+            }\n+            return bindFutures;\n+          }\n+        }\n+    );\n+    Map<SocketAddress, Map<ChannelFuture, ChannelFutureListener>> channelFutures =\n+        bindCallFuture.awaitUninterruptibly().getNow();\n+\n+    if (!bindCallFuture.isSuccess()) {\n+      channelGroup.close().awaitUninterruptibly();\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), bindCallFuture.cause());\n     }\n-    channel = future.channel();\n-    channel.eventLoop().execute(new Runnable() {\n-      @Override\n-      public void run() {\n-        listenSocketStats = new ListenSocket(channel);\n-        channelz.addListenSocket(listenSocketStats);\n+    for (Map.Entry<SocketAddress, Map<ChannelFuture, ChannelFutureListener>> entry:\n+        channelFutures.entrySet()) {\n+      // We'd love to observe interruption, but if interrupted we will need to close the channel,\n+      // which itself would need an await() to guarantee the port is not used when the method\n+      // returns. See #6850\n+      for (ChannelFuture future: entry.getValue().keySet()) {\n+        if (!future.awaitUninterruptibly().isSuccess()) {\n+          channelGroup.close().awaitUninterruptibly();\n+          throw new IOException(String.format(\"Failed to bind to address %s\",\n+              entry.getKey()), future.cause());\n+        }\n       }\n-    });\n+    }\n+    for (Map<ChannelFuture, ChannelFutureListener> channelListener: channelFutures.values()) {\n+      for (Map.Entry<ChannelFuture, ChannelFutureListener> entry: channelListener.entrySet()) {\n+        entry.getKey().channel().closeFuture().removeListener(entry.getValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1NzEwNg=="}, "originalCommit": {"oid": "ecac9055e0ff95796c8e15827a527885cf0b1763"}, "originalPosition": 241}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0038bb5e876034f35c34e4ab1cee5514b30a4b0f", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/0038bb5e876034f35c34e4ab1cee5514b30a4b0f", "committedDate": "2020-12-28T23:38:59Z", "message": "fix listenSocketStatsList read thread-unsafe, remove removing from channelz in shutdown"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ac7aa56121de73b8a55c5cb717c6aa636d12fee", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/6ac7aa56121de73b8a55c5cb717c6aa636d12fee", "committedDate": "2020-12-29T01:48:51Z", "message": "fix thread unsafe listenSocketStatsList"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d091381f74c1aa4a10814f8225b2420faba5ac7c", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/d091381f74c1aa4a10814f8225b2420faba5ac7c", "committedDate": "2020-12-29T02:21:22Z", "message": "fix thread unsafe listenSocketsList"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "589cbe90a402b57cc61915e859aecf935d92e2e5", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/589cbe90a402b57cc61915e859aecf935d92e2e5", "committedDate": "2020-12-30T17:12:33Z", "message": "fix thread unsafe listenSocketStatsList"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwMTQ4MDY2", "url": "https://github.com/grpc/grpc-java/pull/7674#pullrequestreview-560148066", "createdAt": "2020-12-30T18:00:51Z", "commit": {"oid": "589cbe90a402b57cc61915e859aecf935d92e2e5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxODowMDo1MVrOIMyYFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQxODoyMTo1NlrOIMyuCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI3OTE4OQ==", "bodyText": "Assign to Collections.emptyList() to avoid null pointer concerns?", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r550279189", "createdAt": "2020-12-30T18:00:51Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -364,6 +368,7 @@ public void operationComplete(ChannelGroupFuture future) throws Exception {\n               }\n               sharedResourceReferenceCounter.release();\n               protocolNegotiator.close();\n+              listenSocketStatsList = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "589cbe90a402b57cc61915e859aecf935d92e2e5"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI3OTM0Mg==", "bodyText": "This synchronization does nothing.", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r550279342", "createdAt": "2020-12-30T18:01:28Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -348,6 +349,9 @@ public void operationComplete(ChannelFuture future) throws Exception {\n             entry.getKey()), future.cause());\n       }\n     }\n+    synchronized (NettyServer.this) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "589cbe90a402b57cc61915e859aecf935d92e2e5"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI4NDgwOA==", "bodyText": "This is not thread-safe, as it can happen after future.awaitUninterruptibly().isSuccess() returns.\nWe had discussed needing to have another future that is completed right after this synchronized block, and pass that future instead in bindFutures. But I actually think it'd be easier to move this code (and listenSocketStats creation) to the channelFutures.entrySet() for loop directly. At that location, the entire contents of this ChannelFutureListener could be called directly and the synchronized block would be unnecessary. It'd be best to move future.channel().closeFuture().addListener() for channelz.removeListenSocket() to the for loop as well so they stay paired (but it would stay as a listener).", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r550284808", "createdAt": "2020-12-30T18:21:56Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -309,20 +314,16 @@ public void operationComplete(ChannelFuture future) throws Exception {\n                   public void operationComplete(ChannelFuture future) throws Exception {\n                     channelz.addListenSocket(listenSocketStats);\n                     synchronized (NettyServer.this) {\n-                      listenSocketStatsList.add(listenSocketStats);\n+                      socketStats.add(listenSocketStats);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "589cbe90a402b57cc61915e859aecf935d92e2e5"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5de6d7030a29d2995c2d9044454f162ccf4add03", "author": {"user": {"login": "YifeiZhuang", "name": "yifeizhuang"}}, "url": "https://github.com/grpc/grpc-java/commit/5de6d7030a29d2995c2d9044454f162ccf4add03", "committedDate": "2020-12-30T20:50:57Z", "message": "fix thread unsafe listenSocketStatsList"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwMjAxNTIw", "url": "https://github.com/grpc/grpc-java/pull/7674#pullrequestreview-560201520", "createdAt": "2020-12-30T21:10:31Z", "commit": {"oid": "5de6d7030a29d2995c2d9044454f162ccf4add03"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMToxMDozMVrOIM1XEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQyMToxMDozMVrOIM1XEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyODA4Mw==", "bodyText": "nit: no need for final.", "url": "https://github.com/grpc/grpc-java/pull/7674#discussion_r550328083", "createdAt": "2020-12-30T21:10:31Z", "author": {"login": "ejona86"}, "path": "netty/src/main/java/io/grpc/netty/NettyServer.java", "diffHunk": "@@ -258,51 +293,77 @@ public void operationComplete(ChannelFuture future) throws Exception {\n         ch.closeFuture().addListener(loopReleaser);\n       }\n     });\n-    // Bind and start to accept incoming connections.\n-    ChannelFuture future = b.bind(address);\n-    // We'd love to observe interruption, but if interrupted we will need to close the channel,\n-    // which itself would need an await() to guarantee the port is not used when the method returns.\n-    // See #6850\n-    future.awaitUninterruptibly();\n-    if (!future.isSuccess()) {\n-      throw new IOException(String.format(\"Failed to bind to address %s\", address), future.cause());\n+    Future<Map<ChannelFuture, SocketAddress>> bindCallFuture =\n+        bossExecutor.submit(\n+            new Callable<Map<ChannelFuture, SocketAddress>>() {\n+          @Override\n+          public Map<ChannelFuture, SocketAddress> call() {\n+            Map<ChannelFuture, SocketAddress> bindFutures = new HashMap<>();\n+            for (SocketAddress address: addresses) {\n+                ChannelFuture future = b.bind(address);\n+                channelGroup.add(future.channel());\n+                bindFutures.put(future, address);\n+            }\n+            return bindFutures;\n+          }\n+        }\n+    );\n+    Map<ChannelFuture, SocketAddress> channelFutures =\n+        bindCallFuture.awaitUninterruptibly().getNow();\n+\n+    if (!bindCallFuture.isSuccess()) {\n+      channelGroup.close().awaitUninterruptibly();\n+      throw new IOException(String.format(\"Failed to bind to addresses %s\",\n+          addresses), bindCallFuture.cause());\n     }\n-    channel = future.channel();\n-    channel.eventLoop().execute(new Runnable() {\n-      @Override\n-      public void run() {\n-        listenSocketStats = new ListenSocket(channel);\n-        channelz.addListenSocket(listenSocketStats);\n+    final List<InternalInstrumented<SocketStats>> socketStats = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5de6d7030a29d2995c2d9044454f162ccf4add03"}, "originalPosition": 195}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4722, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}