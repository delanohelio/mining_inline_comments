{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxMDgxODM4", "number": 7055, "title": "xds: implement xds_routing policy config generation and parsing", "bodyText": "In this PR, the xDS resolver generates a raw service config with load balancing config that supports all matchers in xds_routing config. This converts XdsClient's data structure EnvoyProtoData.Route to JSON format. Then the XdsRoutingConfig parser parses the JSON-format config back to a Java object. Note this convert-and-parse-back step is tedious and seemingly unnecessary, but this is how it works now as discussed in the design doc. In the future, we might eliminate this. Since EnvoyProtoData.Route and XdsRoutingConfig is somewhat similar in terms of its structure, we move the definition of matchers to a separate class so that the two can share the usage of types for parsed matchers.\nImplementation for XdsRoutingLoadBalancer is temporarily deleted, as the definition of XdsRoutingConfig has changed completely so the routing policy needs to be re-implemeneted.", "createdAt": "2020-05-21T00:14:53Z", "url": "https://github.com/grpc/grpc-java/pull/7055", "merged": true, "mergeCommit": {"oid": "c551fe38072d5c4989f58099b9047f7cf409fd26"}, "closed": true, "closedAt": "2020-06-04T09:03:50Z", "author": {"login": "voidzcy"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjSR__gH2gAyNDIxMDgxODM4OmYyMzhmMjM5NTIwMzc5M2UyNjEwMzI2ZGJjMDhlNTNlMzMzOGFiZDU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnehmjgFqTQyMzE0NzA2MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f238f2395203793e2610326dbc08e53e3338abd5", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/f238f2395203793e2610326dbc08e53e3338abd5", "committedDate": "2020-05-21T00:11:23Z", "message": "Define route matcher types that can be shared by both xDS converted data and by gRPC Lb policies."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f65468f9fde5025bfacdaafe401aac48c17dabfd", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/f65468f9fde5025bfacdaafe401aac48c17dabfd", "committedDate": "2020-05-21T00:12:06Z", "message": "Used shared data types for matchers."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "468ecc24890e683660c3b29d179d134585249e59", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/468ecc24890e683660c3b29d179d134585249e59", "committedDate": "2020-05-21T00:12:48Z", "message": "Temporarily delete implementation for xds_routing LB policy."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "60468d4c525aa3f1ad0d9a803c581e670e6560b7", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/60468d4c525aa3f1ad0d9a803c581e670e6560b7", "committedDate": "2020-05-21T00:13:23Z", "message": "Define new format of xds_routing LB policy config, add in matchers and implement parsing logic."}, "afterCommit": {"oid": "63bfef189bea9dcb757c086fe295eb173c18a543", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/63bfef189bea9dcb757c086fe295eb173c18a543", "committedDate": "2020-05-21T01:02:27Z", "message": "Define new format of xds_routing LB policy config, add in matchers and implement parsing logic."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e85365ad5c149190ea9f6e3bde925e8271c9f5b", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/7e85365ad5c149190ea9f6e3bde925e8271c9f5b", "committedDate": "2020-05-21T01:10:51Z", "message": "Define new format of xds_routing LB policy config, add in matchers and implement parsing logic."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a4f60bbc5f043d6f1f1f041fc4af6cbc4d6bc97", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/3a4f60bbc5f043d6f1f1f041fc4af6cbc4d6bc97", "committedDate": "2020-05-22T01:36:13Z", "message": "Generate xds_routing config with all supported matchers in the xDS resolver."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "63bfef189bea9dcb757c086fe295eb173c18a543", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/63bfef189bea9dcb757c086fe295eb173c18a543", "committedDate": "2020-05-21T01:02:27Z", "message": "Define new format of xds_routing LB policy config, add in matchers and implement parsing logic."}, "afterCommit": {"oid": "3a4f60bbc5f043d6f1f1f041fc4af6cbc4d6bc97", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/3a4f60bbc5f043d6f1f1f041fc4af6cbc4d6bc97", "committedDate": "2020-05-22T01:36:13Z", "message": "Generate xds_routing config with all supported matchers in the xDS resolver."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3fd3ddccf2bbc577f24aed1d89c6abc50d1d54a0", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/3fd3ddccf2bbc577f24aed1d89c6abc50d1d54a0", "committedDate": "2020-05-26T19:33:25Z", "message": "Refactor xds_routing config to the way that can be easily used by the xds_routing policy."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b108802da64692ebe74bbae64a8e04c1cd5ef10", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/5b108802da64692ebe74bbae64a8e04c1cd5ef10", "committedDate": "2020-05-27T19:21:26Z", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/xds_routing_policy_config_generation_and_parsing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMzQ4ODAx", "url": "https://github.com/grpc/grpc-java/pull/7055#pullrequestreview-420348801", "createdAt": "2020-05-28T17:45:09Z", "commit": {"oid": "5b108802da64692ebe74bbae64a8e04c1cd5ef10"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxNzo0NTowOVrOGcAA6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzowNjowMVrOGclEGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjAxMzU0NA==", "bodyText": "Add what getters in TODO?", "url": "https://github.com/grpc/grpc-java/pull/7055#discussion_r432013544", "createdAt": "2020-05-28T17:45:09Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/RouteMatchers.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.MoreObjects.ToStringHelper;\n+import com.google.re2j.Pattern;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+final class RouteMatchers {\n+\n+  // Prevent instantiation\n+  private RouteMatchers() {\n+  }\n+\n+  static final class PathMatcher {\n+    // Exactly one of the following fields is non-null.\n+    @Nullable\n+    private final String path;\n+    @Nullable\n+    private final String prefix;\n+    @Nullable\n+    private final Pattern regEx;\n+\n+    PathMatcher(@Nullable String path, @Nullable String prefix, @Nullable Pattern regEx) {\n+      this.path = path;\n+      this.prefix = prefix;\n+      this.regEx = regEx;\n+    }\n+\n+    @Nullable\n+    String getPath() {\n+      return path;\n+    }\n+\n+    @Nullable\n+    String getPrefix() {\n+      return prefix;\n+    }\n+\n+    @Nullable\n+    Pattern getRegEx() {\n+      return regEx;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      PathMatcher that = (PathMatcher) o;\n+      return Objects.equals(path, that.path)\n+          && Objects.equals(prefix, that.prefix)\n+          && Objects.equals(\n+              regEx == null ? null : regEx.pattern(),\n+              that.regEx == null ? null : that.regEx.pattern());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(path, prefix, regEx == null ? null : regEx.pattern());\n+    }\n+\n+    @Override\n+    public String toString() {\n+      ToStringHelper toStringHelper =\n+          MoreObjects.toStringHelper(this);\n+      if (path != null) {\n+        toStringHelper.add(\"path\", path);\n+      }\n+      if (prefix != null) {\n+        toStringHelper.add(\"prefix\", prefix);\n+      }\n+      if (regEx != null) {\n+        toStringHelper.add(\"regEx\", regEx.pattern());\n+      }\n+      return toStringHelper.toString();\n+    }\n+  }\n+\n+  /**\n+   * Matching rules for a specific HTTP/2 header.\n+   */\n+  static final class HeaderMatcher {\n+    private final String name;\n+\n+    // Exactly one of the following fields is non-null.\n+    @Nullable\n+    private final String exactMatch;\n+    @Nullable\n+    private final Pattern safeRegExMatch;\n+    @Nullable\n+    private final Range rangeMatch;\n+    @Nullable\n+    private final Boolean presentMatch;\n+    @Nullable\n+    private final String prefixMatch;\n+    @Nullable\n+    private final String suffixMatch;\n+\n+    private final boolean isInvertedMatch;\n+\n+    // TODO(chengyuanzhang): use builder to enforce oneof semantics would be better.\n+    HeaderMatcher(\n+        String name,\n+        @Nullable String exactMatch, @Nullable Pattern safeRegExMatch, @Nullable Range rangeMatch,\n+        @Nullable Boolean presentMatch, @Nullable String prefixMatch, @Nullable String suffixMatch,\n+        boolean isInvertedMatch) {\n+      this.name = name;\n+      this.exactMatch = exactMatch;\n+      this.safeRegExMatch = safeRegExMatch;\n+      this.rangeMatch = rangeMatch;\n+      this.presentMatch = presentMatch;\n+      this.prefixMatch = prefixMatch;\n+      this.suffixMatch = suffixMatch;\n+      this.isInvertedMatch = isInvertedMatch;\n+    }\n+\n+    // TODO (chengyuanzhang): add getters when needed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b108802da64692ebe74bbae64a8e04c1cd5ef10"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIxMzY0OQ==", "bodyText": "Should always have headers entry to be compatible with the proto format.", "url": "https://github.com/grpc/grpc-java/pull/7055#discussion_r432213649", "createdAt": "2020-05-29T01:47:44Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver.java", "diffHunk": "@@ -228,70 +230,126 @@ public void onError(Status error) {\n     }\n   }\n \n-  private static ImmutableMap<String, ?> generateXdsRoutingRawConfig(List<Route> routesUpdate) {\n-    List<Object> routes = new ArrayList<>(routesUpdate.size());\n-    Map<String, Object> actions = new LinkedHashMap<>();\n-    Map<RouteAction, String> exitingActions = new HashMap<>();\n-    for (Route route : routesUpdate) {\n-      String service = \"\";\n-      String method = \"\";\n-      if (!route.isDefaultRoute()) {\n-        String prefix = route.getRouteMatch().getPathPrefixMatch();\n-        String path = route.getRouteMatch().getPathExactMatch();\n-        if (prefix != null) {\n-          service = prefix.substring(1, prefix.length() - 1);\n-        } else if (path != null) {\n-          int splitIndex = path.lastIndexOf('/');\n-          service = path.substring(1, splitIndex);\n-          method = path.substring(splitIndex + 1);\n-        } else {\n-          // TODO (chengyuanzhang): match with regex.\n-          continue;\n-        }\n-      }\n-      Map<String, String> methodName = ImmutableMap.of(\"service\", service, \"method\", method);\n-      String actionName;\n+  @VisibleForTesting\n+  static ImmutableMap<String, ?> generateXdsRoutingRawConfig(List<Route> routes) {\n+    List<Object> rawRoutes = new ArrayList<>();\n+    Map<String, Object> rawActions = new LinkedHashMap<>();\n+    Map<RouteAction, String> existingActions = new HashMap<>();\n+    for (Route route : routes) {\n       RouteAction routeAction = route.getRouteAction();\n+      String actionName;\n       Map<String, ?> actionPolicy;\n-      if (exitingActions.containsKey(routeAction)) {\n-        actionName = exitingActions.get(routeAction);\n+      if (existingActions.containsKey(routeAction)) {\n+        actionName = existingActions.get(routeAction);\n       } else {\n         if (routeAction.getCluster() != null) {\n           actionName = \"cds:\" + routeAction.getCluster();\n           actionPolicy = generateCdsRawConfig(routeAction.getCluster());\n-        } else if (routeAction.getWeightedCluster() != null) {\n+        } else {\n           StringBuilder sb = new StringBuilder(\"weighted:\");\n           List<ClusterWeight> clusterWeights = routeAction.getWeightedCluster();\n           for (ClusterWeight clusterWeight : clusterWeights) {\n             sb.append(clusterWeight.getName()).append('_');\n           }\n           sb.append(routeAction.hashCode());\n           actionName = sb.toString();\n-          if (actions.containsKey(actionName)) {\n-            // Just in case of hash collision, append exitingActions.size() to make actionName\n+          if (rawActions.containsKey(actionName)) {\n+            // Just in case of hash collision, append existingActions.size() to make actionName\n             // unique. However, in case of collision, when new ConfigUpdate is received, actions\n             // and actionNames might be associated differently from the previous update, but it\n             // is just suboptimal and won't cause a problem.\n-            actionName = actionName + \"_\" + exitingActions.size();\n+            actionName = actionName + \"_\" + existingActions.size();\n           }\n           actionPolicy = generateWeightedTargetRawConfig(clusterWeights);\n-        } else {\n-          // TODO (chengyuanzhang): route with cluster_header.\n-          continue;\n         }\n-        exitingActions.put(routeAction, actionName);\n+        existingActions.put(routeAction, actionName);\n         List<?> childPolicies = ImmutableList.of(actionPolicy);\n-        actions.put(actionName, ImmutableMap.of(\"childPolicy\", childPolicies));\n+        rawActions.put(actionName, ImmutableMap.of(\"childPolicy\", childPolicies));\n       }\n-      routes.add(ImmutableMap.of(\"methodName\", methodName, \"action\", actionName));\n+      ImmutableMap<String, ?> configRoute = convertToRawRoute(route.getRouteMatch(), actionName);\n+      rawRoutes.add(configRoute);\n     }\n-\n     return ImmutableMap.of(\n         XdsLbPolicies.XDS_ROUTING_POLICY_NAME,\n-        ImmutableMap.of(\"route\", routes, \"action\", actions));\n+        ImmutableMap.of(\n+            \"route\", Collections.unmodifiableList(rawRoutes),\n+            \"action\", Collections.unmodifiableMap(rawActions)));\n+  }\n+\n+  @VisibleForTesting\n+  static ImmutableMap<String, ?> convertToRawRoute(RouteMatch routeMatch, String actionName) {\n+    ImmutableMap.Builder<String, Object> configRouteBuilder = new ImmutableMap.Builder<>();\n+\n+    PathMatcher pathMatcher = routeMatch.getPathMatch();\n+    String path = pathMatcher.getPath();\n+    String prefix = pathMatcher.getPrefix();\n+    Pattern regex = pathMatcher.getRegEx();\n+    if (path != null) {\n+      configRouteBuilder.put(\"path\", path);\n+    }\n+    if (prefix != null) {\n+      configRouteBuilder.put(\"prefix\", prefix);\n+    }\n+    if (regex != null) {\n+      configRouteBuilder.put(\"regex\", regex.pattern());\n+    }\n+\n+    ImmutableList.Builder<Object> rawHeaderMatcherListBuilder = new ImmutableList.Builder<>();\n+    List<HeaderMatcher> headerMatchers = routeMatch.getHeaderMatchers();\n+    for (HeaderMatcher headerMatcher : headerMatchers) {\n+      ImmutableMap.Builder<String, Object> rawHeaderMatcherBuilder = new ImmutableMap.Builder<>();\n+      rawHeaderMatcherBuilder.put(\"name\", headerMatcher.getName());\n+      String exactMatch = headerMatcher.getExactMatch();\n+      Pattern regexMatch = headerMatcher.getRegExMatch();\n+      HeaderMatcher.Range rangeMatch = headerMatcher.getRangeMatch();\n+      Boolean presentMatch = headerMatcher.getPresentMatch();\n+      String prefixMatch = headerMatcher.getPrefixMatch();\n+      String suffixMatch = headerMatcher.getSuffixMatch();\n+      if (exactMatch != null) {\n+        rawHeaderMatcherBuilder.put(\"exactMatch\", exactMatch);\n+      }\n+      if (regexMatch != null) {\n+        rawHeaderMatcherBuilder.put(\"regexMatch\", regexMatch.pattern());\n+      }\n+      if (rangeMatch != null) {\n+        rawHeaderMatcherBuilder\n+            .put(\n+                \"rangeMatch\",\n+                ImmutableMap.of(\"start\", rangeMatch.getStart(), \"end\", rangeMatch.getEnd()));\n+      }\n+      if (presentMatch != null) {\n+        rawHeaderMatcherBuilder.put(\"presentMatch\", presentMatch);\n+      }\n+      if (prefixMatch != null) {\n+        rawHeaderMatcherBuilder.put(\"prefixMatch\", prefixMatch);\n+      }\n+      if (suffixMatch != null) {\n+        rawHeaderMatcherBuilder.put(\"suffixMatch\", suffixMatch);\n+      }\n+      rawHeaderMatcherBuilder.put(\"invertMatch\", headerMatcher.isInvertedMatch());\n+      rawHeaderMatcherListBuilder.add(rawHeaderMatcherBuilder.build());\n+    }\n+    ImmutableList<?> rawHeaderMatchers = rawHeaderMatcherListBuilder.build();\n+    if (!rawHeaderMatchers.isEmpty()) {\n+      configRouteBuilder.put(\"headers\", rawHeaderMatchers);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b108802da64692ebe74bbae64a8e04c1cd5ef10"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwMTg5OQ==", "bodyText": "Revert the empty line change.", "url": "https://github.com/grpc/grpc-java/pull/7055#discussion_r432601899", "createdAt": "2020-05-29T16:33:28Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancer.java", "diffHunk": "@@ -182,39 +181,18 @@ protected Helper delegate() {\n     }\n   }\n \n-  private static final class PathMatchingSubchannelPicker extends SubchannelPicker {\n+  private static final class RouteMatchingSubchannelPicker extends SubchannelPicker {\n \n-    final Map<MethodName, SubchannelPicker> routePickers;\n+    final Map<RouteMatch, SubchannelPicker> routePickers;\n \n-    /**\n-     * Constructs a picker that will match the path of PickSubchannelArgs with the given map.\n-     * The order of the map entries matters. First match will be picked even if second match is an\n-     * exact (service + method) path match.\n-     */\n-    PathMatchingSubchannelPicker(Map<MethodName, SubchannelPicker> routePickers) {\n+    RouteMatchingSubchannelPicker(Map<RouteMatch, SubchannelPicker> routePickers) {\n       this.routePickers = routePickers;\n     }\n \n     @Override\n     public PickResult pickSubchannel(PickSubchannelArgs args) {\n-      for (MethodName methodName : routePickers.keySet()) {\n-        if (match(args.getMethodDescriptor(), methodName)) {\n-          return routePickers.get(methodName).pickSubchannel(args);\n-        }\n-      }\n-      // At least the default route should match, otherwise there is a bug.\n-      throw new IllegalStateException(\"PathMatchingSubchannelPicker: error in matching path\");\n-    }\n-\n-    boolean match(MethodDescriptor<?, ?> methodDescriptor, MethodName methodName) {\n-      if (methodName.service.isEmpty() && methodName.method.isEmpty()) {\n-        return true;\n-      }\n-      if (methodName.method.isEmpty()) {\n-        return methodName.service.equals(methodDescriptor.getServiceName());\n-      }\n-      return (methodName.service + '/' + methodName.method)\n-          .equals(methodDescriptor.getFullMethodName());\n+      // TODO(chengyuanzhang): to be implemented.\n+      return PickResult.withError(Status.INTERNAL.withDescription(\"routing picker unimplemented\"));\n     }\n   }\n-}\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b108802da64692ebe74bbae64a8e04c1cd5ef10"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwNjI5NQ==", "bodyText": "The error message does not indicate which child policy is not specified. However, it will be awkward to pass action name to this method. Seems there's no obvious better alternative.\nWhat about return StructOrErrorStatus<PolicySelection> and then augment the error message?", "url": "https://github.com/grpc/grpc-java/pull/7055#discussion_r432606295", "createdAt": "2020-05-29T16:42:09Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -97,77 +101,167 @@ public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n               \"No config for action \" + name + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n-            JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n-        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n-          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No child policy for action \" + name + \" in xds_routing LB policy: \"\n-                  + rawConfig));\n-        }\n-\n-        LoadBalancerRegistry lbRegistry =\n-            this.lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : this.lbRegistry;\n-        ConfigOrError selectedConfigOrError =\n-            ServiceConfigUtil.selectLbPolicyFromList(childConfigCandidates, lbRegistry);\n-        if (selectedConfigOrError.getError() != null) {\n-          return selectedConfigOrError;\n-        }\n-\n-        parsedActions.put(name, (PolicySelection) selectedConfigOrError.getConfig());\n+        PolicySelection parsedAction =\n+            parseAction(\n+                rawAction,\n+                this.lbRegistry == null\n+                    ? LoadBalancerRegistry.getDefaultRegistry() : this.lbRegistry);\n+        parsedActions.put(name, parsedAction);\n       }\n \n-      List<Map<String, ?>> routes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n-      if (routes == null || routes.isEmpty()) {\n+      List<Route> parsedRoutes = new ArrayList<>();\n+      List<Map<String, ?>> rawRoutes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n+      if (rawRoutes == null || rawRoutes.isEmpty()) {\n         return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n             \"No routes provided for xds_routing LB policy: \" + rawConfig));\n       }\n-      List<Route> parsedRoutes = new ArrayList<>();\n-      Set<MethodName> methodNames = new HashSet<>();\n-      for (int i = 0; i < routes.size(); i++) {\n-        Map<String, ?> route = routes.get(i);\n-        String actionName = JsonUtil.getString(route, \"action\");\n-        if (actionName == null) {\n-          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No action name provided for one of the routes in xds_routing LB policy: \"\n-                  + rawConfig));\n-        }\n-        if (!parsedActions.containsKey(actionName)) {\n+      for (Map<String, ?> rawRoute: rawRoutes) {\n+        Route route = parseRoute(rawRoute);\n+        if (!parsedActions.containsKey(route.getActionName())) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n               \"No action defined for route \" + route + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-        Map<String, ?> methodName = JsonUtil.getObject(route, \"methodName\");\n-        if (methodName == null) {\n-          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No method_name provided for one of the routes in xds_routing LB policy: \"\n-                  + rawConfig));\n-        }\n-        String service = JsonUtil.getString(methodName, \"service\");\n-        String method = JsonUtil.getString(methodName, \"method\");\n-        if (service == null || method == null) {\n-          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No service or method provided for one of the routes in xds_routing LB policy: \"\n-                  + rawConfig));\n+        parsedRoutes.add(route);\n+      }\n+      return ConfigOrError.fromConfig(new XdsRoutingConfig(parsedRoutes, parsedActions));\n+    } catch (RuntimeException e) {\n+      return ConfigOrError.fromError(\n+          Status.fromThrowable(e).withDescription(\n+              \"Failed to parse xds_routing LB config: \" + rawConfig));\n+    }\n+  }\n+\n+  private static PolicySelection parseAction(\n+      Map<String, ?> rawAction, LoadBalancerRegistry registry) {\n+    List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+        JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n+    if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+      throw new RuntimeException(\"childPolicy not specified\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b108802da64692ebe74bbae64a8e04c1cd5ef10"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxMDk3Ng==", "bodyText": "2020?", "url": "https://github.com/grpc/grpc-java/pull/7055#discussion_r432610976", "createdAt": "2020-05-29T16:50:57Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/XdsNameResolverIntegrationTest.java", "diffHunk": "@@ -0,0 +1,626 @@\n+/*\n+ * Copyright 2019 The gRPC Authors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b108802da64692ebe74bbae64a8e04c1cd5ef10"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMDU2OA==", "bodyText": "This wrapping and unwrapping create unnecessary stacktrace of exception. Some other places like\n} catch (RuntimeException e) {\n  throw new RuntimeException(\"Failed to parse Route: \" + e);\n}\nhave the same problem\nI feel the trick returning StructOrErrorStatus<PolicySelection> might be better.", "url": "https://github.com/grpc/grpc-java/pull/7055#discussion_r432620568", "createdAt": "2020-05-29T17:06:01Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -97,77 +101,167 @@ public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n               \"No config for action \" + name + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n-            JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n-        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n-          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No child policy for action \" + name + \" in xds_routing LB policy: \"\n-                  + rawConfig));\n-        }\n-\n-        LoadBalancerRegistry lbRegistry =\n-            this.lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : this.lbRegistry;\n-        ConfigOrError selectedConfigOrError =\n-            ServiceConfigUtil.selectLbPolicyFromList(childConfigCandidates, lbRegistry);\n-        if (selectedConfigOrError.getError() != null) {\n-          return selectedConfigOrError;\n-        }\n-\n-        parsedActions.put(name, (PolicySelection) selectedConfigOrError.getConfig());\n+        PolicySelection parsedAction =\n+            parseAction(\n+                rawAction,\n+                this.lbRegistry == null\n+                    ? LoadBalancerRegistry.getDefaultRegistry() : this.lbRegistry);\n+        parsedActions.put(name, parsedAction);\n       }\n \n-      List<Map<String, ?>> routes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n-      if (routes == null || routes.isEmpty()) {\n+      List<Route> parsedRoutes = new ArrayList<>();\n+      List<Map<String, ?>> rawRoutes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n+      if (rawRoutes == null || rawRoutes.isEmpty()) {\n         return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n             \"No routes provided for xds_routing LB policy: \" + rawConfig));\n       }\n-      List<Route> parsedRoutes = new ArrayList<>();\n-      Set<MethodName> methodNames = new HashSet<>();\n-      for (int i = 0; i < routes.size(); i++) {\n-        Map<String, ?> route = routes.get(i);\n-        String actionName = JsonUtil.getString(route, \"action\");\n-        if (actionName == null) {\n-          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No action name provided for one of the routes in xds_routing LB policy: \"\n-                  + rawConfig));\n-        }\n-        if (!parsedActions.containsKey(actionName)) {\n+      for (Map<String, ?> rawRoute: rawRoutes) {\n+        Route route = parseRoute(rawRoute);\n+        if (!parsedActions.containsKey(route.getActionName())) {\n           return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n               \"No action defined for route \" + route + \" in xds_routing LB policy: \" + rawConfig));\n         }\n-        Map<String, ?> methodName = JsonUtil.getObject(route, \"methodName\");\n-        if (methodName == null) {\n-          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No method_name provided for one of the routes in xds_routing LB policy: \"\n-                  + rawConfig));\n-        }\n-        String service = JsonUtil.getString(methodName, \"service\");\n-        String method = JsonUtil.getString(methodName, \"method\");\n-        if (service == null || method == null) {\n-          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n-              \"No service or method provided for one of the routes in xds_routing LB policy: \"\n-                  + rawConfig));\n+        parsedRoutes.add(route);\n+      }\n+      return ConfigOrError.fromConfig(new XdsRoutingConfig(parsedRoutes, parsedActions));\n+    } catch (RuntimeException e) {\n+      return ConfigOrError.fromError(\n+          Status.fromThrowable(e).withDescription(\n+              \"Failed to parse xds_routing LB config: \" + rawConfig));\n+    }\n+  }\n+\n+  private static PolicySelection parseAction(\n+      Map<String, ?> rawAction, LoadBalancerRegistry registry) {\n+    List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+        JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n+    if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+      throw new RuntimeException(\"childPolicy not specified\");\n+    }\n+    ConfigOrError selectedConfigOrError =\n+        ServiceConfigUtil.selectLbPolicyFromList(childConfigCandidates, registry);\n+    if (selectedConfigOrError.getError() != null) {\n+      throw selectedConfigOrError.getError().asRuntimeException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b108802da64692ebe74bbae64a8e04c1cd5ef10"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxMTc5MDYy", "url": "https://github.com/grpc/grpc-java/pull/7055#pullrequestreview-421179062", "createdAt": "2020-05-29T18:12:26Z", "commit": {"oid": "5b108802da64692ebe74bbae64a8e04c1cd5ef10"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxODoxMjoyNlrOGcnK6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxODoxMjoyNlrOGcnK6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY1NTA4MA==", "bodyText": "This is wrong. It should be import com.google.re2j.PatternSyntaxException;", "url": "https://github.com/grpc/grpc-java/pull/7055#discussion_r432655080", "createdAt": "2020-05-29T18:12:26Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -31,13 +33,15 @@\n import io.grpc.internal.ServiceConfigUtil;\n import io.grpc.internal.ServiceConfigUtil.LbConfig;\n import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.RouteMatchers.FractionMatcher;\n+import io.grpc.xds.RouteMatchers.HeaderMatcher;\n+import io.grpc.xds.RouteMatchers.PathMatcher;\n import java.util.ArrayList;\n-import java.util.HashSet;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n-import java.util.Set;\n+import java.util.regex.PatternSyntaxException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b108802da64692ebe74bbae64a8e04c1cd5ef10"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df9957368b2ac46e957a825f008e2c7046ea8d53", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/df9957368b2ac46e957a825f008e2c7046ea8d53", "committedDate": "2020-06-01T21:31:44Z", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/xds_routing_policy_config_generation_and_parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "665bb77900c96bcd6cd0cc015bdbb8d4a9e44880", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/665bb77900c96bcd6cd0cc015bdbb8d4a9e44880", "committedDate": "2020-06-01T21:34:15Z", "message": "Fix using the wrong regex exception type."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86a66e14756ed22167b052b24d428288070553cb", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/86a66e14756ed22167b052b24d428288070553cb", "committedDate": "2020-06-01T21:34:49Z", "message": "Empty line at the end of file."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c820a6b8e8dbb56ec846b1cbef97d1759fceb0d5", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/c820a6b8e8dbb56ec846b1cbef97d1759fceb0d5", "committedDate": "2020-06-01T21:35:54Z", "message": "Remove implemented TODO"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c5425460163e513ee2a9df53e466961df0f30b7", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/4c5425460163e513ee2a9df53e466961df0f30b7", "committedDate": "2020-06-01T21:36:35Z", "message": "Fix year in preface."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ec36cfd87400c46933df39bedc49f4ee6a30496", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/9ec36cfd87400c46933df39bedc49f4ee6a30496", "committedDate": "2020-06-01T22:52:30Z", "message": "Suppress unchecked warning."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fff55261c72e276015da17cfb070ad5638c64f43", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/fff55261c72e276015da17cfb070ad5638c64f43", "committedDate": "2020-06-01T23:03:48Z", "message": "Use an unified definition of RouteMatch for both parsed Envoy proto and in xds_routing LB config."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c2028fa420008e9fd7a71275225bed28b155200", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/1c2028fa420008e9fd7a71275225bed28b155200", "committedDate": "2020-06-01T23:11:04Z", "message": "Add head comment for RouteMatch."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8348b5b1b1ccb0b3267f4a79129378b4694aef40", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/8348b5b1b1ccb0b3267f4a79129378b4694aef40", "committedDate": "2020-06-01T23:37:23Z", "message": "Improve error message propagation."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMTQ3MDYx", "url": "https://github.com/grpc/grpc-java/pull/7055#pullrequestreview-423147061", "createdAt": "2020-06-03T00:43:00Z", "commit": {"oid": "8348b5b1b1ccb0b3267f4a79129378b4694aef40"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4439, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}