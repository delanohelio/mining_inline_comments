{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MzA4NDM1", "number": 7533, "title": "xds: implement XdsClient thread-safety and synchronization for gRPC client (including refactoring XdsClient to client and server usages separately)", "bodyText": "Based on the design of go/separate-client-server-xds-client and #7491, with thread-safe implementation of XdsClient APIs that can be called from different channels. Similar to C-core's implementation grpc/grpc#24200.\nRelated changes for LoadReportClient: #7528.", "createdAt": "2020-10-19T22:08:40Z", "url": "https://github.com/grpc/grpc-java/pull/7533", "merged": true, "mergeCommit": {"oid": "40191b2f812e9173d6a967c360325ec90e62d1a0"}, "closed": true, "closedAt": "2020-10-23T20:38:24Z", "author": {"login": "voidzcy"}, "timelineItems": {"totalCount": 52, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQGAm1gH2gAyNTA2MzA4NDM1OjA5ZmJkOWQwMGM1YTQ0YjViNThiNWY2NjQwZDUzYzk2YThkMTAzYzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdVcpk8AFqTUxNTk5MjkyOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "09fbd9d00c5a44b5b58b5f6640d53c96a8d103c2", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/09fbd9d00c5a44b5b58b5f6640d53c96a8d103c2", "committedDate": "2020-10-07T05:20:07Z", "message": "Define the medium layer XdsClient implementation used for both client and server side."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2e454da80f554fe32be31d964b8dc5a126d1a8a", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/c2e454da80f554fe32be31d964b8dc5a126d1a8a", "committedDate": "2020-10-07T05:20:29Z", "message": "Implement client side XdsClient logic."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9df386b33fac1931b14bf114f0423570dda1db37", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/9df386b33fac1931b14bf114f0423570dda1db37", "committedDate": "2020-10-07T09:54:47Z", "message": "Move server side logic into the XdsClient implementation for server side."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a0990bd5ece2186668ff5aeff29c4b0cf5cfe70", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/1a0990bd5ece2186668ff5aeff29c4b0cf5cfe70", "committedDate": "2020-10-13T08:23:45Z", "message": "Merge branch 'master' of github.com:grpc/grpc-java into refactor/separate_client_and_server_xds_client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdbef140506a7bec8e37271d5564b8b03bec07c8", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/bdbef140506a7bec8e37271d5564b8b03bec07c8", "committedDate": "2020-10-13T08:35:22Z", "message": "Make node visible for creating LoadReportClient."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3db6361d6793c3aaf85609e45cfda081856c9956", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/3db6361d6793c3aaf85609e45cfda081856c9956", "committedDate": "2020-10-13T23:31:16Z", "message": "Sync with latest change in master."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3e47c987ad08f26e56d5b77fdf87fbf51366946", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/a3e47c987ad08f26e56d5b77fdf87fbf51366946", "committedDate": "2020-10-14T00:05:01Z", "message": "Fix bug in sending ACK/NACK when racing with all watchers of that resource type being removed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b326c517da37df57cfcf06589dc809ba94bf447d", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/b326c517da37df57cfcf06589dc809ba94bf447d", "committedDate": "2020-10-14T00:05:47Z", "message": "Port XdsClientImplTest2 to ClientXdsClientTest."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2699bf118749d93b623f2a067f28a9c9db1e6ad4", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/2699bf118749d93b623f2a067f28a9c9db1e6ad4", "committedDate": "2020-10-14T00:06:19Z", "message": "Port XdsClientImplTestForListener to ServerXdsClientTest."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "359e867cd47064c0c7fdb780d16dbbf5f0e11bdd", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/359e867cd47064c0c7fdb780d16dbbf5f0e11bdd", "committedDate": "2020-10-14T00:06:40Z", "message": "Move message printer tests into AbstractXdsClientTest."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4220e972fd7a597e08083e22ad21cc727a4777fa", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/4220e972fd7a597e08083e22ad21cc727a4777fa", "committedDate": "2020-10-14T00:51:11Z", "message": "Only use a single backoffpolicy provider field."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d8fd8165e08a90fba59b64a56f88de4fefb109e", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/8d8fd8165e08a90fba59b64a56f88de4fefb109e", "committedDate": "2020-10-14T21:00:50Z", "message": "Add Javadoc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c93ee5a55f3d4260b25c6be916325c4c624f22bd", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/c93ee5a55f3d4260b25c6be916325c4c624f22bd", "committedDate": "2020-10-14T21:03:44Z", "message": "Move the initial resource subscription timeout definition to the concrete XdsClient implementations, as it does not belong to the ADS stream logic."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "594c82d7b638f7236e4db7b1641387812f03d8a7", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/594c82d7b638f7236e4db7b1641387812f03d8a7", "committedDate": "2020-10-14T21:17:27Z", "message": "Hide ADS retry timer in child classes by only exposing a getter."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06a25c8ade75ca69ab3d2d6611ce795563109c2e", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/06a25c8ade75ca69ab3d2d6611ce795563109c2e", "committedDate": "2020-10-14T21:21:14Z", "message": "Rephrase Javadoc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfb24a7cb5ebee609c153c5201b26189cf959994", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/dfb24a7cb5ebee609c153c5201b26189cf959994", "committedDate": "2020-10-14T21:27:10Z", "message": "Document limitations for making Node mutable and visible to child classes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e0e069b6efab3bd42772a078b40522a5e452e55", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/9e0e069b6efab3bd42772a078b40522a5e452e55", "committedDate": "2020-10-14T21:38:37Z", "message": "Create a single LoadReportClient but not start in the constructor of XdsClient, this avoids making channel and backoffpolicy provider visible to child classes, which is a better encapsulation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e15542597d39618c59c85c36a06e84548a76ca38", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/e15542597d39618c59c85c36a06e84548a76ca38", "committedDate": "2020-10-15T01:10:58Z", "message": "Stop load reporting when shutting down the XdsClient."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67e0e290fdad6f755b17b599392307cd48340139", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/67e0e290fdad6f755b17b599392307cd48340139", "committedDate": "2020-10-16T01:20:21Z", "message": "Merge branch 'master' of github.com:grpc/grpc-java into refactor/separate_client_and_server_xds_client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd01779fe45a5d457c39c580b42ada1f0c5886ef", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/bd01779fe45a5d457c39c580b42ada1f0c5886ef", "committedDate": "2020-10-16T01:22:34Z", "message": "Sync changes for load reporting related APIs."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "018c3fa610edeb5775ba6fd94718c8979b04af9f", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/018c3fa610edeb5775ba6fd94718c8979b04af9f", "committedDate": "2020-10-19T20:52:39Z", "message": "Abstract out synchronization to decouple its concrete implementation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acde16278fbb719c0ea14cd67a9144a714312b1c", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/acde16278fbb719c0ea14cd67a9144a714312b1c", "committedDate": "2020-10-19T20:53:22Z", "message": "Replace SynchronizationContext with a lock for client side XdsClient."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23222b9a38c30af313ddbffc1bfd5d87e59b4aa6", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/23222b9a38c30af313ddbffc1bfd5d87e59b4aa6", "committedDate": "2020-10-19T20:54:08Z", "message": "Provides server side synchronization implementation to abstract XdsClient"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91b2c102da142a021a670c5c360e42813a3e97b6", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/91b2c102da142a021a670c5c360e42813a3e97b6", "committedDate": "2020-10-19T20:56:57Z", "message": "Expose ScheduledExecutorService via a getter."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8c4651fe651a7272e8bcbe4e47b6094c6aaf81b", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/e8c4651fe651a7272e8bcbe4e47b6094c6aaf81b", "committedDate": "2020-10-19T21:25:51Z", "message": "Access logger via getter."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efcea175c3740024212c8c4a21b7afe4f959e0aa", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/efcea175c3740024212c8c4a21b7afe4f959e0aa", "committedDate": "2020-10-19T21:27:53Z", "message": "Add final to methods not intended to be overriden"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86af29df1dcb2c01e2d99b013e41e7cb665cf75e", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/86af29df1dcb2c01e2d99b013e41e7cb665cf75e", "committedDate": "2020-10-19T22:07:33Z", "message": "Improve comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbbce92b74ebbd65e8de29206d0f460f985a62b3", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/bbbce92b74ebbd65e8de29206d0f460f985a62b3", "committedDate": "2020-10-19T22:16:53Z", "message": "Add TODO for invoking watcher callbacks on its own executor."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMDAzNzY2", "url": "https://github.com/grpc/grpc-java/pull/7533#pullrequestreview-513003766", "createdAt": "2020-10-20T18:10:17Z", "commit": {"oid": "86af29df1dcb2c01e2d99b013e41e7cb665cf75e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODoxMDoxOFrOHlKyrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODoxMDoxOFrOHlKyrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODczNjE3NQ==", "bodyText": "This does not seem to be used anywhere. Does it mean there will be another PR for the server side to actually start using ServerXdsClient from the current XdsClientImpl2?", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508736175", "createdAt": "2020-10-20T18:10:18Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86af29df1dcb2c01e2d99b013e41e7cb665cf75e"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9060990ca6cbcd95c5ba409bb415a9a4f1e063ba", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/9060990ca6cbcd95c5ba409bb415a9a4f1e063ba", "committedDate": "2020-10-20T18:45:49Z", "message": "Change ServerXdsClient back to take in a stopwatch supplier"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMDM0ODcz", "url": "https://github.com/grpc/grpc-java/pull/7533#pullrequestreview-513034873", "createdAt": "2020-10-20T18:47:52Z", "commit": {"oid": "86af29df1dcb2c01e2d99b013e41e7cb665cf75e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo0Nzo1MlrOHlMWwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo0Nzo1MlrOHlMWwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MTc5NA==", "bodyText": "Few comments about this sequence of actions:\n\nif adjustResourceSubscription decided to not issue a request because it's in backoffMode do you still need to set the timer?\nwhy updateNodeMetadataForListenerRequest if you are in backoffMode and not going to issue the request?\ncan the INFO log statement be issued only if a request is issued (and the timer set)?\nif the ServerXdsClient is going to be shared among multiple server instances then updating the common node instance is going to be problematic. Hopefully with the new server side API, modifying Node will not be needed. So we can ignore this problem for now\n\nI understand some of the above was existing code but I understand one of the goals is to fix whatever issues we can fix.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508761794", "createdAt": "2020-10-20T18:47:52Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatch);\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    ldsRespTimer =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86af29df1dcb2c01e2d99b013e41e7cb665cf75e"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMDQxMjg0", "url": "https://github.com/grpc/grpc-java/pull/7533#pullrequestreview-513041284", "createdAt": "2020-10-20T18:56:32Z", "commit": {"oid": "9060990ca6cbcd95c5ba409bb415a9a4f1e063ba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo1NjozMlrOHlMqCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo1NjozMlrOHlMqCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2NjczMQ==", "bodyText": "This can be made abstract instead of returning null as I don't see any advantage of providing a default implementation.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508766731", "createdAt": "2020-10-20T18:56:32Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,762 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  Collection<String> getSubscribedResources(ResourceType type) {\n+    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9060990ca6cbcd95c5ba409bb415a9a4f1e063ba"}, "originalPosition": 208}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMDQzMjU5", "url": "https://github.com/grpc/grpc-java/pull/7533#pullrequestreview-513043259", "createdAt": "2020-10-20T18:59:16Z", "commit": {"oid": "1cf04ed350f130b99e1f96bd9ae02a91ee68ec07"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo1OToxNlrOHlMwQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo1OToxNlrOHlMwQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2ODMyMw==", "bodyText": "Should it be if (!isInBackoff()) ?", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508768323", "createdAt": "2020-10-20T18:59:16Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    if (isInBackoff()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf04ed350f130b99e1f96bd9ae02a91ee68ec07"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMDQ1NDE5", "url": "https://github.com/grpc/grpc-java/pull/7533#pullrequestreview-513045419", "createdAt": "2020-10-20T19:02:07Z", "commit": {"oid": "1cf04ed350f130b99e1f96bd9ae02a91ee68ec07"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTowMjowN1rOHlM3BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTowMjowN1rOHlM3BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MDA1Mg==", "bodyText": "ServerXdsClient will also start using resources so I was thinking this can be moved up into AbstractXdsClient but we can hold off on it.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508770052", "createdAt": "2020-10-20T19:02:07Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/ClientXdsClient.java", "diffHunk": "@@ -0,0 +1,840 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.grpc.xds.EnvoyProtoData.TRANSPORT_SOCKET_NAME_TLS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.util.Durations;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy;\n+import io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.endpoint.v3.LbEndpoint;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.config.route.v3.VirtualHost;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds;\n+import io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.EnvoyProtoData.StructOrError;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.lang.Thread.UncaughtExceptionHandler;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for client side usages.\n+ */\n+final class ClientXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER_V2 =\n+      \"type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2\"\n+          + \".HttpConnectionManager\";\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER =\n+      \"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3\"\n+          + \".HttpConnectionManager\";\n+\n+  private final Object lock = new Object();\n+  private final Map<String, ResourceSubscriber> ldsResourceSubscribers = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1cf04ed350f130b99e1f96bd9ae02a91ee68ec07"}, "originalPosition": 81}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4dc892566d38eaca04596dd211ef1c1fb76f98e", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/a4dc892566d38eaca04596dd211ef1c1fb76f98e", "committedDate": "2020-10-20T19:06:37Z", "message": "Should check if currently in backoff before scheduling the initial resource fetch timer for the server side."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1cf04ed350f130b99e1f96bd9ae02a91ee68ec07", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/1cf04ed350f130b99e1f96bd9ae02a91ee68ec07", "committedDate": "2020-10-20T18:55:27Z", "message": "Should check if currently in backoff before scheduling the initial resource fetch timer for the server side."}, "afterCommit": {"oid": "a4dc892566d38eaca04596dd211ef1c1fb76f98e", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/a4dc892566d38eaca04596dd211ef1c1fb76f98e", "committedDate": "2020-10-20T19:06:37Z", "message": "Should check if currently in backoff before scheduling the initial resource fetch timer for the server side."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc", "committedDate": "2020-10-20T19:11:00Z", "message": "Make getSubscribedResources abstract."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTAzMzA5", "url": "https://github.com/grpc/grpc-java/pull/7533#pullrequestreview-513103309", "createdAt": "2020-10-20T20:23:30Z", "commit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyMzozMFrOHlPlYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyMzozMFrOHlPlYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNDY5MQ==", "bodyText": "Behavior of getSubscribedResources as I have understood is:\n\nthe one in ServerXdsClient returns null if no watcher set else emptyList\nthe one in ClientXdsClient returns null instead of emptyList\nover here if it is null you change it back to emptyList\n\nWhy can't we then have getSubscribedResources return emptyList instead of null? So null should never be returned unless I am missing something", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508814691", "createdAt": "2020-10-20T20:23:30Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 252}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTY0NDQ1", "url": "https://github.com/grpc/grpc-java/pull/7533#pullrequestreview-513164445", "createdAt": "2020-10-20T21:55:34Z", "commit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo1NTozNFrOHlSmvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTo1NTozNFrOHlSmvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2NDE4OA==", "bodyText": "Can you just call handleStreamRestarted() to eliminate code duplication? because you are using constants etc it will be helpful in eliminating trivial errors.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508864188", "createdAt": "2020-10-20T21:55:34Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    if (!isInBackoff()) {\n+      ldsRespTimer =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTY4MjUx", "url": "https://github.com/grpc/grpc-java/pull/7533#pullrequestreview-513168251", "createdAt": "2020-10-20T22:02:27Z", "commit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMjowMjoyN1rOHlSy0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMjowMjoyN1rOHlSy0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2NzI4MA==", "bodyText": "ClientXdsClient has cleanUpResourceTimers. We can combine the 2 into 1 abstract method cleanUpResourceTimers in AbstractXdsClient which might also simplify the code at call sites.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508867280", "createdAt": "2020-10-20T22:02:27Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    if (!isInBackoff()) {\n+      ldsRespTimer =\n+          syncContext\n+              .schedule(\n+                  new ListenerResourceFetchTimeoutTask(\":\" + port),\n+                  INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS, getTimeService());\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  Collection<String> getSubscribedResources(ResourceType type) {\n+    if (listenerWatcher == null) {\n+      return null;\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  /** In case of Listener watcher metadata to be updated to include port. */\n+  private void updateNodeMetadataForListenerRequest(int port) {\n+    Map<String, Object> newMetadata = new HashMap<>();\n+    if (node.getMetadata() != null) {\n+      newMetadata.putAll(node.getMetadata());\n+    }\n+    newMetadata.put(\"TRAFFICDIRECTOR_PROXYLESS\", \"1\");\n+    // TODO(sanjaypujare): eliminate usage of listening_addresses.\n+    EnvoyProtoData.Address listeningAddress =\n+        new EnvoyProtoData.Address(\"0.0.0.0\", port);\n+    node =\n+        node.toBuilder().setMetadata(newMetadata).addListeningAddresses(listeningAddress).build();\n+  }\n+\n+  @Override\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+    // Unpack Listener messages.\n+    Listener requestedListener = null;\n+    getLogger().log(XdsLogLevel.DEBUG, \"Listener count: {0}\", resources.size());\n+    try {\n+      for (com.google.protobuf.Any res : resources) {\n+        if (res.getTypeUrl().equals(ResourceType.LDS.typeUrlV2())) {\n+          res = res.toBuilder().setTypeUrl(ResourceType.LDS.typeUrl()).build();\n+        }\n+        Listener listener = res.unpack(Listener.class);\n+        getLogger().log(XdsLogLevel.DEBUG, \"Found listener {0}\", listener.toString());\n+        if (isRequestedListener(listener)) {\n+          requestedListener = listener;\n+          getLogger().log(XdsLogLevel.DEBUG, \"Requested listener found: {0}\", listener.getName());\n+        }\n+      }\n+    } catch (InvalidProtocolBufferException e) {\n+      getLogger().log(XdsLogLevel.WARNING, \"Failed to unpack Listeners in LDS response {0}\", e);\n+      nackResponse(ResourceType.LDS, nonce, \"Malformed LDS response: \" + e);\n+      return;\n+    }\n+    ListenerUpdate listenerUpdate = null;\n+    if (requestedListener != null) {\n+      if (ldsRespTimer != null) {\n+        ldsRespTimer.cancel();\n+        ldsRespTimer = null;\n+      }\n+      try {\n+        listenerUpdate = ListenerUpdate.newBuilder()\n+            .setListener(EnvoyServerProtoData.Listener.fromEnvoyProtoListener(requestedListener))\n+            .build();\n+      } catch (InvalidProtocolBufferException e) {\n+        getLogger().log(XdsLogLevel.WARNING, \"Failed to unpack Listener in LDS response {0}\", e);\n+        nackResponse(ResourceType.LDS, nonce, \"Malformed LDS response: \" + e);\n+        return;\n+      }\n+    } else {\n+      if (ldsRespTimer == null) {\n+        listenerWatcher.onResourceDoesNotExist(\":\" + listenerPort);\n+      }\n+    }\n+    ackResponse(ResourceType.LDS, versionInfo, nonce);\n+    if (listenerUpdate != null) {\n+      listenerWatcher.onListenerChanged(listenerUpdate);\n+    }\n+  }\n+\n+  private boolean isRequestedListener(Listener listener) {\n+    // TODO(sanjaypujare): check listener.getName() once we know what xDS server returns\n+    return isAddressMatching(listener.getAddress())\n+        && hasMatchingFilter(listener.getFilterChainsList());\n+  }\n+\n+  private boolean isAddressMatching(Address address) {\n+    // TODO(sanjaypujare): check IP address once we know xDS server will include it\n+    return address.hasSocketAddress()\n+        && (address.getSocketAddress().getPortValue() == listenerPort);\n+  }\n+\n+  private boolean hasMatchingFilter(List<FilterChain> filterChainsList) {\n+    // TODO(sanjaypujare): if myIp to be checked against filterChainMatch.getPrefixRangesList()\n+    for (FilterChain filterChain : filterChainsList) {\n+      FilterChainMatch filterChainMatch = filterChain.getFilterChainMatch();\n+\n+      if (listenerPort == filterChainMatch.getDestinationPort().getValue()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  protected void handleStreamClosed(Status error) {\n+    cleanUpResourceTimer();\n+    if (listenerWatcher != null) {\n+      listenerWatcher.onError(error);\n+    }\n+  }\n+\n+  @Override\n+  protected void handleStreamRestarted() {\n+    if (listenerWatcher != null) {\n+      ldsRespTimer =\n+          syncContext\n+              .schedule(\n+                  new ListenerResourceFetchTimeoutTask(\":\" + listenerPort),\n+                  INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS, getTimeService());\n+    }\n+  }\n+\n+  @Override\n+  protected void handleShutdown() {\n+    cleanUpResourceTimer();\n+  }\n+\n+  @Override\n+  protected void runWithSynchronized(Runnable runnable) {\n+    syncContext.execute(runnable);\n+  }\n+\n+  private void cleanUpResourceTimer() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 215}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTg1OTI3", "url": "https://github.com/grpc/grpc-java/pull/7533#pullrequestreview-513185927", "createdAt": "2020-10-20T22:38:51Z", "commit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMjozODo1MVrOHlTqlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMjozODo1MVrOHlTqlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg4MTU1Nw==", "bodyText": "This has only MessagePrinter tests and MessagePrinter is only used in log messages and not for any functionality. So these tests don't test any functionality, is that correct?", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r508881557", "createdAt": "2020-10-20T22:38:51Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/test/java/io/grpc/xds/AbstractXdsClientTest.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsClientTestHelper.buildCluster;\n+import static io.grpc.xds.XdsClientTestHelper.buildClusterLoadAssignment;\n+import static io.grpc.xds.XdsClientTestHelper.buildDiscoveryResponse;\n+import static io.grpc.xds.XdsClientTestHelper.buildDropOverload;\n+import static io.grpc.xds.XdsClientTestHelper.buildLbEndpoint;\n+import static io.grpc.xds.XdsClientTestHelper.buildListener;\n+import static io.grpc.xds.XdsClientTestHelper.buildLocalityLbEndpoints;\n+import static io.grpc.xds.XdsClientTestHelper.buildRouteConfiguration;\n+import static io.grpc.xds.XdsClientTestHelper.buildVirtualHost;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Any;\n+import io.envoyproxy.envoy.config.core.v3.HealthStatus;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.xds.AbstractXdsClient.MessagePrinter;\n+import io.grpc.xds.AbstractXdsClient.ResourceType;\n+import java.util.List;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/**\n+ * Tests for {@link AbstractXdsClient}.\n+ */\n+@RunWith(JUnit4.class)\n+public class AbstractXdsClientTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MjUyMTk0", "url": "https://github.com/grpc/grpc-java/pull/7533#pullrequestreview-514252194", "createdAt": "2020-10-21T23:09:25Z", "commit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzowOToyNlrOHmK40g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzowOToyNlrOHmK40g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4NjMyMg==", "bodyText": "You can delete now, otherwise it will fail to build.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r509786322", "createdAt": "2020-10-21T23:09:26Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/ClientXdsClient.java", "diffHunk": "@@ -0,0 +1,840 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.grpc.xds.EnvoyProtoData.TRANSPORT_SOCKET_NAME_TLS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.util.Durations;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.DiscoveryType;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.EdsClusterConfig;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster.LbPolicy;\n+import io.envoyproxy.envoy.config.core.v3.HttpProtocolOptions;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.endpoint.v3.LbEndpoint;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.config.route.v3.VirtualHost;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.Rds;\n+import io.envoyproxy.envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.EnvoyProtoData.StructOrError;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.lang.Thread.UncaughtExceptionHandler;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for client side usages.\n+ */\n+final class ClientXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER_V2 =\n+      \"type.googleapis.com/envoy.config.filter.network.http_connection_manager.v2\"\n+          + \".HttpConnectionManager\";\n+  private static final String TYPE_URL_HTTP_CONNECTION_MANAGER =\n+      \"type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3\"\n+          + \".HttpConnectionManager\";\n+\n+  private final Object lock = new Object();\n+  private final Map<String, ResourceSubscriber> ldsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> rdsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> cdsResourceSubscribers = new HashMap<>();\n+  private final Map<String, ResourceSubscriber> edsResourceSubscribers = new HashMap<>();\n+  private final LoadStatsManager loadStatsManager = new LoadStatsManager();\n+  private final LoadReportClient lrsClient;\n+  private boolean reportingLoad;\n+\n+  ClientXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    // TODO(chengyuanzhang): delete me after https://github.com/grpc/grpc-java/pull/7528.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 96}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c645486074e2b2d9432a35743bd2df6ab4be988f", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/c645486074e2b2d9432a35743bd2df6ab4be988f", "committedDate": "2020-10-22T00:06:24Z", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/separate_client_server_xds_client_synchronization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/0d453142a0601e36efe151ab6caf0f9a358a7b18", "committedDate": "2020-10-22T00:11:43Z", "message": "Sync with updated LoadReportClient that not taking in SynchronizationContext."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MjU0NzY0", "url": "https://github.com/grpc/grpc-java/pull/7533#pullrequestreview-514254764", "createdAt": "2020-10-21T23:16:04Z", "commit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMzoxNjowNFrOHmLBVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQyMTozODoyNVrOHm00PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4ODUwMw==", "bodyText": "Pass in Supplier<Stopwatch> as discussed before.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r509788503", "createdAt": "2020-10-21T23:16:04Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c0d16f9eac0fff7d2eb671813f0ce69f13c68dc"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0NjIxMQ==", "bodyText": "s/a/an/", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510446211", "createdAt": "2020-10-22T20:46:09Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0NzAzMw==", "bodyText": "If type is not LDS should also return null?", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510447033", "createdAt": "2020-10-22T20:47:43Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/ServerXdsClient.java", "diffHunk": "@@ -0,0 +1,240 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.common.base.Supplier;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import io.envoyproxy.envoy.config.core.v3.Address;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChain;\n+import io.envoyproxy.envoy.config.listener.v3.FilterChainMatch;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * XdsClient implementation for server side usages.\n+ */\n+final class ServerXdsClient extends AbstractXdsClient {\n+\n+  // Longest time to wait, since the subscription to some resource, for concluding its absence.\n+  @VisibleForTesting\n+  static final int INITIAL_RESOURCE_FETCH_TIMEOUT_SEC = 15;\n+  private final SynchronizationContext syncContext;\n+  @Nullable\n+  private ListenerWatcher listenerWatcher;\n+  private int listenerPort = -1;\n+  @Nullable\n+  private ScheduledHandle ldsRespTimer;\n+\n+  ServerXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      SynchronizationContext syncContext,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Supplier<Stopwatch> stopwatchSupplier) {\n+    super(channel, node, timeService, backoffPolicyProvider, stopwatchSupplier.get());\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+  }\n+\n+  @Override\n+  void watchListenerData(int port, ListenerWatcher watcher) {\n+    checkState(listenerWatcher == null, \"ListenerWatcher already registered\");\n+    listenerWatcher = checkNotNull(watcher, \"watcher\");\n+    checkArgument(port > 0, \"port needs to be > 0\");\n+    this.listenerPort = port;\n+    getLogger().log(XdsLogLevel.INFO, \"Started watching listener for port {0}\", port);\n+    updateNodeMetadataForListenerRequest(port);\n+    adjustResourceSubscription(ResourceType.LDS);\n+    if (!isInBackoff()) {\n+      ldsRespTimer =\n+          syncContext\n+              .schedule(\n+                  new ListenerResourceFetchTimeoutTask(\":\" + port),\n+                  INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS, getTimeService());\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  Collection<String> getSubscribedResources(ResourceType type) {\n+    if (listenerWatcher == null) {\n+      return null;\n+    }\n+    return Collections.emptyList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1NzExNQ==", "bodyText": "Add an INFO level log for sending discovery type request for resources? Just as the INFO levels log in NACK and ACK.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510457115", "createdAt": "2020-10-22T21:06:13Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, null);\n+  }\n+\n+  /**\n+   * Rejects the update for the given resource type and sends an NACK request (request with last\n+   * accepted version) to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void nackResponse(ResourceType type, String nonce, String errorDetail) {\n+    String versionInfo = getCurrentVersion(type);\n+    logger.log(XdsLogLevel.INFO, \"Sending NACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, errorDetail);\n+  }\n+\n+  protected final ScheduledExecutorService getTimeService() {\n+    return timeService;\n+  }\n+\n+  protected final XdsLogger getLogger() {\n+    return logger;\n+  }\n+\n+  /**\n+   * Returns {@code true} if the resource discovery is currently in backoff.\n+   */\n+  // Must be synchronized.\n+  protected final boolean isInBackoff() {\n+    return rpcRetryTimer != null && !rpcRetryTimer.isDone();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  // Must be synchronized.\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    stopwatch.reset().start();\n+  }\n+\n+  /**\n+   * Returns the latest accepted version of the given resource type.\n+   */\n+  // Must be synchronized.\n+  private String getCurrentVersion(ResourceType type) {\n+    String version;\n+    switch (type) {\n+      case LDS:\n+        version = ldsVersion;\n+        break;\n+      case RDS:\n+        version = rdsVersion;\n+        break;\n+      case CDS:\n+        version = cdsVersion;\n+        break;\n+      case EDS:\n+        version = edsVersion;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    return version;\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      runWithSynchronized(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (shutdown) {\n+            return;\n+          }\n+          startRpcStream();\n+          for (ResourceType type : ResourceType.values()) {\n+            if (type == ResourceType.UNKNOWN) {\n+              continue;\n+            }\n+            Collection<String> resources = getSubscribedResources(type);\n+            if (resources != null) {\n+              adsStream.sendDiscoveryRequest(type, resources);\n+            }\n+          }\n+          handleStreamRestarted();\n+        }\n+      });\n+    }\n+  }\n+\n+  protected enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  private abstract class AbstractAdsStream {\n+    private boolean responseReceived;\n+    private boolean closed;\n+\n+    // Response nonce for the most recently received discovery responses of each resource type.\n+    // Client initiated requests start response nonce with empty string.\n+    // A nonce is used to indicate the specific DiscoveryResponse each DiscoveryRequest\n+    // corresponds to.\n+    // A nonce becomes stale following a newer nonce being presented to the client in a\n+    // DiscoveryResponse.\n+    private String ldsRespNonce = \"\";\n+    private String rdsRespNonce = \"\";\n+    private String cdsRespNonce = \"\";\n+    private String edsRespNonce = \"\";\n+\n+    abstract void start();\n+\n+    abstract void sendError(Exception error);\n+\n+    /**\n+     * Sends a discovery request with the given {@code versionInfo}, {@code nonce} and\n+     * {@code errorDetail}. Used for reacting to a specific discovery response. For\n+     * client-initiated discovery requests, use {@link\n+     * #sendDiscoveryRequest(ResourceType, Collection)}.\n+     */\n+    abstract void sendDiscoveryRequest(ResourceType type, String versionInfo,\n+        Collection<String> resources, String nonce, @Nullable String errorDetail);\n+\n+    /**\n+     * Sends a client-initiated discovery request.\n+     */\n+    final void sendDiscoveryRequest(ResourceType type, Collection<String> resources) {\n+      String nonce;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 450}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1OTE3Nw==", "bodyText": "Provide the type name?", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510459177", "createdAt": "2020-10-22T21:10:10Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, null);\n+  }\n+\n+  /**\n+   * Rejects the update for the given resource type and sends an NACK request (request with last\n+   * accepted version) to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void nackResponse(ResourceType type, String nonce, String errorDetail) {\n+    String versionInfo = getCurrentVersion(type);\n+    logger.log(XdsLogLevel.INFO, \"Sending NACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, errorDetail);\n+  }\n+\n+  protected final ScheduledExecutorService getTimeService() {\n+    return timeService;\n+  }\n+\n+  protected final XdsLogger getLogger() {\n+    return logger;\n+  }\n+\n+  /**\n+   * Returns {@code true} if the resource discovery is currently in backoff.\n+   */\n+  // Must be synchronized.\n+  protected final boolean isInBackoff() {\n+    return rpcRetryTimer != null && !rpcRetryTimer.isDone();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  // Must be synchronized.\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    stopwatch.reset().start();\n+  }\n+\n+  /**\n+   * Returns the latest accepted version of the given resource type.\n+   */\n+  // Must be synchronized.\n+  private String getCurrentVersion(ResourceType type) {\n+    String version;\n+    switch (type) {\n+      case LDS:\n+        version = ldsVersion;\n+        break;\n+      case RDS:\n+        version = rdsVersion;\n+        break;\n+      case CDS:\n+        version = cdsVersion;\n+        break;\n+      case EDS:\n+        version = edsVersion;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    return version;\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      runWithSynchronized(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (shutdown) {\n+            return;\n+          }\n+          startRpcStream();\n+          for (ResourceType type : ResourceType.values()) {\n+            if (type == ResourceType.UNKNOWN) {\n+              continue;\n+            }\n+            Collection<String> resources = getSubscribedResources(type);\n+            if (resources != null) {\n+              adsStream.sendDiscoveryRequest(type, resources);\n+            }\n+          }\n+          handleStreamRestarted();\n+        }\n+      });\n+    }\n+  }\n+\n+  protected enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  private abstract class AbstractAdsStream {\n+    private boolean responseReceived;\n+    private boolean closed;\n+\n+    // Response nonce for the most recently received discovery responses of each resource type.\n+    // Client initiated requests start response nonce with empty string.\n+    // A nonce is used to indicate the specific DiscoveryResponse each DiscoveryRequest\n+    // corresponds to.\n+    // A nonce becomes stale following a newer nonce being presented to the client in a\n+    // DiscoveryResponse.\n+    private String ldsRespNonce = \"\";\n+    private String rdsRespNonce = \"\";\n+    private String cdsRespNonce = \"\";\n+    private String edsRespNonce = \"\";\n+\n+    abstract void start();\n+\n+    abstract void sendError(Exception error);\n+\n+    /**\n+     * Sends a discovery request with the given {@code versionInfo}, {@code nonce} and\n+     * {@code errorDetail}. Used for reacting to a specific discovery response. For\n+     * client-initiated discovery requests, use {@link\n+     * #sendDiscoveryRequest(ResourceType, Collection)}.\n+     */\n+    abstract void sendDiscoveryRequest(ResourceType type, String versionInfo,\n+        Collection<String> resources, String nonce, @Nullable String errorDetail);\n+\n+    /**\n+     * Sends a client-initiated discovery request.\n+     */\n+    final void sendDiscoveryRequest(ResourceType type, Collection<String> resources) {\n+      String nonce;\n+      switch (type) {\n+        case LDS:\n+          nonce = ldsRespNonce;\n+          break;\n+        case RDS:\n+          nonce = rdsRespNonce;\n+          break;\n+        case CDS:\n+          nonce = cdsRespNonce;\n+          break;\n+        case EDS:\n+          nonce = edsRespNonce;\n+          break;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown resource type: \" + type);\n+      }\n+      sendDiscoveryRequest(type, getCurrentVersion(type), resources, nonce, null);\n+    }\n+\n+    final void handleRpcResponse(\n+        ResourceType type, String versionInfo, List<Any> resources, String nonce) {\n+      if (closed) {\n+        return;\n+      }\n+      responseReceived = true;\n+      // Nonce in each response is echoed back in the following ACK/NACK request. It is\n+      // used for management server to identify which response the client is ACKing/NACking.\n+      // To avoid confusion, client-initiated requests will always use the nonce in\n+      // most recently received responses of each resource type.\n+      switch (type) {\n+        case LDS:\n+          ldsRespNonce = nonce;\n+          handleLdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case RDS:\n+          rdsRespNonce = nonce;\n+          handleRdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case CDS:\n+          cdsRespNonce = nonce;\n+          handleCdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case EDS:\n+          edsRespNonce = nonce;\n+          handleEdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case UNKNOWN:\n+        default:\n+          logger.log(XdsLogLevel.WARNING, \"Ignore an unknown type of DiscoveryResponse\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 500}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2MzUwMw==", "bodyText": "The method has almost identical name as handleRpcStreamClosed().\nSo propagateStreamError() might be a better name, as it's propagating error to the watchers.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510463503", "createdAt": "2020-10-22T21:18:21Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, null);\n+  }\n+\n+  /**\n+   * Rejects the update for the given resource type and sends an NACK request (request with last\n+   * accepted version) to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void nackResponse(ResourceType type, String nonce, String errorDetail) {\n+    String versionInfo = getCurrentVersion(type);\n+    logger.log(XdsLogLevel.INFO, \"Sending NACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, errorDetail);\n+  }\n+\n+  protected final ScheduledExecutorService getTimeService() {\n+    return timeService;\n+  }\n+\n+  protected final XdsLogger getLogger() {\n+    return logger;\n+  }\n+\n+  /**\n+   * Returns {@code true} if the resource discovery is currently in backoff.\n+   */\n+  // Must be synchronized.\n+  protected final boolean isInBackoff() {\n+    return rpcRetryTimer != null && !rpcRetryTimer.isDone();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  // Must be synchronized.\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    stopwatch.reset().start();\n+  }\n+\n+  /**\n+   * Returns the latest accepted version of the given resource type.\n+   */\n+  // Must be synchronized.\n+  private String getCurrentVersion(ResourceType type) {\n+    String version;\n+    switch (type) {\n+      case LDS:\n+        version = ldsVersion;\n+        break;\n+      case RDS:\n+        version = rdsVersion;\n+        break;\n+      case CDS:\n+        version = cdsVersion;\n+        break;\n+      case EDS:\n+        version = edsVersion;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    return version;\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      runWithSynchronized(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (shutdown) {\n+            return;\n+          }\n+          startRpcStream();\n+          for (ResourceType type : ResourceType.values()) {\n+            if (type == ResourceType.UNKNOWN) {\n+              continue;\n+            }\n+            Collection<String> resources = getSubscribedResources(type);\n+            if (resources != null) {\n+              adsStream.sendDiscoveryRequest(type, resources);\n+            }\n+          }\n+          handleStreamRestarted();\n+        }\n+      });\n+    }\n+  }\n+\n+  protected enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  private abstract class AbstractAdsStream {\n+    private boolean responseReceived;\n+    private boolean closed;\n+\n+    // Response nonce for the most recently received discovery responses of each resource type.\n+    // Client initiated requests start response nonce with empty string.\n+    // A nonce is used to indicate the specific DiscoveryResponse each DiscoveryRequest\n+    // corresponds to.\n+    // A nonce becomes stale following a newer nonce being presented to the client in a\n+    // DiscoveryResponse.\n+    private String ldsRespNonce = \"\";\n+    private String rdsRespNonce = \"\";\n+    private String cdsRespNonce = \"\";\n+    private String edsRespNonce = \"\";\n+\n+    abstract void start();\n+\n+    abstract void sendError(Exception error);\n+\n+    /**\n+     * Sends a discovery request with the given {@code versionInfo}, {@code nonce} and\n+     * {@code errorDetail}. Used for reacting to a specific discovery response. For\n+     * client-initiated discovery requests, use {@link\n+     * #sendDiscoveryRequest(ResourceType, Collection)}.\n+     */\n+    abstract void sendDiscoveryRequest(ResourceType type, String versionInfo,\n+        Collection<String> resources, String nonce, @Nullable String errorDetail);\n+\n+    /**\n+     * Sends a client-initiated discovery request.\n+     */\n+    final void sendDiscoveryRequest(ResourceType type, Collection<String> resources) {\n+      String nonce;\n+      switch (type) {\n+        case LDS:\n+          nonce = ldsRespNonce;\n+          break;\n+        case RDS:\n+          nonce = rdsRespNonce;\n+          break;\n+        case CDS:\n+          nonce = cdsRespNonce;\n+          break;\n+        case EDS:\n+          nonce = edsRespNonce;\n+          break;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown resource type: \" + type);\n+      }\n+      sendDiscoveryRequest(type, getCurrentVersion(type), resources, nonce, null);\n+    }\n+\n+    final void handleRpcResponse(\n+        ResourceType type, String versionInfo, List<Any> resources, String nonce) {\n+      if (closed) {\n+        return;\n+      }\n+      responseReceived = true;\n+      // Nonce in each response is echoed back in the following ACK/NACK request. It is\n+      // used for management server to identify which response the client is ACKing/NACking.\n+      // To avoid confusion, client-initiated requests will always use the nonce in\n+      // most recently received responses of each resource type.\n+      switch (type) {\n+        case LDS:\n+          ldsRespNonce = nonce;\n+          handleLdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case RDS:\n+          rdsRespNonce = nonce;\n+          handleRdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case CDS:\n+          cdsRespNonce = nonce;\n+          handleCdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case EDS:\n+          edsRespNonce = nonce;\n+          handleEdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case UNKNOWN:\n+        default:\n+          logger.log(XdsLogLevel.WARNING, \"Ignore an unknown type of DiscoveryResponse\");\n+      }\n+    }\n+\n+    final void handleRpcError(Throwable t) {\n+      handleRpcStreamClosed(Status.fromThrowable(t));\n+    }\n+\n+    final void handleRpcCompleted() {\n+      handleRpcStreamClosed(Status.UNAVAILABLE.withDescription(\"Closed by server\"));\n+    }\n+\n+    private void handleRpcStreamClosed(Status error) {\n+      checkArgument(!error.isOk(), \"unexpected OK status\");\n+      if (closed) {\n+        return;\n+      }\n+      logger.log(\n+          XdsLogLevel.ERROR,\n+          \"ADS stream closed with status {0}: {1}. Cause: {2}\",\n+          error.getCode(), error.getDescription(), error.getCause());\n+      closed = true;\n+      handleStreamClosed(error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 522}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2NDcxNQ==", "bodyText": "stubV2 can be moved into start() as a local variable.", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510464715", "createdAt": "2020-10-22T21:20:50Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.\n+  protected final void adjustResourceSubscription(ResourceType type) {\n+    if (isInBackoff()) {\n+      return;\n+    }\n+    if (adsStream == null) {\n+      startRpcStream();\n+    }\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources != null) {\n+      adsStream.sendDiscoveryRequest(type, resources);\n+    }\n+  }\n+\n+  /**\n+   * Accepts the update for the given resource type by updating the latest resource version\n+   * and sends an ACK request to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void ackResponse(ResourceType type, String versionInfo, String nonce) {\n+    switch (type) {\n+      case LDS:\n+        ldsVersion = versionInfo;\n+        break;\n+      case RDS:\n+        rdsVersion = versionInfo;\n+        break;\n+      case CDS:\n+        cdsVersion = versionInfo;\n+        break;\n+      case EDS:\n+        edsVersion = versionInfo;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    logger.log(XdsLogLevel.INFO, \"Sending ACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, null);\n+  }\n+\n+  /**\n+   * Rejects the update for the given resource type and sends an NACK request (request with last\n+   * accepted version) to the management server.\n+   */\n+  // Must be synchronized.\n+  protected final void nackResponse(ResourceType type, String nonce, String errorDetail) {\n+    String versionInfo = getCurrentVersion(type);\n+    logger.log(XdsLogLevel.INFO, \"Sending NACK for {0} update, nonce: {1}, current version: {2}\",\n+        type, nonce, versionInfo);\n+    Collection<String> resources = getSubscribedResources(type);\n+    if (resources == null) {\n+      resources = Collections.emptyList();\n+    }\n+    adsStream.sendDiscoveryRequest(type, versionInfo, resources, nonce, errorDetail);\n+  }\n+\n+  protected final ScheduledExecutorService getTimeService() {\n+    return timeService;\n+  }\n+\n+  protected final XdsLogger getLogger() {\n+    return logger;\n+  }\n+\n+  /**\n+   * Returns {@code true} if the resource discovery is currently in backoff.\n+   */\n+  // Must be synchronized.\n+  protected final boolean isInBackoff() {\n+    return rpcRetryTimer != null && !rpcRetryTimer.isDone();\n+  }\n+\n+  /**\n+   * Establishes the RPC connection by creating a new RPC stream on the given channel for\n+   * xDS protocol communication.\n+   */\n+  // Must be synchronized.\n+  private void startRpcStream() {\n+    checkState(adsStream == null, \"Previous adsStream has not been cleared yet\");\n+    if (xdsChannel.isUseProtocolV3()) {\n+      adsStream = new AdsStream();\n+    } else {\n+      adsStream = new AdsStreamV2();\n+    }\n+    adsStream.start();\n+    logger.log(XdsLogLevel.INFO, \"ADS stream started\");\n+    stopwatch.reset().start();\n+  }\n+\n+  /**\n+   * Returns the latest accepted version of the given resource type.\n+   */\n+  // Must be synchronized.\n+  private String getCurrentVersion(ResourceType type) {\n+    String version;\n+    switch (type) {\n+      case LDS:\n+        version = ldsVersion;\n+        break;\n+      case RDS:\n+        version = rdsVersion;\n+        break;\n+      case CDS:\n+        version = cdsVersion;\n+        break;\n+      case EDS:\n+        version = edsVersion;\n+        break;\n+      case UNKNOWN:\n+      default:\n+        throw new AssertionError(\"Unknown resource type: \" + type);\n+    }\n+    return version;\n+  }\n+\n+  @VisibleForTesting\n+  final class RpcRetryTask implements Runnable {\n+    @Override\n+    public void run() {\n+      runWithSynchronized(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (shutdown) {\n+            return;\n+          }\n+          startRpcStream();\n+          for (ResourceType type : ResourceType.values()) {\n+            if (type == ResourceType.UNKNOWN) {\n+              continue;\n+            }\n+            Collection<String> resources = getSubscribedResources(type);\n+            if (resources != null) {\n+              adsStream.sendDiscoveryRequest(type, resources);\n+            }\n+          }\n+          handleStreamRestarted();\n+        }\n+      });\n+    }\n+  }\n+\n+  protected enum ResourceType {\n+    UNKNOWN, LDS, RDS, CDS, EDS;\n+\n+    String typeUrl() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    String typeUrlV2() {\n+      switch (this) {\n+        case LDS:\n+          return ADS_TYPE_URL_LDS_V2;\n+        case RDS:\n+          return ADS_TYPE_URL_RDS_V2;\n+        case CDS:\n+          return ADS_TYPE_URL_CDS_V2;\n+        case EDS:\n+          return ADS_TYPE_URL_EDS_V2;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown or missing case in enum switch: \" + this);\n+      }\n+    }\n+\n+    private static ResourceType fromTypeUrl(String typeUrl) {\n+      switch (typeUrl) {\n+        case ADS_TYPE_URL_LDS:\n+          // fall trough\n+        case ADS_TYPE_URL_LDS_V2:\n+          return LDS;\n+        case ADS_TYPE_URL_RDS:\n+          // fall through\n+        case ADS_TYPE_URL_RDS_V2:\n+          return RDS;\n+        case ADS_TYPE_URL_CDS:\n+          // fall through\n+        case ADS_TYPE_URL_CDS_V2:\n+          return CDS;\n+        case ADS_TYPE_URL_EDS:\n+          // fall through\n+        case ADS_TYPE_URL_EDS_V2:\n+          return EDS;\n+        default:\n+          return UNKNOWN;\n+      }\n+    }\n+  }\n+\n+  private abstract class AbstractAdsStream {\n+    private boolean responseReceived;\n+    private boolean closed;\n+\n+    // Response nonce for the most recently received discovery responses of each resource type.\n+    // Client initiated requests start response nonce with empty string.\n+    // A nonce is used to indicate the specific DiscoveryResponse each DiscoveryRequest\n+    // corresponds to.\n+    // A nonce becomes stale following a newer nonce being presented to the client in a\n+    // DiscoveryResponse.\n+    private String ldsRespNonce = \"\";\n+    private String rdsRespNonce = \"\";\n+    private String cdsRespNonce = \"\";\n+    private String edsRespNonce = \"\";\n+\n+    abstract void start();\n+\n+    abstract void sendError(Exception error);\n+\n+    /**\n+     * Sends a discovery request with the given {@code versionInfo}, {@code nonce} and\n+     * {@code errorDetail}. Used for reacting to a specific discovery response. For\n+     * client-initiated discovery requests, use {@link\n+     * #sendDiscoveryRequest(ResourceType, Collection)}.\n+     */\n+    abstract void sendDiscoveryRequest(ResourceType type, String versionInfo,\n+        Collection<String> resources, String nonce, @Nullable String errorDetail);\n+\n+    /**\n+     * Sends a client-initiated discovery request.\n+     */\n+    final void sendDiscoveryRequest(ResourceType type, Collection<String> resources) {\n+      String nonce;\n+      switch (type) {\n+        case LDS:\n+          nonce = ldsRespNonce;\n+          break;\n+        case RDS:\n+          nonce = rdsRespNonce;\n+          break;\n+        case CDS:\n+          nonce = cdsRespNonce;\n+          break;\n+        case EDS:\n+          nonce = edsRespNonce;\n+          break;\n+        case UNKNOWN:\n+        default:\n+          throw new AssertionError(\"Unknown resource type: \" + type);\n+      }\n+      sendDiscoveryRequest(type, getCurrentVersion(type), resources, nonce, null);\n+    }\n+\n+    final void handleRpcResponse(\n+        ResourceType type, String versionInfo, List<Any> resources, String nonce) {\n+      if (closed) {\n+        return;\n+      }\n+      responseReceived = true;\n+      // Nonce in each response is echoed back in the following ACK/NACK request. It is\n+      // used for management server to identify which response the client is ACKing/NACking.\n+      // To avoid confusion, client-initiated requests will always use the nonce in\n+      // most recently received responses of each resource type.\n+      switch (type) {\n+        case LDS:\n+          ldsRespNonce = nonce;\n+          handleLdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case RDS:\n+          rdsRespNonce = nonce;\n+          handleRdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case CDS:\n+          cdsRespNonce = nonce;\n+          handleCdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case EDS:\n+          edsRespNonce = nonce;\n+          handleEdsResponse(versionInfo, resources, nonce);\n+          break;\n+        case UNKNOWN:\n+        default:\n+          logger.log(XdsLogLevel.WARNING, \"Ignore an unknown type of DiscoveryResponse\");\n+      }\n+    }\n+\n+    final void handleRpcError(Throwable t) {\n+      handleRpcStreamClosed(Status.fromThrowable(t));\n+    }\n+\n+    final void handleRpcCompleted() {\n+      handleRpcStreamClosed(Status.UNAVAILABLE.withDescription(\"Closed by server\"));\n+    }\n+\n+    private void handleRpcStreamClosed(Status error) {\n+      checkArgument(!error.isOk(), \"unexpected OK status\");\n+      if (closed) {\n+        return;\n+      }\n+      logger.log(\n+          XdsLogLevel.ERROR,\n+          \"ADS stream closed with status {0}: {1}. Cause: {2}\",\n+          error.getCode(), error.getDescription(), error.getCause());\n+      closed = true;\n+      handleStreamClosed(error);\n+      cleanUp();\n+      if (responseReceived || retryBackoffPolicy == null) {\n+        // Reset the backoff sequence if had received a response, or backoff sequence\n+        // has never been initialized.\n+        retryBackoffPolicy = backoffPolicyProvider.get();\n+      }\n+      long delayNanos = 0;\n+      if (!responseReceived) {\n+        delayNanos =\n+            Math.max(\n+                0,\n+                retryBackoffPolicy.nextBackoffNanos()\n+                    - stopwatch.elapsed(TimeUnit.NANOSECONDS));\n+      }\n+      logger.log(XdsLogLevel.INFO, \"Retry ADS stream in {0} ns\", delayNanos);\n+      rpcRetryTimer = timeService.schedule(new RpcRetryTask(), delayNanos, TimeUnit.NANOSECONDS);\n+    }\n+\n+    private void close(Exception error) {\n+      if (closed) {\n+        return;\n+      }\n+      closed = true;\n+      cleanUp();\n+      sendError(error);\n+    }\n+\n+    private void cleanUp() {\n+      if (adsStream == this) {\n+        adsStream = null;\n+      }\n+    }\n+  }\n+\n+  private final class AdsStreamV2 extends AbstractAdsStream {\n+    private final io.envoyproxy.envoy.service.discovery.v2.AggregatedDiscoveryServiceGrpc\n+        .AggregatedDiscoveryServiceStub stubV2;\n+    private StreamObserver<io.envoyproxy.envoy.api.v2.DiscoveryRequest> requestWriterV2;\n+\n+    AdsStreamV2() {\n+      stubV2 = io.envoyproxy.envoy.service.discovery.v2.AggregatedDiscoveryServiceGrpc.newStub(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 563}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3MzI3Ng==", "bodyText": "Usages of adjustResourceSubscription  seem not synchronized in the sense of runWithSynchronized().", "url": "https://github.com/grpc/grpc-java/pull/7533#discussion_r510473276", "createdAt": "2020-10-22T21:38:25Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/AbstractXdsClient.java", "diffHunk": "@@ -0,0 +1,760 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Stopwatch;\n+import com.google.protobuf.Any;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.protobuf.MessageOrBuilder;\n+import com.google.protobuf.TypeRegistry;\n+import com.google.protobuf.util.JsonFormat;\n+import com.google.rpc.Code;\n+import io.envoyproxy.envoy.config.cluster.v3.Cluster;\n+import io.envoyproxy.envoy.config.endpoint.v3.ClusterLoadAssignment;\n+import io.envoyproxy.envoy.config.listener.v3.Listener;\n+import io.envoyproxy.envoy.config.route.v3.RouteConfiguration;\n+import io.envoyproxy.envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager;\n+import io.envoyproxy.envoy.service.discovery.v3.AggregatedDiscoveryServiceGrpc;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryRequest;\n+import io.envoyproxy.envoy.service.discovery.v3.DiscoveryResponse;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.stub.StreamObserver;\n+import io.grpc.xds.EnvoyProtoData.Node;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Common base type for XdsClient implementations, which encapsulates the layer abstraction of\n+ * the xDS RPC stream.\n+ */\n+abstract class AbstractXdsClient extends XdsClient {\n+\n+  private static final String ADS_TYPE_URL_LDS_V2 = \"type.googleapis.com/envoy.api.v2.Listener\";\n+  private static final String ADS_TYPE_URL_LDS =\n+      \"type.googleapis.com/envoy.config.listener.v3.Listener\";\n+  private static final String ADS_TYPE_URL_RDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_RDS =\n+      \"type.googleapis.com/envoy.config.route.v3.RouteConfiguration\";\n+  private static final String ADS_TYPE_URL_CDS_V2 = \"type.googleapis.com/envoy.api.v2.Cluster\";\n+  private static final String ADS_TYPE_URL_CDS =\n+      \"type.googleapis.com/envoy.config.cluster.v3.Cluster\";\n+  private static final String ADS_TYPE_URL_EDS_V2 =\n+      \"type.googleapis.com/envoy.api.v2.ClusterLoadAssignment\";\n+  private static final String ADS_TYPE_URL_EDS =\n+      \"type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\";\n+\n+  private final MessagePrinter respPrinter = new MessagePrinter();\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final XdsChannel xdsChannel;\n+  private final ScheduledExecutorService timeService;\n+  private final BackoffPolicy.Provider backoffPolicyProvider;\n+  private final Stopwatch stopwatch;\n+  // The node identifier to be included in xDS requests. Management server only requires the\n+  // first request to carry the node identifier on a stream. It should be identical if present\n+  // more than once.\n+  // FIXME(chengyuanzhang): should immutable and invisible to child classes. Currently server side\n+  //  has some protocol workaround usages.\n+  protected Node node;\n+\n+  // Last successfully applied version_info for each resource type. Starts with empty string.\n+  // A version_info is used to update management server with client's most recent knowledge of\n+  // resources.\n+  private String ldsVersion = \"\";\n+  private String rdsVersion = \"\";\n+  private String cdsVersion = \"\";\n+  private String edsVersion = \"\";\n+\n+  private boolean shutdown;\n+  @Nullable\n+  private AbstractAdsStream adsStream;\n+  @Nullable\n+  private BackoffPolicy retryBackoffPolicy;\n+  @Nullable\n+  private ScheduledFuture<?> rpcRetryTimer;\n+\n+  AbstractXdsClient(\n+      XdsChannel channel,\n+      Node node,\n+      ScheduledExecutorService timeService,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      Stopwatch stopwatch) {\n+    this.xdsChannel = checkNotNull(channel, \"channel\");\n+    this.node = checkNotNull(node, \"node\");\n+    this.timeService = checkNotNull(timeService, \"timeService\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    this.stopwatch = checkNotNull(stopwatch, \"stopwatch\");\n+    logId = InternalLogId.allocate(\"xds-client\", null);\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  /**\n+   * Called when an LDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleLdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a RDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleRdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when a CDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleCdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when an EDS response is received.\n+   */\n+  // Must be synchronized.\n+  protected void handleEdsResponse(String versionInfo, List<Any> resources, String nonce) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream is closed passively.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamClosed(Status error) {\n+  }\n+\n+  /**\n+   * Called when the ADS stream has been recreated.\n+   */\n+  // Must be synchronized.\n+  protected void handleStreamRestarted() {\n+  }\n+\n+  /**\n+   * Called when being shut down.\n+   */\n+  // Must be synchronized.\n+  protected void handleShutdown() {\n+  }\n+\n+  /**\n+   * Synchronizes the execution of the given {@code runnable} with other state mutating operations.\n+   */\n+  protected abstract void runWithSynchronized(Runnable runnable);\n+\n+  @Override\n+  final void shutdown() {\n+    runWithSynchronized(new Runnable() {\n+      @Override\n+      public void run() {\n+        shutdown = true;\n+        logger.log(XdsLogLevel.INFO, \"Shutting down\");\n+        xdsChannel.getManagedChannel().shutdown();\n+        if (adsStream != null) {\n+          adsStream.close(Status.CANCELLED.withDescription(\"shutdown\").asException());\n+        }\n+        if (rpcRetryTimer != null) {\n+          rpcRetryTimer.cancel(false);\n+        }\n+        handleShutdown();\n+      }\n+    });\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return logId.toString();\n+  }\n+\n+  /**\n+   * Returns the collection of resources currently subscribing to or {@code null} if not\n+   * subscribing to any resources for the given type.\n+   *\n+   * <p>Note a empty collection indicates subscribing to resources of the given type with\n+   * wildcard mode.\n+   */\n+  // Must be synchronized.\n+  @Nullable\n+  abstract Collection<String> getSubscribedResources(ResourceType type);\n+\n+  /**\n+   * Updates the resource subscription for the given resource type.\n+   */\n+  // Must be synchronized.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d453142a0601e36efe151ab6caf0f9a358a7b18"}, "originalPosition": 212}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e161806961b7f02c62c5bb1b6d35c0642a34f573", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/e161806961b7f02c62c5bb1b6d35c0642a34f573", "committedDate": "2020-10-22T23:06:42Z", "message": "Pass supplier of stopwatch to the abstract layer."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "847ff3680bcb6277bd52adc3b84102df2647ea89", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/847ff3680bcb6277bd52adc3b84102df2647ea89", "committedDate": "2020-10-22T23:09:07Z", "message": "Fixed typo."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc58ad42edf44e469f808a70312201ebd0832ca5", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/bc58ad42edf44e469f808a70312201ebd0832ca5", "committedDate": "2020-10-22T23:10:05Z", "message": "Ensure the abstract layer is requesting for LDS resources."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58387baef23fd6707880953879bd6ff479c72874", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/58387baef23fd6707880953879bd6ff479c72874", "committedDate": "2020-10-22T23:17:18Z", "message": "Cleaned up AdsStream naming."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "702952e174bb13a0f82d3eb24fb1da92b1fd3acc", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/702952e174bb13a0f82d3eb24fb1da92b1fd3acc", "committedDate": "2020-10-22T23:43:17Z", "message": "Add log for sending a client initiated xDS request."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MjAxMzQ1", "url": "https://github.com/grpc/grpc-java/pull/7533#pullrequestreview-515201345", "createdAt": "2020-10-23T00:11:16Z", "commit": {"oid": "702952e174bb13a0f82d3eb24fb1da92b1fd3acc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTkyOTI4", "url": "https://github.com/grpc/grpc-java/pull/7533#pullrequestreview-515992928", "createdAt": "2020-10-23T20:32:24Z", "commit": {"oid": "702952e174bb13a0f82d3eb24fb1da92b1fd3acc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3928, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}