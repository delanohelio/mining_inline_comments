{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2NTMyMjYy", "number": 7191, "title": "xds: Added a CEL-based Authorization Engine", "bodyText": "Currently, gRPC offers built-in and pluggable authentication mechanisms to users, but it doesn't support any standard authorization mechanisms in OSS. Therefore, in order for users to perform authorization checks in their RPC calls, they have to manually implement the authorization algorithm in the source code by themselves, which is often a challenge for gRPC users without much security background. Thus, this PR includes implementation and unit tests for CEL-based authorization engine as part of the gRPC authorization framework in OSS.\nThe CEL-based authorization engine in gRPC-Java is mainly consisted of three classes, AuthorizationEngine, AuthorizationDecision, and EvaluateArgs, where AuthorizationEngine defines an evaluate method that makes an AuthorizationDecision (ALLOW/DENY/UNKNOWN) based on Envoy Attributes. EvaluateArgs takes ServerCall and Metadata as input parameters, which contains sufficient information to extract Envoy Attributes.\n@ZhenLian", "createdAt": "2020-07-08T23:18:52Z", "url": "https://github.com/grpc/grpc-java/pull/7191", "merged": true, "mergeCommit": {"oid": "cd0cc95553778cb640666ee50bdf37ae2ff10a8f"}, "closed": true, "closedAt": "2020-08-13T23:08:36Z", "author": {"login": "cindyxue"}, "timelineItems": {"totalCount": 103, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-k1Y2gBqjM2NTM0NjcwODE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-lG1EABqjM2NTM1MzAzMzg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a1c8d9f7b83955903bcde0f4d09aa58e9243bfe4", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/a1c8d9f7b83955903bcde0f4d09aa58e9243bfe4", "committedDate": "2020-08-13T18:56:44Z", "message": "Resolved Sanjay's review comments"}, "afterCommit": {"oid": "78118e910777a900cf86a9601196c43dc8418664", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/78118e910777a900cf86a9601196c43dc8418664", "committedDate": "2020-08-13T19:04:07Z", "message": "Resolved Sanjay's review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "246c04477f3c8fcddfb17f326de8bd4edd5cc294", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/246c04477f3c8fcddfb17f326de8bd4edd5cc294", "committedDate": "2020-08-13T19:23:06Z", "message": "Resolved Sanjay's review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "78118e910777a900cf86a9601196c43dc8418664", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/78118e910777a900cf86a9601196c43dc8418664", "committedDate": "2020-08-13T19:04:07Z", "message": "Resolved Sanjay's review comments"}, "afterCommit": {"oid": "246c04477f3c8fcddfb17f326de8bd4edd5cc294", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/246c04477f3c8fcddfb17f326de8bd4edd5cc294", "committedDate": "2020-08-13T19:23:06Z", "message": "Resolved Sanjay's review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3941fcd192e00c96157edae57873d2e57c651dea", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/3941fcd192e00c96157edae57873d2e57c651dea", "committedDate": "2020-07-08T23:15:52Z", "message": "Added cel evaluation engine implementation"}, "afterCommit": {"oid": "11bca0f1985bb1062a785b145a53c21ff4ddd62f", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/11bca0f1985bb1062a785b145a53c21ff4ddd62f", "committedDate": "2020-07-09T21:31:22Z", "message": "Added cel evaluation engine implementation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a7bafb026218d2232762cf79060867f659730eb", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/0a7bafb026218d2232762cf79060867f659730eb", "committedDate": "2020-07-13T17:35:40Z", "message": "Updated Cel Engine's evaluate function"}, "afterCommit": {"oid": "d2b82cfaad4bfa29164ef17812ae649d7ca55af3", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/d2b82cfaad4bfa29164ef17812ae649d7ca55af3", "committedDate": "2020-07-13T19:13:07Z", "message": "Updated Cel Engine's evaluate function"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d2b82cfaad4bfa29164ef17812ae649d7ca55af3", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/d2b82cfaad4bfa29164ef17812ae649d7ca55af3", "committedDate": "2020-07-13T19:13:07Z", "message": "Updated Cel Engine's evaluate function"}, "afterCommit": {"oid": "8d13480ec2556ea110b4ed873322c7df50af1726", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/8d13480ec2556ea110b4ed873322c7df50af1726", "committedDate": "2020-07-13T20:08:39Z", "message": "Updated Cel Engine's evaluate function"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8d13480ec2556ea110b4ed873322c7df50af1726", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/8d13480ec2556ea110b4ed873322c7df50af1726", "committedDate": "2020-07-13T20:08:39Z", "message": "Updated Cel Engine's evaluate function"}, "afterCommit": {"oid": "99583cc57f1fd0c0aad3eb1d4497a48f88826085", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/99583cc57f1fd0c0aad3eb1d4497a48f88826085", "committedDate": "2020-07-13T20:35:54Z", "message": "Updated Cel Engine's evaluate function"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "930abadbfd5b6217561be61e54ac655e73924b0b", "author": {"user": {"login": "cindyxue", "name": "Cindy Xue"}}, "url": "https://github.com/grpc/grpc-java/commit/930abadbfd5b6217561be61e54ac655e73924b0b", "committedDate": "2020-07-14T20:48:07Z", "message": "Add unit test for evaluate function and EvaluateArgs\n\nCindy/cel engine mock"}, "afterCommit": {"oid": "02d77d939e57383eb235d61362d26bf09b71b905", "author": {"user": {"login": "cindyxue", "name": "Cindy Xue"}}, "url": "https://github.com/grpc/grpc-java/commit/02d77d939e57383eb235d61362d26bf09b71b905", "committedDate": "2020-07-14T20:49:14Z", "message": "Add unit test for evaluate function and EvaluateArgs\n\nCindy/cel engine mock"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "02d77d939e57383eb235d61362d26bf09b71b905", "author": {"user": {"login": "cindyxue", "name": "Cindy Xue"}}, "url": "https://github.com/grpc/grpc-java/commit/02d77d939e57383eb235d61362d26bf09b71b905", "committedDate": "2020-07-14T20:49:14Z", "message": "Add unit test for evaluate function and EvaluateArgs\n\nCindy/cel engine mock"}, "afterCommit": {"oid": "a72fb92b39e2ce74fc8d683694f8e67a8c403608", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/a72fb92b39e2ce74fc8d683694f8e67a8c403608", "committedDate": "2020-07-14T23:14:51Z", "message": "Merged master into current branch"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a72fb92b39e2ce74fc8d683694f8e67a8c403608", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/a72fb92b39e2ce74fc8d683694f8e67a8c403608", "committedDate": "2020-07-14T23:14:51Z", "message": "Merged master into current branch"}, "afterCommit": {"oid": "2cc3916fb49fcbc735b32270ffede164c2344bea", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/2cc3916fb49fcbc735b32270ffede164c2344bea", "committedDate": "2020-07-14T23:27:06Z", "message": "Rebased with master branch"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2cc3916fb49fcbc735b32270ffede164c2344bea", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/2cc3916fb49fcbc735b32270ffede164c2344bea", "committedDate": "2020-07-14T23:27:06Z", "message": "Rebased with master branch"}, "afterCommit": {"oid": "c7aeba38e5640dc480d09b917425c7f5e9742884", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/c7aeba38e5640dc480d09b917425c7f5e9742884", "committedDate": "2020-07-14T23:52:21Z", "message": "Rebased with master branch"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c7aeba38e5640dc480d09b917425c7f5e9742884", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/c7aeba38e5640dc480d09b917425c7f5e9742884", "committedDate": "2020-07-14T23:52:21Z", "message": "Rebased with master branch"}, "afterCommit": {"oid": "82a2cef263847100a1588d48bb1b3422ac4cdd0b", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/82a2cef263847100a1588d48bb1b3422ac4cdd0b", "committedDate": "2020-07-15T00:27:15Z", "message": "Rebased with master branch"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "82a2cef263847100a1588d48bb1b3422ac4cdd0b", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/82a2cef263847100a1588d48bb1b3422ac4cdd0b", "committedDate": "2020-07-15T00:27:15Z", "message": "Rebased with master branch"}, "afterCommit": {"oid": "f41404a5b7f10e52252156606dddad3822bb5e8e", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/f41404a5b7f10e52252156606dddad3822bb5e8e", "committedDate": "2020-07-15T00:46:07Z", "message": "Rebased with master branch"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f41404a5b7f10e52252156606dddad3822bb5e8e", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/f41404a5b7f10e52252156606dddad3822bb5e8e", "committedDate": "2020-07-15T00:46:07Z", "message": "Rebased with master branch"}, "afterCommit": {"oid": "4f91b1510db52065bf4603b41856a249b75474e2", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/4f91b1510db52065bf4603b41856a249b75474e2", "committedDate": "2020-07-15T01:36:12Z", "message": "Rebased with master branch"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4f91b1510db52065bf4603b41856a249b75474e2", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/4f91b1510db52065bf4603b41856a249b75474e2", "committedDate": "2020-07-15T01:36:12Z", "message": "Rebased with master branch"}, "afterCommit": {"oid": "460cfaf10608f1e7fbbda9dc8a2d127cf332da64", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/460cfaf10608f1e7fbbda9dc8a2d127cf332da64", "committedDate": "2020-07-15T02:02:55Z", "message": "Rebased with master branch"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "460cfaf10608f1e7fbbda9dc8a2d127cf332da64", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/460cfaf10608f1e7fbbda9dc8a2d127cf332da64", "committedDate": "2020-07-15T02:02:55Z", "message": "Rebased with master branch"}, "afterCommit": {"oid": "e0d29d23dd88e025cce194232507c888fc6fa902", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/e0d29d23dd88e025cce194232507c888fc6fa902", "committedDate": "2020-07-15T02:21:42Z", "message": "Rebased with master branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "507ef4a7983d4bb6e980874c56694984c87b0df2", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/507ef4a7983d4bb6e980874c56694984c87b0df2", "committedDate": "2020-07-15T02:34:25Z", "message": "Rebased with master branch"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e0d29d23dd88e025cce194232507c888fc6fa902", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/e0d29d23dd88e025cce194232507c888fc6fa902", "committedDate": "2020-07-15T02:21:42Z", "message": "Rebased with master branch"}, "afterCommit": {"oid": "507ef4a7983d4bb6e980874c56694984c87b0df2", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/507ef4a7983d4bb6e980874c56694984c87b0df2", "committedDate": "2020-07-15T02:34:25Z", "message": "Rebased with master branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c4199484718789ea60c5dcec2341d96aa58c457", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/2c4199484718789ea60c5dcec2341d96aa58c457", "committedDate": "2020-07-15T19:19:52Z", "message": "Addressed updates on Cel engine"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9b370d3d36f58a928993b27a1e6403d32084073", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/c9b370d3d36f58a928993b27a1e6403d32084073", "committedDate": "2020-07-15T20:36:19Z", "message": "Changed evaluate's arguments from taking args to activation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/17fd01592608b46af8eacc4c3079f9f4f64fa7a3", "committedDate": "2020-07-15T22:48:23Z", "message": "Enabled cel engine to return a list of matching policies when there is a match"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NDIwODE4", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-449420818", "createdAt": "2020-07-16T00:00:17Z", "commit": {"oid": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMDowMDoxN1rOGyVYGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMDo1OTo1OVrOGyWY8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQzMjIxNw==", "bodyText": "nit: s/Cel/CEL/g.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455432217", "createdAt": "2020-07-16T00:00:17Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationDecision.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import java.lang.StringBuilder;\n+import java.util.List;\n+\n+/** \n+ * The AuthorizationDecision class holds authorization decision \n+ * returned by Cel Evaluation Engine. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQzNjAyNA==", "bodyText": "Should the length of action and conditions always be the same? If so, I think we can have one List here where RBACEngine is an inner class that contains RBAC.Action and ImmutableMap<String, Expr>. That might make the structure clearer.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455436024", "createdAt": "2020-07-16T00:12:41Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/CelEvaluationEngine.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.xds.internal.cel.Activation;\n+import io.grpc.xds.internal.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.cel.Dispatcher;\n+import io.grpc.xds.internal.cel.Interpreter;\n+import io.grpc.xds.internal.cel.InterpreterException;\n+import io.grpc.xds.internal.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Cel Evaluation Engine is part of the authorization framework in gRPC.\n+ * Cel Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * Cel Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  CelEvaluationEngine engine = new CelEvaluationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class CelEvaluationEngine<ReqT, RespT> {\n+  private final List<RBAC.Action> action;\n+  private final List<ImmutableMap<String, Expr>> conditions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQzODMyOQ==", "bodyText": "You can just use variable name rbac here otherwise rbacPolicy.getPolicies() looks a bit weird to me.\nAlso can we use range-based for loop hereI as well(like you did for the map)?", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455438329", "createdAt": "2020-07-16T00:20:43Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/CelEvaluationEngine.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.xds.internal.cel.Activation;\n+import io.grpc.xds.internal.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.cel.Dispatcher;\n+import io.grpc.xds.internal.cel.Interpreter;\n+import io.grpc.xds.internal.cel.InterpreterException;\n+import io.grpc.xds.internal.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Cel Evaluation Engine is part of the authorization framework in gRPC.\n+ * Cel Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * Cel Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  CelEvaluationEngine engine = new CelEvaluationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class CelEvaluationEngine<ReqT, RespT> {\n+  private final List<RBAC.Action> action;\n+  private final List<ImmutableMap<String, Expr>> conditions;\n+\n+  /**\n+   * Creates a Cel Evaluation Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public CelEvaluationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != RBAC.Action.DENY \n+        || rbacPolicies.get(1).getAction() != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.action = new ArrayList<>();\n+    this.conditions = new ArrayList<>();\n+    for (int i = 0; i < rbacPolicies.size(); i++) {\n+      RBAC rbacPolicy = rbacPolicies.get(i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0Mzk0MA==", "bodyText": "You can directly generate an ImmutableMap using ImmutableMap.Builder. No need to create one from Map.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455443940", "createdAt": "2020-07-16T00:41:29Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/CelEvaluationEngine.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.xds.internal.cel.Activation;\n+import io.grpc.xds.internal.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.cel.Dispatcher;\n+import io.grpc.xds.internal.cel.Interpreter;\n+import io.grpc.xds.internal.cel.InterpreterException;\n+import io.grpc.xds.internal.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Cel Evaluation Engine is part of the authorization framework in gRPC.\n+ * Cel Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * Cel Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  CelEvaluationEngine engine = new CelEvaluationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class CelEvaluationEngine<ReqT, RespT> {\n+  private final List<RBAC.Action> action;\n+  private final List<ImmutableMap<String, Expr>> conditions;\n+\n+  /**\n+   * Creates a Cel Evaluation Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public CelEvaluationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != RBAC.Action.DENY \n+        || rbacPolicies.get(1).getAction() != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.action = new ArrayList<>();\n+    this.conditions = new ArrayList<>();\n+    for (int i = 0; i < rbacPolicies.size(); i++) {\n+      RBAC rbacPolicy = rbacPolicies.get(i);\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> entry: rbacPolicy.getPolicies().entrySet()) {\n+        conditions.put(entry.getKey(), entry.getValue().getCondition());\n+      }\n+      this.action.add(Preconditions.checkNotNull(rbacPolicy.getAction()));\n+      this.conditions.add(Preconditions.checkNotNull(ImmutableMap.copyOf(conditions)));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of Cel Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by Cel Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.action.size() < 1 || this.action.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.action.size() == 2 && (this.action.get(0) != RBAC.Action.DENY \n+        || this.action.get(1) != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (int i = 0; i < this.action.size(); i++) {\n+      // Go through each condition in the RBAC policy.\n+      for (Map.Entry<String, Expr> entry : this.conditions.get(i).entrySet()) {\n+        try {\n+          if (matches(entry.getValue(), activation)) {\n+            if (this.action.get(i) == RBAC.Action.ALLOW) {\n+              authorizationDecision = AuthorizationDecision.Decision.ALLOW;\n+            } else {\n+              authorizationDecision = AuthorizationDecision.Decision.DENY;\n+            }\n+            matchingPolicyNames.add(entry.getKey());\n+          }\n+        } catch (InterpreterException e) {\n+          unknownPolicyNames.add(entry.getKey());\n+        }\n+      }\n+      if (matchingPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);\n+      }\n+    }\n+    // No RBAC conditions matched and found unknown conditions. \n+    if (unknownPolicyNames.size() > 0) {\n+      authorizationDecision = AuthorizationDecision.Decision.UNKNOWN;\n+      return new AuthorizationDecision(authorizationDecision, unknownPolicyNames);\n+    }\n+    // No RBAC conditions matched and didn't find unknown conditions.\n+    if (this.action.size() == 1 && this.action.get(0) == RBAC.Action.DENY) {\n+      authorizationDecision = AuthorizationDecision.Decision.ALLOW;\n+    } else {\n+      authorizationDecision = AuthorizationDecision.Decision.DENY;\n+    }\n+    return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);\n+  }\n+\n+  /** Evaluate if a condition matches the given Enovy Attributes using Cel library. */\n+  protected boolean matches(Expr condition, Activation activation) throws InterpreterException {\n+    // Set up interpreter used in Cel library's eval function.\n+    List<Descriptor> descriptors = new ArrayList<>();\n+    RuntimeTypeProvider messageProvider = DescriptorMessageProvider.dynamicMessages(descriptors);\n+    Dispatcher dispatcher = DefaultDispatcher.create();\n+    Interpreter interpreter = new DefaultInterpreter(messageProvider, dispatcher);\n+    // Parse the generated result object to a boolean variable.\n+    Object result = interpreter.createInterpretable(condition).eval(activation);\n+    if (result instanceof Boolean) {\n+      return Boolean.parseBoolean(result.toString());\n+    }\n+    return false;\n+  }\n+\n+  /** Extract Envoy Attributes from EvaluateArgs. */\n+  protected ImmutableMap<String, Object> extractFields(EvaluateArgs<ReqT, RespT> args) {\n+    Map<String, Object> attributes = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0NDU3Mg==", "bodyText": "nit: range-based loop.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455444572", "createdAt": "2020-07-16T00:43:52Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/CelEvaluationEngine.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.xds.internal.cel.Activation;\n+import io.grpc.xds.internal.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.cel.Dispatcher;\n+import io.grpc.xds.internal.cel.Interpreter;\n+import io.grpc.xds.internal.cel.InterpreterException;\n+import io.grpc.xds.internal.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Cel Evaluation Engine is part of the authorization framework in gRPC.\n+ * Cel Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * Cel Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  CelEvaluationEngine engine = new CelEvaluationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class CelEvaluationEngine<ReqT, RespT> {\n+  private final List<RBAC.Action> action;\n+  private final List<ImmutableMap<String, Expr>> conditions;\n+\n+  /**\n+   * Creates a Cel Evaluation Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public CelEvaluationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != RBAC.Action.DENY \n+        || rbacPolicies.get(1).getAction() != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.action = new ArrayList<>();\n+    this.conditions = new ArrayList<>();\n+    for (int i = 0; i < rbacPolicies.size(); i++) {\n+      RBAC rbacPolicy = rbacPolicies.get(i);\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> entry: rbacPolicy.getPolicies().entrySet()) {\n+        conditions.put(entry.getKey(), entry.getValue().getCondition());\n+      }\n+      this.action.add(Preconditions.checkNotNull(rbacPolicy.getAction()));\n+      this.conditions.add(Preconditions.checkNotNull(ImmutableMap.copyOf(conditions)));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of Cel Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by Cel Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.action.size() < 1 || this.action.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.action.size() == 2 && (this.action.get(0) != RBAC.Action.DENY \n+        || this.action.get(1) != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (int i = 0; i < this.action.size(); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0NDcxNQ==", "bodyText": "nit: avoid using vague names like \"entry\", etc.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455444715", "createdAt": "2020-07-16T00:44:21Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/CelEvaluationEngine.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.xds.internal.cel.Activation;\n+import io.grpc.xds.internal.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.cel.Dispatcher;\n+import io.grpc.xds.internal.cel.Interpreter;\n+import io.grpc.xds.internal.cel.InterpreterException;\n+import io.grpc.xds.internal.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Cel Evaluation Engine is part of the authorization framework in gRPC.\n+ * Cel Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * Cel Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  CelEvaluationEngine engine = new CelEvaluationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class CelEvaluationEngine<ReqT, RespT> {\n+  private final List<RBAC.Action> action;\n+  private final List<ImmutableMap<String, Expr>> conditions;\n+\n+  /**\n+   * Creates a Cel Evaluation Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public CelEvaluationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != RBAC.Action.DENY \n+        || rbacPolicies.get(1).getAction() != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.action = new ArrayList<>();\n+    this.conditions = new ArrayList<>();\n+    for (int i = 0; i < rbacPolicies.size(); i++) {\n+      RBAC rbacPolicy = rbacPolicies.get(i);\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> entry: rbacPolicy.getPolicies().entrySet()) {\n+        conditions.put(entry.getKey(), entry.getValue().getCondition());\n+      }\n+      this.action.add(Preconditions.checkNotNull(rbacPolicy.getAction()));\n+      this.conditions.add(Preconditions.checkNotNull(ImmutableMap.copyOf(conditions)));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of Cel Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by Cel Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.action.size() < 1 || this.action.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.action.size() == 2 && (this.action.get(0) != RBAC.Action.DENY \n+        || this.action.get(1) != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (int i = 0; i < this.action.size(); i++) {\n+      // Go through each condition in the RBAC policy.\n+      for (Map.Entry<String, Expr> entry : this.conditions.get(i).entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0NTIyOA==", "bodyText": "nit:\nauthorizationDecision = this.action.get(i) == RBAC.Action.ALLOW ? AuthorizationDecision.Decision.ALLOW : AuthorizationDecision.Decision.DENY", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455445228", "createdAt": "2020-07-16T00:46:08Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/CelEvaluationEngine.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.xds.internal.cel.Activation;\n+import io.grpc.xds.internal.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.cel.Dispatcher;\n+import io.grpc.xds.internal.cel.Interpreter;\n+import io.grpc.xds.internal.cel.InterpreterException;\n+import io.grpc.xds.internal.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Cel Evaluation Engine is part of the authorization framework in gRPC.\n+ * Cel Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * Cel Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  CelEvaluationEngine engine = new CelEvaluationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class CelEvaluationEngine<ReqT, RespT> {\n+  private final List<RBAC.Action> action;\n+  private final List<ImmutableMap<String, Expr>> conditions;\n+\n+  /**\n+   * Creates a Cel Evaluation Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public CelEvaluationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != RBAC.Action.DENY \n+        || rbacPolicies.get(1).getAction() != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.action = new ArrayList<>();\n+    this.conditions = new ArrayList<>();\n+    for (int i = 0; i < rbacPolicies.size(); i++) {\n+      RBAC rbacPolicy = rbacPolicies.get(i);\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> entry: rbacPolicy.getPolicies().entrySet()) {\n+        conditions.put(entry.getKey(), entry.getValue().getCondition());\n+      }\n+      this.action.add(Preconditions.checkNotNull(rbacPolicy.getAction()));\n+      this.conditions.add(Preconditions.checkNotNull(ImmutableMap.copyOf(conditions)));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of Cel Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by Cel Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.action.size() < 1 || this.action.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.action.size() == 2 && (this.action.get(0) != RBAC.Action.DENY \n+        || this.action.get(1) != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (int i = 0; i < this.action.size(); i++) {\n+      // Go through each condition in the RBAC policy.\n+      for (Map.Entry<String, Expr> entry : this.conditions.get(i).entrySet()) {\n+        try {\n+          if (matches(entry.getValue(), activation)) {\n+            if (this.action.get(i) == RBAC.Action.ALLOW) {\n+              authorizationDecision = AuthorizationDecision.Decision.ALLOW;\n+            } else {\n+              authorizationDecision = AuthorizationDecision.Decision.DENY;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0NTU3NQ==", "bodyText": "when action is unknown, we will need to return a unknownPolicyNames; when action is allow/deny, we will need matchingPolicyNames. So actually we just need one list here.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455445575", "createdAt": "2020-07-16T00:47:31Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/CelEvaluationEngine.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.xds.internal.cel.Activation;\n+import io.grpc.xds.internal.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.cel.Dispatcher;\n+import io.grpc.xds.internal.cel.Interpreter;\n+import io.grpc.xds.internal.cel.InterpreterException;\n+import io.grpc.xds.internal.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Cel Evaluation Engine is part of the authorization framework in gRPC.\n+ * Cel Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * Cel Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  CelEvaluationEngine engine = new CelEvaluationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class CelEvaluationEngine<ReqT, RespT> {\n+  private final List<RBAC.Action> action;\n+  private final List<ImmutableMap<String, Expr>> conditions;\n+\n+  /**\n+   * Creates a Cel Evaluation Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public CelEvaluationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != RBAC.Action.DENY \n+        || rbacPolicies.get(1).getAction() != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.action = new ArrayList<>();\n+    this.conditions = new ArrayList<>();\n+    for (int i = 0; i < rbacPolicies.size(); i++) {\n+      RBAC rbacPolicy = rbacPolicies.get(i);\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> entry: rbacPolicy.getPolicies().entrySet()) {\n+        conditions.put(entry.getKey(), entry.getValue().getCondition());\n+      }\n+      this.action.add(Preconditions.checkNotNull(rbacPolicy.getAction()));\n+      this.conditions.add(Preconditions.checkNotNull(ImmutableMap.copyOf(conditions)));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of Cel Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by Cel Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.action.size() < 1 || this.action.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.action.size() == 2 && (this.action.get(0) != RBAC.Action.DENY \n+        || this.action.get(1) != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ0ODgxNw==", "bodyText": "Let's change this to\nif (this.action.size() == 1 && this.action.get(0) == RBAC.Action.DENY) {\n      return new AuthorizationDecision(AuthorizationDecision.Decision.ALLOW, matchingPolicyNames);\n} \nreturn new AuthorizationDecision(AuthorizationDecision.Decision.DENY, matchingPolicyNames);\n\nSo basically we want to first pick out the special case, and do whatever we want for the rest, to avoid embedded if-else statements.\nAlso if matchingPolicyNames should always be empty in this case, consider adding a check before the if statement, or explicitly return an empty list.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r455448817", "createdAt": "2020-07-16T00:59:59Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/CelEvaluationEngine.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.xds.internal.cel.Activation;\n+import io.grpc.xds.internal.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.cel.Dispatcher;\n+import io.grpc.xds.internal.cel.Interpreter;\n+import io.grpc.xds.internal.cel.InterpreterException;\n+import io.grpc.xds.internal.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Cel Evaluation Engine is part of the authorization framework in gRPC.\n+ * Cel Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * Cel Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  CelEvaluationEngine engine = new CelEvaluationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class CelEvaluationEngine<ReqT, RespT> {\n+  private final List<RBAC.Action> action;\n+  private final List<ImmutableMap<String, Expr>> conditions;\n+\n+  /**\n+   * Creates a Cel Evaluation Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public CelEvaluationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != RBAC.Action.DENY \n+        || rbacPolicies.get(1).getAction() != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.action = new ArrayList<>();\n+    this.conditions = new ArrayList<>();\n+    for (int i = 0; i < rbacPolicies.size(); i++) {\n+      RBAC rbacPolicy = rbacPolicies.get(i);\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> entry: rbacPolicy.getPolicies().entrySet()) {\n+        conditions.put(entry.getKey(), entry.getValue().getCondition());\n+      }\n+      this.action.add(Preconditions.checkNotNull(rbacPolicy.getAction()));\n+      this.conditions.add(Preconditions.checkNotNull(ImmutableMap.copyOf(conditions)));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of Cel Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by Cel Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.action.size() < 1 || this.action.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.action.size() == 2 && (this.action.get(0) != RBAC.Action.DENY \n+        || this.action.get(1) != RBAC.Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (int i = 0; i < this.action.size(); i++) {\n+      // Go through each condition in the RBAC policy.\n+      for (Map.Entry<String, Expr> entry : this.conditions.get(i).entrySet()) {\n+        try {\n+          if (matches(entry.getValue(), activation)) {\n+            if (this.action.get(i) == RBAC.Action.ALLOW) {\n+              authorizationDecision = AuthorizationDecision.Decision.ALLOW;\n+            } else {\n+              authorizationDecision = AuthorizationDecision.Decision.DENY;\n+            }\n+            matchingPolicyNames.add(entry.getKey());\n+          }\n+        } catch (InterpreterException e) {\n+          unknownPolicyNames.add(entry.getKey());\n+        }\n+      }\n+      if (matchingPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);\n+      }\n+    }\n+    // No RBAC conditions matched and found unknown conditions. \n+    if (unknownPolicyNames.size() > 0) {\n+      authorizationDecision = AuthorizationDecision.Decision.UNKNOWN;\n+      return new AuthorizationDecision(authorizationDecision, unknownPolicyNames);\n+    }\n+    // No RBAC conditions matched and didn't find unknown conditions.\n+    if (this.action.size() == 1 && this.action.get(0) == RBAC.Action.DENY) {\n+      authorizationDecision = AuthorizationDecision.Decision.ALLOW;\n+    } else {\n+      authorizationDecision = AuthorizationDecision.Decision.DENY;\n+    }\n+    return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17fd01592608b46af8eacc4c3079f9f4f64fa7a3"}, "originalPosition": 143}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d66f0250a2ba43524f7334f13fe6b262d8ac32cb", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/d66f0250a2ba43524f7334f13fe6b262d8ac32cb", "committedDate": "2020-07-16T03:26:19Z", "message": "Review comments #1 - resolved nit issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a03e0ca5be8c3042a697b777c97ce2313735e09f", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/a03e0ca5be8c3042a697b777c97ce2313735e09f", "committedDate": "2020-07-16T03:54:10Z", "message": "Used ImmutableMap builder to build ImmutableMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "122e9979dba536d949050c9d8f3156131e1adfc4", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/122e9979dba536d949050c9d8f3156131e1adfc4", "committedDate": "2020-07-16T03:41:30Z", "message": "Used ImmutableMap builder to build ImmutableMap"}, "afterCommit": {"oid": "a03e0ca5be8c3042a697b777c97ce2313735e09f", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/a03e0ca5be8c3042a697b777c97ce2313735e09f", "committedDate": "2020-07-16T03:54:10Z", "message": "Used ImmutableMap builder to build ImmutableMap"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e2a1405cfb48cee37674433363da19f5dc9727c1", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/e2a1405cfb48cee37674433363da19f5dc9727c1", "committedDate": "2020-07-16T18:49:01Z", "message": "Added an inner class RbacEngine to wrap action and condition fields"}, "afterCommit": {"oid": "c4f3542dd3d19ec73837334fac6e22db9280d4c9", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/c4f3542dd3d19ec73837334fac6e22db9280d4c9", "committedDate": "2020-07-16T19:18:01Z", "message": "Added an inner class RbacEngine to wrap action and condition fields"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75f4575a3d7503d9ff7377ec03eb01fc8e0f7993", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/75f4575a3d7503d9ff7377ec03eb01fc8e0f7993", "committedDate": "2020-07-16T19:23:15Z", "message": "Added an inner class RbacEngine to wrap action and condition fields"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c4f3542dd3d19ec73837334fac6e22db9280d4c9", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/c4f3542dd3d19ec73837334fac6e22db9280d4c9", "committedDate": "2020-07-16T19:18:01Z", "message": "Added an inner class RbacEngine to wrap action and condition fields"}, "afterCommit": {"oid": "75f4575a3d7503d9ff7377ec03eb01fc8e0f7993", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/75f4575a3d7503d9ff7377ec03eb01fc8e0f7993", "committedDate": "2020-07-16T19:23:15Z", "message": "Added an inner class RbacEngine to wrap action and condition fields"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb21aeceb15469296e891a326c3a90bbd8bb5345", "author": {"user": {"login": "cindyxue", "name": "Cindy Xue"}}, "url": "https://github.com/grpc/grpc-java/commit/bb21aeceb15469296e891a326c3a90bbd8bb5345", "committedDate": "2020-07-18T03:57:50Z", "message": "Merged master branch\n\nMerge with master branch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bf2da7a3f93da20e5c5c46d647b55ed4168064a", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/4bf2da7a3f93da20e5c5c46d647b55ed4168064a", "committedDate": "2020-07-18T04:19:03Z", "message": "Changed package name for Cel Engine"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "310e725be68be08f931a84befbf173ab44822ced", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/310e725be68be08f931a84befbf173ab44822ced", "committedDate": "2020-07-19T23:35:15Z", "message": "Restructured unit test for cel evaluation which is able to take rbac with multiple policies now"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c71c92b271c81d5f70408df52f327d07faff499", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/6c71c92b271c81d5f70408df52f327d07faff499", "committedDate": "2020-07-20T20:30:33Z", "message": "Updated cel engine and unit tests based on new decision logic"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ba49de7f5157a7057bb086c99a3ec04156951fd0", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/ba49de7f5157a7057bb086c99a3ec04156951fd0", "committedDate": "2020-07-20T19:03:45Z", "message": "Updated cel engine and unit tests based on new decision logic"}, "afterCommit": {"oid": "6c71c92b271c81d5f70408df52f327d07faff499", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/6c71c92b271c81d5f70408df52f327d07faff499", "committedDate": "2020-07-20T20:30:33Z", "message": "Updated cel engine and unit tests based on new decision logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a0d1caaf088834027d3c4844f0c0d325453f63f", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/9a0d1caaf088834027d3c4844f0c0d325453f63f", "committedDate": "2020-07-22T18:48:14Z", "message": "Renamed CelEngine to AuthorizationEngine"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "284144bc586fb6dae24d06b73b7f74dc5b7e3058", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/284144bc586fb6dae24d06b73b7f74dc5b7e3058", "committedDate": "2020-07-23T19:31:24Z", "message": "Updated matches function to handle unsuccessful evaluation and incomplete attributes"}, "afterCommit": {"oid": "c7a5a7a73b94eaad9b9d428e74a905d0c3337bc5", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/c7a5a7a73b94eaad9b9d428e74a905d0c3337bc5", "committedDate": "2020-07-23T19:59:12Z", "message": "Updated matches function to handle unsuccessful evaluation and incomplete attributes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c7a5a7a73b94eaad9b9d428e74a905d0c3337bc5", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/c7a5a7a73b94eaad9b9d428e74a905d0c3337bc5", "committedDate": "2020-07-23T19:59:12Z", "message": "Updated matches function to handle unsuccessful evaluation and incomplete attributes"}, "afterCommit": {"oid": "9a20315153097991e4de88a3f704b2af1f376e82", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/9a20315153097991e4de88a3f704b2af1f376e82", "committedDate": "2020-07-23T20:13:32Z", "message": "Updated matches function to handle unsuccessful evaluation and incomplete attributes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9a20315153097991e4de88a3f704b2af1f376e82", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/9a20315153097991e4de88a3f704b2af1f376e82", "committedDate": "2020-07-23T20:13:32Z", "message": "Updated matches function to handle unsuccessful evaluation and incomplete attributes"}, "afterCommit": {"oid": "f867d922aee9110ab0f89fe8b3ba5648348086b2", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/f867d922aee9110ab0f89fe8b3ba5648348086b2", "committedDate": "2020-07-24T01:41:11Z", "message": "Updated matches function to handle unsuccessful evaluation and incomplete attributes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "93ccf7a93333e44b7b1ceb7e670d6ee0bd8f8ed8", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/93ccf7a93333e44b7b1ceb7e670d6ee0bd8f8ed8", "committedDate": "2020-07-31T16:37:47Z", "message": "Revised javadoc comment"}, "afterCommit": {"oid": "9a0d1caaf088834027d3c4844f0c0d325453f63f", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/9a0d1caaf088834027d3c4844f0c0d325453f63f", "committedDate": "2020-07-22T18:48:14Z", "message": "Renamed CelEngine to AuthorizationEngine"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2bbd7b93f040b91cf11eb71b7be24e52602f2055", "author": {"user": {"login": "cindyxue", "name": "Cindy Xue"}}, "url": "https://github.com/grpc/grpc-java/commit/2bbd7b93f040b91cf11eb71b7be24e52602f2055", "committedDate": "2020-07-31T21:24:38Z", "message": "Merged master branch"}, "afterCommit": {"oid": "9a0d1caaf088834027d3c4844f0c0d325453f63f", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/9a0d1caaf088834027d3c4844f0c0d325453f63f", "committedDate": "2020-07-22T18:48:14Z", "message": "Renamed CelEngine to AuthorizationEngine"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4c3ec8c2deee07c161ef87072a145632c287fba", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/a4c3ec8c2deee07c161ef87072a145632c287fba", "committedDate": "2020-07-31T22:30:12Z", "message": "Updated matches function to handle unsuccessful evaluation and incomplete attributes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e6f5a8d1b4408d443669bb243603c80bc0546220", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/e6f5a8d1b4408d443669bb243603c80bc0546220", "committedDate": "2020-07-31T21:26:02Z", "message": "Updated matches function to handle unsuccessful evaluation and incomplete attributes"}, "afterCommit": {"oid": "a4c3ec8c2deee07c161ef87072a145632c287fba", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/a4c3ec8c2deee07c161ef87072a145632c287fba", "committedDate": "2020-07-31T22:30:12Z", "message": "Updated matches function to handle unsuccessful evaluation and incomplete attributes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d38b1f494d4a719dd54a45ff11f4ee076adbdc2", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/0d38b1f494d4a719dd54a45ff11f4ee076adbdc2", "committedDate": "2020-07-31T22:42:22Z", "message": "Merge branch 'master' into Cindy/CelEvaluationEngine"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65c31bda15da82ddf56726044a8adc80df9455ef", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/65c31bda15da82ddf56726044a8adc80df9455ef", "committedDate": "2020-08-01T03:06:16Z", "message": "Merge branch 'master' into Cindy/CelEvaluationEngine"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5Njg5MjM0", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-459689234", "createdAt": "2020-08-02T23:44:41Z", "commit": {"oid": "65c31bda15da82ddf56726044a8adc80df9455ef"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQyMzo0NDo0MVrOG6ovUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QwMDoyNjoxN1rOG6pCAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzODA2NQ==", "bodyText": "nit: shall we change this variable name to policyNames? CEL expression is used to check if matches. At the level of authorization engine, we might not need to use the term matching, to avoid confusion.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464138065", "createdAt": "2020-08-02T23:44:41Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationDecision.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import java.lang.StringBuilder;\n+import java.util.List;\n+\n+/** \n+ * The AuthorizationDecision class holds authorization decision \n+ * returned by CEL Evaluation Engine. \n+ */\n+public class AuthorizationDecision {\n+  /** The Decision enum represents the possible decisions outputted by CEL Evaluation Engine.*/\n+  public enum Decision {\n+    /** \n+     * The Decision ALLOW indicates that CEL Evaluate Engine \n+     * had authorized the gRPC call and allowed the gRPC call to go through.\n+     */\n+    ALLOW,\n+    /** \n+     * The Decision DENY indicates that CEL Evaluate Engine \n+     * had authorized the gRPC call and denied the gRPC call from going through.\n+     */\n+    DENY,\n+    /** \n+     * The Decision UNKNOWN indicates that CEL Evaluate Engine \n+     * did not have enough information to authorize the gRPC call. \n+     * */\n+    UNKNOWN,\n+  }\n+\n+  private final Decision decision;\n+  private final List<String> matchingPolicyNames;\n+\n+  /**\n+   * Creates a new authorization decision using the input {@code decision} \n+   * for resolving authorization decision\n+   * and {@code matchingPolicyNames} for resolving authorization context.\n+   */\n+  public AuthorizationDecision(Decision decision, List<String> matchingPolicyNames) {\n+    this.decision = decision;\n+    this.matchingPolicyNames = matchingPolicyNames;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65c31bda15da82ddf56726044a8adc80df9455ef"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzODI1Ng==", "bodyText": "Can we use some other names for authContext? such as authzStr, or decisionStr, etc.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464138256", "createdAt": "2020-08-02T23:46:00Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationDecision.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import java.lang.StringBuilder;\n+import java.util.List;\n+\n+/** \n+ * The AuthorizationDecision class holds authorization decision \n+ * returned by CEL Evaluation Engine. \n+ */\n+public class AuthorizationDecision {\n+  /** The Decision enum represents the possible decisions outputted by CEL Evaluation Engine.*/\n+  public enum Decision {\n+    /** \n+     * The Decision ALLOW indicates that CEL Evaluate Engine \n+     * had authorized the gRPC call and allowed the gRPC call to go through.\n+     */\n+    ALLOW,\n+    /** \n+     * The Decision DENY indicates that CEL Evaluate Engine \n+     * had authorized the gRPC call and denied the gRPC call from going through.\n+     */\n+    DENY,\n+    /** \n+     * The Decision UNKNOWN indicates that CEL Evaluate Engine \n+     * did not have enough information to authorize the gRPC call. \n+     * */\n+    UNKNOWN,\n+  }\n+\n+  private final Decision decision;\n+  private final List<String> matchingPolicyNames;\n+\n+  /**\n+   * Creates a new authorization decision using the input {@code decision} \n+   * for resolving authorization decision\n+   * and {@code matchingPolicyNames} for resolving authorization context.\n+   */\n+  public AuthorizationDecision(Decision decision, List<String> matchingPolicyNames) {\n+    this.decision = decision;\n+    this.matchingPolicyNames = matchingPolicyNames;\n+  }\n+\n+  /** Returns the authorization decision. */\n+  public Decision getDecision() {\n+    return this.decision;\n+  }\n+\n+  /** Returns the matching policy list. */\n+  public List<String> getMatchingPolicyNames() {\n+    return this.matchingPolicyNames;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder authContext = new StringBuilder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65c31bda15da82ddf56726044a8adc80df9455ef"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzOTk3OQ==", "bodyText": "Can we directly use RBAC.Conditions here? If so, we probably can avoid creating our own map and can just use whatever provided by RBAC.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464139979", "createdAt": "2020-08-03T00:01:28Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65c31bda15da82ddf56726044a8adc80df9455ef"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MDUwOA==", "bodyText": "Interpreter will be created for every CEL evaluation checking. Let's move it outside of the loop.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464140508", "createdAt": "2020-08-03T00:06:42Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final List<RbacEngine> rbacEngines;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.rbacEngines = new ArrayList<>();\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      this.rbacEngines.add(new RbacEngine(\n+          Preconditions.checkNotNull(rbac.getAction()), \n+          Preconditions.checkNotNull(ImmutableMap.copyOf(conditions))));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.rbacEngines.size() < 1 || this.rbacEngines.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.rbacEngines.size() == 2 && (this.rbacEngines.get(0).action != Action.DENY \n+        || this.rbacEngines.get(1).action != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    // Set up activation used in CEL library's eval function.\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (RbacEngine rbacEngine : rbacEngines) {\n+      // Go through each condition in the RBAC policy.\n+      for (Map.Entry<String, Expr> condition : rbacEngine.conditions.entrySet()) {\n+        try {\n+          if (matches(condition.getValue(), activation)) {\n+            authorizationDecision = rbacEngine.action == Action.ALLOW \n+                ? AuthorizationDecision.Decision.ALLOW : AuthorizationDecision.Decision.DENY;\n+            matchingPolicyNames.add(condition.getKey());\n+          }\n+        } catch (InterpreterException e) {\n+          unknownPolicyNames.add(condition.getKey());\n+        }\n+      }\n+      if (matchingPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);\n+      }\n+      if (unknownPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(\n+            AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);\n+      }\n+    }\n+    // No RBAC conditions matched and didn't find unknown conditions.\n+    if (this.rbacEngines.size() == 1 && this.rbacEngines.get(0).action == Action.DENY) {\n+      return new AuthorizationDecision(\n+          AuthorizationDecision.Decision.ALLOW, new ArrayList<String>());\n+    }\n+    return new AuthorizationDecision(AuthorizationDecision.Decision.DENY, new ArrayList<String>());\n+  }\n+\n+  /** Evaluate if a condition matches the given Enovy Attributes using CEL library. */\n+  protected boolean matches(Expr condition, Activation activation) throws InterpreterException {\n+    // Set up interpreter used in CEL library's eval function.\n+    List<Descriptor> descriptors = new ArrayList<>();\n+    RuntimeTypeProvider messageProvider = DescriptorMessageProvider.dynamicMessages(descriptors);\n+    Dispatcher dispatcher = DefaultDispatcher.create();\n+    Interpreter interpreter = new DefaultInterpreter(messageProvider, dispatcher);\n+    // Parse the generated result object to a boolean variable.\n+    try {\n+      Object result = interpreter.createInterpretable(condition).eval(activation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65c31bda15da82ddf56726044a8adc80df9455ef"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MTEwMg==", "bodyText": "As far as I understand, the design of part is still ongoing yet. In this PR, we can assume evaluate function takes the activation and gRPC stack will set it directly(so in this PR we don't have to deal with that EvaluateArgs<ReqT, RespT> args anymore).\n@jiangtaoli2016 Feel free to correct me if this is not our current plan. Thanks!", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464141102", "createdAt": "2020-08-03T00:11:44Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final List<RbacEngine> rbacEngines;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.rbacEngines = new ArrayList<>();\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      this.rbacEngines.add(new RbacEngine(\n+          Preconditions.checkNotNull(rbac.getAction()), \n+          Preconditions.checkNotNull(ImmutableMap.copyOf(conditions))));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.rbacEngines.size() < 1 || this.rbacEngines.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.rbacEngines.size() == 2 && (this.rbacEngines.get(0).action != Action.DENY \n+        || this.rbacEngines.get(1).action != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    // Set up activation used in CEL library's eval function.\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (RbacEngine rbacEngine : rbacEngines) {\n+      // Go through each condition in the RBAC policy.\n+      for (Map.Entry<String, Expr> condition : rbacEngine.conditions.entrySet()) {\n+        try {\n+          if (matches(condition.getValue(), activation)) {\n+            authorizationDecision = rbacEngine.action == Action.ALLOW \n+                ? AuthorizationDecision.Decision.ALLOW : AuthorizationDecision.Decision.DENY;\n+            matchingPolicyNames.add(condition.getKey());\n+          }\n+        } catch (InterpreterException e) {\n+          unknownPolicyNames.add(condition.getKey());\n+        }\n+      }\n+      if (matchingPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);\n+      }\n+      if (unknownPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(\n+            AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);\n+      }\n+    }\n+    // No RBAC conditions matched and didn't find unknown conditions.\n+    if (this.rbacEngines.size() == 1 && this.rbacEngines.get(0).action == Action.DENY) {\n+      return new AuthorizationDecision(\n+          AuthorizationDecision.Decision.ALLOW, new ArrayList<String>());\n+    }\n+    return new AuthorizationDecision(AuthorizationDecision.Decision.DENY, new ArrayList<String>());\n+  }\n+\n+  /** Evaluate if a condition matches the given Enovy Attributes using CEL library. */\n+  protected boolean matches(Expr condition, Activation activation) throws InterpreterException {\n+    // Set up interpreter used in CEL library's eval function.\n+    List<Descriptor> descriptors = new ArrayList<>();\n+    RuntimeTypeProvider messageProvider = DescriptorMessageProvider.dynamicMessages(descriptors);\n+    Dispatcher dispatcher = DefaultDispatcher.create();\n+    Interpreter interpreter = new DefaultInterpreter(messageProvider, dispatcher);\n+    // Parse the generated result object to a boolean variable.\n+    try {\n+      Object result = interpreter.createInterpretable(condition).eval(activation);\n+      if (result instanceof Boolean) {\n+        return Boolean.valueOf(result.toString());\n+      }\n+      // Throw an InterpreterException if there are missing Envoy Attributes.\n+      if (result instanceof IncompleteData) {\n+        throw new InterpreterException.Builder(\"Incomplete Envoy Attributes to be evaluated.\")\n+            .build(); \n+      }\n+    } catch (InterpreterException e) {\n+      // If any InterpreterExceptions are catched, throw it and log the error.\n+      log.log(Level.WARNING, e.toString(), e);\n+      throw e;\n+    }\n+    return false;\n+  }\n+\n+  /** Extract Envoy Attributes from EvaluateArgs. */\n+  protected ImmutableMap<String, Object> extractFields(EvaluateArgs<ReqT, RespT> args) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65c31bda15da82ddf56726044a8adc80df9455ef"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MjE2OA==", "bodyText": "if matches is only used once, can we move it to the evaluate logic? It might simplify the logic to handle IncompleteData.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464142168", "createdAt": "2020-08-03T00:21:04Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final List<RbacEngine> rbacEngines;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.rbacEngines = new ArrayList<>();\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      this.rbacEngines.add(new RbacEngine(\n+          Preconditions.checkNotNull(rbac.getAction()), \n+          Preconditions.checkNotNull(ImmutableMap.copyOf(conditions))));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.rbacEngines.size() < 1 || this.rbacEngines.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.rbacEngines.size() == 2 && (this.rbacEngines.get(0).action != Action.DENY \n+        || this.rbacEngines.get(1).action != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    // Set up activation used in CEL library's eval function.\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (RbacEngine rbacEngine : rbacEngines) {\n+      // Go through each condition in the RBAC policy.\n+      for (Map.Entry<String, Expr> condition : rbacEngine.conditions.entrySet()) {\n+        try {\n+          if (matches(condition.getValue(), activation)) {\n+            authorizationDecision = rbacEngine.action == Action.ALLOW \n+                ? AuthorizationDecision.Decision.ALLOW : AuthorizationDecision.Decision.DENY;\n+            matchingPolicyNames.add(condition.getKey());\n+          }\n+        } catch (InterpreterException e) {\n+          unknownPolicyNames.add(condition.getKey());\n+        }\n+      }\n+      if (matchingPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);\n+      }\n+      if (unknownPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(\n+            AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);\n+      }\n+    }\n+    // No RBAC conditions matched and didn't find unknown conditions.\n+    if (this.rbacEngines.size() == 1 && this.rbacEngines.get(0).action == Action.DENY) {\n+      return new AuthorizationDecision(\n+          AuthorizationDecision.Decision.ALLOW, new ArrayList<String>());\n+    }\n+    return new AuthorizationDecision(AuthorizationDecision.Decision.DENY, new ArrayList<String>());\n+  }\n+\n+  /** Evaluate if a condition matches the given Enovy Attributes using CEL library. */\n+  protected boolean matches(Expr condition, Activation activation) throws InterpreterException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65c31bda15da82ddf56726044a8adc80df9455ef"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0Mjg0OA==", "bodyText": "Now when there is a match, we will only return the policy that first matches and return it in a list. So if there is a match, we will do an early stop and return a list containing only 1 item. We might also want to slightly change the logic we check the RBACs(So we will first check the first RABC, if it's undecided, then the result would be the decision of second RBAC). You can checkout the latest design details in @jiangtaoli2016 's doc, or check with Elizabeth. Please LMK if you have any questions. Thanks!", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464142848", "createdAt": "2020-08-03T00:26:17Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final List<RbacEngine> rbacEngines;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.rbacEngines = new ArrayList<>();\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      this.rbacEngines.add(new RbacEngine(\n+          Preconditions.checkNotNull(rbac.getAction()), \n+          Preconditions.checkNotNull(ImmutableMap.copyOf(conditions))));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.rbacEngines.size() < 1 || this.rbacEngines.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.rbacEngines.size() == 2 && (this.rbacEngines.get(0).action != Action.DENY \n+        || this.rbacEngines.get(1).action != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65c31bda15da82ddf56726044a8adc80df9455ef"}, "originalPosition": 127}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4def2622ab97ef95d96a39a5c0e02077eafa51e", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/e4def2622ab97ef95d96a39a5c0e02077eafa51e", "committedDate": "2020-08-03T04:10:30Z", "message": "Resolved Zhen's comments pt.2"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fa67284cd343387fe81844340012cfd10300aebb", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/fa67284cd343387fe81844340012cfd10300aebb", "committedDate": "2020-08-03T03:34:59Z", "message": "Changed variable names to make it more readable"}, "afterCommit": {"oid": "e4def2622ab97ef95d96a39a5c0e02077eafa51e", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/e4def2622ab97ef95d96a39a5c0e02077eafa51e", "committedDate": "2020-08-03T04:10:30Z", "message": "Resolved Zhen's comments pt.2"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMTIzOTk0", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-460123994", "createdAt": "2020-08-03T15:29:18Z", "commit": {"oid": "e4def2622ab97ef95d96a39a5c0e02077eafa51e"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNToyOToxOVrOG6-JfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxNjowNDozMFrOG6_cbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4ODgyOQ==", "bodyText": "Since we don't allow changing the policyNames, use ImmutableList", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464488829", "createdAt": "2020-08-03T15:29:19Z", "author": {"login": "jiangtaoli2016"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationDecision.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import java.lang.StringBuilder;\n+import java.util.List;\n+\n+/** \n+ * The AuthorizationDecision class holds authorization decision \n+ * returned by CEL Evaluation Engine. \n+ */\n+public class AuthorizationDecision {\n+  /** The Decision enum represents the possible decisions outputted by CEL Evaluation Engine.*/\n+  public enum Decision {\n+    /** \n+     * The Decision ALLOW indicates that CEL Evaluate Engine \n+     * had authorized the gRPC call and allowed the gRPC call to go through.\n+     */\n+    ALLOW,\n+    /** \n+     * The Decision DENY indicates that CEL Evaluate Engine \n+     * had authorized the gRPC call and denied the gRPC call from going through.\n+     */\n+    DENY,\n+    /** \n+     * The Decision UNKNOWN indicates that CEL Evaluate Engine \n+     * did not have enough information to authorize the gRPC call. \n+     * */\n+    UNKNOWN,\n+  }\n+\n+  private final Decision decision;\n+  private final List<String> policyNames;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4def2622ab97ef95d96a39a5c0e02077eafa51e"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5NjY2MQ==", "bodyText": "I would keep the current API, i.e.,\nAuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args)\nAlso keep the extractFields -- so that we can test it.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464496661", "createdAt": "2020-08-03T15:42:06Z", "author": {"login": "jiangtaoli2016"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final List<RbacEngine> rbacEngines;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.rbacEngines = new ArrayList<>();\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      this.rbacEngines.add(new RbacEngine(\n+          Preconditions.checkNotNull(rbac.getAction()), \n+          Preconditions.checkNotNull(ImmutableMap.copyOf(conditions))));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.rbacEngines.size() < 1 || this.rbacEngines.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.rbacEngines.size() == 2 && (this.rbacEngines.get(0).action != Action.DENY \n+        || this.rbacEngines.get(1).action != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    // Set up activation used in CEL library's eval function.\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (RbacEngine rbacEngine : rbacEngines) {\n+      // Go through each condition in the RBAC policy.\n+      for (Map.Entry<String, Expr> condition : rbacEngine.conditions.entrySet()) {\n+        try {\n+          if (matches(condition.getValue(), activation)) {\n+            authorizationDecision = rbacEngine.action == Action.ALLOW \n+                ? AuthorizationDecision.Decision.ALLOW : AuthorizationDecision.Decision.DENY;\n+            matchingPolicyNames.add(condition.getKey());\n+          }\n+        } catch (InterpreterException e) {\n+          unknownPolicyNames.add(condition.getKey());\n+        }\n+      }\n+      if (matchingPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);\n+      }\n+      if (unknownPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(\n+            AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);\n+      }\n+    }\n+    // No RBAC conditions matched and didn't find unknown conditions.\n+    if (this.rbacEngines.size() == 1 && this.rbacEngines.get(0).action == Action.DENY) {\n+      return new AuthorizationDecision(\n+          AuthorizationDecision.Decision.ALLOW, new ArrayList<String>());\n+    }\n+    return new AuthorizationDecision(AuthorizationDecision.Decision.DENY, new ArrayList<String>());\n+  }\n+\n+  /** Evaluate if a condition matches the given Enovy Attributes using CEL library. */\n+  protected boolean matches(Expr condition, Activation activation) throws InterpreterException {\n+    // Set up interpreter used in CEL library's eval function.\n+    List<Descriptor> descriptors = new ArrayList<>();\n+    RuntimeTypeProvider messageProvider = DescriptorMessageProvider.dynamicMessages(descriptors);\n+    Dispatcher dispatcher = DefaultDispatcher.create();\n+    Interpreter interpreter = new DefaultInterpreter(messageProvider, dispatcher);\n+    // Parse the generated result object to a boolean variable.\n+    try {\n+      Object result = interpreter.createInterpretable(condition).eval(activation);\n+      if (result instanceof Boolean) {\n+        return Boolean.valueOf(result.toString());\n+      }\n+      // Throw an InterpreterException if there are missing Envoy Attributes.\n+      if (result instanceof IncompleteData) {\n+        throw new InterpreterException.Builder(\"Incomplete Envoy Attributes to be evaluated.\")\n+            .build(); \n+      }\n+    } catch (InterpreterException e) {\n+      // If any InterpreterExceptions are catched, throw it and log the error.\n+      log.log(Level.WARNING, e.toString(), e);\n+      throw e;\n+    }\n+    return false;\n+  }\n+\n+  /** Extract Envoy Attributes from EvaluateArgs. */\n+  protected ImmutableMap<String, Object> extractFields(EvaluateArgs<ReqT, RespT> args) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MTEwMg=="}, "originalCommit": {"oid": "65c31bda15da82ddf56726044a8adc80df9455ef"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUwMjYxMg==", "bodyText": "Eventually we don't need RbacEngine.\nAuthorizationEngine just need to keep two InternalAuthorzationPolicy proto (allowPolicy and denyPolicy).\nDuring constructor of AuthorizationEngine:\n\nif input is Envoy RBAC, we just convert to InternalAuthorzationPolicy\nif input is InternalAuthorzationPolicy, we just store input internally.\n\nIn Evaluate(), we just first iterate denyPolicy then allowPolicy.\nFor now, let's keep as it is.\nOnce my design is signed off, I will make a PR for the AuthorizatioPolicy proto.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464502612", "createdAt": "2020-08-03T15:51:58Z", "author": {"login": "jiangtaoli2016"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEzOTk3OQ=="}, "originalCommit": {"oid": "65c31bda15da82ddf56726044a8adc80df9455ef"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUwNTE5Mw==", "bodyText": "nit: make it static\nstatic private class RbacEngine", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464505193", "createdAt": "2020-08-03T15:56:09Z", "author": {"login": "jiangtaoli2016"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4def2622ab97ef95d96a39a5c0e02077eafa51e"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUwNjg1Ng==", "bodyText": "I would explicitly have two engines: allowEngine and denyEngine, built from constructor.\nIf there is only one RBAC policy as input, we still have two engines, one of the engine has empty map though.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464506856", "createdAt": "2020-08-03T15:58:52Z", "author": {"login": "jiangtaoli2016"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final List<RbacEngine> rbacEngines;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4def2622ab97ef95d96a39a5c0e02077eafa51e"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUxMDA2Mw==", "bodyText": "Once you have allowEngine and denyEngine. See discussion above. The evaluation logic is as follows:\nFirst iterate denyEngine's map (could be empty map). If there is match, immediately return deny. If there are unknown results, return undecided. If all non-match, we iterate allowEngine.\nOnce we enter allowEngine, if there is a match, immediately return allow. In the end of iteration, if there are unknown rules, return undecided. If all non-match, return deny.\nThe above logic is the same regardless if the constructor takes 1 or 2 RBAC rules.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r464510063", "createdAt": "2020-08-03T16:04:30Z", "author": {"login": "jiangtaoli2016"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final List<RbacEngine> rbacEngines;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.rbacEngines = new ArrayList<>();\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      this.rbacEngines.add(new RbacEngine(\n+          Preconditions.checkNotNull(rbac.getAction()), \n+          Preconditions.checkNotNull(ImmutableMap.copyOf(conditions))));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.rbacEngines.size() < 1 || this.rbacEngines.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.rbacEngines.size() == 2 && (this.rbacEngines.get(0).action != Action.DENY \n+        || this.rbacEngines.get(1).action != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0Mjg0OA=="}, "originalCommit": {"oid": "65c31bda15da82ddf56726044a8adc80df9455ef"}, "originalPosition": 127}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "598bc4a391dcffe4609f230c24a1e27599a7213d", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/598bc4a391dcffe4609f230c24a1e27599a7213d", "committedDate": "2020-08-03T16:35:53Z", "message": "Resolved Jiangtao's comments"}, "afterCommit": {"oid": "d590b35322ad35a13d815fd3337615863f4a86a4", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/d590b35322ad35a13d815fd3337615863f4a86a4", "committedDate": "2020-08-03T19:05:21Z", "message": "Resolved Jiangtao's comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d590b35322ad35a13d815fd3337615863f4a86a4", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/d590b35322ad35a13d815fd3337615863f4a86a4", "committedDate": "2020-08-03T19:05:21Z", "message": "Resolved Jiangtao's comments"}, "afterCommit": {"oid": "00d018a8ca8afb535fc9f8bf4c4b59830fdb9262", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/00d018a8ca8afb535fc9f8bf4c4b59830fdb9262", "committedDate": "2020-08-03T19:16:40Z", "message": "Resolved Jiangtao's comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "00d018a8ca8afb535fc9f8bf4c4b59830fdb9262", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/00d018a8ca8afb535fc9f8bf4c4b59830fdb9262", "committedDate": "2020-08-03T19:16:40Z", "message": "Resolved Jiangtao's comments"}, "afterCommit": {"oid": "bcc7f0f9d7ba3c2d4c50de01105c5d1915445cac", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/bcc7f0f9d7ba3c2d4c50de01105c5d1915445cac", "committedDate": "2020-08-03T19:19:54Z", "message": "Resolved Jiangtao's comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bcc7f0f9d7ba3c2d4c50de01105c5d1915445cac", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/bcc7f0f9d7ba3c2d4c50de01105c5d1915445cac", "committedDate": "2020-08-03T19:19:54Z", "message": "Resolved Jiangtao's comments"}, "afterCommit": {"oid": "91b3835e2eb7de0c8dc75796590bd656248ab684", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/91b3835e2eb7de0c8dc75796590bd656248ab684", "committedDate": "2020-08-03T19:26:10Z", "message": "Resolved Jiangtao's comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "91b3835e2eb7de0c8dc75796590bd656248ab684", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/91b3835e2eb7de0c8dc75796590bd656248ab684", "committedDate": "2020-08-03T19:26:10Z", "message": "Resolved Jiangtao's comments"}, "afterCommit": {"oid": "3ef75f16f9a1687f284fa2947b82b9536ad7f1c5", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/3ef75f16f9a1687f284fa2947b82b9536ad7f1c5", "committedDate": "2020-08-03T19:26:42Z", "message": "Resolved Jiangtao's comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3ef75f16f9a1687f284fa2947b82b9536ad7f1c5", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/3ef75f16f9a1687f284fa2947b82b9536ad7f1c5", "committedDate": "2020-08-03T19:26:42Z", "message": "Resolved Jiangtao's comments"}, "afterCommit": {"oid": "ee29c98b1f332595f223e3c46f7e7802800d83b1", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/ee29c98b1f332595f223e3c46f7e7802800d83b1", "committedDate": "2020-08-03T20:22:22Z", "message": "Resolved Jiangtao's comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ee29c98b1f332595f223e3c46f7e7802800d83b1", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/ee29c98b1f332595f223e3c46f7e7802800d83b1", "committedDate": "2020-08-03T20:22:22Z", "message": "Resolved Jiangtao's comments"}, "afterCommit": {"oid": "63e65e98269bf63e8a61f7bd145dddb0fb7fe048", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/63e65e98269bf63e8a61f7bd145dddb0fb7fe048", "committedDate": "2020-08-03T20:51:52Z", "message": "Resolved Jiangtao's comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "63e65e98269bf63e8a61f7bd145dddb0fb7fe048", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/63e65e98269bf63e8a61f7bd145dddb0fb7fe048", "committedDate": "2020-08-03T20:51:52Z", "message": "Resolved Jiangtao's comments"}, "afterCommit": {"oid": "2fa798fa85c5d4b4066649f590f277d3608b45b2", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/2fa798fa85c5d4b4066649f590f277d3608b45b2", "committedDate": "2020-08-03T21:36:33Z", "message": "Resolved Jiangtao's comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2fa798fa85c5d4b4066649f590f277d3608b45b2", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/2fa798fa85c5d4b4066649f590f277d3608b45b2", "committedDate": "2020-08-03T21:36:33Z", "message": "Resolved Jiangtao's comments"}, "afterCommit": {"oid": "bf3556e792c1bf024043ee1c7cd1782d0cace08d", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/bf3556e792c1bf024043ee1c7cd1782d0cace08d", "committedDate": "2020-08-03T21:44:09Z", "message": "Resolved Jiangtao's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb9d66ae38890ccbb5fede9bb0767f6715519334", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/bb9d66ae38890ccbb5fede9bb0767f6715519334", "committedDate": "2020-08-03T22:03:24Z", "message": "Resolved Jiangtao's comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bf3556e792c1bf024043ee1c7cd1782d0cace08d", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/bf3556e792c1bf024043ee1c7cd1782d0cace08d", "committedDate": "2020-08-03T21:44:09Z", "message": "Resolved Jiangtao's comments"}, "afterCommit": {"oid": "bb9d66ae38890ccbb5fede9bb0767f6715519334", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/bb9d66ae38890ccbb5fede9bb0767f6715519334", "committedDate": "2020-08-03T22:03:24Z", "message": "Resolved Jiangtao's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "baf4e4361699877f27439910b855e52222c3a0d5", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/baf4e4361699877f27439910b855e52222c3a0d5", "committedDate": "2020-08-05T16:47:53Z", "message": "Added source.principal field"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxODQ1ODc3", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-461845877", "createdAt": "2020-08-05T16:49:02Z", "commit": {"oid": "bb9d66ae38890ccbb5fede9bb0767f6715519334"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjo0OTowMlrOG8SI_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODowMTo0N1rOG8UtpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2NDk1OA==", "bodyText": "nit: you can directly setting this.allowEngine, without these local variables.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r465864958", "createdAt": "2020-08-05T16:49:02Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  private static class RbacEngine {\n+    @SuppressWarnings(\"UnusedVariable\")\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final RbacEngine allowEngine;\n+  private final RbacEngine denyEngine;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    RbacEngine allowEngine = null;\n+    RbacEngine denyEngine = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb9d66ae38890ccbb5fede9bb0767f6715519334"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3NzE4NQ==", "bodyText": "I guess you can also mock interpretable.eval(...) to achieve similar purposes, right?\nIMO, generally it is probably not a good idea to change the code structures to make the testing easier, unless you really have to. Also making this function protected also raised a bit of my concern(I guess you make it for testing purposes as well).\nBut honestly I am not sure about this as well. We can keep it as what it is right now, and see if other reviewers have any suggestions on that.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r465877185", "createdAt": "2020-08-05T17:09:18Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(rbacPolicies);\n+ *  AuthorizationDecision result = engine.evaluate();\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  @SuppressWarnings(\"ClassCanBeStatic\")\n+  private class RbacEngine {\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final List<RbacEngine> rbacEngines;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    this.rbacEngines = new ArrayList<>();\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new HashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      this.rbacEngines.add(new RbacEngine(\n+          Preconditions.checkNotNull(rbac.getAction()), \n+          Preconditions.checkNotNull(ImmutableMap.copyOf(conditions))));\n+    }\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   * @throws InterpreterException if something goes wrong in CEL library.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n+      throws IllegalArgumentException {\n+    if (this.rbacEngines.size() < 1 || this.rbacEngines.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (this.rbacEngines.size() == 2 && (this.rbacEngines.get(0).action != Action.DENY \n+        || this.rbacEngines.get(1).action != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    AuthorizationDecision.Decision authorizationDecision = null;\n+    List<String> matchingPolicyNames = new ArrayList<>();\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    // Set up activation used in CEL library's eval function.\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Go through each RBAC in the Envoy RBAC list.\n+    for (RbacEngine rbacEngine : rbacEngines) {\n+      // Go through each condition in the RBAC policy.\n+      for (Map.Entry<String, Expr> condition : rbacEngine.conditions.entrySet()) {\n+        try {\n+          if (matches(condition.getValue(), activation)) {\n+            authorizationDecision = rbacEngine.action == Action.ALLOW \n+                ? AuthorizationDecision.Decision.ALLOW : AuthorizationDecision.Decision.DENY;\n+            matchingPolicyNames.add(condition.getKey());\n+          }\n+        } catch (InterpreterException e) {\n+          unknownPolicyNames.add(condition.getKey());\n+        }\n+      }\n+      if (matchingPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(authorizationDecision, matchingPolicyNames);\n+      }\n+      if (unknownPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(\n+            AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);\n+      }\n+    }\n+    // No RBAC conditions matched and didn't find unknown conditions.\n+    if (this.rbacEngines.size() == 1 && this.rbacEngines.get(0).action == Action.DENY) {\n+      return new AuthorizationDecision(\n+          AuthorizationDecision.Decision.ALLOW, new ArrayList<String>());\n+    }\n+    return new AuthorizationDecision(AuthorizationDecision.Decision.DENY, new ArrayList<String>());\n+  }\n+\n+  /** Evaluate if a condition matches the given Enovy Attributes using CEL library. */\n+  protected boolean matches(Expr condition, Activation activation) throws InterpreterException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE0MjE2OA=="}, "originalCommit": {"oid": "65c31bda15da82ddf56726044a8adc80df9455ef"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwNTk5Mg==", "bodyText": "Some general thoughts on this: try not to use policy_1, policy_2, ...  for variables that could exist across functions. That would make the purposes of each variables very difficult to understand.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r465905992", "createdAt": "2020-08-05T17:59:46Z", "author": {"login": "ZhenLian"}, "path": "xds/src/test/java/io/grpc/xds/internal/rbac/engine/CelEvaluationTest.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.api.expr.v1alpha1.Expr.Ident;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import java.lang.StringBuilder;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for evaluate function of CEL Evaluation Engine. */\n+@RunWith(JUnit4.class)\n+public class CelEvaluationTest<ReqT, RespT> {\n+  @Rule\n+  public final MockitoRule mocks = MockitoJUnit.rule();\n+  \n+  @Mock\n+  private EvaluateArgs<ReqT,RespT> args;\n+\n+  @Mock\n+  private Activation activation;\n+\n+  @Mock\n+  private Map<String, Object> attributes;\n+\n+  private AuthorizationEngine<ReqT,RespT> engine;\n+  private AuthorizationEngine<ReqT,RespT> spyEngine;\n+  private AuthorizationDecision evaluateResult;\n+  private RBAC rbacAllow;\n+  private RBAC rbacDeny;\n+  private Policy policy1;\n+  private Policy policy2;\n+  private Policy policy3;\n+  private Policy policy4;\n+  private Policy policy5;\n+  private Policy policy6;\n+  private Expr condition1;\n+  private Expr condition2;\n+  private Expr condition3;\n+  private Expr condition4;\n+  private Expr condition5;\n+  private Expr condition6;\n+  \n+  @Before\n+  public void buildRbac() {\n+    // Set up RBAC condition.\n+    condition1 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 1\").build())\n+        .build();\n+    condition2 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 2\").build())\n+        .build();\n+    condition3 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 3\").build())\n+        .build();\n+    condition4 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 4\").build())\n+        .build();\n+    condition5 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 5\").build())\n+        .build();\n+    condition6 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 6\").build())\n+        .build();\n+    // Set up RBAC policy.\n+    policy1 = Policy.newBuilder().setCondition(condition1).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf4e4361699877f27439910b855e52222c3a0d5"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwNzEwOA==", "bodyText": "For a test this long, you can add some comments on the purposes of each policy, or try to break them down into small pieces. Otherwise it's a bit hard to keep track of what's tested in each small section.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r465907108", "createdAt": "2020-08-05T18:01:47Z", "author": {"login": "ZhenLian"}, "path": "xds/src/test/java/io/grpc/xds/internal/rbac/engine/CelEvaluationTest.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.api.expr.v1alpha1.Expr.Ident;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import java.lang.StringBuilder;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for evaluate function of CEL Evaluation Engine. */\n+@RunWith(JUnit4.class)\n+public class CelEvaluationTest<ReqT, RespT> {\n+  @Rule\n+  public final MockitoRule mocks = MockitoJUnit.rule();\n+  \n+  @Mock\n+  private EvaluateArgs<ReqT,RespT> args;\n+\n+  @Mock\n+  private Activation activation;\n+\n+  @Mock\n+  private Map<String, Object> attributes;\n+\n+  private AuthorizationEngine<ReqT,RespT> engine;\n+  private AuthorizationEngine<ReqT,RespT> spyEngine;\n+  private AuthorizationDecision evaluateResult;\n+  private RBAC rbacAllow;\n+  private RBAC rbacDeny;\n+  private Policy policy1;\n+  private Policy policy2;\n+  private Policy policy3;\n+  private Policy policy4;\n+  private Policy policy5;\n+  private Policy policy6;\n+  private Expr condition1;\n+  private Expr condition2;\n+  private Expr condition3;\n+  private Expr condition4;\n+  private Expr condition5;\n+  private Expr condition6;\n+  \n+  @Before\n+  public void buildRbac() {\n+    // Set up RBAC condition.\n+    condition1 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 1\").build())\n+        .build();\n+    condition2 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 2\").build())\n+        .build();\n+    condition3 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 3\").build())\n+        .build();\n+    condition4 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 4\").build())\n+        .build();\n+    condition5 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 5\").build())\n+        .build();\n+    condition6 = Expr.newBuilder()\n+        .setIdentExpr(Ident.newBuilder().setName(\"Condition 6\").build())\n+        .build();\n+    // Set up RBAC policy.\n+    policy1 = Policy.newBuilder().setCondition(condition1).build();\n+    policy2 = Policy.newBuilder().setCondition(condition2).build();\n+    policy3 = Policy.newBuilder().setCondition(condition3).build();\n+    policy4 = Policy.newBuilder().setCondition(condition4).build();\n+    policy5 = Policy.newBuilder().setCondition(condition5).build();\n+    policy6 = Policy.newBuilder().setCondition(condition6).build();\n+    // Set up RBAC.\n+    rbacAllow = RBAC.newBuilder()\n+        .setAction(Action.ALLOW)\n+        .putPolicies(\"Policy 1\", policy1)\n+        .putPolicies(\"Policy 2\", policy2)\n+        .putPolicies(\"Policy 3\", policy3)\n+        .build();\n+    rbacDeny = RBAC.newBuilder()\n+        .setAction(Action.DENY)\n+        .putPolicies(\"Policy 4\", policy4)\n+        .putPolicies(\"Policy 5\", policy5)\n+        .putPolicies(\"Policy 6\", policy6)\n+        .build();\n+  }\n+\n+  @Before\n+  public void setupEngineSingleRbacAllow() {\n+    buildRbac();\n+    List<RBAC> rbacList = new ArrayList<>(Arrays.asList(new RBAC[] {rbacAllow}));\n+    engine = new AuthorizationEngine<>(ImmutableList.copyOf(rbacList));\n+    spyEngine = Mockito.spy(engine);\n+    doReturn(ImmutableMap.copyOf(attributes)).when(spyEngine).extractFields(\n+        ArgumentMatchers.<EvaluateArgs<ReqT,RespT>>any());\n+  }\n+\n+  @Before\n+  public void setupEngineSingleRbacDeny() {\n+    buildRbac();\n+    List<RBAC> rbacList = new ArrayList<>(Arrays.asList(new RBAC[] {rbacDeny}));\n+    engine = new AuthorizationEngine<>(ImmutableList.copyOf(rbacList));\n+    spyEngine = Mockito.spy(engine);\n+    doReturn(ImmutableMap.copyOf(attributes)).when(spyEngine).extractFields(\n+        ArgumentMatchers.<EvaluateArgs<ReqT,RespT>>any());\n+  }\n+\n+  @Before\n+  public void setupEngineRbacPair() {\n+    buildRbac();\n+    List<RBAC> rbacList = new ArrayList<>(Arrays.asList(new RBAC[] {rbacDeny, rbacAllow}));\n+    engine = new AuthorizationEngine<>(ImmutableList.copyOf(rbacList));\n+    spyEngine = Mockito.spy(engine);\n+    doReturn(ImmutableMap.copyOf(attributes)).when(spyEngine).extractFields(\n+        ArgumentMatchers.<EvaluateArgs<ReqT,RespT>>any());\n+  }\n+\n+  @Test\n+  public void testEvaluateEngineRbacAllow() throws InterpreterException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf4e4361699877f27439910b855e52222c3a0d5"}, "originalPosition": 158}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "807dd42d450371c39a0d35b33abbdf7902a0feab", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/807dd42d450371c39a0d35b33abbdf7902a0feab", "committedDate": "2020-08-05T20:51:27Z", "message": "Split up unit test into smaller pieces"}, "afterCommit": {"oid": "bd238afaf54349ef56683d60c6e34e19c12e2358", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/bd238afaf54349ef56683d60c6e34e19c12e2358", "committedDate": "2020-08-05T20:57:17Z", "message": "Split up unit test into smaller pieces"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bd238afaf54349ef56683d60c6e34e19c12e2358", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/bd238afaf54349ef56683d60c6e34e19c12e2358", "committedDate": "2020-08-05T20:57:17Z", "message": "Split up unit test into smaller pieces"}, "afterCommit": {"oid": "b46ae5ded873b466cd8d7cffa28a6c5bbf0ef005", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/b46ae5ded873b466cd8d7cffa28a6c5bbf0ef005", "committedDate": "2020-08-05T21:28:15Z", "message": "Split up unit test into smaller pieces"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b46ae5ded873b466cd8d7cffa28a6c5bbf0ef005", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/b46ae5ded873b466cd8d7cffa28a6c5bbf0ef005", "committedDate": "2020-08-05T21:28:15Z", "message": "Split up unit test into smaller pieces"}, "afterCommit": {"oid": "f6ba1e5b4bfd53fc25b7e59d4755f7414d0b4a20", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/f6ba1e5b4bfd53fc25b7e59d4755f7414d0b4a20", "committedDate": "2020-08-05T23:35:23Z", "message": "Split up unit test into smaller pieces"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f6ba1e5b4bfd53fc25b7e59d4755f7414d0b4a20", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/f6ba1e5b4bfd53fc25b7e59d4755f7414d0b4a20", "committedDate": "2020-08-05T23:35:23Z", "message": "Split up unit test into smaller pieces"}, "afterCommit": {"oid": "39dbf3ecd577dae9c8d76a3e43b8f5aea92f3b7e", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/39dbf3ecd577dae9c8d76a3e43b8f5aea92f3b7e", "committedDate": "2020-08-05T23:49:48Z", "message": "Split up unit test into smaller pieces"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5d3291faa4090cd3fd699e7ef51942aced48ee98", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/5d3291faa4090cd3fd699e7ef51942aced48ee98", "committedDate": "2020-08-05T23:50:59Z", "message": "Fixed constructor of CEL engine"}, "afterCommit": {"oid": "7e68169c1a05692410a60bed43f952412705dafd", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/7e68169c1a05692410a60bed43f952412705dafd", "committedDate": "2020-08-05T23:58:55Z", "message": "Fixed constructor of CEL engine"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7e68169c1a05692410a60bed43f952412705dafd", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/7e68169c1a05692410a60bed43f952412705dafd", "committedDate": "2020-08-05T23:58:55Z", "message": "Fixed constructor of CEL engine"}, "afterCommit": {"oid": "39dbf3ecd577dae9c8d76a3e43b8f5aea92f3b7e", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/39dbf3ecd577dae9c8d76a3e43b8f5aea92f3b7e", "committedDate": "2020-08-05T23:49:48Z", "message": "Split up unit test into smaller pieces"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "661ac0f8b66abc23ce554f87ff1077c41608fbed", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/661ac0f8b66abc23ce554f87ff1077c41608fbed", "committedDate": "2020-08-06T00:08:16Z", "message": "Split up unit test into smaller pieces"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "39dbf3ecd577dae9c8d76a3e43b8f5aea92f3b7e", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/39dbf3ecd577dae9c8d76a3e43b8f5aea92f3b7e", "committedDate": "2020-08-05T23:49:48Z", "message": "Split up unit test into smaller pieces"}, "afterCommit": {"oid": "661ac0f8b66abc23ce554f87ff1077c41608fbed", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/661ac0f8b66abc23ce554f87ff1077c41608fbed", "committedDate": "2020-08-06T00:08:16Z", "message": "Split up unit test into smaller pieces"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eee48bfffd740416da9c7f2cbb3b8f20fc6d7be0", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/eee48bfffd740416da9c7f2cbb3b8f20fc6d7be0", "committedDate": "2020-08-06T17:40:33Z", "message": "Added fake tests for attributes extraction"}, "afterCommit": {"oid": "9c28a4f4db1c400859436a8c444fc94117bc668b", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/9c28a4f4db1c400859436a8c444fc94117bc668b", "committedDate": "2020-08-06T17:54:22Z", "message": "Added fake tests for attributes extraction"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9c28a4f4db1c400859436a8c444fc94117bc668b", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/9c28a4f4db1c400859436a8c444fc94117bc668b", "committedDate": "2020-08-06T17:54:22Z", "message": "Added fake tests for attributes extraction"}, "afterCommit": {"oid": "1802a522c03b59ad78b9234cf2e4253b4d5b85a8", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/1802a522c03b59ad78b9234cf2e4253b4d5b85a8", "committedDate": "2020-08-06T18:13:58Z", "message": "Added fake tests for attributes extraction"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1802a522c03b59ad78b9234cf2e4253b4d5b85a8", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/1802a522c03b59ad78b9234cf2e4253b4d5b85a8", "committedDate": "2020-08-06T18:13:58Z", "message": "Added fake tests for attributes extraction"}, "afterCommit": {"oid": "cc7cc45ec764f5049b3af057ee4202bc7c2207e6", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/cc7cc45ec764f5049b3af057ee4202bc7c2207e6", "committedDate": "2020-08-06T18:42:08Z", "message": "Added fake tests for attributes extraction"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cc7cc45ec764f5049b3af057ee4202bc7c2207e6", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/cc7cc45ec764f5049b3af057ee4202bc7c2207e6", "committedDate": "2020-08-06T18:42:08Z", "message": "Added fake tests for attributes extraction"}, "afterCommit": {"oid": "d7511aea2c354fcc89c127d557dbb93ff3c0df26", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/d7511aea2c354fcc89c127d557dbb93ff3c0df26", "committedDate": "2020-08-06T19:24:44Z", "message": "Added fake tests for attributes extraction"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyODgxNTk1", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-462881595", "createdAt": "2020-08-06T21:14:21Z", "commit": {"oid": "d7511aea2c354fcc89c127d557dbb93ff3c0df26"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMToxNDoyMVrOG9EfuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMToxNDoyMVrOG9EfuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY4OTk3Nw==", "bodyText": "Just curious - why do we give up on throwing an exception here?", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r466689977", "createdAt": "2020-08-06T21:14:21Z", "author": {"login": "ZhenLian"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -119,10 +119,8 @@ public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgum\n    * Determines whether a gRPC call is allowed, denied, or unable to decide.\n    * @param args evaluate argument that is used to evaluate the RBAC conditions.\n    * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n-   * @throws InterpreterException if something goes wrong in CEL library.\n    */\n-  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) \n-      throws IllegalArgumentException {\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7511aea2c354fcc89c127d557dbb93ff3c0df26"}, "originalPosition": 8}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d7511aea2c354fcc89c127d557dbb93ff3c0df26", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/d7511aea2c354fcc89c127d557dbb93ff3c0df26", "committedDate": "2020-08-06T19:24:44Z", "message": "Added fake tests for attributes extraction"}, "afterCommit": {"oid": "d50ae19fe52afe9161b30984af7ebd24aab34b50", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/d50ae19fe52afe9161b30984af7ebd24aab34b50", "committedDate": "2020-08-06T21:50:41Z", "message": "Added fake tests for attributes extraction"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d50ae19fe52afe9161b30984af7ebd24aab34b50", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/d50ae19fe52afe9161b30984af7ebd24aab34b50", "committedDate": "2020-08-06T21:50:41Z", "message": "Added fake tests for attributes extraction"}, "afterCommit": {"oid": "337dba23ce34189be2aa35880dcd162b7fec9d7a", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/337dba23ce34189be2aa35880dcd162b7fec9d7a", "committedDate": "2020-08-06T22:28:27Z", "message": "Added fake tests for attributes extraction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "978d5bdca250141d50eb4975b09822dca6f842c3", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/978d5bdca250141d50eb4975b09822dca6f842c3", "committedDate": "2020-08-06T23:03:28Z", "message": "Added fake tests for attributes extraction"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "337dba23ce34189be2aa35880dcd162b7fec9d7a", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/337dba23ce34189be2aa35880dcd162b7fec9d7a", "committedDate": "2020-08-06T22:28:27Z", "message": "Added fake tests for attributes extraction"}, "afterCommit": {"oid": "978d5bdca250141d50eb4975b09822dca6f842c3", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/978d5bdca250141d50eb4975b09822dca6f842c3", "committedDate": "2020-08-06T23:03:28Z", "message": "Added fake tests for attributes extraction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/e76be48e2e58dd2b825e2d5dd4f213d76174e3f7", "committedDate": "2020-08-06T23:53:41Z", "message": "Added test for matches function"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNzA1MzIy", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-463705322", "createdAt": "2020-08-08T01:18:47Z", "commit": {"oid": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjEyOTMz", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-464612933", "createdAt": "2020-08-10T21:51:21Z", "commit": {"oid": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMTo1MToyMVrOG-hC5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMTo1MToyMVrOG-hC5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwNjMwOQ==", "bodyText": "Instead of accepting a list of size 1 or 2 why not accept 2 params: if both params present then 1st param is DENY RBAC and 2nd param ALLOW RBAC\nIs there a reason for a list (such as future enhancements) which is not documented here?", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468206309", "createdAt": "2020-08-10T21:51:21Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(\n+ *      ImmutableList.of(rbacPolicies));\n+ *  AuthorizationDecision result = engine.evaluate(new EvaluateArgs(call, headers));\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  private static class RbacEngine {\n+    @SuppressWarnings(\"UnusedVariable\")\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final RbacEngine allowEngine;\n+  private final RbacEngine denyEngine;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjE0MDMx", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-464614031", "createdAt": "2020-08-10T21:53:26Z", "commit": {"oid": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMTo1MzoyNlrOG-hGhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMTo1MzoyNlrOG-hGhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwNzIzOA==", "bodyText": "Why not final ?", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468207238", "createdAt": "2020-08-10T21:53:26Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(\n+ *      ImmutableList.of(rbacPolicies));\n+ *  AuthorizationDecision result = engine.evaluate(new EvaluateArgs(call, headers));\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjI0NDU2", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-464624456", "createdAt": "2020-08-10T22:14:34Z", "commit": {"oid": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMjoxNDozNFrOG-hnzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMjoxNDozNFrOG-hnzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxNTc1Ng==", "bodyText": "Not in this PR but from might be a better name than copyOf since the method creates an Activation from a Map?", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468215756", "createdAt": "2020-08-10T22:14:34Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(\n+ *      ImmutableList.of(rbacPolicies));\n+ *  AuthorizationDecision result = engine.evaluate(new EvaluateArgs(call, headers));\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  private static class RbacEngine {\n+    @SuppressWarnings(\"UnusedVariable\")\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final RbacEngine allowEngine;\n+  private final RbacEngine denyEngine;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    RbacEngine allowEngine = null;\n+    RbacEngine denyEngine = null;\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new LinkedHashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      if (rbac.getAction() == Action.ALLOW) {\n+        allowEngine = new RbacEngine(Action.ALLOW, ImmutableMap.copyOf(conditions));\n+      }\n+      if (rbac.getAction() == Action.DENY) {\n+        denyEngine = new RbacEngine(Action.DENY, ImmutableMap.copyOf(conditions));\n+      }\n+    }\n+    this.allowEngine = allowEngine;\n+    this.denyEngine = denyEngine;\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) {\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    // Set up activation used in CEL library's eval function.\n+    Activation activation = Activation.copyOf(extractFields(args));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7"}, "originalPosition": 126}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjI3MjA5", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-464627209", "createdAt": "2020-08-10T22:20:26Z", "commit": {"oid": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMjoyMDoyNlrOG-hwcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMjoyMDoyNlrOG-hwcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxNzk2OA==", "bodyText": "Will be good avoid repetition of Decision in AuthorizationDecision.Decision ? Just a suggestion.", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468217968", "createdAt": "2020-08-10T22:20:26Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationDecision.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.lang.StringBuilder;\n+import java.util.List;\n+\n+/** \n+ * The AuthorizationDecision class holds authorization decision \n+ * returned by CEL Evaluation Engine. \n+ */\n+public class AuthorizationDecision {\n+  /** The Decision enum represents the possible decisions outputted by CEL Evaluation Engine.*/\n+  public enum Decision {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjMxMDgw", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-464631080", "createdAt": "2020-08-10T22:29:22Z", "commit": {"oid": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMjoyOToyM1rOG-h88w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMjoyOToyM1rOG-h88w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyMTE3MQ==", "bodyText": "So the above 2 if clauses can be refactored to avoid repetition, right? The method takes an entrySet and AuthorizationDecision.Decision as params and you call it twice with (allowEngine.conditions.entrySet(), AuthorizationDecision.Decision.ALLOW) and (denyEngine.conditions.entrySet(), AuthorizationDecision.Decision.DENY).", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468221171", "createdAt": "2020-08-10T22:29:23Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(\n+ *      ImmutableList.of(rbacPolicies));\n+ *  AuthorizationDecision result = engine.evaluate(new EvaluateArgs(call, headers));\n+ * </pre>\n+ */\n+public class AuthorizationEngine<ReqT, RespT> {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  private static class RbacEngine {\n+    @SuppressWarnings(\"UnusedVariable\")\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final RbacEngine allowEngine;\n+  private final RbacEngine denyEngine;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    RbacEngine allowEngine = null;\n+    RbacEngine denyEngine = null;\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new LinkedHashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      if (rbac.getAction() == Action.ALLOW) {\n+        allowEngine = new RbacEngine(Action.ALLOW, ImmutableMap.copyOf(conditions));\n+      }\n+      if (rbac.getAction() == Action.DENY) {\n+        denyEngine = new RbacEngine(Action.DENY, ImmutableMap.copyOf(conditions));\n+      }\n+    }\n+    this.allowEngine = allowEngine;\n+    this.denyEngine = denyEngine;\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs<ReqT, RespT> args) {\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    // Set up activation used in CEL library's eval function.\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Iterate through denyEngine's map.\n+    // If there is match, immediately return deny. \n+    // If there are unknown results, return undecided. \n+    // If all non-match, then iterate through allowEngine.\n+    if (denyEngine != null) {\n+      for (Map.Entry<String, Expr> condition : denyEngine.conditions.entrySet()) {\n+        try {\n+          if (matches(condition.getValue(), activation)) {\n+            return new AuthorizationDecision(AuthorizationDecision.Decision.DENY, \n+                new ArrayList<String>(Arrays.asList(new String[] {condition.getKey()})));\n+          }\n+        } catch (InterpreterException e) {\n+          unknownPolicyNames.add(condition.getKey());\n+        }\n+      }\n+      if (unknownPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(\n+            AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);\n+      }\n+    }\n+    // Once we enter allowEngine, if there is a match, immediately return allow. \n+    // In the end of iteration, if there are unknown rules, return undecided.\n+    // If all non-match, return deny.\n+    if (allowEngine != null) {\n+      for (Map.Entry<String, Expr> condition : allowEngine.conditions.entrySet()) {\n+        try {\n+          if (matches(condition.getValue(), activation)) {\n+            return new AuthorizationDecision(AuthorizationDecision.Decision.ALLOW, \n+                new ArrayList<String>(Arrays.asList(new String[] {condition.getKey()})));\n+          }\n+        } catch (InterpreterException e) {\n+          unknownPolicyNames.add(condition.getKey());\n+        }\n+      }\n+      if (unknownPolicyNames.size() > 0) {\n+        return new AuthorizationDecision(\n+            AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7"}, "originalPosition": 165}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjUwNDE1", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-464650415", "createdAt": "2020-08-10T23:20:48Z", "commit": {"oid": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMzoyMDo0OFrOG-i-nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMzoyMDo0OFrOG-i-nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzNzk4Mw==", "bodyText": "This is a general comment/question that applies to multiple classes in this PR and not just this class. I noticed the use of ReqT, RespT as type params which causes all of these classes (EvaluateArgs in this example) to be generic types. However these type params always (unless I miss somewhere) are ultimately plumbed down to a ServerCall<ReqT, RespT> and serve no other purpose. So in your code itself you never use ReqT, RespT to define/reference any generic types. In that case if you just use ServerCall<?, ?> do you lose any functionality or even type checks offered by the Java compiler? I suspect the answer is no .", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468237983", "createdAt": "2020-08-10T23:20:48Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/EvaluateArgs.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import io.grpc.Grpc;\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+\n+/** The EvaluateArgs class holds evaluate arguments used in CEL Evaluation Engine. */\n+public class EvaluateArgs<ReqT, RespT> {\n+  private Metadata headers;\n+  private ServerCall<ReqT, RespT> call;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76be48e2e58dd2b825e2d5dd4f213d76174e3f7"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "218211826f95c3807e492d5fc6a2851e54b036c2", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/218211826f95c3807e492d5fc6a2851e54b036c2", "committedDate": "2020-08-10T23:45:43Z", "message": "Removed useless <ReqT, RespT>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d989faef9e560286834ddbe23a01380ab902aba", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/4d989faef9e560286834ddbe23a01380ab902aba", "committedDate": "2020-08-11T00:25:06Z", "message": "Refactor code for evaluating a single engine"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzE0OTA0", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-464714904", "createdAt": "2020-08-11T02:55:05Z", "commit": {"oid": "4d989faef9e560286834ddbe23a01380ab902aba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjo1NTowNVrOG-mmPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjo1NTowNVrOG-mmPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5NzI3Nw==", "bodyText": "Shouldn't this belong to EvaluateArgs? It should know how to generate a Map out of its field values. Otherwise you are exposing fields like request.method here. You can call the method (there) generateEnvoyAttributes (based on the comment here)", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468297277", "createdAt": "2020-08-11T02:55:05Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(\n+ *      ImmutableList.of(rbacPolicies));\n+ *  AuthorizationDecision result = engine.evaluate(new EvaluateArgs(call, headers));\n+ * </pre>\n+ */\n+public class AuthorizationEngine {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  private static class RbacEngine {\n+    @SuppressWarnings(\"UnusedVariable\")\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final RbacEngine allowEngine;\n+  private final RbacEngine denyEngine;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    RbacEngine allowEngine = null;\n+    RbacEngine denyEngine = null;\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new LinkedHashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      if (rbac.getAction() == Action.ALLOW) {\n+        allowEngine = new RbacEngine(Action.ALLOW, ImmutableMap.copyOf(conditions));\n+      }\n+      if (rbac.getAction() == Action.DENY) {\n+        denyEngine = new RbacEngine(Action.DENY, ImmutableMap.copyOf(conditions));\n+      }\n+    }\n+    this.allowEngine = allowEngine;\n+    this.denyEngine = denyEngine;\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs args) {\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    // Set up activation used in CEL library's eval function.\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Iterate through denyEngine's map.\n+    // If there is match, immediately return deny. \n+    // If there are unknown results, return undecided. \n+    // If all non-match, then iterate through allowEngine.\n+    if (denyEngine != null) {\n+      AuthorizationDecision authzDecision = evaluateEngine(denyEngine.conditions.entrySet(), \n+          AuthorizationDecision.Decision.DENY, unknownPolicyNames, activation);\n+      if (authzDecision != null) {\n+        return authzDecision;\n+      }\n+    }\n+    // Once we enter allowEngine, if there is a match, immediately return allow. \n+    // In the end of iteration, if there are unknown rules, return undecided.\n+    // If all non-match, return deny.\n+    if (allowEngine != null) {\n+      AuthorizationDecision authzDecision = evaluateEngine(allowEngine.conditions.entrySet(), \n+          AuthorizationDecision.Decision.ALLOW, unknownPolicyNames, activation);\n+      if (authzDecision != null) {\n+        return authzDecision;\n+      }\n+    }\n+    // Only has a denyEngine and it\u2019s unmatched.\n+    if (this.allowEngine == null && this.denyEngine != null) {\n+      return new AuthorizationDecision(\n+          AuthorizationDecision.Decision.ALLOW, new ArrayList<String>());\n+    }\n+    // None of denyEngine and allowEngine matched, or the single Allow Engine is unmatched.\n+    return new AuthorizationDecision(AuthorizationDecision.Decision.DENY, new ArrayList<String>());\n+  }\n+\n+  /** Evaluate a single RbacEngine. */\n+  protected AuthorizationDecision evaluateEngine(Set<Map.Entry<String, Expr>> entrySet, \n+      AuthorizationDecision.Decision decision, List<String> unknownPolicyNames, \n+      Activation activation) {\n+    for (Map.Entry<String, Expr> condition : entrySet) {\n+      try {\n+        if (matches(condition.getValue(), activation)) {\n+          return new AuthorizationDecision(decision, \n+              new ArrayList<String>(Arrays.asList(new String[] {condition.getKey()})));\n+        }\n+      } catch (InterpreterException e) {\n+        unknownPolicyNames.add(condition.getKey());\n+      }\n+    }\n+    if (unknownPolicyNames.size() > 0) {\n+      return new AuthorizationDecision(\n+          AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);\n+    }\n+    return null;\n+  }\n+\n+  /** Evaluate if a condition matches the given Enovy Attributes using CEL library. */\n+  protected boolean matches(Expr condition, Activation activation) throws InterpreterException {\n+    // Set up interpretable used in CEL library's eval function.\n+    List<Descriptor> descriptors = new ArrayList<>();\n+    RuntimeTypeProvider messageProvider = DescriptorMessageProvider.dynamicMessages(descriptors);\n+    Dispatcher dispatcher = DefaultDispatcher.create();\n+    Interpreter interpreter = new DefaultInterpreter(messageProvider, dispatcher);\n+    Interpretable interpretable = interpreter.createInterpretable(condition);\n+    // Parse the generated result object to a boolean variable.\n+    try {\n+      Object result = interpretable.eval(activation);\n+      if (result instanceof Boolean) {\n+        return Boolean.valueOf(result.toString());\n+      }\n+      // Throw an InterpreterException if there are missing Envoy Attributes.\n+      if (result instanceof IncompleteData) {\n+        throw new InterpreterException.Builder(\"Incomplete Envoy Attributes to be evaluated.\")\n+            .build(); \n+      }\n+    } catch (InterpreterException e) {\n+      // If any InterpreterExceptions are catched, throw it and log the error.\n+      log.log(Level.WARNING, e.toString(), e);\n+      throw e;\n+    }\n+    return false;\n+  }\n+\n+  /** Extract Envoy Attributes from EvaluateArgs. */\n+  protected ImmutableMap<String, Object> extractFields(EvaluateArgs args) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d989faef9e560286834ddbe23a01380ab902aba"}, "originalPosition": 207}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzE2NzQ5", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-464716749", "createdAt": "2020-08-11T03:01:24Z", "commit": {"oid": "4d989faef9e560286834ddbe23a01380ab902aba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzowMToyNFrOG-msnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzowMToyNFrOG-msnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5ODkwOA==", "bodyText": "Any reason for using getCall instead of directly using this.call? Mocking getCall could be the only reason but why would you mock a simple getter?", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468298908", "createdAt": "2020-08-11T03:01:24Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/EvaluateArgs.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import io.grpc.Grpc;\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+\n+/** The EvaluateArgs class holds evaluate arguments used in CEL Evaluation Engine. */\n+public class EvaluateArgs {\n+  private Metadata headers;\n+  private ServerCall<?, ?> call;\n+\n+  /**\n+   * Creates a new evaluate argument using the input {@code headers} for resolving headers\n+   * and {@code call} for resolving gRPC call.\n+   */\n+  public EvaluateArgs(Metadata headers, ServerCall<?, ?> call) {\n+    this.headers = headers;\n+    this.call = call;\n+  }\n+\n+  /** Return the headers. */\n+  public Metadata getHeaders() {\n+    return headers;\n+  }\n+\n+  /** Return the gRPC call. */\n+  public ServerCall<?, ?> getCall() {\n+    return call;\n+  }\n+\n+  /** Extract the request.url_path field. */\n+  public String getRequestUrlPath() {\n+    String requestUrlPath = this.getCall().getMethodDescriptor().getFullMethodName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d989faef9e560286834ddbe23a01380ab902aba"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzE4MDg0", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-464718084", "createdAt": "2020-08-11T03:06:18Z", "commit": {"oid": "4d989faef9e560286834ddbe23a01380ab902aba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzowNjoxOVrOG-mxFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzowNjoxOVrOG-mxFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwMDA1NQ==", "bodyText": "Couple of things about this test:\n\n\nwhich class are you testing? EvaluateArgs or AuthorizationEngine ? Ideally only one class. And like I said elsewhere if you had moved extractFields to EvaluateArgs there would be only one class to test\n\n\nmocking EvaluateArgs's getter methods is not very useful or trivial. Better would be to mock/spy ServerCall<?,?> call member inside EvaluateArgs which is more work but is a better test", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468300055", "createdAt": "2020-08-11T03:06:19Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/test/java/io/grpc/xds/internal/rbac/engine/AttributesExtractionTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.grpc.Metadata;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for evaluate argument. */\n+@RunWith(JUnit4.class)\n+public class AttributesExtractionTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d989faef9e560286834ddbe23a01380ab902aba"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzE5Mzk0", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-464719394", "createdAt": "2020-08-11T03:10:56Z", "commit": {"oid": "4d989faef9e560286834ddbe23a01380ab902aba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzoxMDo1NlrOG-m1ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzoxMDo1NlrOG-m1ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwMTIxNA==", "bodyText": "This can be static since it doesn't use any member vars? But this function really belongs to EvaluateArgs", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468301214", "createdAt": "2020-08-11T03:10:56Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(\n+ *      ImmutableList.of(rbacPolicies));\n+ *  AuthorizationDecision result = engine.evaluate(new EvaluateArgs(call, headers));\n+ * </pre>\n+ */\n+public class AuthorizationEngine {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  private static class RbacEngine {\n+    @SuppressWarnings(\"UnusedVariable\")\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = action;\n+      this.conditions = conditions;\n+    }\n+  }\n+\n+  private final RbacEngine allowEngine;\n+  private final RbacEngine denyEngine;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from a list of Envoy RBACs.\n+   * The constructor can take either one or two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param rbacPolicies input Envoy RBAC list.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(ImmutableList<RBAC> rbacPolicies) throws IllegalArgumentException {\n+    if (rbacPolicies.size() < 1 || rbacPolicies.size() > 2) {\n+      throw new IllegalArgumentException(\n+        \"Invalid RBAC list size, must provide either one RBAC or two RBACs. \");\n+    } \n+    if (rbacPolicies.size() == 2 && (rbacPolicies.get(0).getAction() != Action.DENY \n+        || rbacPolicies.get(1).getAction() != Action.ALLOW)) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    RbacEngine allowEngine = null;\n+    RbacEngine denyEngine = null;\n+    for (RBAC rbac : rbacPolicies) {\n+      Map<String, Expr> conditions = new LinkedHashMap<>();\n+      for (Map.Entry<String, Policy> rbacPolicy: rbac.getPolicies().entrySet()) {\n+        conditions.put(rbacPolicy.getKey(), rbacPolicy.getValue().getCondition());\n+      }\n+      if (rbac.getAction() == Action.ALLOW) {\n+        allowEngine = new RbacEngine(Action.ALLOW, ImmutableMap.copyOf(conditions));\n+      }\n+      if (rbac.getAction() == Action.DENY) {\n+        denyEngine = new RbacEngine(Action.DENY, ImmutableMap.copyOf(conditions));\n+      }\n+    }\n+    this.allowEngine = allowEngine;\n+    this.denyEngine = denyEngine;\n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs args) {\n+    List<String> unknownPolicyNames = new ArrayList<>();\n+    // Set up activation used in CEL library's eval function.\n+    Activation activation = Activation.copyOf(extractFields(args));\n+    // Iterate through denyEngine's map.\n+    // If there is match, immediately return deny. \n+    // If there are unknown results, return undecided. \n+    // If all non-match, then iterate through allowEngine.\n+    if (denyEngine != null) {\n+      AuthorizationDecision authzDecision = evaluateEngine(denyEngine.conditions.entrySet(), \n+          AuthorizationDecision.Decision.DENY, unknownPolicyNames, activation);\n+      if (authzDecision != null) {\n+        return authzDecision;\n+      }\n+    }\n+    // Once we enter allowEngine, if there is a match, immediately return allow. \n+    // In the end of iteration, if there are unknown rules, return undecided.\n+    // If all non-match, return deny.\n+    if (allowEngine != null) {\n+      AuthorizationDecision authzDecision = evaluateEngine(allowEngine.conditions.entrySet(), \n+          AuthorizationDecision.Decision.ALLOW, unknownPolicyNames, activation);\n+      if (authzDecision != null) {\n+        return authzDecision;\n+      }\n+    }\n+    // Only has a denyEngine and it\u2019s unmatched.\n+    if (this.allowEngine == null && this.denyEngine != null) {\n+      return new AuthorizationDecision(\n+          AuthorizationDecision.Decision.ALLOW, new ArrayList<String>());\n+    }\n+    // None of denyEngine and allowEngine matched, or the single Allow Engine is unmatched.\n+    return new AuthorizationDecision(AuthorizationDecision.Decision.DENY, new ArrayList<String>());\n+  }\n+\n+  /** Evaluate a single RbacEngine. */\n+  protected AuthorizationDecision evaluateEngine(Set<Map.Entry<String, Expr>> entrySet, \n+      AuthorizationDecision.Decision decision, List<String> unknownPolicyNames, \n+      Activation activation) {\n+    for (Map.Entry<String, Expr> condition : entrySet) {\n+      try {\n+        if (matches(condition.getValue(), activation)) {\n+          return new AuthorizationDecision(decision, \n+              new ArrayList<String>(Arrays.asList(new String[] {condition.getKey()})));\n+        }\n+      } catch (InterpreterException e) {\n+        unknownPolicyNames.add(condition.getKey());\n+      }\n+    }\n+    if (unknownPolicyNames.size() > 0) {\n+      return new AuthorizationDecision(\n+          AuthorizationDecision.Decision.UNKNOWN, unknownPolicyNames);\n+    }\n+    return null;\n+  }\n+\n+  /** Evaluate if a condition matches the given Enovy Attributes using CEL library. */\n+  protected boolean matches(Expr condition, Activation activation) throws InterpreterException {\n+    // Set up interpretable used in CEL library's eval function.\n+    List<Descriptor> descriptors = new ArrayList<>();\n+    RuntimeTypeProvider messageProvider = DescriptorMessageProvider.dynamicMessages(descriptors);\n+    Dispatcher dispatcher = DefaultDispatcher.create();\n+    Interpreter interpreter = new DefaultInterpreter(messageProvider, dispatcher);\n+    Interpretable interpretable = interpreter.createInterpretable(condition);\n+    // Parse the generated result object to a boolean variable.\n+    try {\n+      Object result = interpretable.eval(activation);\n+      if (result instanceof Boolean) {\n+        return Boolean.valueOf(result.toString());\n+      }\n+      // Throw an InterpreterException if there are missing Envoy Attributes.\n+      if (result instanceof IncompleteData) {\n+        throw new InterpreterException.Builder(\"Incomplete Envoy Attributes to be evaluated.\")\n+            .build(); \n+      }\n+    } catch (InterpreterException e) {\n+      // If any InterpreterExceptions are catched, throw it and log the error.\n+      log.log(Level.WARNING, e.toString(), e);\n+      throw e;\n+    }\n+    return false;\n+  }\n+\n+  /** Extract Envoy Attributes from EvaluateArgs. */\n+  protected ImmutableMap<String, Object> extractFields(EvaluateArgs args) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d989faef9e560286834ddbe23a01380ab902aba"}, "originalPosition": 207}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzIwMTk5", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-464720199", "createdAt": "2020-08-11T03:13:59Z", "commit": {"oid": "4d989faef9e560286834ddbe23a01380ab902aba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzoxMzo1OVrOG-m4SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMzoxMzo1OVrOG-m4SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODMwMTg5Nw==", "bodyText": "Can you mock the other properties of call to be able to better test your EvalutateArgs getters?", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r468301897", "createdAt": "2020-08-11T03:13:59Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/test/java/io/grpc/xds/internal/rbac/engine/EvaluateArgsTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.when;\n+\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Unit tests for evaluate argument. */\n+@RunWith(JUnit4.class)\n+public class EvaluateArgsTest<ReqT,RespT> {\n+  @Rule\n+  public final MockitoRule mocks = MockitoJUnit.rule();\n+\n+  @Mock\n+  private ServerCall<ReqT,RespT> call;\n+\n+  private EvaluateArgs args;\n+  \n+  @Test\n+  public void testEvaluateArgsAccessorFunctions() {\n+    args = new EvaluateArgs(new Metadata(), call);\n+    when(call.getAuthority()).thenReturn(\"fooapi.googleapis.com\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d989faef9e560286834ddbe23a01380ab902aba"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzIwNjU3", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-464720657", "createdAt": "2020-08-11T03:15:36Z", "commit": {"oid": "4d989faef9e560286834ddbe23a01380ab902aba"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "106bc62b99dd21aa4950203fe923ea87c0e04941", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/106bc62b99dd21aa4950203fe923ea87c0e04941", "committedDate": "2020-08-11T04:40:29Z", "message": "Moved extractFields from AuthzEngine to EvaluateArgs and renamed to generateEnvoyAttributes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8300230ca1441f360423c64789a6c6a9758f6b4", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/f8300230ca1441f360423c64789a6c6a9758f6b4", "committedDate": "2020-08-11T05:40:59Z", "message": "Added tests for getSourceAddress and getDestinationAddress"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad5c73bb1232b69e18e44bb764ddf13c5bbac556", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/ad5c73bb1232b69e18e44bb764ddf13c5bbac556", "committedDate": "2020-08-11T06:07:32Z", "message": "Renamed enum Decision to Output"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4a547dec11da88e965679d53ec19269be31d15b2", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/4a547dec11da88e965679d53ec19269be31d15b2", "committedDate": "2020-08-11T16:43:55Z", "message": "Separate AuthzEngine constructor"}, "afterCommit": {"oid": "47923382e65bc00ef095ef8d47e7f6ede2823b63", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/47923382e65bc00ef095ef8d47e7f6ede2823b63", "committedDate": "2020-08-11T17:03:38Z", "message": "Separate AuthzEngine constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab103c81f41c1c512423aa8457aabceeedd87aec", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/ab103c81f41c1c512423aa8457aabceeedd87aec", "committedDate": "2020-08-11T17:10:13Z", "message": "Separate AuthzEngine constructor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "47923382e65bc00ef095ef8d47e7f6ede2823b63", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/47923382e65bc00ef095ef8d47e7f6ede2823b63", "committedDate": "2020-08-11T17:03:38Z", "message": "Separate AuthzEngine constructor"}, "afterCommit": {"oid": "ab103c81f41c1c512423aa8457aabceeedd87aec", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/ab103c81f41c1c512423aa8457aabceeedd87aec", "committedDate": "2020-08-11T17:10:13Z", "message": "Separate AuthzEngine constructor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2ODcyODgx", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-466872881", "createdAt": "2020-08-13T15:27:11Z", "commit": {"oid": "ab103c81f41c1c512423aa8457aabceeedd87aec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNToyNzoxMlrOHAQxvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNToyNzoxMlrOHAQxvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzNjkyNQ==", "bodyText": "Consider using com.google.common.base.Preconditions.checkArgument like it is used everywhere else in grpc-java", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r470036925", "createdAt": "2020-08-13T15:27:12Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(\n+ *      ImmutableList.of(rbacPolicies));\n+ *  AuthorizationDecision result = engine.evaluate(new EvaluateArgs(call, headers));\n+ * </pre>\n+ */\n+public class AuthorizationEngine {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  private static class RbacEngine {\n+    @SuppressWarnings(\"UnusedVariable\")\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = Preconditions.checkNotNull(action);\n+      this.conditions = Preconditions.checkNotNull(conditions);\n+    }\n+  }\n+\n+  private final RbacEngine allowEngine;\n+  private final RbacEngine denyEngine;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from one Envoy RBAC.\n+   * @param rbacPolicy input Envoy RBAC policy.\n+   */\n+  public AuthorizationEngine(RBAC rbacPolicy) {\n+    Map<String, Expr> conditions = new LinkedHashMap<>();\n+    for (Map.Entry<String, Policy> policy: rbacPolicy.getPolicies().entrySet()) {\n+      conditions.put(policy.getKey(), policy.getValue().getCondition());\n+    }\n+    allowEngine = (rbacPolicy.getAction() == Action.ALLOW) \n+        ? new RbacEngine(Action.ALLOW, ImmutableMap.copyOf(conditions)) : null; \n+    denyEngine = (rbacPolicy.getAction() == Action.DENY) \n+        ? new RbacEngine(Action.DENY, ImmutableMap.copyOf(conditions)) : null; \n+  }\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param denyPolicy input Envoy RBAC policy with DENY action.\n+   * @param allowPolicy input Envoy RBAC policy with ALLOW action.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(RBAC denyPolicy, RBAC allowPolicy) throws IllegalArgumentException {\n+    if (denyPolicy.getAction() != Action.DENY || allowPolicy.getAction() != Action.ALLOW) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab103c81f41c1c512423aa8457aabceeedd87aec"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2ODgzODQ2", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-466883846", "createdAt": "2020-08-13T15:39:26Z", "commit": {"oid": "ab103c81f41c1c512423aa8457aabceeedd87aec"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozOToyNlrOHARRKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxNTozOToyNlrOHARRKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0NDk3MA==", "bodyText": "unknownPolicyNames belongs to this method and you are passing it to evaluateEngine twice and having that method return UNKNOWN based on the length of the array. What will be simpler/more elegant is to make the check in this method and have evaluateEngine return only ALLOW/DENY or null. Just a suggestion", "url": "https://github.com/grpc/grpc-java/pull/7191#discussion_r470044970", "createdAt": "2020-08-13T15:39:26Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/rbac/engine/AuthorizationEngine.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.rbac.engine;\n+\n+import com.google.api.expr.v1alpha1.Expr;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.protobuf.Descriptors.Descriptor;\n+import io.envoyproxy.envoy.config.rbac.v2.Policy;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC;\n+import io.envoyproxy.envoy.config.rbac.v2.RBAC.Action;\n+import io.grpc.xds.internal.rbac.engine.cel.Activation;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultDispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.DefaultInterpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.DescriptorMessageProvider;\n+import io.grpc.xds.internal.rbac.engine.cel.Dispatcher;\n+import io.grpc.xds.internal.rbac.engine.cel.IncompleteData;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpretable;\n+import io.grpc.xds.internal.rbac.engine.cel.Interpreter;\n+import io.grpc.xds.internal.rbac.engine.cel.InterpreterException;\n+import io.grpc.xds.internal.rbac.engine.cel.RuntimeTypeProvider;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * CEL Evaluation Engine is part of the authorization framework in gRPC.\n+ * CEL Evaluation Engine takes one or two Envoy RBAC policies as input\n+ * and uses CEL library to evaluate the condition field \n+ * inside each RBAC policy based on the provided Envoy Attributes. \n+ * CEL Evaluation Engine will generate an authorization decision which\n+ * could be ALLOW, DENY or UNKNOWN.\n+ * \n+ * <p>Use as in:\n+ * \n+ * <pre>\n+ *  AuthorizationEngine engine = new AuthorizationEngine(\n+ *      ImmutableList.of(rbacPolicies));\n+ *  AuthorizationDecision result = engine.evaluate(new EvaluateArgs(call, headers));\n+ * </pre>\n+ */\n+public class AuthorizationEngine {\n+  private static final Logger log = Logger.getLogger(AuthorizationEngine.class.getName());\n+  \n+  /**\n+   * RbacEngine is an inner class that holds RBAC action \n+   * and conditions of RBAC policy.\n+   */\n+  private static class RbacEngine {\n+    @SuppressWarnings(\"UnusedVariable\")\n+    private final Action action;\n+    private final ImmutableMap<String, Expr> conditions;\n+\n+    public RbacEngine(Action action, ImmutableMap<String, Expr> conditions) {\n+      this.action = Preconditions.checkNotNull(action);\n+      this.conditions = Preconditions.checkNotNull(conditions);\n+    }\n+  }\n+\n+  private final RbacEngine allowEngine;\n+  private final RbacEngine denyEngine;\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from one Envoy RBAC.\n+   * @param rbacPolicy input Envoy RBAC policy.\n+   */\n+  public AuthorizationEngine(RBAC rbacPolicy) {\n+    Map<String, Expr> conditions = new LinkedHashMap<>();\n+    for (Map.Entry<String, Policy> policy: rbacPolicy.getPolicies().entrySet()) {\n+      conditions.put(policy.getKey(), policy.getValue().getCondition());\n+    }\n+    allowEngine = (rbacPolicy.getAction() == Action.ALLOW) \n+        ? new RbacEngine(Action.ALLOW, ImmutableMap.copyOf(conditions)) : null; \n+    denyEngine = (rbacPolicy.getAction() == Action.DENY) \n+        ? new RbacEngine(Action.DENY, ImmutableMap.copyOf(conditions)) : null; \n+  }\n+\n+  /**\n+   * Creates a CEL-based Authorization Engine from two Envoy RBACs.\n+   * When it takes two RBACs, the order has to be a RBAC with DENY action\n+   * followed by a RBAC with ALLOW action.\n+   * @param denyPolicy input Envoy RBAC policy with DENY action.\n+   * @param allowPolicy input Envoy RBAC policy with ALLOW action.\n+   * @throws IllegalArgumentException if the user inputs an invalid RBAC list.\n+   */\n+  public AuthorizationEngine(RBAC denyPolicy, RBAC allowPolicy) throws IllegalArgumentException {\n+    if (denyPolicy.getAction() != Action.DENY || allowPolicy.getAction() != Action.ALLOW) {\n+      throw new IllegalArgumentException( \"Invalid RBAC list, \" \n+          + \"must provide a RBAC with DENY action followed by a RBAC with ALLOW action. \");\n+    }\n+    Map<String, Expr> denyConditions = new LinkedHashMap<>();\n+    for (Map.Entry<String, Policy> policy: denyPolicy.getPolicies().entrySet()) {\n+      denyConditions.put(policy.getKey(), policy.getValue().getCondition());\n+    }\n+    denyEngine = new RbacEngine(Action.DENY, ImmutableMap.copyOf(denyConditions));\n+    Map<String, Expr> allowConditions = new LinkedHashMap<>();\n+    for (Map.Entry<String, Policy> policy: allowPolicy.getPolicies().entrySet()) {\n+      allowConditions.put(policy.getKey(), policy.getValue().getCondition());\n+    }\n+    allowEngine = new RbacEngine(Action.ALLOW, ImmutableMap.copyOf(allowConditions));   \n+  }\n+\n+  /**\n+   * The evaluate function performs the core authorization mechanism of CEL Evaluation Engine.\n+   * Determines whether a gRPC call is allowed, denied, or unable to decide.\n+   * @param args evaluate argument that is used to evaluate the RBAC conditions.\n+   * @return an AuthorizationDecision generated by CEL Evaluation Engine.\n+   */\n+  public AuthorizationDecision evaluate(EvaluateArgs args) {\n+    List<String> unknownPolicyNames = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ab103c81f41c1c512423aa8457aabceeedd87aec"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2ODg1NDQw", "url": "https://github.com/grpc/grpc-java/pull/7191#pullrequestreview-466885440", "createdAt": "2020-08-13T15:41:19Z", "commit": {"oid": "ab103c81f41c1c512423aa8457aabceeedd87aec"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d334f3cf329740247619f24957d27563f441fc52", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/d334f3cf329740247619f24957d27563f441fc52", "committedDate": "2020-08-13T18:31:22Z", "message": "Used checkArgument for arg checking instead"}, "afterCommit": {"oid": "a1c8d9f7b83955903bcde0f4d09aa58e9243bfe4", "author": {"user": null}, "url": "https://github.com/grpc/grpc-java/commit/a1c8d9f7b83955903bcde0f4d09aa58e9243bfe4", "committedDate": "2020-08-13T18:56:44Z", "message": "Resolved Sanjay's review comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4302, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}