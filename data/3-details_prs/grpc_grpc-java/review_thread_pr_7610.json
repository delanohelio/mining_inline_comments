{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4NzE2NDk5", "number": 7610, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxOToyNzowM1rOE319ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMToyODo0M1rOE4XGzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTkxMjQyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ConfigSelectingClientCall.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxOToyNzowM1rOHxbMdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNDoyOToxNlrOHxqHnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU4NzgyOA==", "bodyText": "I don't think we should actually apply the config here. I think we should continue applying the config in ClientCallImpl. That most closely mirrors Envoy and makes it easier to avoiding relying on CallOptions (e.g., outbound max message size should be removed from call options eventually).", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r521587828", "createdAt": "2020-11-11T19:27:03Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ConfigSelectingClientCall.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.Context;\n+import io.grpc.Deadline;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.internal.ManagedChannelServiceConfig.MethodInfo;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A client call for a given channel that applies a given config selector when it starts.\n+ */\n+final class ConfigSelectingClientCall<ReqT, RespT> extends ForwardingClientCall<ReqT, RespT> {\n+\n+  private final InternalConfigSelector configSelector;\n+  private final Channel channel;\n+  private final Executor callExecutor;\n+  private final MethodDescriptor<ReqT, RespT> method;\n+  private final Context context;\n+  private CallOptions callOptions;\n+\n+  private ClientCall<ReqT, RespT> delegate;\n+\n+  ConfigSelectingClientCall(\n+      InternalConfigSelector configSelector, Channel channel, Executor channelExecutor,\n+      MethodDescriptor<ReqT, RespT> method,\n+      CallOptions callOptions) {\n+    this.configSelector = configSelector;\n+    this.channel = channel;\n+    this.method = method;\n+    this.callOptions = callOptions;\n+    this.callExecutor =\n+        callOptions.getExecutor() == null ? channelExecutor : callOptions.getExecutor();\n+    this.context = Context.current();\n+  }\n+\n+  @Override\n+  protected ClientCall<ReqT, RespT> delegate() {\n+    return delegate;\n+  }\n+\n+  @Override\n+  public void start(Listener<RespT> observer, Metadata headers) {\n+    PickSubchannelArgs args = new PickSubchannelArgsImpl(method, headers, callOptions);\n+    InternalConfigSelector.Result result = configSelector.selectConfig(args);\n+    Status status = result.getStatus();\n+    if (!status.isOk()) {\n+      executeCloseObserverInContext(observer, status);\n+      return;\n+    }\n+    ClientInterceptor interceptor = result.getInterceptor();\n+    ManagedChannelServiceConfig config = (ManagedChannelServiceConfig) result.getConfig();\n+    MethodInfo methodInfo = config.getMethodConfig(method);\n+    applyMethodConfig(methodInfo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55b0d078e1f53e7cef8bc03533041df215ac3cc"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzMjM0OA==", "bodyText": "Propagated methodInfo to ClientCallImpl via CallOptions now.", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r521832348", "createdAt": "2020-11-12T04:29:16Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ConfigSelectingClientCall.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.Context;\n+import io.grpc.Deadline;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.internal.ManagedChannelServiceConfig.MethodInfo;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A client call for a given channel that applies a given config selector when it starts.\n+ */\n+final class ConfigSelectingClientCall<ReqT, RespT> extends ForwardingClientCall<ReqT, RespT> {\n+\n+  private final InternalConfigSelector configSelector;\n+  private final Channel channel;\n+  private final Executor callExecutor;\n+  private final MethodDescriptor<ReqT, RespT> method;\n+  private final Context context;\n+  private CallOptions callOptions;\n+\n+  private ClientCall<ReqT, RespT> delegate;\n+\n+  ConfigSelectingClientCall(\n+      InternalConfigSelector configSelector, Channel channel, Executor channelExecutor,\n+      MethodDescriptor<ReqT, RespT> method,\n+      CallOptions callOptions) {\n+    this.configSelector = configSelector;\n+    this.channel = channel;\n+    this.method = method;\n+    this.callOptions = callOptions;\n+    this.callExecutor =\n+        callOptions.getExecutor() == null ? channelExecutor : callOptions.getExecutor();\n+    this.context = Context.current();\n+  }\n+\n+  @Override\n+  protected ClientCall<ReqT, RespT> delegate() {\n+    return delegate;\n+  }\n+\n+  @Override\n+  public void start(Listener<RespT> observer, Metadata headers) {\n+    PickSubchannelArgs args = new PickSubchannelArgsImpl(method, headers, callOptions);\n+    InternalConfigSelector.Result result = configSelector.selectConfig(args);\n+    Status status = result.getStatus();\n+    if (!status.isOk()) {\n+      executeCloseObserverInContext(observer, status);\n+      return;\n+    }\n+    ClientInterceptor interceptor = result.getInterceptor();\n+    ManagedChannelServiceConfig config = (ManagedChannelServiceConfig) result.getConfig();\n+    MethodInfo methodInfo = config.getMethodConfig(method);\n+    applyMethodConfig(methodInfo);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU4NzgyOA=="}, "originalCommit": {"oid": "d55b0d078e1f53e7cef8bc03533041df215ac3cc"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTk0NDA1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxOTozNjozNlrOHxbf4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNDoyNDo0MVrOHxqDEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5MjgwMA==", "bodyText": "We need a fast path for when the selector is set, but it is a ManagedChannelServiceConfig.getDefaultConfigSelector(). We should only pay the indirection cost when it is necessary.", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r521592800", "createdAt": "2020-11-11T19:36:36Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1071,17 +1095,12 @@ public void run() {\n \n     private <ReqT, RespT> ClientCall<ReqT, RespT> newClientCall(\n         MethodDescriptor<ReqT, RespT> method, CallOptions callOptions) {\n-      return new ClientCallImpl<>(\n-          method,\n-          getCallExecutor(callOptions),\n-          callOptions,\n-          transportProvider,\n-          terminated ? null : transportFactory.getScheduledExecutorService(),\n-          channelCallTracer,\n-          configSelector.get())\n-          .setFullStreamDecompression(fullStreamDecompression)\n-          .setDecompressorRegistry(decompressorRegistry)\n-          .setCompressorRegistry(compressorRegistry);\n+      InternalConfigSelector selector = configSelector.get();\n+      if (selector == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55b0d078e1f53e7cef8bc03533041df215ac3cc"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzMTE4NQ==", "bodyText": "Added a fast path for this below.", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r521831185", "createdAt": "2020-11-12T04:24:41Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ManagedChannelImpl.java", "diffHunk": "@@ -1071,17 +1095,12 @@ public void run() {\n \n     private <ReqT, RespT> ClientCall<ReqT, RespT> newClientCall(\n         MethodDescriptor<ReqT, RespT> method, CallOptions callOptions) {\n-      return new ClientCallImpl<>(\n-          method,\n-          getCallExecutor(callOptions),\n-          callOptions,\n-          transportProvider,\n-          terminated ? null : transportFactory.getScheduledExecutorService(),\n-          channelCallTracer,\n-          configSelector.get())\n-          .setFullStreamDecompression(fullStreamDecompression)\n-          .setDecompressorRegistry(decompressorRegistry)\n-          .setCompressorRegistry(compressorRegistry);\n+      InternalConfigSelector selector = configSelector.get();\n+      if (selector == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5MjgwMA=="}, "originalCommit": {"oid": "d55b0d078e1f53e7cef8bc03533041df215ac3cc"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTk4ODE1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ClientCallImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxOTo0OTo0MlrOHxb6TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwNDoyNjowMFrOHxqEPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5OTU2NQ==", "bodyText": "I'm concerned about this double-picking and it assuming we get the same results both times. Could you either migrate the current user of the committedCallback or convert the callback to an interceptor in ConfigSelectingClientCall? It seems that should be really easy. If not, then maybe disable this flow if the CallOptions contain the service config.", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r521599565", "createdAt": "2020-11-11T19:49:42Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ClientCallImpl.java", "diffHunk": "@@ -221,6 +222,7 @@ public void runInContext() {\n       return;\n     }\n \n+    // TODO(zdapeng): remove this after migration to interceptor based config selector.\n     if (configSelector != null) {\n       PickSubchannelArgs args = new PickSubchannelArgsImpl(method, headers, callOptions);\n       InternalConfigSelector.Result result = configSelector.selectConfig(args);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d55b0d078e1f53e7cef8bc03533041df215ac3cc"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzMTQ4NQ==", "bodyText": "I converted the callback to an interceptor for the moment.  (It seems not working to disable this flow if the CallOptions contain the service config)", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r521831485", "createdAt": "2020-11-12T04:26:00Z", "author": {"login": "dapengzhang0"}, "path": "core/src/main/java/io/grpc/internal/ClientCallImpl.java", "diffHunk": "@@ -221,6 +222,7 @@ public void runInContext() {\n       return;\n     }\n \n+    // TODO(zdapeng): remove this after migration to interceptor based config selector.\n     if (configSelector != null) {\n       PickSubchannelArgs args = new PickSubchannelArgsImpl(method, headers, callOptions);\n       InternalConfigSelector.Result result = configSelector.selectConfig(args);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTU5OTU2NQ=="}, "originalCommit": {"oid": "d55b0d078e1f53e7cef8bc03533041df215ac3cc"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzYyOTIwOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNDo1Mjo0NFrOHx-c5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNDo1Mjo0NFrOHx-c5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2NTQ3Nw==", "bodyText": "If you want, you can extend NoopClientCall.", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r522165477", "createdAt": "2020-11-12T14:52:44Z", "author": {"login": "ejona86"}, "path": "core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.verify;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.MethodDescriptor.MethodType;\n+import io.grpc.Status;\n+import io.grpc.internal.ManagedChannelServiceConfig.MethodInfo;\n+import io.grpc.testing.TestMethodDescriptors;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Tests for {@link ConfigSelectingClientCall}. */\n+@RunWith(JUnit4.class)\n+public class ConfigSelectingClientCallTest {\n+  @Rule\n+  public MockitoRule mockitoRule = MockitoJUnit.rule();\n+  private final MethodDescriptor<Void, Void> method = MethodDescriptor.<Void, Void>newBuilder()\n+      .setType(MethodType.UNARY)\n+      .setFullMethodName(\"service/method\")\n+      .setRequestMarshaller(TestMethodDescriptors.voidMarshaller())\n+      .setResponseMarshaller(TestMethodDescriptors.voidMarshaller())\n+      .build();\n+  private final TestChannel channel = new TestChannel();\n+  @Mock\n+  private ClientCall.Listener<Void> callListener;\n+  private TestCall<Void, Void> call;\n+\n+  @Test\n+  public void configSelectorInterceptsCall() {\n+    Map<String, ?> rawMethodConfig = ImmutableMap.of(\n+        \"retryPolicy\",\n+        ImmutableMap.of(\n+            \"maxAttempts\", 3.0D,\n+            \"initialBackoff\", \"1s\",\n+            \"maxBackoff\", \"10s\",\n+            \"backoffMultiplier\", 1.5D,\n+            \"retryableStatusCodes\", ImmutableList.of(\"UNAVAILABLE\")\n+        ));\n+    final MethodInfo methodInfo = new MethodInfo(rawMethodConfig, true, 4, 4);\n+    final Metadata.Key<String> metadataKey =\n+        Metadata.Key.of(\"test\", Metadata.ASCII_STRING_MARSHALLER);\n+    final CallOptions.Key<String> callOptionsKey = CallOptions.Key.create(\"test\");\n+    InternalConfigSelector configSelector = new InternalConfigSelector() {\n+      @Override\n+      public Result selectConfig(final PickSubchannelArgs args) {\n+        ManagedChannelServiceConfig config = new ManagedChannelServiceConfig(\n+            methodInfo,\n+            ImmutableMap.<String, MethodInfo>of(),\n+            ImmutableMap.<String, MethodInfo>of(),\n+            null,\n+            null,\n+            null);\n+        return Result.newBuilder()\n+            .setConfig(config)\n+            .setInterceptor(\n+                // An interceptor that mutates CallOptions base on headers value.\n+                new ClientInterceptor() {\n+                  String value = args.getHeaders().get(metadataKey);\n+                  @Override\n+                  public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(\n+                      MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, Channel next) {\n+                    callOptions = callOptions.withOption(callOptionsKey, value);\n+                    return next.newCall(method, callOptions);\n+                  }\n+                })\n+            .build();\n+      }\n+    };\n+\n+    ClientCall<Void, Void> configSelectingClientCall = new ConfigSelectingClientCall<>(\n+        configSelector,\n+        channel,\n+        MoreExecutors.directExecutor(),\n+        method,\n+        CallOptions.DEFAULT.withAuthority(\"bar.authority\"));\n+    Metadata metadata = new Metadata();\n+    metadata.put(metadataKey, \"fooValue\");\n+    configSelectingClientCall.start(callListener, metadata);\n+\n+    assertThat(call.callOptions.getAuthority()).isEqualTo(\"bar.authority\");\n+    assertThat(call.callOptions.getOption(MethodInfo.KEY)).isEqualTo(methodInfo);\n+    assertThat(call.callOptions.getOption(callOptionsKey)).isEqualTo(\"fooValue\");\n+  }\n+\n+  @Test\n+  public void selectionErrorPropagatedToListener() {\n+    InternalConfigSelector configSelector = new InternalConfigSelector() {\n+      @Override\n+      public Result selectConfig(PickSubchannelArgs args) {\n+        return Result.forError(Status.FAILED_PRECONDITION);\n+      }\n+    };\n+\n+    ClientCall<Void, Void> configSelectingClientCall = new ConfigSelectingClientCall<>(\n+        configSelector,\n+        channel,\n+        MoreExecutors.directExecutor(),\n+        method,\n+        CallOptions.DEFAULT);\n+    configSelectingClientCall.start(callListener, new Metadata());\n+    ArgumentCaptor<Status> statusCaptor = ArgumentCaptor.forClass(null);\n+    verify(callListener).onClose(statusCaptor.capture(), any(Metadata.class));\n+    assertThat(statusCaptor.getValue().getCode()).isEqualTo(Status.Code.FAILED_PRECONDITION);\n+  }\n+\n+  private final class TestChannel extends Channel {\n+\n+    @SuppressWarnings(\"unchecked\") // Don't care\n+    @Override\n+    public <ReqT, RespT> ClientCall<ReqT, RespT> newCall(\n+        MethodDescriptor<ReqT, RespT> methodDescriptor, CallOptions callOptions) {\n+      TestCall<ReqT, RespT> clientCall = new TestCall<>(callOptions);\n+      call = (TestCall<Void, Void>) clientCall;\n+      return clientCall;\n+    }\n+\n+    @Override\n+    public String authority() {\n+      return \"foo.authority\";\n+    }\n+  }\n+\n+  private static final class TestCall<ReqT, RespT> extends ClientCall<ReqT, RespT> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c8ea16eea9c98eb82ae975827bbf40568083561"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzY0MzkwOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNDo1NTozNFrOHx-lyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMDoxODoyOFrOHyMkZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2Nzc1NQ==", "bodyText": "It's not clear to me why you are storing the CallOptions in the ClientCall instead of just storing the CallOptions in a test field directly.", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r522167755", "createdAt": "2020-11-12T14:55:34Z", "author": {"login": "ejona86"}, "path": "core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.verify;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.MethodDescriptor.MethodType;\n+import io.grpc.Status;\n+import io.grpc.internal.ManagedChannelServiceConfig.MethodInfo;\n+import io.grpc.testing.TestMethodDescriptors;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Tests for {@link ConfigSelectingClientCall}. */\n+@RunWith(JUnit4.class)\n+public class ConfigSelectingClientCallTest {\n+  @Rule\n+  public MockitoRule mockitoRule = MockitoJUnit.rule();\n+  private final MethodDescriptor<Void, Void> method = MethodDescriptor.<Void, Void>newBuilder()\n+      .setType(MethodType.UNARY)\n+      .setFullMethodName(\"service/method\")\n+      .setRequestMarshaller(TestMethodDescriptors.voidMarshaller())\n+      .setResponseMarshaller(TestMethodDescriptors.voidMarshaller())\n+      .build();\n+  private final TestChannel channel = new TestChannel();\n+  @Mock\n+  private ClientCall.Listener<Void> callListener;\n+  private TestCall<Void, Void> call;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c8ea16eea9c98eb82ae975827bbf40568083561"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3MjY5Nw==", "bodyText": "I wanted to verify the CallOptions that the underlying call (TestCall) received is as expected, so the CallOption is kind of belonging to the underlying call. I agree it's not so clear by reading the code. Now I use a mock channel instead.", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r522372697", "createdAt": "2020-11-12T19:38:32Z", "author": {"login": "dapengzhang0"}, "path": "core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.verify;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.MethodDescriptor.MethodType;\n+import io.grpc.Status;\n+import io.grpc.internal.ManagedChannelServiceConfig.MethodInfo;\n+import io.grpc.testing.TestMethodDescriptors;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Tests for {@link ConfigSelectingClientCall}. */\n+@RunWith(JUnit4.class)\n+public class ConfigSelectingClientCallTest {\n+  @Rule\n+  public MockitoRule mockitoRule = MockitoJUnit.rule();\n+  private final MethodDescriptor<Void, Void> method = MethodDescriptor.<Void, Void>newBuilder()\n+      .setType(MethodType.UNARY)\n+      .setFullMethodName(\"service/method\")\n+      .setRequestMarshaller(TestMethodDescriptors.voidMarshaller())\n+      .setResponseMarshaller(TestMethodDescriptors.voidMarshaller())\n+      .build();\n+  private final TestChannel channel = new TestChannel();\n+  @Mock\n+  private ClientCall.Listener<Void> callListener;\n+  private TestCall<Void, Void> call;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2Nzc1NQ=="}, "originalCommit": {"oid": "0c8ea16eea9c98eb82ae975827bbf40568083561"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM4MTg2MA==", "bodyText": "Oh, I preferred how you had it instead of using a Mock. A concrete Channel implementation is far more readable and more useful as tests are added. And argument captures are harder to follow.", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r522381860", "createdAt": "2020-11-12T19:54:09Z", "author": {"login": "ejona86"}, "path": "core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.verify;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.MethodDescriptor.MethodType;\n+import io.grpc.Status;\n+import io.grpc.internal.ManagedChannelServiceConfig.MethodInfo;\n+import io.grpc.testing.TestMethodDescriptors;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Tests for {@link ConfigSelectingClientCall}. */\n+@RunWith(JUnit4.class)\n+public class ConfigSelectingClientCallTest {\n+  @Rule\n+  public MockitoRule mockitoRule = MockitoJUnit.rule();\n+  private final MethodDescriptor<Void, Void> method = MethodDescriptor.<Void, Void>newBuilder()\n+      .setType(MethodType.UNARY)\n+      .setFullMethodName(\"service/method\")\n+      .setRequestMarshaller(TestMethodDescriptors.voidMarshaller())\n+      .setResponseMarshaller(TestMethodDescriptors.voidMarshaller())\n+      .build();\n+  private final TestChannel channel = new TestChannel();\n+  @Mock\n+  private ClientCall.Listener<Void> callListener;\n+  private TestCall<Void, Void> call;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2Nzc1NQ=="}, "originalCommit": {"oid": "0c8ea16eea9c98eb82ae975827bbf40568083561"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM5Njc3Mw==", "bodyText": "Reverted mock channel and added some explanation comments.", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r522396773", "createdAt": "2020-11-12T20:18:28Z", "author": {"login": "dapengzhang0"}, "path": "core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.verify;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.MethodDescriptor.MethodType;\n+import io.grpc.Status;\n+import io.grpc.internal.ManagedChannelServiceConfig.MethodInfo;\n+import io.grpc.testing.TestMethodDescriptors;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Tests for {@link ConfigSelectingClientCall}. */\n+@RunWith(JUnit4.class)\n+public class ConfigSelectingClientCallTest {\n+  @Rule\n+  public MockitoRule mockitoRule = MockitoJUnit.rule();\n+  private final MethodDescriptor<Void, Void> method = MethodDescriptor.<Void, Void>newBuilder()\n+      .setType(MethodType.UNARY)\n+      .setFullMethodName(\"service/method\")\n+      .setRequestMarshaller(TestMethodDescriptors.voidMarshaller())\n+      .setResponseMarshaller(TestMethodDescriptors.voidMarshaller())\n+      .build();\n+  private final TestChannel channel = new TestChannel();\n+  @Mock\n+  private ClientCall.Listener<Void> callListener;\n+  private TestCall<Void, Void> call;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE2Nzc1NQ=="}, "originalCommit": {"oid": "0c8ea16eea9c98eb82ae975827bbf40568083561"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3MzY2OTY1OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTowMDo1MlrOHx-2QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNTowMDo1MlrOHx-2QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE3MTk2OQ==", "bodyText": "Use TestMethodDescriptors.voidMethod()? I assumed this was done so you could clearly define the method name for service config, but it seems your using the wildcard.", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r522171969", "createdAt": "2020-11-12T15:00:52Z", "author": {"login": "ejona86"}, "path": "core/src/test/java/io/grpc/internal/ConfigSelectingClientCallTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.verify;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.MethodDescriptor.MethodType;\n+import io.grpc.Status;\n+import io.grpc.internal.ManagedChannelServiceConfig.MethodInfo;\n+import io.grpc.testing.TestMethodDescriptors;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+/** Tests for {@link ConfigSelectingClientCall}. */\n+@RunWith(JUnit4.class)\n+public class ConfigSelectingClientCallTest {\n+  @Rule\n+  public MockitoRule mockitoRule = MockitoJUnit.rule();\n+  private final MethodDescriptor<Void, Void> method = MethodDescriptor.<Void, Void>newBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c8ea16eea9c98eb82ae975827bbf40568083561"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTI4ODQzOnYy", "diffSide": "RIGHT", "path": "api/src/test/java/io/grpc/InternalConfigSelectorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMToxMTozN1rOHyOh4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMToxMTozN1rOHyOh4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQyODg5Ng==", "bodyText": "I don't see any usefulness of such a test, except it trivially increases the code coverage...", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r522428896", "createdAt": "2020-11-12T21:11:37Z", "author": {"login": "voidzcy"}, "path": "api/src/test/java/io/grpc/InternalConfigSelectorTest.java", "diffHunk": "@@ -55,6 +56,18 @@ public void run() {}\n     assertThat(result.getCommittedCallback()).isSameInstanceAs(committedCallback);\n   }\n \n+  @Test\n+  public void resultBuilder_interceptorBased() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1cc804492b8774d7721354000f6f22ec1ea213a"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NTM0Mjg2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ConfigSelectingClientCall.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMToyODo0M1rOHyPC5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMToyODo0M1rOHyPC5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQzNzM0OA==", "bodyText": "nit: This class looks simple and small (after the interceptor for wrapping the existing committed callback is deleted), so maybe just embedded it in ManagedChannelImpl? But anyway, I am fine with either.", "url": "https://github.com/grpc/grpc-java/pull/7610#discussion_r522437348", "createdAt": "2020-11-12T21:28:43Z", "author": {"login": "voidzcy"}, "path": "core/src/main/java/io/grpc/internal/ConfigSelectingClientCall.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.Context;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener.SimpleForwardingClientCallListener;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.internal.ManagedChannelServiceConfig.MethodInfo;\n+import java.util.concurrent.Executor;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A client call for a given channel that applies a given config selector when it starts.\n+ */\n+final class ConfigSelectingClientCall<ReqT, RespT> extends ForwardingClientCall<ReqT, RespT> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1cc804492b8774d7721354000f6f22ec1ea213a"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2288, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}