{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM2NDI1Njc5", "number": 7722, "title": "xds: implement new CDS LB policy for supporting aggregate clusters", "bodyText": "Implementation for (new) CDS LB policy that supports cluster discovery for aggregate clusters.\nThe new implementation takes takes the same LB config as before, which contains a single cluster name. But this cluster can be representing an aggregate cluster, which is a composition for a tree-structured cluster hierarchy (precisely speaking, it can be a directed graph with no cycles. That is, the hierarchy can contain diamond, where a cluster belongs to more than one aggregate clusters). Therefore, the output (aka, LB config for its child LB policy, which is ClustserResolverLoadBalancer) contains a list of cluster configurations (aka, DiscoveryMechanism).\nWhen receiving its LB config, the CDS LB policy starts watching on the CDS resource (the root) using the cluster name from the LB config. Upon receiving a resource update, which is the configuration for the cluster, it can have the following two cases:\n\nThe cluster is an EDS/Logical DNS cluster: we've reached the end of cluster discovery for this cluster, output it as an DiscoveryMechanism entry.\nThe cluster is an aggregate cluster: the update contains a list of cluster names (in order) that composites this cluster. Then we start one CDS watcher for each of the contained clusters.\n\nThe discovery process happens recursively for a tree-hierarchy aggregate cluster until all (leaf) clusters have been discovered. Example and details can be seen in go/grpc-xds-directpath-c2p-fallback.\nA few implementation assumptions for cluster resources:\n\nClusters are uniquely identified by its name and a cluster can never change its intrinsic property (e.g., an EDS cluster will never become a Logical DNS or aggregate cluster).\nThe composition of an aggregate cluster is allowed to be changed (e.g., aggregate cluster containing [A, B, C] can change to contain [A, B] or [D]).", "createdAt": "2020-12-11T02:37:04Z", "url": "https://github.com/grpc/grpc-java/pull/7722", "merged": true, "mergeCommit": {"oid": "a584baf86af1b1ad75d3774784757fb6874e702a"}, "closed": true, "closedAt": "2021-01-14T21:17:55Z", "author": {"login": "voidzcy"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdk-ncDAH2gAyNTM2NDI1Njc5OjNmYmNhNDQ4YjRkZjAwNDVlMzA3OGI4N2YxN2U2YTk2OGMwODE5MjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdwJYobgH2gAyNTM2NDI1Njc5Ojg3ZjlhN2VmZjllZWEwNTlhODYzOTJkNWNmZGM1NjQyN2I0NjM3OGE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3fbca448b4df0045e3078b87f17e6a968c081925", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/3fbca448b4df0045e3078b87f17e6a968c081925", "committedDate": "2020-12-11T02:35:42Z", "message": "Implement the new CDS LB policy, which is capable of discovering an aggregate cluster with tree hierarchy."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d99112542cd10a8517e42b95dccfc014b8f333ff", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/d99112542cd10a8517e42b95dccfc014b8f333ff", "committedDate": "2020-12-11T02:40:27Z", "message": "Implement tests."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "258695177b310657daa0dc7d384b56aa3aff83f0", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/258695177b310657daa0dc7d384b56aa3aff83f0", "committedDate": "2020-12-11T02:36:07Z", "message": "Implement tests."}, "afterCommit": {"oid": "d99112542cd10a8517e42b95dccfc014b8f333ff", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/d99112542cd10a8517e42b95dccfc014b8f333ff", "committedDate": "2020-12-11T02:40:27Z", "message": "Implement tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5b593de03f078658950c9305e8ed2379d925398", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/f5b593de03f078658950c9305e8ed2379d925398", "committedDate": "2020-12-31T00:39:50Z", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/implement_new_cds_lb_policy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c0834d6c42f03383bf700a3f21af936c2c6b998", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/3c0834d6c42f03383bf700a3f21af936c2c6b998", "committedDate": "2020-12-31T00:40:47Z", "message": "Fix wrong import."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e49a2d88d547323107faa4ce6b835a75ba24546", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/6e49a2d88d547323107faa4ce6b835a75ba24546", "committedDate": "2020-12-31T00:43:20Z", "message": "Prefer ArrayDeque to LinkedList for Queue."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3259603025fd0fe3d438dfdb22f0f2ed910f825", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/e3259603025fd0fe3d438dfdb22f0f2ed910f825", "committedDate": "2020-12-31T00:49:32Z", "message": "Fix style line too long."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f1c2b381256dae82341f8862f72a3d8f6e52e18", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/3f1c2b381256dae82341f8862f72a3d8f6e52e18", "committedDate": "2021-01-08T09:09:24Z", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/implement_new_cds_lb_policy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1ODE0MDA2", "url": "https://github.com/grpc/grpc-java/pull/7722#pullrequestreview-565814006", "createdAt": "2021-01-11T23:17:17Z", "commit": {"oid": "3f1c2b381256dae82341f8862f72a3d8f6e52e18"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQyMzoxNzoxN1rOIRq9-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQyMzoxNzoxN1rOIRq9-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQwMDY5Ng==", "bodyText": "also revoke child clusters if if (childClusterStates != null), and then set childClusterStates = null?", "url": "https://github.com/grpc/grpc-java/pull/7722#discussion_r555400696", "createdAt": "2021-01-11T23:17:17Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.CLUSTER_RESOLVER_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.CdsLoadBalancerProvider.CdsConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig.DiscoveryMechanism;\n+import io.grpc.xds.XdsClient.CdsResourceWatcher;\n+import io.grpc.xds.XdsClient.CdsUpdate;\n+import io.grpc.xds.XdsClient.CdsUpdate.AggregateClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.ClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.ClusterType;\n+import io.grpc.xds.XdsClient.CdsUpdate.EdsClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.LogicalDnsClusterConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Load balancer for cds_experimental LB policy. One instance per top-level cluster.\n+ * The top-level cluster may be a plain EDS/logical-DNS cluster or an aggregate cluster that\n+ * formed by a group of sub-clusters in a tree hierarchy.\n+ */\n+final class CdsLoadBalancer2 extends LoadBalancer {\n+  private final XdsLogger logger;\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final LoadBalancerRegistry lbRegistry;\n+  // Following fields are effectively final.\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private CdsLbState cdsLbState;\n+  private ResolvedAddresses resolvedAddresses;\n+\n+  CdsLoadBalancer2(Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry());\n+  }\n+\n+  @VisibleForTesting\n+  CdsLoadBalancer2(Helper helper, LoadBalancerRegistry lbRegistry) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    if (this.resolvedAddresses != null) {\n+      return;\n+    }\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+    xdsClient = xdsClientPool.getObject();\n+    CdsConfig config = (CdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    logger.log(XdsLogLevel.INFO, \"Config: {0}\", config);\n+    cdsLbState = new CdsLbState(config.name);\n+    cdsLbState.start();\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    if (cdsLbState != null && cdsLbState.childLb != null) {\n+      cdsLbState.childLb.handleNameResolutionError(error);\n+    } else {\n+      helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    if (cdsLbState != null) {\n+      cdsLbState.shutdown();\n+    }\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  /**\n+   * The state of a CDS working session of {@link CdsLoadBalancer2}. Created and started when\n+   * receiving the CDS LB policy config with the top-level cluster name.\n+   */\n+  private final class CdsLbState {\n+    private ClusterState root;\n+    private LoadBalancer childLb;\n+\n+    private CdsLbState(String rootCluster) {\n+      root = new ClusterState(rootCluster);\n+    }\n+\n+    private void start() {\n+      root.start();\n+    }\n+\n+    private void shutdown() {\n+      root.shutdown();\n+    }\n+\n+    private void handleClusterDiscovered() {\n+      List<DiscoveryMechanism> instances = new ArrayList<>();\n+      // Level-order traversal.\n+      // Collect configurations for all non-aggregate (leaf) clusters.\n+      Queue<ClusterState> queue = new ArrayDeque<>();\n+      queue.add(root);\n+      while (!queue.isEmpty()) {\n+        int size = queue.size();\n+        for (int i = 0; i < size; i++) {\n+          ClusterState clusterState = queue.remove();\n+          if (!clusterState.discovered) {\n+            return;  // do not proceed until all clusters discovered\n+          }\n+          if (clusterState.result == null) {  // resource revoked or not exists\n+            continue;\n+          }\n+          if (clusterState.isLeaf) {\n+            DiscoveryMechanism instance;\n+            if (clusterState.result instanceof EdsClusterConfig) {\n+              EdsClusterConfig clusterConfig = (EdsClusterConfig) clusterState.result;\n+              instance = DiscoveryMechanism.forEds(clusterState.name, clusterConfig.edsServiceName,\n+                  clusterConfig.lrsServerName, clusterConfig.maxConcurrentRequests,\n+                  clusterConfig.upstreamTlsContext);\n+            } else {  // logical DNS\n+              LogicalDnsClusterConfig clusterConfig =\n+                  (LogicalDnsClusterConfig) clusterState.result;\n+              instance = DiscoveryMechanism.forLogicalDns(clusterState.name,\n+                  clusterConfig.lrsServerName, clusterConfig.maxConcurrentRequests,\n+                  clusterConfig.upstreamTlsContext);\n+            }\n+            instances.add(instance);\n+          } else {\n+            if (clusterState.childClusterStates != null) {\n+              queue.addAll(clusterState.childClusterStates.values());\n+            }\n+          }\n+        }\n+      }\n+      if (instances.isEmpty()) {  // none of non-aggregate clusters exists\n+        if (childLb != null) {\n+          childLb.shutdown();\n+          childLb = null;\n+        }\n+        Status unavailable =\n+            Status.UNAVAILABLE.withDescription(\"Cluster \" + root.name + \" unusable\");\n+        helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(unavailable));\n+        return;\n+      }\n+      String endpointPickingPolicy = root.result.lbPolicy;\n+      LoadBalancerProvider localityPickingLbProvider =\n+          lbRegistry.getProvider(XdsLbPolicies.WEIGHTED_TARGET_POLICY_NAME);  // hardcoded\n+      LoadBalancerProvider endpointPickingLbProvider =\n+          lbRegistry.getProvider(endpointPickingPolicy);\n+      ClusterResolverConfig config = new ClusterResolverConfig(\n+          Collections.unmodifiableList(instances),\n+          new PolicySelection(localityPickingLbProvider, null /* by cluster_resolver LB policy */),\n+          new PolicySelection(endpointPickingLbProvider, null));\n+      if (childLb == null) {\n+        childLb = lbRegistry.getProvider(CLUSTER_RESOLVER_POLICY_NAME).newLoadBalancer(helper);\n+      }\n+      childLb.handleResolvedAddresses(\n+          resolvedAddresses.toBuilder().setLoadBalancingPolicyConfig(config).build());\n+    }\n+\n+    private void handleClusterDiscoveryError(Status error) {\n+      if (childLb != null) {\n+        childLb.handleNameResolutionError(error);\n+      } else {\n+        helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+      }\n+    }\n+\n+    private final class ClusterState implements CdsResourceWatcher {\n+      private final String name;\n+      @Nullable\n+      private Map<String, ClusterState> childClusterStates;\n+      @Nullable\n+      private ClusterConfig result;\n+      // Following fields are effectively final.\n+      private boolean isLeaf;\n+      private boolean discovered;\n+      private boolean shutdown;\n+\n+      private ClusterState(String name) {\n+        this.name = name;\n+      }\n+\n+      private void start() {\n+        xdsClient.watchCdsResource(name, this);\n+      }\n+\n+      void shutdown() {\n+        shutdown = true;\n+        xdsClient.cancelCdsResourceWatch(name, this);\n+        if (childClusterStates != null) {  // recursively shut down all descendants\n+          for (ClusterState state : childClusterStates.values()) {\n+            state.shutdown();\n+          }\n+        }\n+      }\n+\n+      @Override\n+      public void onError(final Status error) {\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            if (shutdown) {\n+              return;\n+            }\n+            // All watchers should receive the same error, so we only propagate it once.\n+            if (ClusterState.this == root) {\n+              handleClusterDiscoveryError(error);\n+            }\n+          }\n+        });\n+      }\n+\n+      @Override\n+      public void onResourceDoesNotExist(String resourceName) {\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            if (shutdown) {\n+              return;\n+            }\n+            discovered = true;\n+            result = null;\n+            if (childClusterStates != null) {\n+              for (ClusterState state : childClusterStates.values()) {\n+                state.shutdown();\n+              }\n+              childClusterStates = null;\n+            }\n+            handleClusterDiscovered();\n+          }\n+        });\n+      }\n+\n+      @Override\n+      public void onChanged(final CdsUpdate update) {\n+        class ClusterDiscovered implements Runnable {\n+          @Override\n+          public void run() {\n+            if (shutdown) {\n+              return;\n+            }\n+            discovered = true;\n+            result = update.clusterConfig;\n+            if (update.clusterType == ClusterType.AGGREGATE) {\n+              isLeaf = false;\n+              AggregateClusterConfig clusterConfig = (AggregateClusterConfig) update.clusterConfig;\n+              logger.log(XdsLogLevel.INFO, \"Aggregate cluster {0}\", update.clusterName);\n+              logger.log(XdsLogLevel.DEBUG, \"Cluster config: {0}\", clusterConfig);\n+              Map<String, ClusterState> newChildStates = new LinkedHashMap<>();\n+              for (String cluster : clusterConfig.prioritizedClusterNames) {\n+                if (childClusterStates == null || !childClusterStates.containsKey(cluster)) {\n+                  ClusterState childState = new ClusterState(cluster);\n+                  childState.start();\n+                  newChildStates.put(cluster, childState);\n+                } else {\n+                  newChildStates.put(cluster, childClusterStates.remove(cluster));\n+                }\n+              }\n+              if (childClusterStates != null) {  // stop subscribing to revoked child clusters\n+                for (ClusterState watcher : childClusterStates.values()) {\n+                  watcher.shutdown();\n+                }\n+              }\n+              childClusterStates = newChildStates;\n+            } else if (update.clusterType == ClusterType.EDS) {\n+              isLeaf = true;\n+              EdsClusterConfig clusterConfig = (EdsClusterConfig) update.clusterConfig;\n+              logger.log(XdsLogLevel.INFO, \"EDS cluster {0}, edsServiceName: {1}\",\n+                  update.clusterName, clusterConfig.edsServiceName);\n+              logger.log(XdsLogLevel.DEBUG, \"Cluster config: {0}\", clusterConfig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f1c2b381256dae82341f8862f72a3d8f6e52e18"}, "originalPosition": 312}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2NjM5NDkz", "url": "https://github.com/grpc/grpc-java/pull/7722#pullrequestreview-566639493", "createdAt": "2021-01-12T19:54:57Z", "commit": {"oid": "3f1c2b381256dae82341f8862f72a3d8f6e52e18"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxOTo1NDo1N1rOISSMaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxOTo1NToxMVrOISSNDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA0MzM2OA==", "bodyText": "'that is formed' or 'that formed'", "url": "https://github.com/grpc/grpc-java/pull/7722#discussion_r556043368", "createdAt": "2021-01-12T19:54:57Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.CLUSTER_RESOLVER_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.CdsLoadBalancerProvider.CdsConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig.DiscoveryMechanism;\n+import io.grpc.xds.XdsClient.CdsResourceWatcher;\n+import io.grpc.xds.XdsClient.CdsUpdate;\n+import io.grpc.xds.XdsClient.CdsUpdate.AggregateClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.ClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.ClusterType;\n+import io.grpc.xds.XdsClient.CdsUpdate.EdsClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.LogicalDnsClusterConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Load balancer for cds_experimental LB policy. One instance per top-level cluster.\n+ * The top-level cluster may be a plain EDS/logical-DNS cluster or an aggregate cluster that\n+ * formed by a group of sub-clusters in a tree hierarchy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f1c2b381256dae82341f8862f72a3d8f6e52e18"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA0MzUzMg==", "bodyText": "nit: final", "url": "https://github.com/grpc/grpc-java/pull/7722#discussion_r556043532", "createdAt": "2021-01-12T19:55:11Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/CdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.CLUSTER_RESOLVER_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.CdsLoadBalancerProvider.CdsConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig;\n+import io.grpc.xds.ClusterResolverLoadBalancerProvider.ClusterResolverConfig.DiscoveryMechanism;\n+import io.grpc.xds.XdsClient.CdsResourceWatcher;\n+import io.grpc.xds.XdsClient.CdsUpdate;\n+import io.grpc.xds.XdsClient.CdsUpdate.AggregateClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.ClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.ClusterType;\n+import io.grpc.xds.XdsClient.CdsUpdate.EdsClusterConfig;\n+import io.grpc.xds.XdsClient.CdsUpdate.LogicalDnsClusterConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Load balancer for cds_experimental LB policy. One instance per top-level cluster.\n+ * The top-level cluster may be a plain EDS/logical-DNS cluster or an aggregate cluster that\n+ * formed by a group of sub-clusters in a tree hierarchy.\n+ */\n+final class CdsLoadBalancer2 extends LoadBalancer {\n+  private final XdsLogger logger;\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final LoadBalancerRegistry lbRegistry;\n+  // Following fields are effectively final.\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private CdsLbState cdsLbState;\n+  private ResolvedAddresses resolvedAddresses;\n+\n+  CdsLoadBalancer2(Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry());\n+  }\n+\n+  @VisibleForTesting\n+  CdsLoadBalancer2(Helper helper, LoadBalancerRegistry lbRegistry) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.syncContext = checkNotNull(helper.getSynchronizationContext(), \"syncContext\");\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"cds-lb\", helper.getAuthority()));\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    if (this.resolvedAddresses != null) {\n+      return;\n+    }\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+    xdsClient = xdsClientPool.getObject();\n+    CdsConfig config = (CdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    logger.log(XdsLogLevel.INFO, \"Config: {0}\", config);\n+    cdsLbState = new CdsLbState(config.name);\n+    cdsLbState.start();\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    if (cdsLbState != null && cdsLbState.childLb != null) {\n+      cdsLbState.childLb.handleNameResolutionError(error);\n+    } else {\n+      helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    if (cdsLbState != null) {\n+      cdsLbState.shutdown();\n+    }\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  /**\n+   * The state of a CDS working session of {@link CdsLoadBalancer2}. Created and started when\n+   * receiving the CDS LB policy config with the top-level cluster name.\n+   */\n+  private final class CdsLbState {\n+    private ClusterState root;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f1c2b381256dae82341f8862f72a3d8f6e52e18"}, "originalPosition": 123}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87f9a7eff9eea059a86392d5cfdc56427b46378a", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/87f9a7eff9eea059a86392d5cfdc56427b46378a", "committedDate": "2021-01-14T19:21:39Z", "message": "Minor stylish fixes."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4761, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}