{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1MTQzMzU5", "number": 7590, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxOTo1NTowN1rOE10jYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMjoyOTozOFrOE2QnaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODcxMDA4OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxOTo1NTowN1rOHuUJ3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMDozMjo1M1rOHuVZYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMyNjc1MA==", "bodyText": "DynamicReloadingCertificateProvider is passing a directory, why this one is not?", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r518326750", "createdAt": "2020-11-05T19:55:07Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProvider.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.FileTime;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/** Implementation of {@link CertificateProvider} for file watching cert provider. */\n+final class FileWatcherCertificateProvider extends CertificateProvider {\n+  private static final Logger logger =\n+      Logger.getLogger(FileWatcherCertificateProvider.class.getName());\n+\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final TimeProvider timeProvider;\n+  private final Path certFile;\n+  private final Path keyFile;\n+  private final Path trustFile;\n+  private final long refreshIntervalInSeconds;\n+  @VisibleForTesting SynchronizationContext.ScheduledHandle scheduledHandle;\n+  private FileTime lastModifiedTimeCert;\n+  private FileTime lastModifiedTimeKey;\n+  private FileTime lastModifiedTimeRoot;\n+\n+  FileWatcherCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String certFile,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e093fb1e7667d41f57dbe6614e6b1454b153581b"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM0NzEwNw==", "bodyText": "As mentioned offline this is going to eventually replace DynamicReloadingCertificateProvider since the design now calls for a generic file-watcher plugin instead of assuming a symlink based provider. So we don't assume a common directory.", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r518347107", "createdAt": "2020-11-05T20:32:53Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProvider.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.FileTime;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/** Implementation of {@link CertificateProvider} for file watching cert provider. */\n+final class FileWatcherCertificateProvider extends CertificateProvider {\n+  private static final Logger logger =\n+      Logger.getLogger(FileWatcherCertificateProvider.class.getName());\n+\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final TimeProvider timeProvider;\n+  private final Path certFile;\n+  private final Path keyFile;\n+  private final Path trustFile;\n+  private final long refreshIntervalInSeconds;\n+  @VisibleForTesting SynchronizationContext.ScheduledHandle scheduledHandle;\n+  private FileTime lastModifiedTimeCert;\n+  private FileTime lastModifiedTimeKey;\n+  private FileTime lastModifiedTimeRoot;\n+\n+  FileWatcherCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String certFile,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMyNjc1MA=="}, "originalCommit": {"oid": "e093fb1e7667d41f57dbe6614e6b1454b153581b"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODc0MDY5OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMDowMzo1OFrOHuUc1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMDozNDoxOVrOHuVcNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMzMTYwNg==", "bodyText": "I wonder if we can have an intermediate class AbstractCertProvider that provides createSynchronizationContext() and generateErrorIfCurrentCertExpired() etc.", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r518331606", "createdAt": "2020-11-05T20:03:58Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProvider.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.FileTime;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/** Implementation of {@link CertificateProvider} for file watching cert provider. */\n+final class FileWatcherCertificateProvider extends CertificateProvider {\n+  private static final Logger logger =\n+      Logger.getLogger(FileWatcherCertificateProvider.class.getName());\n+\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final TimeProvider timeProvider;\n+  private final Path certFile;\n+  private final Path keyFile;\n+  private final Path trustFile;\n+  private final long refreshIntervalInSeconds;\n+  @VisibleForTesting SynchronizationContext.ScheduledHandle scheduledHandle;\n+  private FileTime lastModifiedTimeCert;\n+  private FileTime lastModifiedTimeKey;\n+  private FileTime lastModifiedTimeRoot;\n+\n+  FileWatcherCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String certFile,\n+      String keyFile,\n+      String trustFile,\n+      long refreshIntervalInSeconds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider) {\n+    super(watcher, notifyCertUpdates);\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.certFile = Paths.get(checkNotNull(certFile, \"certFile\"));\n+    this.keyFile = Paths.get(checkNotNull(keyFile, \"keyFile\"));\n+    this.trustFile = Paths.get(checkNotNull(trustFile, \"trustFile\"));\n+    this.refreshIntervalInSeconds = refreshIntervalInSeconds;\n+    this.syncContext = createSynchronizationContext(certFile);\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e093fb1e7667d41f57dbe6614e6b1454b153581b"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM0NzgzMQ==", "bodyText": "Yes, that's something I considered too. I will create a TODO item and an issue to refactor this to create the intermediate class after we remove the unused providers.", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r518347831", "createdAt": "2020-11-05T20:34:19Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProvider.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.InternalLogId;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+\n+import java.io.ByteArrayInputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.FileTime;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/** Implementation of {@link CertificateProvider} for file watching cert provider. */\n+final class FileWatcherCertificateProvider extends CertificateProvider {\n+  private static final Logger logger =\n+      Logger.getLogger(FileWatcherCertificateProvider.class.getName());\n+\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService scheduledExecutorService;\n+  private final TimeProvider timeProvider;\n+  private final Path certFile;\n+  private final Path keyFile;\n+  private final Path trustFile;\n+  private final long refreshIntervalInSeconds;\n+  @VisibleForTesting SynchronizationContext.ScheduledHandle scheduledHandle;\n+  private FileTime lastModifiedTimeCert;\n+  private FileTime lastModifiedTimeKey;\n+  private FileTime lastModifiedTimeRoot;\n+\n+  FileWatcherCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String certFile,\n+      String keyFile,\n+      String trustFile,\n+      long refreshIntervalInSeconds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider) {\n+    super(watcher, notifyCertUpdates);\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.certFile = Paths.get(checkNotNull(certFile, \"certFile\"));\n+    this.keyFile = Paths.get(checkNotNull(keyFile, \"keyFile\"));\n+    this.trustFile = Paths.get(checkNotNull(trustFile, \"trustFile\"));\n+    this.refreshIntervalInSeconds = refreshIntervalInSeconds;\n+    this.syncContext = createSynchronizationContext(certFile);\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMzMTYwNg=="}, "originalCommit": {"oid": "e093fb1e7667d41f57dbe6614e6b1454b153581b"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0ODc2NjIzOnYy", "diffSide": "RIGHT", "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProviderTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMDoxMToyMVrOHuUstA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQyMDo1MDowM1rOHuV8Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMzNTY2OA==", "bodyText": "I'm not wild about calling an essentially private attribute in tests. This does not look like a real usecase. Why calling cancel() followed by checkAndReloadCertificates()?", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r518335668", "createdAt": "2020-11-05T20:11:21Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProviderTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_PEM_FILE;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.grpc.Status;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.DistributorWatcher;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.PrivateKey;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link FileWatcherCertificateProvider}. */\n+@RunWith(JUnit4.class)\n+public class FileWatcherCertificateProviderTest {\n+  private static final String CERT_FILE = \"cert.pem\";\n+  private static final String KEY_FILE = \"key.pem\";\n+  private static final String ROOT_FILE = \"root.pem\";\n+\n+  @Mock private CertificateProvider.Watcher mockWatcher;\n+  @Mock private ScheduledExecutorService timeService;\n+  @Mock private TimeProvider timeProvider;\n+\n+  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+  private String certFile;\n+  private String keyFile;\n+  private String rootFile;\n+\n+  private FileWatcherCertificateProvider provider;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+\n+    DistributorWatcher watcher = new DistributorWatcher();\n+    watcher.addWatcher(mockWatcher);\n+\n+    certFile = new File(tempFolder.getRoot(), CERT_FILE).getAbsolutePath();\n+    keyFile = new File(tempFolder.getRoot(), KEY_FILE).getAbsolutePath();\n+    rootFile = new File(tempFolder.getRoot(), ROOT_FILE).getAbsolutePath();\n+    provider =\n+        new FileWatcherCertificateProvider(\n+            watcher, true, certFile, keyFile, rootFile, 600L, timeService, timeProvider);\n+  }\n+\n+  private void populateTarget(\n+      String certFileSource,\n+      String keyFileSource,\n+      String rootFileSource,\n+      boolean deleteCurCert,\n+      boolean deleteCurKey,\n+      boolean deleteCurRoot)\n+      throws IOException {\n+    if (deleteCurCert) {\n+      Files.delete(Paths.get(certFile));\n+    }\n+    if (certFileSource != null) {\n+      certFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(certFileSource);\n+      Files.copy(Paths.get(certFileSource), Paths.get(certFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurKey) {\n+      Files.delete(Paths.get(keyFile));\n+    }\n+    if (keyFileSource != null) {\n+      keyFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(keyFileSource);\n+      Files.copy(Paths.get(keyFileSource), Paths.get(keyFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurRoot) {\n+      Files.delete(Paths.get(rootFile));\n+    }\n+    if (rootFileSource != null) {\n+      rootFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(rootFileSource);\n+      Files.copy(Paths.get(rootFileSource), Paths.get(rootFile), REPLACE_EXISTING);\n+    }\n+  }\n+\n+  @Test\n+  public void getCertificateAndCheckUpdates()\n+      throws IOException, CertificateException, InterruptedException {\n+    MeshCaCertificateProviderTest.TestScheduledFuture<?> scheduledFuture =\n+        new MeshCaCertificateProviderTest.TestScheduledFuture<>();\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    populateTarget(CLIENT_PEM_FILE, CLIENT_KEY_FILE, CA_PEM_FILE, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(CLIENT_PEM_FILE, CA_PEM_FILE);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    provider.scheduledHandle.cancel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e093fb1e7667d41f57dbe6614e6b1454b153581b"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM1NTk5OQ==", "bodyText": "That's right, there is no use case for calling cancel() since it is not really exercised in checkAndReloadCertificates(). Will remove it", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r518355999", "createdAt": "2020-11-05T20:50:03Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProviderTest.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_PEM_FILE;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.grpc.Status;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.DistributorWatcher;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.PrivateKey;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link FileWatcherCertificateProvider}. */\n+@RunWith(JUnit4.class)\n+public class FileWatcherCertificateProviderTest {\n+  private static final String CERT_FILE = \"cert.pem\";\n+  private static final String KEY_FILE = \"key.pem\";\n+  private static final String ROOT_FILE = \"root.pem\";\n+\n+  @Mock private CertificateProvider.Watcher mockWatcher;\n+  @Mock private ScheduledExecutorService timeService;\n+  @Mock private TimeProvider timeProvider;\n+\n+  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+  private String certFile;\n+  private String keyFile;\n+  private String rootFile;\n+\n+  private FileWatcherCertificateProvider provider;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+\n+    DistributorWatcher watcher = new DistributorWatcher();\n+    watcher.addWatcher(mockWatcher);\n+\n+    certFile = new File(tempFolder.getRoot(), CERT_FILE).getAbsolutePath();\n+    keyFile = new File(tempFolder.getRoot(), KEY_FILE).getAbsolutePath();\n+    rootFile = new File(tempFolder.getRoot(), ROOT_FILE).getAbsolutePath();\n+    provider =\n+        new FileWatcherCertificateProvider(\n+            watcher, true, certFile, keyFile, rootFile, 600L, timeService, timeProvider);\n+  }\n+\n+  private void populateTarget(\n+      String certFileSource,\n+      String keyFileSource,\n+      String rootFileSource,\n+      boolean deleteCurCert,\n+      boolean deleteCurKey,\n+      boolean deleteCurRoot)\n+      throws IOException {\n+    if (deleteCurCert) {\n+      Files.delete(Paths.get(certFile));\n+    }\n+    if (certFileSource != null) {\n+      certFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(certFileSource);\n+      Files.copy(Paths.get(certFileSource), Paths.get(certFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurKey) {\n+      Files.delete(Paths.get(keyFile));\n+    }\n+    if (keyFileSource != null) {\n+      keyFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(keyFileSource);\n+      Files.copy(Paths.get(keyFileSource), Paths.get(keyFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurRoot) {\n+      Files.delete(Paths.get(rootFile));\n+    }\n+    if (rootFileSource != null) {\n+      rootFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(rootFileSource);\n+      Files.copy(Paths.get(rootFileSource), Paths.get(rootFile), REPLACE_EXISTING);\n+    }\n+  }\n+\n+  @Test\n+  public void getCertificateAndCheckUpdates()\n+      throws IOException, CertificateException, InterruptedException {\n+    MeshCaCertificateProviderTest.TestScheduledFuture<?> scheduledFuture =\n+        new MeshCaCertificateProviderTest.TestScheduledFuture<>();\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    populateTarget(CLIENT_PEM_FILE, CLIENT_KEY_FILE, CA_PEM_FILE, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(CLIENT_PEM_FILE, CA_PEM_FILE);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    provider.scheduledHandle.cancel();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMzNTY2OA=="}, "originalCommit": {"oid": "e093fb1e7667d41f57dbe6614e6b1454b153581b"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MzMwNzkzOnYy", "diffSide": "RIGHT", "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProviderTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQyMjoyOTozOFrOHu_gkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwMTo0MjozNVrOHvchrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNzA3Mw==", "bodyText": "The test might take a little too long, 5s. Is it possible to make use of FakeClock for scheduler like other tests are doing?", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r519037073", "createdAt": "2020-11-06T22:29:38Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProviderTest.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_PEM_FILE;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.grpc.Status;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.DistributorWatcher;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.PrivateKey;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link FileWatcherCertificateProvider}. */\n+@RunWith(JUnit4.class)\n+public class FileWatcherCertificateProviderTest {\n+  private static final String CERT_FILE = \"cert.pem\";\n+  private static final String KEY_FILE = \"key.pem\";\n+  private static final String ROOT_FILE = \"root.pem\";\n+\n+  @Mock private CertificateProvider.Watcher mockWatcher;\n+  @Mock private ScheduledExecutorService timeService;\n+  @Mock private TimeProvider timeProvider;\n+\n+  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+  private String certFile;\n+  private String keyFile;\n+  private String rootFile;\n+\n+  private FileWatcherCertificateProvider provider;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+\n+    DistributorWatcher watcher = new DistributorWatcher();\n+    watcher.addWatcher(mockWatcher);\n+\n+    certFile = new File(tempFolder.getRoot(), CERT_FILE).getAbsolutePath();\n+    keyFile = new File(tempFolder.getRoot(), KEY_FILE).getAbsolutePath();\n+    rootFile = new File(tempFolder.getRoot(), ROOT_FILE).getAbsolutePath();\n+    provider =\n+        new FileWatcherCertificateProvider(\n+            watcher, true, certFile, keyFile, rootFile, 600L, timeService, timeProvider);\n+  }\n+\n+  private void populateTarget(\n+      String certFileSource,\n+      String keyFileSource,\n+      String rootFileSource,\n+      boolean deleteCurCert,\n+      boolean deleteCurKey,\n+      boolean deleteCurRoot)\n+      throws IOException {\n+    if (deleteCurCert) {\n+      Files.delete(Paths.get(certFile));\n+    }\n+    if (certFileSource != null) {\n+      certFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(certFileSource);\n+      Files.copy(Paths.get(certFileSource), Paths.get(certFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurKey) {\n+      Files.delete(Paths.get(keyFile));\n+    }\n+    if (keyFileSource != null) {\n+      keyFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(keyFileSource);\n+      Files.copy(Paths.get(keyFileSource), Paths.get(keyFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurRoot) {\n+      Files.delete(Paths.get(rootFile));\n+    }\n+    if (rootFileSource != null) {\n+      rootFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(rootFileSource);\n+      Files.copy(Paths.get(rootFileSource), Paths.get(rootFile), REPLACE_EXISTING);\n+    }\n+  }\n+\n+  @Test\n+  public void getCertificateAndCheckUpdates()\n+      throws IOException, CertificateException, InterruptedException {\n+    MeshCaCertificateProviderTest.TestScheduledFuture<?> scheduledFuture =\n+        new MeshCaCertificateProviderTest.TestScheduledFuture<>();\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    populateTarget(CLIENT_PEM_FILE, CLIENT_KEY_FILE, CA_PEM_FILE, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(CLIENT_PEM_FILE, CA_PEM_FILE);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherErrorUpdates(null, null, 0, 0, (String[]) null);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);\n+    populateTarget(null, null, SERVER_1_PEM_FILE, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(null, SERVER_1_PEM_FILE);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);\n+    populateTarget(SERVER_0_PEM_FILE, SERVER_0_KEY_FILE, null, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(SERVER_0_PEM_FILE, null);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60af22e1b1d105c8a733aaeb23c5dd03c165d8bd"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0ODcyNw==", "bodyText": "The problem is the file system timestamp precision is 1 second and the test uses actual files with their time stamps which cannot be faked. Hence 1 sec delay for unequal time stamps", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r519048727", "createdAt": "2020-11-06T23:07:16Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProviderTest.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_PEM_FILE;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.grpc.Status;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.DistributorWatcher;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.PrivateKey;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link FileWatcherCertificateProvider}. */\n+@RunWith(JUnit4.class)\n+public class FileWatcherCertificateProviderTest {\n+  private static final String CERT_FILE = \"cert.pem\";\n+  private static final String KEY_FILE = \"key.pem\";\n+  private static final String ROOT_FILE = \"root.pem\";\n+\n+  @Mock private CertificateProvider.Watcher mockWatcher;\n+  @Mock private ScheduledExecutorService timeService;\n+  @Mock private TimeProvider timeProvider;\n+\n+  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+  private String certFile;\n+  private String keyFile;\n+  private String rootFile;\n+\n+  private FileWatcherCertificateProvider provider;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+\n+    DistributorWatcher watcher = new DistributorWatcher();\n+    watcher.addWatcher(mockWatcher);\n+\n+    certFile = new File(tempFolder.getRoot(), CERT_FILE).getAbsolutePath();\n+    keyFile = new File(tempFolder.getRoot(), KEY_FILE).getAbsolutePath();\n+    rootFile = new File(tempFolder.getRoot(), ROOT_FILE).getAbsolutePath();\n+    provider =\n+        new FileWatcherCertificateProvider(\n+            watcher, true, certFile, keyFile, rootFile, 600L, timeService, timeProvider);\n+  }\n+\n+  private void populateTarget(\n+      String certFileSource,\n+      String keyFileSource,\n+      String rootFileSource,\n+      boolean deleteCurCert,\n+      boolean deleteCurKey,\n+      boolean deleteCurRoot)\n+      throws IOException {\n+    if (deleteCurCert) {\n+      Files.delete(Paths.get(certFile));\n+    }\n+    if (certFileSource != null) {\n+      certFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(certFileSource);\n+      Files.copy(Paths.get(certFileSource), Paths.get(certFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurKey) {\n+      Files.delete(Paths.get(keyFile));\n+    }\n+    if (keyFileSource != null) {\n+      keyFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(keyFileSource);\n+      Files.copy(Paths.get(keyFileSource), Paths.get(keyFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurRoot) {\n+      Files.delete(Paths.get(rootFile));\n+    }\n+    if (rootFileSource != null) {\n+      rootFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(rootFileSource);\n+      Files.copy(Paths.get(rootFileSource), Paths.get(rootFile), REPLACE_EXISTING);\n+    }\n+  }\n+\n+  @Test\n+  public void getCertificateAndCheckUpdates()\n+      throws IOException, CertificateException, InterruptedException {\n+    MeshCaCertificateProviderTest.TestScheduledFuture<?> scheduledFuture =\n+        new MeshCaCertificateProviderTest.TestScheduledFuture<>();\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    populateTarget(CLIENT_PEM_FILE, CLIENT_KEY_FILE, CA_PEM_FILE, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(CLIENT_PEM_FILE, CA_PEM_FILE);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherErrorUpdates(null, null, 0, 0, (String[]) null);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);\n+    populateTarget(null, null, SERVER_1_PEM_FILE, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(null, SERVER_1_PEM_FILE);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);\n+    populateTarget(SERVER_0_PEM_FILE, SERVER_0_KEY_FILE, null, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(SERVER_0_PEM_FILE, null);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNzA3Mw=="}, "originalCommit": {"oid": "60af22e1b1d105c8a733aaeb23c5dd03c165d8bd"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MDIxNQ==", "bodyText": "I see. Then can we separate them in multiple tests, each sleeps shorter? So if we run tests in parallel with gradle, it can save some time.", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r519050215", "createdAt": "2020-11-06T23:13:33Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProviderTest.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_PEM_FILE;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.grpc.Status;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.DistributorWatcher;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.PrivateKey;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link FileWatcherCertificateProvider}. */\n+@RunWith(JUnit4.class)\n+public class FileWatcherCertificateProviderTest {\n+  private static final String CERT_FILE = \"cert.pem\";\n+  private static final String KEY_FILE = \"key.pem\";\n+  private static final String ROOT_FILE = \"root.pem\";\n+\n+  @Mock private CertificateProvider.Watcher mockWatcher;\n+  @Mock private ScheduledExecutorService timeService;\n+  @Mock private TimeProvider timeProvider;\n+\n+  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+  private String certFile;\n+  private String keyFile;\n+  private String rootFile;\n+\n+  private FileWatcherCertificateProvider provider;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+\n+    DistributorWatcher watcher = new DistributorWatcher();\n+    watcher.addWatcher(mockWatcher);\n+\n+    certFile = new File(tempFolder.getRoot(), CERT_FILE).getAbsolutePath();\n+    keyFile = new File(tempFolder.getRoot(), KEY_FILE).getAbsolutePath();\n+    rootFile = new File(tempFolder.getRoot(), ROOT_FILE).getAbsolutePath();\n+    provider =\n+        new FileWatcherCertificateProvider(\n+            watcher, true, certFile, keyFile, rootFile, 600L, timeService, timeProvider);\n+  }\n+\n+  private void populateTarget(\n+      String certFileSource,\n+      String keyFileSource,\n+      String rootFileSource,\n+      boolean deleteCurCert,\n+      boolean deleteCurKey,\n+      boolean deleteCurRoot)\n+      throws IOException {\n+    if (deleteCurCert) {\n+      Files.delete(Paths.get(certFile));\n+    }\n+    if (certFileSource != null) {\n+      certFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(certFileSource);\n+      Files.copy(Paths.get(certFileSource), Paths.get(certFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurKey) {\n+      Files.delete(Paths.get(keyFile));\n+    }\n+    if (keyFileSource != null) {\n+      keyFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(keyFileSource);\n+      Files.copy(Paths.get(keyFileSource), Paths.get(keyFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurRoot) {\n+      Files.delete(Paths.get(rootFile));\n+    }\n+    if (rootFileSource != null) {\n+      rootFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(rootFileSource);\n+      Files.copy(Paths.get(rootFileSource), Paths.get(rootFile), REPLACE_EXISTING);\n+    }\n+  }\n+\n+  @Test\n+  public void getCertificateAndCheckUpdates()\n+      throws IOException, CertificateException, InterruptedException {\n+    MeshCaCertificateProviderTest.TestScheduledFuture<?> scheduledFuture =\n+        new MeshCaCertificateProviderTest.TestScheduledFuture<>();\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    populateTarget(CLIENT_PEM_FILE, CLIENT_KEY_FILE, CA_PEM_FILE, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(CLIENT_PEM_FILE, CA_PEM_FILE);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherErrorUpdates(null, null, 0, 0, (String[]) null);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);\n+    populateTarget(null, null, SERVER_1_PEM_FILE, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(null, SERVER_1_PEM_FILE);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);\n+    populateTarget(SERVER_0_PEM_FILE, SERVER_0_KEY_FILE, null, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(SERVER_0_PEM_FILE, null);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNzA3Mw=="}, "originalCommit": {"oid": "60af22e1b1d105c8a733aaeb23c5dd03c165d8bd"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUxMjQ5Mg==", "bodyText": "Good idea. Done.", "url": "https://github.com/grpc/grpc-java/pull/7590#discussion_r519512492", "createdAt": "2020-11-09T01:42:35Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/FileWatcherCertificateProviderTest.java", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CLIENT_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_KEY_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_PEM_FILE;\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.grpc.Status;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.DistributorWatcher;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Paths;\n+import java.security.PrivateKey;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/** Unit tests for {@link FileWatcherCertificateProvider}. */\n+@RunWith(JUnit4.class)\n+public class FileWatcherCertificateProviderTest {\n+  private static final String CERT_FILE = \"cert.pem\";\n+  private static final String KEY_FILE = \"key.pem\";\n+  private static final String ROOT_FILE = \"root.pem\";\n+\n+  @Mock private CertificateProvider.Watcher mockWatcher;\n+  @Mock private ScheduledExecutorService timeService;\n+  @Mock private TimeProvider timeProvider;\n+\n+  @Rule public TemporaryFolder tempFolder = new TemporaryFolder();\n+\n+  private String certFile;\n+  private String keyFile;\n+  private String rootFile;\n+\n+  private FileWatcherCertificateProvider provider;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+\n+    DistributorWatcher watcher = new DistributorWatcher();\n+    watcher.addWatcher(mockWatcher);\n+\n+    certFile = new File(tempFolder.getRoot(), CERT_FILE).getAbsolutePath();\n+    keyFile = new File(tempFolder.getRoot(), KEY_FILE).getAbsolutePath();\n+    rootFile = new File(tempFolder.getRoot(), ROOT_FILE).getAbsolutePath();\n+    provider =\n+        new FileWatcherCertificateProvider(\n+            watcher, true, certFile, keyFile, rootFile, 600L, timeService, timeProvider);\n+  }\n+\n+  private void populateTarget(\n+      String certFileSource,\n+      String keyFileSource,\n+      String rootFileSource,\n+      boolean deleteCurCert,\n+      boolean deleteCurKey,\n+      boolean deleteCurRoot)\n+      throws IOException {\n+    if (deleteCurCert) {\n+      Files.delete(Paths.get(certFile));\n+    }\n+    if (certFileSource != null) {\n+      certFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(certFileSource);\n+      Files.copy(Paths.get(certFileSource), Paths.get(certFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurKey) {\n+      Files.delete(Paths.get(keyFile));\n+    }\n+    if (keyFileSource != null) {\n+      keyFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(keyFileSource);\n+      Files.copy(Paths.get(keyFileSource), Paths.get(keyFile), REPLACE_EXISTING);\n+    }\n+    if (deleteCurRoot) {\n+      Files.delete(Paths.get(rootFile));\n+    }\n+    if (rootFileSource != null) {\n+      rootFileSource = CommonTlsContextTestsUtil.getTempFileNameForResourcesFile(rootFileSource);\n+      Files.copy(Paths.get(rootFileSource), Paths.get(rootFile), REPLACE_EXISTING);\n+    }\n+  }\n+\n+  @Test\n+  public void getCertificateAndCheckUpdates()\n+      throws IOException, CertificateException, InterruptedException {\n+    MeshCaCertificateProviderTest.TestScheduledFuture<?> scheduledFuture =\n+        new MeshCaCertificateProviderTest.TestScheduledFuture<>();\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    populateTarget(CLIENT_PEM_FILE, CLIENT_KEY_FILE, CA_PEM_FILE, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(CLIENT_PEM_FILE, CA_PEM_FILE);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherErrorUpdates(null, null, 0, 0, (String[]) null);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);\n+    populateTarget(null, null, SERVER_1_PEM_FILE, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(null, SERVER_1_PEM_FILE);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);\n+    populateTarget(SERVER_0_PEM_FILE, SERVER_0_KEY_FILE, null, false, false, false);\n+    provider.checkAndReloadCertificates();\n+    verifyWatcherUpdates(SERVER_0_PEM_FILE, null);\n+    verifyTimeServiceAndScheduledHandle();\n+\n+    reset(mockWatcher, timeService);\n+    doReturn(scheduledFuture)\n+        .when(timeService)\n+        .schedule(any(Runnable.class), any(Long.TYPE), eq(TimeUnit.SECONDS));\n+    Thread.sleep(1000L);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNzA3Mw=="}, "originalCommit": {"oid": "60af22e1b1d105c8a733aaeb23c5dd03c165d8bd"}, "originalPosition": 172}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2272, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}