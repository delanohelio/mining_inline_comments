{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ1NzY3ODI5", "number": 7188, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozNzo1NFrOEM_iPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMTowMTowM1rOENafdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMDU5MzI2OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProviderStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxNzozNzo1NFrOGvbQtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjo0MjoxN1rOGv-KDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MjkwMQ==", "bodyText": "I think it's not necessary to introduce yet a new interface. Just make Handle a concrete class would be sufficient. Actually even the test is not taking advantage of interface.", "url": "https://github.com/grpc/grpc-java/pull/7188#discussion_r452382901", "createdAt": "2020-07-09T17:37:54Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProviderStore.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Status;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.Watcher;\n+import io.grpc.xds.internal.sds.ReferenceCountingMap;\n+\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Global map of all ref-counted {@link CertificateProvider}s that have been instantiated in\n+ * the application. Also  propagates updates received from a {@link CertificateProvider} to all\n+ * the {@link Watcher}s registered for that CertificateProvider. The Store is meant to be\n+ * used internally by gRPC and *not* a public API.\n+ */\n+@ThreadSafe\n+public final class CertificateProviderStore {\n+  private static final Logger logger = Logger.getLogger(CertificateProviderStore.class.getName());\n+\n+  private static CertificateProviderStore instance;\n+  private final CertificateProviderRegistry certificateProviderRegistry;\n+  private final ReferenceCountingMap<CertProviderKey, CertificateProvider> certProviderMap;\n+\n+  /** Opaque Handle returned by {@link #createOrGetProvider}. */\n+  interface Handle extends java.io.Closeable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99125a567dc11a94d349ae614807ce14f6186b49"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1NDYzOQ==", "bodyText": "Good point. Done.", "url": "https://github.com/grpc/grpc-java/pull/7188#discussion_r452954639", "createdAt": "2020-07-10T16:42:17Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProviderStore.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Status;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.Watcher;\n+import io.grpc.xds.internal.sds.ReferenceCountingMap;\n+\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Global map of all ref-counted {@link CertificateProvider}s that have been instantiated in\n+ * the application. Also  propagates updates received from a {@link CertificateProvider} to all\n+ * the {@link Watcher}s registered for that CertificateProvider. The Store is meant to be\n+ * used internally by gRPC and *not* a public API.\n+ */\n+@ThreadSafe\n+public final class CertificateProviderStore {\n+  private static final Logger logger = Logger.getLogger(CertificateProviderStore.class.getName());\n+\n+  private static CertificateProviderStore instance;\n+  private final CertificateProviderRegistry certificateProviderRegistry;\n+  private final ReferenceCountingMap<CertProviderKey, CertificateProvider> certProviderMap;\n+\n+  /** Opaque Handle returned by {@link #createOrGetProvider}. */\n+  interface Handle extends java.io.Closeable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM4MjkwMQ=="}, "originalCommit": {"oid": "99125a567dc11a94d349ae614807ce14f6186b49"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTMxODY3OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProviderStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMToyNTo0NVrOGviXdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjo0Mzo0MFrOGv-MsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5OTMxOA==", "bodyText": "This casting is not obvious. What about defining CertificateProvider with a generic type for watcher:\npublic abstract class CertificateProvider<T extends Watcher> implements Closeable {\n  final T watcher;\n  public T getWatcher() {\n    return watcher;\n   }\n}", "url": "https://github.com/grpc/grpc-java/pull/7188#discussion_r452499318", "createdAt": "2020-07-09T21:25:45Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProviderStore.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Status;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.Watcher;\n+import io.grpc.xds.internal.sds.ReferenceCountingMap;\n+\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Global map of all ref-counted {@link CertificateProvider}s that have been instantiated in\n+ * the application. Also  propagates updates received from a {@link CertificateProvider} to all\n+ * the {@link Watcher}s registered for that CertificateProvider. The Store is meant to be\n+ * used internally by gRPC and *not* a public API.\n+ */\n+@ThreadSafe\n+public final class CertificateProviderStore {\n+  private static final Logger logger = Logger.getLogger(CertificateProviderStore.class.getName());\n+\n+  private static CertificateProviderStore instance;\n+  private final CertificateProviderRegistry certificateProviderRegistry;\n+  private final ReferenceCountingMap<CertProviderKey, CertificateProvider> certProviderMap;\n+\n+  /** Opaque Handle returned by {@link #createOrGetProvider}. */\n+  interface Handle extends java.io.Closeable {\n+\n+    /**\n+     * Removes the associated {@link Watcher} for the {@link CertificateProvider} and\n+     * decrements the ref-count. Releases the {@link CertificateProvider} if the ref-count\n+     * has reached 0.\n+     */\n+    @Override\n+    void close();\n+  }\n+\n+  private static final class CertProviderKey {\n+    private final String certName;\n+    private final String pluginName;\n+    private final boolean notifyCertUpdates;\n+    private final Object config;\n+\n+    private CertProviderKey(\n+        String certName, String pluginName, boolean notifyCertUpdates, Object config) {\n+      this.certName = certName;\n+      this.pluginName = pluginName;\n+      this.notifyCertUpdates = notifyCertUpdates;\n+      this.config = config;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (!(o instanceof CertProviderKey)) {\n+        return false;\n+      }\n+      CertProviderKey that = (CertProviderKey) o;\n+      return notifyCertUpdates == that.notifyCertUpdates\n+          && Objects.equals(certName, that.certName)\n+          && Objects.equals(pluginName, that.pluginName)\n+          && Objects.equals(config, that.config);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(certName, pluginName, notifyCertUpdates, config);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"CertProviderKey{\"\n+          + \"certName='\"\n+          + certName\n+          + '\\''\n+          + \", pluginName='\"\n+          + pluginName\n+          + '\\''\n+          + \", notifyCertUpdates=\"\n+          + notifyCertUpdates\n+          + \", config=\"\n+          + config\n+          + '}';\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  static final class DistributorWatcher implements CertificateProvider.Watcher {\n+    @VisibleForTesting\n+    final ArrayList<Watcher> downsstreamWatchers = new ArrayList<>();\n+\n+    private synchronized void addWatcher(Watcher watcher) {\n+      downsstreamWatchers.add(watcher);\n+    }\n+\n+    private synchronized void removeWatcher(Watcher watcher) {\n+      downsstreamWatchers.remove(watcher);\n+    }\n+\n+    private DistributorWatcher() {\n+    }\n+\n+    @Override\n+    public void updateCertificate(PrivateKey key, List<X509Certificate> certChain) {\n+      for (Watcher watcher : downsstreamWatchers) {\n+        watcher.updateCertificate(key, certChain);\n+      }\n+    }\n+\n+    @Override\n+    public void updateTrustedRoots(List<X509Certificate> trustedRoots) {\n+      for (Watcher watcher : downsstreamWatchers) {\n+        watcher.updateTrustedRoots(trustedRoots);\n+      }\n+    }\n+\n+    @Override\n+    public void onError(Status errorStatus) {\n+      for (Watcher watcher : downsstreamWatchers) {\n+        watcher.onError(errorStatus);\n+      }\n+    }\n+  }\n+\n+  private final class CertProviderFactory\n+      implements ReferenceCountingMap.ValueFactory<CertProviderKey, CertificateProvider> {\n+\n+    private CertProviderFactory() {\n+    }\n+\n+    @Override\n+    public CertificateProvider create(CertProviderKey key) {\n+      CertificateProviderProvider certProviderProvider =\n+          certificateProviderRegistry.getProvider(key.pluginName);\n+      if (certProviderProvider == null) {\n+        throw new IllegalArgumentException(\"Provider not found.\");\n+      }\n+      return certProviderProvider.createCertificateProvider(\n+          key.config, new DistributorWatcher(), key.notifyCertUpdates);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  CertificateProviderStore(CertificateProviderRegistry certificateProviderRegistry) {\n+    this.certificateProviderRegistry = certificateProviderRegistry;\n+    certProviderMap = new ReferenceCountingMap<>(new CertProviderFactory());\n+  }\n+\n+  @VisibleForTesting\n+  final class HandleImpl implements Handle {\n+    private final CertProviderKey key;\n+    private final Watcher watcher;\n+    @VisibleForTesting\n+    final CertificateProvider certProvider;\n+\n+    private HandleImpl(CertProviderKey key, Watcher watcher, CertificateProvider certProvider) {\n+      this.key = key;\n+      this.watcher = watcher;\n+      this.certProvider = certProvider;\n+    }\n+\n+    @Override\n+    public synchronized void close() {\n+      DistributorWatcher distWatcher = (DistributorWatcher)certProvider.getWatcher();\n+      distWatcher.removeWatcher(watcher);\n+      certProviderMap.release(key, certProvider);\n+    }\n+  }\n+\n+  /**\n+   * Creates or retrieves a {@link CertificateProvider} instance, increments its ref-count and\n+   * registers the watcher passed. Returns a {@link Handle} that can be {@link Handle#close()}d when\n+   * the instance is no longer needed by the caller.\n+   *\n+   * @param notifyCertUpdates when true, the caller is interested in identity cert updates. When\n+   *     false, the caller cannot depend on receiving the {@link Watcher#updateCertificate}\n+   *     callbacks but may still receive these callbacks which should be ignored.\n+   * @throws IllegalArgumentException in case of errors in processing config or the plugin is\n+   *     incapable of sending cert updates when notifyCertUpdates is true.\n+   * @throws UnsupportedOperationException if the plugin is incapable of sending cert updates when\n+   *     notifyCertUpdates is true.\n+   */\n+  public synchronized Handle createOrGetProvider(\n+      String certName,\n+      String pluginName,\n+      Object config,\n+      Watcher watcher,\n+      boolean notifyCertUpdates) {\n+    if (!notifyCertUpdates) {\n+      // we try to get a provider first for notifyCertUpdates==true always\n+      try {\n+        return createProviderHelper(certName, pluginName, config, watcher, true);\n+      } catch (UnsupportedOperationException uoe) {\n+        // ignore & log exception and fall thru to create a provider with actual value\n+        logger.log(Level.FINE, \"Trying to get provider for notifyCertUpdates==true\", uoe);\n+      }\n+    }\n+    return createProviderHelper(certName, pluginName, config, watcher, notifyCertUpdates);\n+  }\n+\n+  private synchronized Handle createProviderHelper(\n+      String certName,\n+      String pluginName,\n+      Object config,\n+      Watcher watcher,\n+      boolean notifyCertUpdates) {\n+    CertProviderKey key = new CertProviderKey(certName, pluginName, notifyCertUpdates, config);\n+    CertificateProvider provider = certProviderMap.get(key);\n+    DistributorWatcher distWatcher = (DistributorWatcher) provider.getWatcher();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99125a567dc11a94d349ae614807ce14f6186b49"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1NTMxMg==", "bodyText": "Good point about the casting. But I realized a generic is not needed. The CertificateProvider always takes a DistributorWatcher so I moved the inner class here and removed the casting in all those places.", "url": "https://github.com/grpc/grpc-java/pull/7188#discussion_r452955312", "createdAt": "2020-07-10T16:43:40Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProviderStore.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Status;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.Watcher;\n+import io.grpc.xds.internal.sds.ReferenceCountingMap;\n+\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * Global map of all ref-counted {@link CertificateProvider}s that have been instantiated in\n+ * the application. Also  propagates updates received from a {@link CertificateProvider} to all\n+ * the {@link Watcher}s registered for that CertificateProvider. The Store is meant to be\n+ * used internally by gRPC and *not* a public API.\n+ */\n+@ThreadSafe\n+public final class CertificateProviderStore {\n+  private static final Logger logger = Logger.getLogger(CertificateProviderStore.class.getName());\n+\n+  private static CertificateProviderStore instance;\n+  private final CertificateProviderRegistry certificateProviderRegistry;\n+  private final ReferenceCountingMap<CertProviderKey, CertificateProvider> certProviderMap;\n+\n+  /** Opaque Handle returned by {@link #createOrGetProvider}. */\n+  interface Handle extends java.io.Closeable {\n+\n+    /**\n+     * Removes the associated {@link Watcher} for the {@link CertificateProvider} and\n+     * decrements the ref-count. Releases the {@link CertificateProvider} if the ref-count\n+     * has reached 0.\n+     */\n+    @Override\n+    void close();\n+  }\n+\n+  private static final class CertProviderKey {\n+    private final String certName;\n+    private final String pluginName;\n+    private final boolean notifyCertUpdates;\n+    private final Object config;\n+\n+    private CertProviderKey(\n+        String certName, String pluginName, boolean notifyCertUpdates, Object config) {\n+      this.certName = certName;\n+      this.pluginName = pluginName;\n+      this.notifyCertUpdates = notifyCertUpdates;\n+      this.config = config;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (!(o instanceof CertProviderKey)) {\n+        return false;\n+      }\n+      CertProviderKey that = (CertProviderKey) o;\n+      return notifyCertUpdates == that.notifyCertUpdates\n+          && Objects.equals(certName, that.certName)\n+          && Objects.equals(pluginName, that.pluginName)\n+          && Objects.equals(config, that.config);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(certName, pluginName, notifyCertUpdates, config);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"CertProviderKey{\"\n+          + \"certName='\"\n+          + certName\n+          + '\\''\n+          + \", pluginName='\"\n+          + pluginName\n+          + '\\''\n+          + \", notifyCertUpdates=\"\n+          + notifyCertUpdates\n+          + \", config=\"\n+          + config\n+          + '}';\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  static final class DistributorWatcher implements CertificateProvider.Watcher {\n+    @VisibleForTesting\n+    final ArrayList<Watcher> downsstreamWatchers = new ArrayList<>();\n+\n+    private synchronized void addWatcher(Watcher watcher) {\n+      downsstreamWatchers.add(watcher);\n+    }\n+\n+    private synchronized void removeWatcher(Watcher watcher) {\n+      downsstreamWatchers.remove(watcher);\n+    }\n+\n+    private DistributorWatcher() {\n+    }\n+\n+    @Override\n+    public void updateCertificate(PrivateKey key, List<X509Certificate> certChain) {\n+      for (Watcher watcher : downsstreamWatchers) {\n+        watcher.updateCertificate(key, certChain);\n+      }\n+    }\n+\n+    @Override\n+    public void updateTrustedRoots(List<X509Certificate> trustedRoots) {\n+      for (Watcher watcher : downsstreamWatchers) {\n+        watcher.updateTrustedRoots(trustedRoots);\n+      }\n+    }\n+\n+    @Override\n+    public void onError(Status errorStatus) {\n+      for (Watcher watcher : downsstreamWatchers) {\n+        watcher.onError(errorStatus);\n+      }\n+    }\n+  }\n+\n+  private final class CertProviderFactory\n+      implements ReferenceCountingMap.ValueFactory<CertProviderKey, CertificateProvider> {\n+\n+    private CertProviderFactory() {\n+    }\n+\n+    @Override\n+    public CertificateProvider create(CertProviderKey key) {\n+      CertificateProviderProvider certProviderProvider =\n+          certificateProviderRegistry.getProvider(key.pluginName);\n+      if (certProviderProvider == null) {\n+        throw new IllegalArgumentException(\"Provider not found.\");\n+      }\n+      return certProviderProvider.createCertificateProvider(\n+          key.config, new DistributorWatcher(), key.notifyCertUpdates);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  CertificateProviderStore(CertificateProviderRegistry certificateProviderRegistry) {\n+    this.certificateProviderRegistry = certificateProviderRegistry;\n+    certProviderMap = new ReferenceCountingMap<>(new CertProviderFactory());\n+  }\n+\n+  @VisibleForTesting\n+  final class HandleImpl implements Handle {\n+    private final CertProviderKey key;\n+    private final Watcher watcher;\n+    @VisibleForTesting\n+    final CertificateProvider certProvider;\n+\n+    private HandleImpl(CertProviderKey key, Watcher watcher, CertificateProvider certProvider) {\n+      this.key = key;\n+      this.watcher = watcher;\n+      this.certProvider = certProvider;\n+    }\n+\n+    @Override\n+    public synchronized void close() {\n+      DistributorWatcher distWatcher = (DistributorWatcher)certProvider.getWatcher();\n+      distWatcher.removeWatcher(watcher);\n+      certProviderMap.release(key, certProvider);\n+    }\n+  }\n+\n+  /**\n+   * Creates or retrieves a {@link CertificateProvider} instance, increments its ref-count and\n+   * registers the watcher passed. Returns a {@link Handle} that can be {@link Handle#close()}d when\n+   * the instance is no longer needed by the caller.\n+   *\n+   * @param notifyCertUpdates when true, the caller is interested in identity cert updates. When\n+   *     false, the caller cannot depend on receiving the {@link Watcher#updateCertificate}\n+   *     callbacks but may still receive these callbacks which should be ignored.\n+   * @throws IllegalArgumentException in case of errors in processing config or the plugin is\n+   *     incapable of sending cert updates when notifyCertUpdates is true.\n+   * @throws UnsupportedOperationException if the plugin is incapable of sending cert updates when\n+   *     notifyCertUpdates is true.\n+   */\n+  public synchronized Handle createOrGetProvider(\n+      String certName,\n+      String pluginName,\n+      Object config,\n+      Watcher watcher,\n+      boolean notifyCertUpdates) {\n+    if (!notifyCertUpdates) {\n+      // we try to get a provider first for notifyCertUpdates==true always\n+      try {\n+        return createProviderHelper(certName, pluginName, config, watcher, true);\n+      } catch (UnsupportedOperationException uoe) {\n+        // ignore & log exception and fall thru to create a provider with actual value\n+        logger.log(Level.FINE, \"Trying to get provider for notifyCertUpdates==true\", uoe);\n+      }\n+    }\n+    return createProviderHelper(certName, pluginName, config, watcher, notifyCertUpdates);\n+  }\n+\n+  private synchronized Handle createProviderHelper(\n+      String certName,\n+      String pluginName,\n+      Object config,\n+      Watcher watcher,\n+      boolean notifyCertUpdates) {\n+    CertProviderKey key = new CertProviderKey(certName, pluginName, notifyCertUpdates, config);\n+    CertificateProvider provider = certProviderMap.get(key);\n+    DistributorWatcher distWatcher = (DistributorWatcher) provider.getWatcher();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5OTMxOA=="}, "originalCommit": {"oid": "99125a567dc11a94d349ae614807ce14f6186b49"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyMTMyMTc4OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMToyNjo0MVrOGviZPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQxNjo0Mzo1N1rOGv-NQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5OTc3NA==", "bodyText": "protected fields can be private as now you have public accessors.", "url": "https://github.com/grpc/grpc-java/pull/7188#discussion_r452499774", "createdAt": "2020-07-09T21:26:41Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProvider.java", "diffHunk": "@@ -62,4 +62,12 @@ protected CertificateProvider(Watcher watcher, boolean notifyCertUpdates) {\n \n   protected final Watcher watcher;\n   protected final boolean notifyCertUpdates;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "99125a567dc11a94d349ae614807ce14f6186b49"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjk1NTQ1OQ==", "bodyText": "Done", "url": "https://github.com/grpc/grpc-java/pull/7188#discussion_r452955459", "createdAt": "2020-07-10T16:43:57Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProvider.java", "diffHunk": "@@ -62,4 +62,12 @@ protected CertificateProvider(Watcher watcher, boolean notifyCertUpdates) {\n \n   protected final Watcher watcher;\n   protected final boolean notifyCertUpdates;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5OTc3NA=="}, "originalCommit": {"oid": "99125a567dc11a94d349ae614807ce14f6186b49"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNTAwOTgyOnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMTowMTowM1rOGwFhDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMTo1MzoxMVrOGwGovA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NTIxNA==", "bodyText": "What's the reason of using ArrayList rather than HashSet? Could there be duplicate entries in the collection? Do the order of the entries matter?", "url": "https://github.com/grpc/grpc-java/pull/7188#discussion_r453075214", "createdAt": "2020-07-10T21:01:03Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProvider.java", "diffHunk": "@@ -42,6 +44,41 @@\n     void onError(Status errorStatus);\n   }\n \n+  @VisibleForTesting\n+  static final class DistributorWatcher implements Watcher {\n+    @VisibleForTesting\n+    final ArrayList<Watcher> downsstreamWatchers = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73120c0a16b8d1b7cc50ae8661261fe0f66be0b1"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA5MzU2NA==", "bodyText": "Order definitely doesn't matter. And I cannot think of any straightforward example that requires duplicate entries support. For now I will change it to HashSet.", "url": "https://github.com/grpc/grpc-java/pull/7188#discussion_r453093564", "createdAt": "2020-07-10T21:53:11Z", "author": {"login": "sanjaypujare"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProvider.java", "diffHunk": "@@ -42,6 +44,41 @@\n     void onError(Status errorStatus);\n   }\n \n+  @VisibleForTesting\n+  static final class DistributorWatcher implements Watcher {\n+    @VisibleForTesting\n+    final ArrayList<Watcher> downsstreamWatchers = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3NTIxNA=="}, "originalCommit": {"oid": "73120c0a16b8d1b7cc50ae8661261fe0f66be0b1"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2586, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}