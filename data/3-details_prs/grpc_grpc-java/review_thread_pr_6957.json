{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2ODc1NDk3", "number": 6957, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMTowNjoxNlrOD0gfBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxODoxNTozMVrOD05eiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mzg0Nzc0OnYy", "diffSide": "RIGHT", "path": "rls/src/main/java/io/grpc/rls/internal/LinkedHashLruCache.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMTowNjoxNlrOGJeyrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjo1Nzo0OVrOGKA5ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5NDg2MA==", "bodyText": "get() will trigger LinkedHashMap's access ordering. If the existing value is not the one to be deleted, it will be re-inserted to the tail of the linked list. Maybe\nboolean replaced = delegate.replace(key, new SizedValue(0, value), null);\nif (replaced) {\n  delegate.remove(key);\n  evictionListener.onEviction(key, value, EvictionType.EXPLICIT);\n  return true;\n}\n\nEdited: it's tricky to replace a sized value.", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r412594860", "createdAt": "2020-04-22T01:06:16Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/LinkedHashLruCache.java", "diffHunk": "@@ -191,6 +191,22 @@ private V invalidate(K key, EvictionType cause) {\n     }\n   }\n \n+  @Override\n+  public final boolean invalidate(K key, V value) {\n+    checkNotNull(key, \"key\");\n+    checkNotNull(value, \"value\");\n+    synchronized (lock) {\n+      SizedValue existing = delegate.get(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "444a471f34dd53059ea4a5be724f555b7d3b9049"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxMjgwNg==", "bodyText": "yes, i didn't really consider the access ordering. thanks", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r412612806", "createdAt": "2020-04-22T01:58:41Z", "author": {"login": "creamsoup"}, "path": "rls/src/main/java/io/grpc/rls/internal/LinkedHashLruCache.java", "diffHunk": "@@ -191,6 +191,22 @@ private V invalidate(K key, EvictionType cause) {\n     }\n   }\n \n+  @Override\n+  public final boolean invalidate(K key, V value) {\n+    checkNotNull(key, \"key\");\n+    checkNotNull(value, \"value\");\n+    synchronized (lock) {\n+      SizedValue existing = delegate.get(key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5NDg2MA=="}, "originalCommit": {"oid": "444a471f34dd53059ea4a5be724f555b7d3b9049"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxNjI0MQ==", "bodyText": "unfortunately the replace is java8 api. doesn't seem like there is a good option for java7", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r412616241", "createdAt": "2020-04-22T02:09:04Z", "author": {"login": "creamsoup"}, "path": "rls/src/main/java/io/grpc/rls/internal/LinkedHashLruCache.java", "diffHunk": "@@ -191,6 +191,22 @@ private V invalidate(K key, EvictionType cause) {\n     }\n   }\n \n+  @Override\n+  public final boolean invalidate(K key, V value) {\n+    checkNotNull(key, \"key\");\n+    checkNotNull(value, \"value\");\n+    synchronized (lock) {\n+      SizedValue existing = delegate.get(key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5NDg2MA=="}, "originalCommit": {"oid": "444a471f34dd53059ea4a5be724f555b7d3b9049"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE0MDE0OQ==", "bodyText": "Maybe leave here a TODO with rationale on access ordering and java7 restriction.", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413140149", "createdAt": "2020-04-22T16:40:54Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/main/java/io/grpc/rls/internal/LinkedHashLruCache.java", "diffHunk": "@@ -191,6 +191,22 @@ private V invalidate(K key, EvictionType cause) {\n     }\n   }\n \n+  @Override\n+  public final boolean invalidate(K key, V value) {\n+    checkNotNull(key, \"key\");\n+    checkNotNull(value, \"value\");\n+    synchronized (lock) {\n+      SizedValue existing = delegate.get(key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5NDg2MA=="}, "originalCommit": {"oid": "444a471f34dd53059ea4a5be724f555b7d3b9049"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE0NzEwNw==", "bodyText": "i am trying to remove this method. and make the caller work around this problem.", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413147107", "createdAt": "2020-04-22T16:48:40Z", "author": {"login": "creamsoup"}, "path": "rls/src/main/java/io/grpc/rls/internal/LinkedHashLruCache.java", "diffHunk": "@@ -191,6 +191,22 @@ private V invalidate(K key, EvictionType cause) {\n     }\n   }\n \n+  @Override\n+  public final boolean invalidate(K key, V value) {\n+    checkNotNull(key, \"key\");\n+    checkNotNull(value, \"value\");\n+    synchronized (lock) {\n+      SizedValue existing = delegate.get(key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5NDg2MA=="}, "originalCommit": {"oid": "444a471f34dd53059ea4a5be724f555b7d3b9049"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE1MzcyMg==", "bodyText": "okay removed.", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413153722", "createdAt": "2020-04-22T16:57:49Z", "author": {"login": "creamsoup"}, "path": "rls/src/main/java/io/grpc/rls/internal/LinkedHashLruCache.java", "diffHunk": "@@ -191,6 +191,22 @@ private V invalidate(K key, EvictionType cause) {\n     }\n   }\n \n+  @Override\n+  public final boolean invalidate(K key, V value) {\n+    checkNotNull(key, \"key\");\n+    checkNotNull(value, \"value\");\n+    synchronized (lock) {\n+      SizedValue existing = delegate.get(key);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5NDg2MA=="}, "originalCommit": {"oid": "444a471f34dd53059ea4a5be724f555b7d3b9049"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mzg5MjkzOnYy", "diffSide": "RIGHT", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMToyNDo0M1rOGJfKEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjo1Mzo0OVrOGKAuJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwMDg0OA==", "bodyText": "Seems every method of DoNotUseDirectScheduledExecutorService calls maybeInit(), why not just init these fields directly at their declaration and remove maybeInit().", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r412600848", "createdAt": "2020-04-22T01:24:43Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized = false;\n+\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "444a471f34dd53059ea4a5be724f555b7d3b9049"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxNDEwOQ==", "bodyText": "this was due to the CALLS_REAL_METHODS doesn't initialize instance variables. comment will be added.", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r412614109", "createdAt": "2020-04-22T02:02:27Z", "author": {"login": "creamsoup"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized = false;\n+\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwMDg0OA=="}, "originalCommit": {"oid": "444a471f34dd53059ea4a5be724f555b7d3b9049"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEzOTM1Mw==", "bodyText": "Maybe also add a non-constructor\nprivate DoNotUseDirectScheduledExecutorService() {\n  throw new UnsupportedOperationException(\"this class is for mock only\");\n}\n\nBtw, did you ever consider implementing FakeClock.ScheduledExecutorImpl.scheduleAtFixedRate()? Will there be any problem?", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413139353", "createdAt": "2020-04-22T16:39:49Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized = false;\n+\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwMDg0OA=="}, "originalCommit": {"oid": "444a471f34dd53059ea4a5be724f555b7d3b9049"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE1MDc1Nw==", "bodyText": "the only reason i didn't implement scheduleAtFixedRate is i don't need it. it can be added if we need. also supporting multiple scheduled tasks is not hard. just don't need it at this point.", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413150757", "createdAt": "2020-04-22T16:53:49Z", "author": {"login": "creamsoup"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized = false;\n+\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwMDg0OA=="}, "originalCommit": {"oid": "444a471f34dd53059ea4a5be724f555b7d3b9049"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzQ5NjU4OnYy", "diffSide": "RIGHT", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjo0MzoxMVrOGKALXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNjo0MzoxMVrOGKALXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE0MTg1Mw==", "bodyText": "Don't set initial value here.", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413141853", "createdAt": "2020-04-22T16:43:11Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e333ef027cf2bc98ba09e2d98f040e5d42910464"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzY1NDkzOnYy", "diffSide": "RIGHT", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzoxNDozMVrOGKBpkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzo1OTo1MFrOGKDplQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE2NTk2OQ==", "bodyText": "Why set running = true?", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413165969", "createdAt": "2020-04-22T17:14:31Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {\n+    maybeInit();\n+    return new FakeTimeProvider();\n+  }\n+\n+  void forwardTime(long delta, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delta > 0, \"delta must be positive\");\n+    long finalTime = currTimeNanos + unit.toNanos(delta);\n+\n+    if (repeatedCommand.get() != null) {\n+      while (finalTime >= nextRun) {\n+        scheduledCommands.add(new ScheduledRunnable(nextRun, repeatedCommand.get()));\n+        nextRun += period;\n+      }\n+    }\n+\n+    while (!scheduledCommands.isEmpty()\n+        && scheduledCommands.peek().scheduledTimeNanos <= finalTime) {\n+      ScheduledRunnable scheduledCommand = scheduledCommands.poll();\n+      try {\n+        // pretend to run at the scheduled time\n+        currTimeNanos = scheduledCommand.scheduledTimeNanos;\n+        scheduledCommand.run();\n+      } catch (Throwable t) {\n+        throw new RuntimeException(\"failed to run scheduled command: \" + scheduledCommand, t);\n+      }\n+    }\n+\n+    this.currTimeNanos = finalTime;\n+  }\n+\n+  private final class ScheduledRunnable implements Runnable {\n+    private final long scheduledTimeNanos;\n+    private final Runnable command;\n+    private final ScheduledFuture<?> scheduledFuture = new ScheduledRunnable.FakeScheduledFuture();\n+    private final Object lock = new Object();\n+    private boolean running = false;\n+    private boolean done = false;\n+\n+    public ScheduledRunnable(long scheduledTimeNanos, Runnable command) {\n+      this.scheduledTimeNanos = scheduledTimeNanos;\n+      this.command = checkNotNull(command, \"command\");\n+    }\n+\n+    @Override\n+    public void run() {\n+      synchronized (lock) {\n+        if (!scheduledFuture.isCancelled()) {\n+          running = true;\n+          command.run();\n+          done = true;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"scheduledTimeNanos\", scheduledTimeNanos)\n+          .add(\"command\", command)\n+          .add(\"scheduledFuture\", scheduledFuture)\n+          .add(\"running\", running)\n+          .add(\"done\", done)\n+          .toString();\n+    }\n+\n+    private class FakeScheduledFuture implements ScheduledFuture<Object> {\n+      boolean cancelled = false;\n+\n+      @Override\n+      public long getDelay(TimeUnit unit) {\n+        return unit.convert(scheduledTimeNanos - currTimeNanos, TimeUnit.NANOSECONDS);\n+      }\n+\n+      @Override\n+      public int compareTo(Delayed unused) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      @Override\n+      public synchronized boolean cancel(boolean mayInterruptIfRunning) {\n+        if (running) {\n+          return false;\n+        }\n+        running = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "847b8e88976b9949f44f061fb40e393245b799cd"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE5ODc0MQ==", "bodyText": "oops probably mistake thanks.", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413198741", "createdAt": "2020-04-22T17:59:50Z", "author": {"login": "creamsoup"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {\n+    maybeInit();\n+    return new FakeTimeProvider();\n+  }\n+\n+  void forwardTime(long delta, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delta > 0, \"delta must be positive\");\n+    long finalTime = currTimeNanos + unit.toNanos(delta);\n+\n+    if (repeatedCommand.get() != null) {\n+      while (finalTime >= nextRun) {\n+        scheduledCommands.add(new ScheduledRunnable(nextRun, repeatedCommand.get()));\n+        nextRun += period;\n+      }\n+    }\n+\n+    while (!scheduledCommands.isEmpty()\n+        && scheduledCommands.peek().scheduledTimeNanos <= finalTime) {\n+      ScheduledRunnable scheduledCommand = scheduledCommands.poll();\n+      try {\n+        // pretend to run at the scheduled time\n+        currTimeNanos = scheduledCommand.scheduledTimeNanos;\n+        scheduledCommand.run();\n+      } catch (Throwable t) {\n+        throw new RuntimeException(\"failed to run scheduled command: \" + scheduledCommand, t);\n+      }\n+    }\n+\n+    this.currTimeNanos = finalTime;\n+  }\n+\n+  private final class ScheduledRunnable implements Runnable {\n+    private final long scheduledTimeNanos;\n+    private final Runnable command;\n+    private final ScheduledFuture<?> scheduledFuture = new ScheduledRunnable.FakeScheduledFuture();\n+    private final Object lock = new Object();\n+    private boolean running = false;\n+    private boolean done = false;\n+\n+    public ScheduledRunnable(long scheduledTimeNanos, Runnable command) {\n+      this.scheduledTimeNanos = scheduledTimeNanos;\n+      this.command = checkNotNull(command, \"command\");\n+    }\n+\n+    @Override\n+    public void run() {\n+      synchronized (lock) {\n+        if (!scheduledFuture.isCancelled()) {\n+          running = true;\n+          command.run();\n+          done = true;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"scheduledTimeNanos\", scheduledTimeNanos)\n+          .add(\"command\", command)\n+          .add(\"scheduledFuture\", scheduledFuture)\n+          .add(\"running\", running)\n+          .add(\"done\", done)\n+          .toString();\n+    }\n+\n+    private class FakeScheduledFuture implements ScheduledFuture<Object> {\n+      boolean cancelled = false;\n+\n+      @Override\n+      public long getDelay(TimeUnit unit) {\n+        return unit.convert(scheduledTimeNanos - currTimeNanos, TimeUnit.NANOSECONDS);\n+      }\n+\n+      @Override\n+      public int compareTo(Delayed unused) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      @Override\n+      public synchronized boolean cancel(boolean mayInterruptIfRunning) {\n+        if (running) {\n+          return false;\n+        }\n+        running = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE2NTk2OQ=="}, "originalCommit": {"oid": "847b8e88976b9949f44f061fb40e393245b799cd"}, "originalPosition": 196}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzcwNjQ2OnYy", "diffSide": "RIGHT", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzoyNTo1M1rOGKCJRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxODowMzozOVrOGKD0jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3NDA4NQ==", "bodyText": "If you really want ThreadSafe, isCancelled() and isDone() also need synchronized.", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413174085", "createdAt": "2020-04-22T17:25:53Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {\n+    maybeInit();\n+    return new FakeTimeProvider();\n+  }\n+\n+  void forwardTime(long delta, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delta > 0, \"delta must be positive\");\n+    long finalTime = currTimeNanos + unit.toNanos(delta);\n+\n+    if (repeatedCommand.get() != null) {\n+      while (finalTime >= nextRun) {\n+        scheduledCommands.add(new ScheduledRunnable(nextRun, repeatedCommand.get()));\n+        nextRun += period;\n+      }\n+    }\n+\n+    while (!scheduledCommands.isEmpty()\n+        && scheduledCommands.peek().scheduledTimeNanos <= finalTime) {\n+      ScheduledRunnable scheduledCommand = scheduledCommands.poll();\n+      try {\n+        // pretend to run at the scheduled time\n+        currTimeNanos = scheduledCommand.scheduledTimeNanos;\n+        scheduledCommand.run();\n+      } catch (Throwable t) {\n+        throw new RuntimeException(\"failed to run scheduled command: \" + scheduledCommand, t);\n+      }\n+    }\n+\n+    this.currTimeNanos = finalTime;\n+  }\n+\n+  private final class ScheduledRunnable implements Runnable {\n+    private final long scheduledTimeNanos;\n+    private final Runnable command;\n+    private final ScheduledFuture<?> scheduledFuture = new ScheduledRunnable.FakeScheduledFuture();\n+    private final Object lock = new Object();\n+    private boolean running = false;\n+    private boolean done = false;\n+\n+    public ScheduledRunnable(long scheduledTimeNanos, Runnable command) {\n+      this.scheduledTimeNanos = scheduledTimeNanos;\n+      this.command = checkNotNull(command, \"command\");\n+    }\n+\n+    @Override\n+    public void run() {\n+      synchronized (lock) {\n+        if (!scheduledFuture.isCancelled()) {\n+          running = true;\n+          command.run();\n+          done = true;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"scheduledTimeNanos\", scheduledTimeNanos)\n+          .add(\"command\", command)\n+          .add(\"scheduledFuture\", scheduledFuture)\n+          .add(\"running\", running)\n+          .add(\"done\", done)\n+          .toString();\n+    }\n+\n+    private class FakeScheduledFuture implements ScheduledFuture<Object> {\n+      boolean cancelled = false;\n+\n+      @Override\n+      public long getDelay(TimeUnit unit) {\n+        return unit.convert(scheduledTimeNanos - currTimeNanos, TimeUnit.NANOSECONDS);\n+      }\n+\n+      @Override\n+      public int compareTo(Delayed unused) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      @Override\n+      public synchronized boolean cancel(boolean mayInterruptIfRunning) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "847b8e88976b9949f44f061fb40e393245b799cd"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwMTU0OA==", "bodyText": "yeah removing it makes sense. making it thread safe requires little more work, but it is really meant to be \"direct\".", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413201548", "createdAt": "2020-04-22T18:03:39Z", "author": {"login": "creamsoup"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {\n+    maybeInit();\n+    return new FakeTimeProvider();\n+  }\n+\n+  void forwardTime(long delta, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delta > 0, \"delta must be positive\");\n+    long finalTime = currTimeNanos + unit.toNanos(delta);\n+\n+    if (repeatedCommand.get() != null) {\n+      while (finalTime >= nextRun) {\n+        scheduledCommands.add(new ScheduledRunnable(nextRun, repeatedCommand.get()));\n+        nextRun += period;\n+      }\n+    }\n+\n+    while (!scheduledCommands.isEmpty()\n+        && scheduledCommands.peek().scheduledTimeNanos <= finalTime) {\n+      ScheduledRunnable scheduledCommand = scheduledCommands.poll();\n+      try {\n+        // pretend to run at the scheduled time\n+        currTimeNanos = scheduledCommand.scheduledTimeNanos;\n+        scheduledCommand.run();\n+      } catch (Throwable t) {\n+        throw new RuntimeException(\"failed to run scheduled command: \" + scheduledCommand, t);\n+      }\n+    }\n+\n+    this.currTimeNanos = finalTime;\n+  }\n+\n+  private final class ScheduledRunnable implements Runnable {\n+    private final long scheduledTimeNanos;\n+    private final Runnable command;\n+    private final ScheduledFuture<?> scheduledFuture = new ScheduledRunnable.FakeScheduledFuture();\n+    private final Object lock = new Object();\n+    private boolean running = false;\n+    private boolean done = false;\n+\n+    public ScheduledRunnable(long scheduledTimeNanos, Runnable command) {\n+      this.scheduledTimeNanos = scheduledTimeNanos;\n+      this.command = checkNotNull(command, \"command\");\n+    }\n+\n+    @Override\n+    public void run() {\n+      synchronized (lock) {\n+        if (!scheduledFuture.isCancelled()) {\n+          running = true;\n+          command.run();\n+          done = true;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"scheduledTimeNanos\", scheduledTimeNanos)\n+          .add(\"command\", command)\n+          .add(\"scheduledFuture\", scheduledFuture)\n+          .add(\"running\", running)\n+          .add(\"done\", done)\n+          .toString();\n+    }\n+\n+    private class FakeScheduledFuture implements ScheduledFuture<Object> {\n+      boolean cancelled = false;\n+\n+      @Override\n+      public long getDelay(TimeUnit unit) {\n+        return unit.convert(scheduledTimeNanos - currTimeNanos, TimeUnit.NANOSECONDS);\n+      }\n+\n+      @Override\n+      public int compareTo(Delayed unused) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      @Override\n+      public synchronized boolean cancel(boolean mayInterruptIfRunning) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3NDA4NQ=="}, "originalCommit": {"oid": "847b8e88976b9949f44f061fb40e393245b799cd"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzcxNzA5OnYy", "diffSide": "RIGHT", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzoyODowNlrOGKCPrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxODowNDoxNVrOGKD2Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3NTcyNQ==", "bodyText": "If you really want to support callers from multiple threads without caller's synchronization, other methods also need synchronized. As javadoc says implementation is not thread-safe,  so synchronized is not necessary.", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413175725", "createdAt": "2020-04-22T17:28:06Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "847b8e88976b9949f44f061fb40e393245b799cd"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIwMTk1NA==", "bodyText": "done.", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413201954", "createdAt": "2020-04-22T18:04:15Z", "author": {"login": "creamsoup"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3NTcyNQ=="}, "originalCommit": {"oid": "847b8e88976b9949f44f061fb40e393245b799cd"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzcyNzUwOnYy", "diffSide": "RIGHT", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzozMDoxOVrOGKCWBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzozMDoxOVrOGKCWBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3NzM0OQ==", "bodyText": "nit: final?", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413177349", "createdAt": "2020-04-22T17:30:19Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "847b8e88976b9949f44f061fb40e393245b799cd"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzczNzE5OnYy", "diffSide": "RIGHT", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzozMTozNlrOGKCbig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNzozMTozNlrOGKCbig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3ODc2Mg==", "bodyText": "nit: private?", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413178762", "createdAt": "2020-04-22T17:31:36Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private synchronized void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {\n+    maybeInit();\n+    return new FakeTimeProvider();\n+  }\n+\n+  void forwardTime(long delta, TimeUnit unit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "847b8e88976b9949f44f061fb40e393245b799cd"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Nzk0MDQ0OnYy", "diffSide": "RIGHT", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxODoxNTowNVrOGKEVvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxODoxNTowNVrOGKEVvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIxMDA0NA==", "bodyText": "nit: final", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413210044", "createdAt": "2020-04-22T18:15:05Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {\n+    maybeInit();\n+    return new FakeTimeProvider();\n+  }\n+\n+  private void forwardTime(long delta, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delta > 0, \"delta must be positive\");\n+    long finalTime = currTimeNanos + unit.toNanos(delta);\n+\n+    if (repeatedCommand.get() != null) {\n+      while (finalTime >= nextRun) {\n+        scheduledCommands.add(new ScheduledRunnable(nextRun, repeatedCommand.get()));\n+        nextRun += period;\n+      }\n+    }\n+\n+    while (!scheduledCommands.isEmpty()\n+        && scheduledCommands.peek().scheduledTimeNanos <= finalTime) {\n+      ScheduledRunnable scheduledCommand = scheduledCommands.poll();\n+      try {\n+        // pretend to run at the scheduled time\n+        currTimeNanos = scheduledCommand.scheduledTimeNanos;\n+        scheduledCommand.run();\n+      } catch (Throwable t) {\n+        throw new RuntimeException(\"failed to run scheduled command: \" + scheduledCommand, t);\n+      }\n+    }\n+\n+    this.currTimeNanos = finalTime;\n+  }\n+\n+  private final class ScheduledRunnable implements Runnable {\n+    private final long scheduledTimeNanos;\n+    private final Runnable command;\n+    private final ScheduledFuture<?> scheduledFuture = new ScheduledRunnable.FakeScheduledFuture();\n+    private boolean running = false;\n+    private boolean done = false;\n+\n+    public ScheduledRunnable(long scheduledTimeNanos, Runnable command) {\n+      this.scheduledTimeNanos = scheduledTimeNanos;\n+      this.command = checkNotNull(command, \"command\");\n+    }\n+\n+    @Override\n+    public void run() {\n+      if (!scheduledFuture.isCancelled()) {\n+        running = true;\n+        command.run();\n+        done = true;\n+      }\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"scheduledTimeNanos\", scheduledTimeNanos)\n+          .add(\"command\", command)\n+          .add(\"scheduledFuture\", scheduledFuture)\n+          .add(\"running\", running)\n+          .add(\"done\", done)\n+          .toString();\n+    }\n+\n+    private class FakeScheduledFuture implements ScheduledFuture<Object> {\n+      boolean cancelled = false;\n+\n+      @Override\n+      public long getDelay(TimeUnit unit) {\n+        return unit.convert(scheduledTimeNanos - currTimeNanos, TimeUnit.NANOSECONDS);\n+      }\n+\n+      @Override\n+      public int compareTo(Delayed unused) {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      @Override\n+      public boolean cancel(boolean mayInterruptIfRunning) {\n+        if (running) {\n+          return false;\n+        }\n+        cancelled = true;\n+        return true;\n+      }\n+\n+      @Override\n+      public boolean isCancelled() {\n+        return cancelled;\n+      }\n+\n+      @Override\n+      public boolean isDone() {\n+        return done;\n+      }\n+\n+      @Override\n+      public Object get() throws InterruptedException, ExecutionException {\n+        throw new UnsupportedOperationException();\n+      }\n+\n+      @Override\n+      public Object get(long timeout, TimeUnit unit)\n+          throws InterruptedException, ExecutionException, TimeoutException {\n+        throw new UnsupportedOperationException();\n+      }\n+    }\n+  }\n+\n+  private static final class ScheduledRunnableComparator\n+      implements Comparator<ScheduledRunnable> {\n+    @Override\n+    public int compare(ScheduledRunnable o1, ScheduledRunnable o2) {\n+      return Long.compare(o1.scheduledTimeNanos, o2.scheduledTimeNanos);\n+    }\n+  }\n+\n+  class FakeTimeProvider implements TimeProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "579ed15197c282b83d6aaed3e0479f361a0aec0f"}, "originalPosition": 228}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Nzk0MjQ4OnYy", "diffSide": "RIGHT", "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxODoxNTozMVrOGKEW-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxODoxNTozMVrOGKEW-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzIxMDM2Mw==", "bodyText": "nit: final", "url": "https://github.com/grpc/grpc-java/pull/6957#discussion_r413210363", "createdAt": "2020-04-22T18:15:31Z", "author": {"login": "dapengzhang0"}, "path": "rls/src/test/java/io/grpc/rls/internal/DoNotUseDirectScheduledExecutorService.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.rls.internal;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static org.mockito.Mockito.mock;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.internal.TimeProvider;\n+import java.util.Comparator;\n+import java.util.PriorityQueue;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * A fake minimal implementation of {@link ScheduledExecutorService} *only* supports\n+ * {@link ScheduledExecutorService#scheduleAtFixedRate(Runnable, long, long, TimeUnit)} (at most 1\n+ * task is allowed) and {@link ScheduledExecutorService#schedule(Runnable, long, TimeUnit)}. It is\n+ * directExecutor equivalent for {@link ScheduledExecutorService}.\n+ *\n+ * <p>Example:\n+ * <pre>\n+ * import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+ * import static org.mockito.Mockito.mock;\n+ *\n+ * private final DoNotUseDirectScheduledExecutorService fakeScheduledService =\n+ *     mock(DoNotUseDirectScheduledExecutorService.class, CALLS_REAL_METHODS);\n+ * </pre>\n+ *\n+ * <p>Note: This class is only intended to be used in this test with CALL_REAL_METHODS mock. This\n+ * implementation is not thread-safe. Not safe to use elsewhere.\n+ */\n+abstract class DoNotUseDirectScheduledExecutorService implements ScheduledExecutorService {\n+\n+  private long currTimeNanos;\n+  private long period;\n+  private long nextRun;\n+  private AtomicReference<Runnable> repeatedCommand;\n+  private PriorityQueue<ScheduledRunnable> scheduledCommands;\n+  private boolean initialized;\n+\n+  private DoNotUseDirectScheduledExecutorService() {\n+    throw new UnsupportedOperationException(\"this class is for mock only\");\n+  }\n+\n+  /**\n+   * Note: CALLS_REAL_METHODS doesn't initialize instance variables, all the methods need to call\n+   * maybeInit if they access instance variables.\n+   */\n+  private void maybeInit() {\n+    if (initialized) {\n+      return;\n+    }\n+\n+    initialized = true;\n+    repeatedCommand = new AtomicReference<>();\n+    scheduledCommands = new PriorityQueue<>(11, new ScheduledRunnableComparator());\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> scheduleAtFixedRate(\n+      Runnable command, long initialDelay, long period, TimeUnit unit) {\n+    maybeInit();\n+    checkArgument(period > 0, \"period should be positive\");\n+    checkArgument(initialDelay >= 0, \"initial delay should be >= 0\");\n+    checkState(this.repeatedCommand.get() == null, \"only can schedule one\");\n+    if (initialDelay == 0) {\n+      initialDelay = period;\n+      command.run();\n+    }\n+    this.repeatedCommand.set(checkNotNull(command, \"command\"));\n+    this.nextRun = checkNotNull(unit, \"unit\").toNanos(initialDelay) + currTimeNanos;\n+    this.period = unit.toNanos(period);\n+    return mock(ScheduledFuture.class);\n+  }\n+\n+  @Override\n+  public final ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {\n+    maybeInit();\n+    checkNotNull(command, \"command\");\n+    checkNotNull(unit, \"unit\");\n+    checkArgument(delay > 0, \"delay must be positive\");\n+    ScheduledRunnable scheduledRunnable =\n+        new ScheduledRunnable(currTimeNanos + TimeUnit.NANOSECONDS.convert(delay, unit), command);\n+    scheduledCommands.add(scheduledRunnable);\n+    return scheduledRunnable.scheduledFuture;\n+  }\n+\n+  FakeTimeProvider getFakeTimeProvider() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "579ed15197c282b83d6aaed3e0479f361a0aec0f"}, "originalPosition": 110}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2816, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}