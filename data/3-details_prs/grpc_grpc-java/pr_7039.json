{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3NTM4NjYz", "number": 7039, "title": "xds: implement priority lb", "bodyText": "See details in refactoring design docs. Not including address filter yet.", "createdAt": "2020-05-13T18:32:52Z", "url": "https://github.com/grpc/grpc-java/pull/7039", "merged": true, "mergeCommit": {"oid": "0cb91d97bf3aab8be583e3c82e72d504f9840faf"}, "closed": true, "closedAt": "2020-05-29T19:47:47Z", "author": {"login": "dapengzhang0"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcinlKoABqjMzNDkzNDAwODI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcl2dKAAFqTQyMDU1ODg0Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "be1b82c13c956be07795ee35f007bcee06b98669", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/be1b82c13c956be07795ee35f007bcee06b98669", "committedDate": "2020-05-13T17:59:07Z", "message": "xds: implement priority lb"}, "afterCommit": {"oid": "d9394bbde09f9b753e76e656700ef8ba4c72a48d", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/d9394bbde09f9b753e76e656700ef8ba4c72a48d", "committedDate": "2020-05-18T22:25:51Z", "message": "add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a9a6141e5d40b210acd404c697188aea578ca21", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/2a9a6141e5d40b210acd404c697188aea578ca21", "committedDate": "2020-05-19T00:03:58Z", "message": "xds: implement priority lb"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03", "committedDate": "2020-05-19T00:04:06Z", "message": "add tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d9394bbde09f9b753e76e656700ef8ba4c72a48d", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/d9394bbde09f9b753e76e656700ef8ba4c72a48d", "committedDate": "2020-05-18T22:25:51Z", "message": "add tests"}, "afterCommit": {"oid": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03", "committedDate": "2020-05-19T00:04:06Z", "message": "add tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjcyMDEw", "url": "https://github.com/grpc/grpc-java/pull/7039#pullrequestreview-414672010", "createdAt": "2020-05-19T17:32:18Z", "commit": {"oid": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNzozMjoxOFrOGXrJ0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo1ODowMVrOGXuX8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3NzQ1Ng==", "bodyText": "Should this be put in XdsLbPolicies?", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427477456", "createdAt": "2020-05-19T17:32:18Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/PriorityLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** Provider for priority load balancing policy. */\n+final class PriorityLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return \"priority_experimental\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ5NTQ2NA==", "bodyText": "Maybe also check the other direction to ensure exact 1:1 mapping?", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427495464", "createdAt": "2020-05-19T18:00:06Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/PriorityLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.MoreObjects;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+/** Provider for priority load balancing policy. */\n+final class PriorityLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return \"priority_experimental\";\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    return new PriorityLoadBalancer(helper);\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  static final class PriorityLbConfig {\n+    final Map<String, PolicySelection> childConfigs;\n+    final List<String> priorities;\n+\n+    PriorityLbConfig(Map<String, PolicySelection> childConfigs, List<String> priorities) {\n+      this.childConfigs = Collections.unmodifiableMap(checkNotNull(childConfigs, \"childConfigs\"));\n+      this.priorities = Collections.unmodifiableList(checkNotNull(priorities, \"priorities\"));\n+      checkArgument(!priorities.isEmpty(), \"priority list is empty\");\n+      checkArgument(\n+          childConfigs.keySet().containsAll(priorities),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUxODk0NA==", "bodyText": "It's better to cache addresses and mappings in a way that is easy for this class to use and represents this class's internal state, instead of dumping ResolvedAddresses here.", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427518944", "createdAt": "2020-05-19T18:39:16Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/PriorityLoadBalancer.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for priority policy. */\n+final class PriorityLoadBalancer extends LoadBalancer {\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService executor;\n+  private final XdsLogger logger;\n+\n+  // Includes all active and deactivated children. Mutable. New entries are only added from priority\n+  // 0 up to the selected priority. Entries are only deleted when priority lb is shutdown or 15\n+  // minutes after the entry's deactivation.\n+  private final Map<String, ChildLbState> children = new HashMap<>();\n+\n+  // Following fields are only null initially.\n+  private ResolvedAddresses resolvedAddresses;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMzA4Nw==", "bodyText": "\"Resources\" might be ambiguous. Maybe: \"Unable to connect to endpoints with priority ...\". Also, the variable priority (and keys of priorityToIndex) is just a canonical string used to refer to each child policy, it does not reveal any priority information. I believe those names are internal implementation details and have no real meanings (they are created only for easiness of updating existing child policies). So you may want to change misleading usages in this class such as error messages, variable naming, etc.", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427523087", "createdAt": "2020-05-19T18:46:07Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/PriorityLoadBalancer.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for priority policy. */\n+final class PriorityLoadBalancer extends LoadBalancer {\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService executor;\n+  private final XdsLogger logger;\n+\n+  // Includes all active and deactivated children. Mutable. New entries are only added from priority\n+  // 0 up to the selected priority. Entries are only deleted when priority lb is shutdown or 15\n+  // minutes after the entry's deactivation.\n+  private final Map<String, ChildLbState> children = new HashMap<>();\n+\n+  // Following fields are only null initially.\n+  private ResolvedAddresses resolvedAddresses;\n+  private List<String> priorities;\n+  private Map<String, Integer> priorityToIndex;\n+  private ConnectivityState currentConnectivityState;\n+  private SubchannelPicker currentPicker;\n+  private String currentPriority;\n+\n+  PriorityLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    syncContext = helper.getSynchronizationContext();\n+    executor = helper.getScheduledExecutorService();\n+    InternalLogId logId = InternalLogId.allocate(\"priority-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    PriorityLbConfig config = (PriorityLbConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    checkNotNull(config, \"missing priority lb config\");\n+    priorities = config.priorities;\n+    Map<String, Integer> pToI = new HashMap<>();\n+    for (int i = 0; i < priorities.size(); i++) {\n+      pToI.put(priorities.get(i), i);\n+    }\n+    priorityToIndex = Collections.unmodifiableMap(pToI);\n+    for (String priority : children.keySet()) {\n+      if (!priorityToIndex.containsKey(priority)) {\n+        children.get(priority).deactivate();\n+      }\n+    }\n+    for (String priority : priorities) {\n+      if (children.containsKey(priority)) {\n+        children.get(priority).updateResolvedAddresses();\n+      }\n+    }\n+    tryNextPriority(0);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    if (children.isEmpty()) {\n+      updateOverallState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+    for (ChildLbState child : children.values()) {\n+      child.lb.handleNameResolutionError(error);\n+    }\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    for (ChildLbState child : children.values()) {\n+      child.tearDown();\n+    }\n+  }\n+\n+  private void tryNextPriority(int startIdx) {\n+    for (int i = startIdx; i < priorities.size(); i++) {\n+      String priority = priorities.get(i);\n+      if (!children.containsKey(priority)) {\n+        ChildLbState child = new ChildLbState(priority);\n+        children.put(priority, child);\n+        child.updateResolvedAddresses();\n+        return; // Give priority i time to connect.\n+      }\n+      ChildLbState child = children.get(priority);\n+      child.reactivate();\n+      if (child.connectivityState.equals(READY) || child.connectivityState.equals(IDLE)) {\n+        logger.log(XdsLogLevel.DEBUG, \"Shifted to priority {0}\", priority);\n+        currentPriority = priority;\n+        updateOverallState(child.connectivityState, child.picker);\n+        for (int j = i + 1; j < priorities.size(); j++) {\n+          String p = priorities.get(j);\n+          if (children.containsKey(p)) {\n+            children.get(p).deactivate();\n+          }\n+        }\n+        return;\n+      }\n+      if (child.failOverTimer != null && child.failOverTimer.isPending()) {\n+        return; // Give priority i time to connect.\n+      }\n+    }\n+    // TODO(zdapeng): Include error details of each priority.\n+    logger.log(XdsLogLevel.DEBUG, \"All priority failed\");\n+    updateOverallState(TRANSIENT_FAILURE, new ErrorPicker(Status.UNAVAILABLE));\n+  }\n+\n+  private void updateOverallState(ConnectivityState state, SubchannelPicker picker) {\n+    if (!state.equals(currentConnectivityState) || !picker.equals(currentPicker)) {\n+      currentConnectivityState = state;\n+      currentPicker = picker;\n+      helper.updateBalancingState(state, picker);\n+    }\n+  }\n+\n+  private final class ChildLbState {\n+    final String priority;\n+    final ChildHelper childHelper;\n+    final GracefulSwitchLoadBalancer lb;\n+    // Timer to fail over to the next priority if not connected in 10 sec. Scheduled only once at\n+    // child initialization.\n+    final ScheduledHandle failOverTimer;\n+    // Timer to delay shutdown and deletion of the priority. Scheduled whenever the child is\n+    // deactivated.\n+    @Nullable ScheduledHandle deletionTimer;\n+    @Nullable String policy;\n+    ConnectivityState connectivityState = CONNECTING;\n+    SubchannelPicker picker = BUFFER_PICKER;\n+\n+    ChildLbState(final String priority) {\n+      this.priority = priority;\n+      childHelper = new ChildHelper();\n+      lb = new GracefulSwitchLoadBalancer(childHelper);\n+\n+      class FailOverTask implements Runnable {\n+        @Override\n+        public void run() {\n+          if (deletionTimer != null && deletionTimer.isPending()) {\n+            // The child is deactivated.\n+            return;\n+          }\n+          int idx = priorityToIndex.get(priority);\n+          updateOverallState(\n+              TRANSIENT_FAILURE,\n+              new ErrorPicker(\n+                  Status.UNAVAILABLE.withDescription(\n+                      \"Resources for priority \" + priority + \" not reachable in 10 seconds\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMDIyNA==", "bodyText": "Isn't this wrong? Failing over from one priority to another causes a TRANSIENT_FAILURE picker to the upstream policy (and maybe Channel)?", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r427530224", "createdAt": "2020-05-19T18:58:01Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/PriorityLoadBalancer.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for priority policy. */\n+final class PriorityLoadBalancer extends LoadBalancer {\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService executor;\n+  private final XdsLogger logger;\n+\n+  // Includes all active and deactivated children. Mutable. New entries are only added from priority\n+  // 0 up to the selected priority. Entries are only deleted when priority lb is shutdown or 15\n+  // minutes after the entry's deactivation.\n+  private final Map<String, ChildLbState> children = new HashMap<>();\n+\n+  // Following fields are only null initially.\n+  private ResolvedAddresses resolvedAddresses;\n+  private List<String> priorities;\n+  private Map<String, Integer> priorityToIndex;\n+  private ConnectivityState currentConnectivityState;\n+  private SubchannelPicker currentPicker;\n+  private String currentPriority;\n+\n+  PriorityLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    syncContext = helper.getSynchronizationContext();\n+    executor = helper.getScheduledExecutorService();\n+    InternalLogId logId = InternalLogId.allocate(\"priority-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    PriorityLbConfig config = (PriorityLbConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    checkNotNull(config, \"missing priority lb config\");\n+    priorities = config.priorities;\n+    Map<String, Integer> pToI = new HashMap<>();\n+    for (int i = 0; i < priorities.size(); i++) {\n+      pToI.put(priorities.get(i), i);\n+    }\n+    priorityToIndex = Collections.unmodifiableMap(pToI);\n+    for (String priority : children.keySet()) {\n+      if (!priorityToIndex.containsKey(priority)) {\n+        children.get(priority).deactivate();\n+      }\n+    }\n+    for (String priority : priorities) {\n+      if (children.containsKey(priority)) {\n+        children.get(priority).updateResolvedAddresses();\n+      }\n+    }\n+    tryNextPriority(0);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    if (children.isEmpty()) {\n+      updateOverallState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+    for (ChildLbState child : children.values()) {\n+      child.lb.handleNameResolutionError(error);\n+    }\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    for (ChildLbState child : children.values()) {\n+      child.tearDown();\n+    }\n+  }\n+\n+  private void tryNextPriority(int startIdx) {\n+    for (int i = startIdx; i < priorities.size(); i++) {\n+      String priority = priorities.get(i);\n+      if (!children.containsKey(priority)) {\n+        ChildLbState child = new ChildLbState(priority);\n+        children.put(priority, child);\n+        child.updateResolvedAddresses();\n+        return; // Give priority i time to connect.\n+      }\n+      ChildLbState child = children.get(priority);\n+      child.reactivate();\n+      if (child.connectivityState.equals(READY) || child.connectivityState.equals(IDLE)) {\n+        logger.log(XdsLogLevel.DEBUG, \"Shifted to priority {0}\", priority);\n+        currentPriority = priority;\n+        updateOverallState(child.connectivityState, child.picker);\n+        for (int j = i + 1; j < priorities.size(); j++) {\n+          String p = priorities.get(j);\n+          if (children.containsKey(p)) {\n+            children.get(p).deactivate();\n+          }\n+        }\n+        return;\n+      }\n+      if (child.failOverTimer != null && child.failOverTimer.isPending()) {\n+        return; // Give priority i time to connect.\n+      }\n+    }\n+    // TODO(zdapeng): Include error details of each priority.\n+    logger.log(XdsLogLevel.DEBUG, \"All priority failed\");\n+    updateOverallState(TRANSIENT_FAILURE, new ErrorPicker(Status.UNAVAILABLE));\n+  }\n+\n+  private void updateOverallState(ConnectivityState state, SubchannelPicker picker) {\n+    if (!state.equals(currentConnectivityState) || !picker.equals(currentPicker)) {\n+      currentConnectivityState = state;\n+      currentPicker = picker;\n+      helper.updateBalancingState(state, picker);\n+    }\n+  }\n+\n+  private final class ChildLbState {\n+    final String priority;\n+    final ChildHelper childHelper;\n+    final GracefulSwitchLoadBalancer lb;\n+    // Timer to fail over to the next priority if not connected in 10 sec. Scheduled only once at\n+    // child initialization.\n+    final ScheduledHandle failOverTimer;\n+    // Timer to delay shutdown and deletion of the priority. Scheduled whenever the child is\n+    // deactivated.\n+    @Nullable ScheduledHandle deletionTimer;\n+    @Nullable String policy;\n+    ConnectivityState connectivityState = CONNECTING;\n+    SubchannelPicker picker = BUFFER_PICKER;\n+\n+    ChildLbState(final String priority) {\n+      this.priority = priority;\n+      childHelper = new ChildHelper();\n+      lb = new GracefulSwitchLoadBalancer(childHelper);\n+\n+      class FailOverTask implements Runnable {\n+        @Override\n+        public void run() {\n+          if (deletionTimer != null && deletionTimer.isPending()) {\n+            // The child is deactivated.\n+            return;\n+          }\n+          int idx = priorityToIndex.get(priority);\n+          updateOverallState(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03"}, "originalPosition": 187}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a0e10eb861b01eb71b69915b55139c047c8dd7e", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/4a0e10eb861b01eb71b69915b55139c047c8dd7e", "committedDate": "2020-05-19T22:01:09Z", "message": "add more checks for PriorityLbConfig"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NTU3NTMx", "url": "https://github.com/grpc/grpc-java/pull/7039#pullrequestreview-415557531", "createdAt": "2020-05-20T17:25:12Z", "commit": {"oid": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNzoyNToxMlrOGYWPYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNzoyNzo0NFrOGYWVZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MzM5NA==", "bodyText": "If the current priority fails and there is another priority to try, we should report CONNECTING.  I think we should report failure only if all priorities have failed.\nIn C-core, TryNextPriority() takes a boolean parameter called report_connecting that tells it whether to put the channel in CONNECTING when it finds a priority that needs time to connect:\nhttps://github.com/grpc/grpc/blob/7f20bccd4ddeceaad0a8ad9532e68a0f9e10b359/src/core/ext/filters/client_channel/lb_policy/priority/priority.cc#L399\nWe call TryNextPriority() with report_connecting=true when the current priority fails and when we get our very first update after we are created.  Otherwise, we call it with report_connecting=false.\nI've updated the psuedo-code in the design doc to clarify this.", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r428183394", "createdAt": "2020-05-20T17:25:12Z", "author": {"login": "markdroth"}, "path": "xds/src/main/java/io/grpc/xds/PriorityLoadBalancer.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for priority policy. */\n+final class PriorityLoadBalancer extends LoadBalancer {\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService executor;\n+  private final XdsLogger logger;\n+\n+  // Includes all active and deactivated children. Mutable. New entries are only added from priority\n+  // 0 up to the selected priority. Entries are only deleted when priority lb is shutdown or 15\n+  // minutes after the entry's deactivation.\n+  private final Map<String, ChildLbState> children = new HashMap<>();\n+\n+  // Following fields are only null initially.\n+  private ResolvedAddresses resolvedAddresses;\n+  private List<String> priorities;\n+  private Map<String, Integer> priorityToIndex;\n+  private ConnectivityState currentConnectivityState;\n+  private SubchannelPicker currentPicker;\n+  private String currentPriority;\n+\n+  PriorityLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    syncContext = helper.getSynchronizationContext();\n+    executor = helper.getScheduledExecutorService();\n+    InternalLogId logId = InternalLogId.allocate(\"priority-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    PriorityLbConfig config = (PriorityLbConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    checkNotNull(config, \"missing priority lb config\");\n+    priorities = config.priorities;\n+    Map<String, Integer> pToI = new HashMap<>();\n+    for (int i = 0; i < priorities.size(); i++) {\n+      pToI.put(priorities.get(i), i);\n+    }\n+    priorityToIndex = Collections.unmodifiableMap(pToI);\n+    for (String priority : children.keySet()) {\n+      if (!priorityToIndex.containsKey(priority)) {\n+        children.get(priority).deactivate();\n+      }\n+    }\n+    for (String priority : priorities) {\n+      if (children.containsKey(priority)) {\n+        children.get(priority).updateResolvedAddresses();\n+      }\n+    }\n+    tryNextPriority(0);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    if (children.isEmpty()) {\n+      updateOverallState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+    for (ChildLbState child : children.values()) {\n+      child.lb.handleNameResolutionError(error);\n+    }\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    for (ChildLbState child : children.values()) {\n+      child.tearDown();\n+    }\n+  }\n+\n+  private void tryNextPriority(int startIdx) {\n+    for (int i = startIdx; i < priorities.size(); i++) {\n+      String priority = priorities.get(i);\n+      if (!children.containsKey(priority)) {\n+        ChildLbState child = new ChildLbState(priority);\n+        children.put(priority, child);\n+        child.updateResolvedAddresses();\n+        return; // Give priority i time to connect.\n+      }\n+      ChildLbState child = children.get(priority);\n+      child.reactivate();\n+      if (child.connectivityState.equals(READY) || child.connectivityState.equals(IDLE)) {\n+        logger.log(XdsLogLevel.DEBUG, \"Shifted to priority {0}\", priority);\n+        currentPriority = priority;\n+        updateOverallState(child.connectivityState, child.picker);\n+        for (int j = i + 1; j < priorities.size(); j++) {\n+          String p = priorities.get(j);\n+          if (children.containsKey(p)) {\n+            children.get(p).deactivate();\n+          }\n+        }\n+        return;\n+      }\n+      if (child.failOverTimer != null && child.failOverTimer.isPending()) {\n+        return; // Give priority i time to connect.\n+      }\n+    }\n+    // TODO(zdapeng): Include error details of each priority.\n+    logger.log(XdsLogLevel.DEBUG, \"All priority failed\");\n+    updateOverallState(TRANSIENT_FAILURE, new ErrorPicker(Status.UNAVAILABLE));\n+  }\n+\n+  private void updateOverallState(ConnectivityState state, SubchannelPicker picker) {\n+    if (!state.equals(currentConnectivityState) || !picker.equals(currentPicker)) {\n+      currentConnectivityState = state;\n+      currentPicker = picker;\n+      helper.updateBalancingState(state, picker);\n+    }\n+  }\n+\n+  private final class ChildLbState {\n+    final String priority;\n+    final ChildHelper childHelper;\n+    final GracefulSwitchLoadBalancer lb;\n+    // Timer to fail over to the next priority if not connected in 10 sec. Scheduled only once at\n+    // child initialization.\n+    final ScheduledHandle failOverTimer;\n+    // Timer to delay shutdown and deletion of the priority. Scheduled whenever the child is\n+    // deactivated.\n+    @Nullable ScheduledHandle deletionTimer;\n+    @Nullable String policy;\n+    ConnectivityState connectivityState = CONNECTING;\n+    SubchannelPicker picker = BUFFER_PICKER;\n+\n+    ChildLbState(final String priority) {\n+      this.priority = priority;\n+      childHelper = new ChildHelper();\n+      lb = new GracefulSwitchLoadBalancer(childHelper);\n+\n+      class FailOverTask implements Runnable {\n+        @Override\n+        public void run() {\n+          if (deletionTimer != null && deletionTimer.isPending()) {\n+            // The child is deactivated.\n+            return;\n+          }\n+          int idx = priorityToIndex.get(priority);\n+          updateOverallState(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMDIyNA=="}, "originalCommit": {"oid": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4NDkzNQ==", "bodyText": "I haven't reviewed all of this code, but I happened to notice this while replying to the comment above, and I thought I should mention that this looks wrong.\nWhen a given child goes into TRANSIENT_FAILURE, we don't necessarily know that we should go to the priority after the current one.  For example, consider the following case:\n\nPriority list is [A, B, C], and we are currently using A.\nWe get an update that changes the priority list to [B, A, C].  We keep the current priority set to A, but we immediately start trying to connect to B, since it is now a higher priority.\nWhile B is still trying to connect, A fails.\n\nIn this case, there is no need to start trying C, because we are already trying B.  We should not try C unless B winds up failing.\nTo address this, I think that TryNextPriority() should always start from the highest priority and work its way down the list, even if it's called because a priority halfway down the list failed.  At worst, this will cause it to iterate over some priorities that are already known to be bad, but the current state of those priorities should be cached, so that shouldn't cause much overhead.", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r428184935", "createdAt": "2020-05-20T17:27:44Z", "author": {"login": "markdroth"}, "path": "xds/src/main/java/io/grpc/xds/PriorityLoadBalancer.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for priority policy. */\n+final class PriorityLoadBalancer extends LoadBalancer {\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService executor;\n+  private final XdsLogger logger;\n+\n+  // Includes all active and deactivated children. Mutable. New entries are only added from priority\n+  // 0 up to the selected priority. Entries are only deleted when priority lb is shutdown or 15\n+  // minutes after the entry's deactivation.\n+  private final Map<String, ChildLbState> children = new HashMap<>();\n+\n+  // Following fields are only null initially.\n+  private ResolvedAddresses resolvedAddresses;\n+  private List<String> priorities;\n+  private Map<String, Integer> priorityToIndex;\n+  private ConnectivityState currentConnectivityState;\n+  private SubchannelPicker currentPicker;\n+  private String currentPriority;\n+\n+  PriorityLoadBalancer(Helper helper) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    syncContext = helper.getSynchronizationContext();\n+    executor = helper.getScheduledExecutorService();\n+    InternalLogId logId = InternalLogId.allocate(\"priority-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    PriorityLbConfig config = (PriorityLbConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    checkNotNull(config, \"missing priority lb config\");\n+    priorities = config.priorities;\n+    Map<String, Integer> pToI = new HashMap<>();\n+    for (int i = 0; i < priorities.size(); i++) {\n+      pToI.put(priorities.get(i), i);\n+    }\n+    priorityToIndex = Collections.unmodifiableMap(pToI);\n+    for (String priority : children.keySet()) {\n+      if (!priorityToIndex.containsKey(priority)) {\n+        children.get(priority).deactivate();\n+      }\n+    }\n+    for (String priority : priorities) {\n+      if (children.containsKey(priority)) {\n+        children.get(priority).updateResolvedAddresses();\n+      }\n+    }\n+    tryNextPriority(0);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    if (children.isEmpty()) {\n+      updateOverallState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+    }\n+    for (ChildLbState child : children.values()) {\n+      child.lb.handleNameResolutionError(error);\n+    }\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    for (ChildLbState child : children.values()) {\n+      child.tearDown();\n+    }\n+  }\n+\n+  private void tryNextPriority(int startIdx) {\n+    for (int i = startIdx; i < priorities.size(); i++) {\n+      String priority = priorities.get(i);\n+      if (!children.containsKey(priority)) {\n+        ChildLbState child = new ChildLbState(priority);\n+        children.put(priority, child);\n+        child.updateResolvedAddresses();\n+        return; // Give priority i time to connect.\n+      }\n+      ChildLbState child = children.get(priority);\n+      child.reactivate();\n+      if (child.connectivityState.equals(READY) || child.connectivityState.equals(IDLE)) {\n+        logger.log(XdsLogLevel.DEBUG, \"Shifted to priority {0}\", priority);\n+        currentPriority = priority;\n+        updateOverallState(child.connectivityState, child.picker);\n+        for (int j = i + 1; j < priorities.size(); j++) {\n+          String p = priorities.get(j);\n+          if (children.containsKey(p)) {\n+            children.get(p).deactivate();\n+          }\n+        }\n+        return;\n+      }\n+      if (child.failOverTimer != null && child.failOverTimer.isPending()) {\n+        return; // Give priority i time to connect.\n+      }\n+    }\n+    // TODO(zdapeng): Include error details of each priority.\n+    logger.log(XdsLogLevel.DEBUG, \"All priority failed\");\n+    updateOverallState(TRANSIENT_FAILURE, new ErrorPicker(Status.UNAVAILABLE));\n+  }\n+\n+  private void updateOverallState(ConnectivityState state, SubchannelPicker picker) {\n+    if (!state.equals(currentConnectivityState) || !picker.equals(currentPicker)) {\n+      currentConnectivityState = state;\n+      currentPicker = picker;\n+      helper.updateBalancingState(state, picker);\n+    }\n+  }\n+\n+  private final class ChildLbState {\n+    final String priority;\n+    final ChildHelper childHelper;\n+    final GracefulSwitchLoadBalancer lb;\n+    // Timer to fail over to the next priority if not connected in 10 sec. Scheduled only once at\n+    // child initialization.\n+    final ScheduledHandle failOverTimer;\n+    // Timer to delay shutdown and deletion of the priority. Scheduled whenever the child is\n+    // deactivated.\n+    @Nullable ScheduledHandle deletionTimer;\n+    @Nullable String policy;\n+    ConnectivityState connectivityState = CONNECTING;\n+    SubchannelPicker picker = BUFFER_PICKER;\n+\n+    ChildLbState(final String priority) {\n+      this.priority = priority;\n+      childHelper = new ChildHelper();\n+      lb = new GracefulSwitchLoadBalancer(childHelper);\n+\n+      class FailOverTask implements Runnable {\n+        @Override\n+        public void run() {\n+          if (deletionTimer != null && deletionTimer.isPending()) {\n+            // The child is deactivated.\n+            return;\n+          }\n+          int idx = priorityToIndex.get(priority);\n+          updateOverallState(\n+              TRANSIENT_FAILURE,\n+              new ErrorPicker(\n+                  Status.UNAVAILABLE.withDescription(\n+                      \"Resources for priority \" + priority + \" not reachable in 10 seconds\")));\n+          logger.log(XdsLogLevel.DEBUG, \"Priority {0} failed over to next\", priority);\n+          tryNextPriority(idx + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac67d3b8049f18aa3c572ea3ad9a2b1375b91f03"}, "originalPosition": 193}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "676ef03c9a29c2a3fc6e8c23f0f6a2363ea9ded5", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/676ef03c9a29c2a3fc6e8c23f0f6a2363ea9ded5", "committedDate": "2020-05-21T23:09:49Z", "message": "tryNextPriority() always starts from P0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f8058e4b8e50bae47288ecf993616ca60e44454", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/1f8058e4b8e50bae47288ecf993616ca60e44454", "committedDate": "2020-05-22T00:18:18Z", "message": "comply with the latest tryNextPriority()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3fbd774f7ae3aeb5d41a395b469af6258eb7a08", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/a3fbd774f7ae3aeb5d41a395b469af6258eb7a08", "committedDate": "2020-05-22T00:23:29Z", "message": "fix a typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NzY2NjY4", "url": "https://github.com/grpc/grpc-java/pull/7039#pullrequestreview-418766668", "createdAt": "2020-05-27T00:31:42Z", "commit": {"oid": "a3fbd774f7ae3aeb5d41a395b469af6258eb7a08"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMDozMTo0MlrOGa0u0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwMDozMTo0MlrOGa0u0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MDExNA==", "bodyText": "nit: Can you update the naming? Things like List<String> priorities or String priority are hard to follow (I would expect a number when seeing something named priority). Something like priorityName would be much better.", "url": "https://github.com/grpc/grpc-java/pull/7039#discussion_r430780114", "createdAt": "2020-05-27T00:31:42Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/PriorityLoadBalancer.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.CONNECTING;\n+import static io.grpc.ConnectivityState.IDLE;\n+import static io.grpc.ConnectivityState.READY;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsSubchannelPickers.BUFFER_PICKER;\n+\n+import io.grpc.ConnectivityState;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.SynchronizationContext.ScheduledHandle;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/** Load balancer for priority policy. */\n+final class PriorityLoadBalancer extends LoadBalancer {\n+  private final Helper helper;\n+  private final SynchronizationContext syncContext;\n+  private final ScheduledExecutorService executor;\n+  private final XdsLogger logger;\n+\n+  // Includes all active and deactivated children. Mutable. New entries are only added from priority\n+  // 0 up to the selected priority. Entries are only deleted when priority lb is shutdown or 15\n+  // minutes after the entry's deactivation.\n+  private final Map<String, ChildLbState> children = new HashMap<>();\n+\n+  // Following fields are only null initially.\n+  private ResolvedAddresses resolvedAddresses;\n+  private List<String> priorities;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3fbd774f7ae3aeb5d41a395b469af6258eb7a08"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f38f13c9929766557bb0c676e944074f5ea01258", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/f38f13c9929766557bb0c676e944074f5ea01258", "committedDate": "2020-05-28T17:22:50Z", "message": "make comment more precise"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7cc4f0638f7bd89e544a1fcd5e657bec20b7239", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/b7cc4f0638f7bd89e544a1fcd5e657bec20b7239", "committedDate": "2020-05-28T17:31:21Z", "message": "rename priorities to priorityNames"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNTU4ODQ2", "url": "https://github.com/grpc/grpc-java/pull/7039#pullrequestreview-420558846", "createdAt": "2020-05-28T23:28:00Z", "commit": {"oid": "b7cc4f0638f7bd89e544a1fcd5e657bec20b7239"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4425, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}