{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU5ODAzMzY2", "number": 7274, "title": "xds: implement MeshCACertificateProvider", "bodyText": "", "createdAt": "2020-07-31T05:44:40Z", "url": "https://github.com/grpc/grpc-java/pull/7274", "merged": true, "mergeCommit": {"oid": "65e7ffc788197174d4d1389120ec6bafc63a9f94"}, "closed": true, "closedAt": "2020-08-07T23:16:23Z", "author": {"login": "sanjaypujare"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc8KMzBAFqTQ1OTUyNjUxNg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc8sJ9DAFqTQ2MzY3MDI4Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NTI2NTE2", "url": "https://github.com/grpc/grpc-java/pull/7274#pullrequestreview-459526516", "createdAt": "2020-07-31T23:48:38Z", "commit": {"oid": "50081e9e9fe230fcfc7afa705be80a88aab6e28e"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQyMzo0ODozOFrOG6ZkcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQwNjo1MzowM1rOG8llcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzg4OTUyMQ==", "bodyText": "Although not a change in this PR, should not be protected as the class is final.", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r463889521", "createdAt": "2020-07-31T23:48:38Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -17,35 +17,349 @@\n package io.grpc.xds.internal.certprovider;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.Status.Code.ABORTED;\n+import static io.grpc.Status.Code.CANCELLED;\n+import static io.grpc.Status.Code.DEADLINE_EXCEEDED;\n+import static io.grpc.Status.Code.INTERNAL;\n+import static io.grpc.Status.Code.RESOURCE_EXHAUSTED;\n+import static io.grpc.Status.Code.UNAVAILABLE;\n+import static io.grpc.Status.Code.UNKNOWN;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Duration;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener;\n+import io.grpc.InternalLogId;\n import io.grpc.ManagedChannel;\n import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.auth.MoreCallCredentials;\n import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n+import javax.security.auth.x500.X500Principal;\n+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequest;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;\n+import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;\n+import org.bouncycastle.util.io.pem.PemObject;\n \n /** Implementation of {@link CertificateProvider} for the Google Mesh CA. */\n final class MeshCaCertificateProvider extends CertificateProvider {\n   private static final Logger logger = Logger.getLogger(MeshCaCertificateProvider.class.getName());\n \n-  protected MeshCaCertificateProvider(DistributorWatcher watcher, boolean notifyCertUpdates,\n-      String meshCaUrl, String zone, long validitySeconds,\n-      int keySize, String alg, String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n-      BackoffPolicy.Provider backoffPolicyProvider, long renewalGracePeriodSeconds,\n-      int maxRetryAttempts, GoogleCredentials oauth2Creds) {\n+  protected MeshCaCertificateProvider(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50081e9e9fe230fcfc7afa705be80a88aab6e28e"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjEzMzQ5OQ==", "bodyText": "typo: downsstreamWatchers", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466133499", "createdAt": "2020-08-06T04:07:05Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProvider.java", "diffHunk": "@@ -104,6 +104,24 @@ public synchronized void onError(Status errorStatus) {\n         watcher.onError(errorStatus);\n       }\n     }\n+\n+    X509Certificate getLastIdentityCert() {\n+      if (lastCertChain != null && !lastCertChain.isEmpty()) {\n+        return lastCertChain.get(0);\n+      }\n+      return null;\n+    }\n+\n+    void close() {\n+      downsstreamWatchers.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87bf16499833f063d3af39926bf350738a51002b"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE1NzIzMA==", "bodyText": "Just clearKeys() might be a better name.\nAlso I wonder if lastKey, lasterCertChain and lastTrustedRoots  can be just renamed to key, certChain and trustedRoots.", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466157230", "createdAt": "2020-08-06T05:37:17Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/CertificateProvider.java", "diffHunk": "@@ -104,6 +104,24 @@ public synchronized void onError(Status errorStatus) {\n         watcher.onError(errorStatus);\n       }\n     }\n+\n+    X509Certificate getLastIdentityCert() {\n+      if (lastCertChain != null && !lastCertChain.isEmpty()) {\n+        return lastCertChain.get(0);\n+      }\n+      return null;\n+    }\n+\n+    void close() {\n+      downsstreamWatchers.clear();\n+      cleanupLastValues();\n+    }\n+\n+    void cleanupLastValues() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87bf16499833f063d3af39926bf350738a51002b"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE2NDA0NQ==", "bodyText": "\"XdsClientWrapperForServerSds\"?", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466164045", "createdAt": "2020-08-06T05:59:35Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -17,35 +17,349 @@\n package io.grpc.xds.internal.certprovider;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.Status.Code.ABORTED;\n+import static io.grpc.Status.Code.CANCELLED;\n+import static io.grpc.Status.Code.DEADLINE_EXCEEDED;\n+import static io.grpc.Status.Code.INTERNAL;\n+import static io.grpc.Status.Code.RESOURCE_EXHAUSTED;\n+import static io.grpc.Status.Code.UNAVAILABLE;\n+import static io.grpc.Status.Code.UNKNOWN;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Duration;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener;\n+import io.grpc.InternalLogId;\n import io.grpc.ManagedChannel;\n import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.auth.MoreCallCredentials;\n import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n+import javax.security.auth.x500.X500Principal;\n+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequest;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;\n+import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;\n+import org.bouncycastle.util.io.pem.PemObject;\n \n /** Implementation of {@link CertificateProvider} for the Google Mesh CA. */\n final class MeshCaCertificateProvider extends CertificateProvider {\n   private static final Logger logger = Logger.getLogger(MeshCaCertificateProvider.class.getName());\n \n-  protected MeshCaCertificateProvider(DistributorWatcher watcher, boolean notifyCertUpdates,\n-      String meshCaUrl, String zone, long validitySeconds,\n-      int keySize, String alg, String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n-      BackoffPolicy.Provider backoffPolicyProvider, long renewalGracePeriodSeconds,\n-      int maxRetryAttempts, GoogleCredentials oauth2Creds) {\n+  protected MeshCaCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String meshCaUrl,\n+      String zone,\n+      long validitySeconds,\n+      int keySize,\n+      String alg,\n+      String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      long renewalGracePeriodSeconds,\n+      int maxRetryAttempts,\n+      GoogleCredentials oauth2Creds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider,\n+      long rpcTimeoutMillis) {\n     super(watcher, notifyCertUpdates);\n+    this.meshCaUrl = checkNotNull(meshCaUrl, \"meshCaUrl\");\n+    checkArgument(\n+        validitySeconds > INITIAL_DELAY_SECONDS,\n+        \"validitySeconds must be greater than \" + INITIAL_DELAY_SECONDS);\n+    this.validitySeconds = validitySeconds;\n+    this.keySize = keySize;\n+    this.alg = checkNotNull(alg, \"alg\");\n+    this.signatureAlg = checkNotNull(signatureAlg, \"signatureAlg\");\n+    this.meshCaChannelFactory = checkNotNull(meshCaChannelFactory, \"meshCaChannelFactory\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    checkArgument(\n+        renewalGracePeriodSeconds > 0L && renewalGracePeriodSeconds < validitySeconds,\n+        \"renewalGracePeriodSeconds should be between 0 and \" + validitySeconds);\n+    this.renewalGracePeriodSeconds = renewalGracePeriodSeconds;\n+    checkArgument(maxRetryAttempts >= 0, \"maxRetryAttempts must be >= 0\");\n+    this.maxRetryAttempts = maxRetryAttempts;\n+    this.oauth2Creds = checkNotNull(oauth2Creds, \"oauth2Creds\");\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.headerInterceptor = new ZoneInfoClientInterceptor(checkNotNull(zone, \"zone\"));\n+    this.syncContext = createSynchronizationContext(meshCaUrl);\n+    this.rpcTimeoutMillis = rpcTimeoutMillis;\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"XdsClientWrapperForServerSds\", details);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87bf16499833f063d3af39926bf350738a51002b"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE3Mzc1NQ==", "bodyText": "It might be better to move it to the scheduleNextRefreshCertificate() method.:\n@VisibleForTesting RefreshCertificateTask scheduledTask;\n@VisibleForTesting SynchronizationContext.ScheduledHandle scheduledHandle; // top level field\n\nprivate void scheduleNextRefreshCertificate(long delayInSeconds) {\n  if (scheduledHandle != null && scheduledHandle.isPending()) {\n    logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n    scheduledHandle.cancel();\n  }\n  RefreshCertificateTask runnable = new RefreshCertificateTask();  // Pure Runnable class\n  scheduledHandle = syncContext.schedule(\n      runnable, delayInSeconds, TimeUnit.SECONDS, scheduledExecutorService);\n}\n\nclass RefreshCertificateTask implements Runnable {\n  @Override\n  public void run() {\n    try {\n      refreshCertificate();\n    } catch (NoSuchAlgorithmException | OperatorCreationException | IOException ex) {\n      logger.log(Level.SEVERE, \"refreshing certificate\", ex);\n    }\n  }\n}", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466173755", "createdAt": "2020-08-06T06:29:00Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -17,35 +17,349 @@\n package io.grpc.xds.internal.certprovider;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.Status.Code.ABORTED;\n+import static io.grpc.Status.Code.CANCELLED;\n+import static io.grpc.Status.Code.DEADLINE_EXCEEDED;\n+import static io.grpc.Status.Code.INTERNAL;\n+import static io.grpc.Status.Code.RESOURCE_EXHAUSTED;\n+import static io.grpc.Status.Code.UNAVAILABLE;\n+import static io.grpc.Status.Code.UNKNOWN;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Duration;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener;\n+import io.grpc.InternalLogId;\n import io.grpc.ManagedChannel;\n import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.auth.MoreCallCredentials;\n import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n+import javax.security.auth.x500.X500Principal;\n+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequest;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;\n+import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;\n+import org.bouncycastle.util.io.pem.PemObject;\n \n /** Implementation of {@link CertificateProvider} for the Google Mesh CA. */\n final class MeshCaCertificateProvider extends CertificateProvider {\n   private static final Logger logger = Logger.getLogger(MeshCaCertificateProvider.class.getName());\n \n-  protected MeshCaCertificateProvider(DistributorWatcher watcher, boolean notifyCertUpdates,\n-      String meshCaUrl, String zone, long validitySeconds,\n-      int keySize, String alg, String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n-      BackoffPolicy.Provider backoffPolicyProvider, long renewalGracePeriodSeconds,\n-      int maxRetryAttempts, GoogleCredentials oauth2Creds) {\n+  protected MeshCaCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String meshCaUrl,\n+      String zone,\n+      long validitySeconds,\n+      int keySize,\n+      String alg,\n+      String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      long renewalGracePeriodSeconds,\n+      int maxRetryAttempts,\n+      GoogleCredentials oauth2Creds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider,\n+      long rpcTimeoutMillis) {\n     super(watcher, notifyCertUpdates);\n+    this.meshCaUrl = checkNotNull(meshCaUrl, \"meshCaUrl\");\n+    checkArgument(\n+        validitySeconds > INITIAL_DELAY_SECONDS,\n+        \"validitySeconds must be greater than \" + INITIAL_DELAY_SECONDS);\n+    this.validitySeconds = validitySeconds;\n+    this.keySize = keySize;\n+    this.alg = checkNotNull(alg, \"alg\");\n+    this.signatureAlg = checkNotNull(signatureAlg, \"signatureAlg\");\n+    this.meshCaChannelFactory = checkNotNull(meshCaChannelFactory, \"meshCaChannelFactory\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    checkArgument(\n+        renewalGracePeriodSeconds > 0L && renewalGracePeriodSeconds < validitySeconds,\n+        \"renewalGracePeriodSeconds should be between 0 and \" + validitySeconds);\n+    this.renewalGracePeriodSeconds = renewalGracePeriodSeconds;\n+    checkArgument(maxRetryAttempts >= 0, \"maxRetryAttempts must be >= 0\");\n+    this.maxRetryAttempts = maxRetryAttempts;\n+    this.oauth2Creds = checkNotNull(oauth2Creds, \"oauth2Creds\");\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.headerInterceptor = new ZoneInfoClientInterceptor(checkNotNull(zone, \"zone\"));\n+    this.syncContext = createSynchronizationContext(meshCaUrl);\n+    this.rpcTimeoutMillis = rpcTimeoutMillis;\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"XdsClientWrapperForServerSds\", details);\n+    return new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          private boolean panicMode;\n+\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                \"[\" + logId + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                e);\n+            panic(e);\n+          }\n+\n+          void panic(final Throwable t) {\n+            if (panicMode) {\n+              // Preserve the first panic information\n+              return;\n+            }\n+            panicMode = true;\n+            close();\n+          }\n+        });\n   }\n \n   @Override\n   public void start() {\n-    // TODO implement\n+    scheduleNextRefreshCertificate(INITIAL_DELAY_SECONDS);\n   }\n \n   @Override\n   public void close() {\n-    // TODO implement\n+    if (scheduledTask != null) {\n+      scheduledTask.scheduledHandle.cancel();\n+      scheduledTask = null;\n+    }\n+    getWatcher().close();\n+  }\n+\n+  private void scheduleNextRefreshCertificate(long delayInSeconds) {\n+    if (scheduledTask != null) {\n+      if (scheduledTask.scheduledHandle.isPending()) {\n+        logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n+        scheduledTask.scheduledHandle.cancel();\n+      }\n+    }\n+    scheduledTask = new RefreshCertificateTask(delayInSeconds);\n+  }\n+\n+  @VisibleForTesting\n+  void refreshCertificate()\n+      throws NoSuchAlgorithmException, IOException, OperatorCreationException {\n+    long refreshDelaySeconds = computeRefreshSecondsFromCurrentCertExpiry();\n+    ManagedChannel channel = meshCaChannelFactory.createChannel(meshCaUrl);\n+    try {\n+      String uniqueReqIdForAllRetries = UUID.randomUUID().toString();\n+      Duration duration = Duration.newBuilder().setSeconds(validitySeconds).build();\n+      KeyPair keyPair = generateKeyPair();\n+      String csr = generateCsr(keyPair);\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub =\n+          createStubToMeshCa(channel);\n+      List<X509Certificate> x509Chain = makeRequestWithRetries(stub, uniqueReqIdForAllRetries,\n+          duration, csr);\n+      if (x509Chain != null) {\n+        refreshDelaySeconds =\n+            computeDelaySecondsToCertExpiry(x509Chain.get(0)) - renewalGracePeriodSeconds;\n+        getWatcher().updateCertificate(keyPair.getPrivate(), x509Chain);\n+        getWatcher().updateTrustedRoots(ImmutableList.of(x509Chain.get(x509Chain.size() - 1)));\n+      }\n+    } finally {\n+      shutdownChannel(channel);\n+      scheduleNextRefreshCertificate(refreshDelaySeconds);\n+    }\n+  }\n+\n+  private MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub createStubToMeshCa(\n+      ManagedChannel channel) {\n+    return MeshCertificateServiceGrpc\n+        .newBlockingStub(channel)\n+        .withCallCredentials(MoreCallCredentials.from(oauth2Creds))\n+        .withInterceptors(headerInterceptor);\n+  }\n+\n+  private List<X509Certificate> makeRequestWithRetries(\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub,\n+      String reqId,\n+      Duration duration,\n+      String csr) {\n+    Meshca.MeshCertificateRequest request =\n+        Meshca.MeshCertificateRequest.newBuilder()\n+            .setValidity(duration)\n+            .setCsr(csr)\n+            .setRequestId(reqId)\n+            .build();\n+\n+    BackoffPolicy backoffPolicy = backoffPolicyProvider.get();\n+    Throwable lastException = null;\n+    for (int i = 0; i <= maxRetryAttempts; i++) {\n+      try {\n+        Meshca.MeshCertificateResponse response =\n+            stub.withDeadlineAfter(rpcTimeoutMillis, TimeUnit.MILLISECONDS)\n+                .createCertificate(request);\n+        return getX509CertificatesFromResponse(response);\n+      } catch (Throwable t) {\n+        if (!retriable(t)) {\n+          generateErrorIfCurrentCertExpired(t);\n+          return null;\n+        }\n+        lastException = t;\n+        sleepForNanos(backoffPolicy.nextBackoffNanos());\n+      }\n+    }\n+    generateErrorIfCurrentCertExpired(lastException);\n+    return null;\n+  }\n+\n+  private void sleepForNanos(long nanos) {\n+    ScheduledFuture<?> future = scheduledExecutorService.schedule(new Runnable() {\n+      @Override\n+      public void run() {\n+        // do nothing\n+      }\n+    }, nanos, TimeUnit.NANOSECONDS);\n+    try {\n+      future.get(nanos, TimeUnit.NANOSECONDS);\n+    } catch (InterruptedException | ExecutionException | TimeoutException ex) {\n+      logger.log(Level.SEVERE, \"Inside sleep\", ex);\n+    }\n+  }\n+\n+  private static boolean retriable(Throwable t) {\n+    if (t instanceof StatusRuntimeException) {\n+      return retriable(((StatusRuntimeException) t).getStatus());\n+    } else if (t.getCause() instanceof StatusRuntimeException) {\n+      return retriable(((StatusRuntimeException) t.getCause()).getStatus());\n+    }\n+    return false;\n+  }\n+\n+  private static boolean retriable(Status status) {\n+    return RETRIABLE_CODES.contains(status.getCode());\n+  }\n+\n+  private void generateErrorIfCurrentCertExpired(Throwable t) {\n+    X509Certificate currentCert = getWatcher().getLastIdentityCert();\n+    if (currentCert != null) {\n+      long delaySeconds = computeDelaySecondsToCertExpiry(currentCert);\n+      if (delaySeconds > INITIAL_DELAY_SECONDS) {\n+        return;\n+      }\n+      getWatcher().cleanupLastValues();\n+    }\n+    getWatcher().onError(Status.fromThrowable(t));\n+  }\n+\n+  private KeyPair generateKeyPair() throws NoSuchAlgorithmException {\n+    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(alg);\n+    keyPairGenerator.initialize(keySize);\n+    return keyPairGenerator.generateKeyPair();\n+  }\n+\n+  private String generateCsr(KeyPair pair) throws IOException, OperatorCreationException {\n+    PKCS10CertificationRequestBuilder p10Builder =\n+        new JcaPKCS10CertificationRequestBuilder(\n+            new X500Principal(\"CN=EXAMPLE.COM\"), pair.getPublic());\n+    JcaContentSignerBuilder csBuilder = new JcaContentSignerBuilder(signatureAlg);\n+    ContentSigner signer = csBuilder.build(pair.getPrivate());\n+    PKCS10CertificationRequest csr = p10Builder.build(signer);\n+    PemObject pemObject = new PemObject(\"NEW CERTIFICATE REQUEST\", csr.getEncoded());\n+    StringWriter str = new StringWriter();\n+    JcaPEMWriter pemWriter = new JcaPEMWriter(str);\n+    pemWriter.writeObject(pemObject);\n+    pemWriter.close();\n+    str.close();\n+    return str.toString();\n+  }\n+\n+  /** Compute refresh interval as half of interval to current cert expiry. */\n+  private long computeRefreshSecondsFromCurrentCertExpiry() {\n+    X509Certificate lastCert = getWatcher().getLastIdentityCert();\n+    if (lastCert == null) {\n+      return INITIAL_DELAY_SECONDS;\n+    }\n+    long delayToCertExpirySeconds = computeDelaySecondsToCertExpiry(lastCert) / 2;\n+    return Math.max(delayToCertExpirySeconds, INITIAL_DELAY_SECONDS);\n+  }\n+\n+  private long computeDelaySecondsToCertExpiry(X509Certificate lastCert) {\n+    checkNotNull(lastCert, \"lastCert\");\n+    return TimeUnit.NANOSECONDS.toSeconds(\n+        TimeUnit.MILLISECONDS.toNanos(lastCert.getNotAfter().getTime()) - timeProvider\n+            .currentTimeNanos());\n+  }\n+\n+  private static void shutdownChannel(ManagedChannel channel) {\n+    channel.shutdown();\n+    try {\n+      channel.awaitTermination(10, TimeUnit.SECONDS);\n+    } catch (InterruptedException ex) {\n+      logger.log(Level.SEVERE, \"awaiting channel Termination\", ex);\n+      channel.shutdownNow();\n+    }\n+  }\n+\n+  private List<X509Certificate> getX509CertificatesFromResponse(\n+      Meshca.MeshCertificateResponse response) throws CertificateException, IOException {\n+    List<String> certChain = response.getCertChainList();\n+    List<X509Certificate> x509Chain = new ArrayList<>(certChain.size());\n+    for (String certString : certChain) {\n+      x509Chain.add(\n+          CertificateUtils\n+              .toX509Certificate(new ByteArrayInputStream(certString.getBytes(UTF_8))));\n+    }\n+    return x509Chain;\n+  }\n+\n+  @VisibleForTesting\n+  class RefreshCertificateTask implements Runnable {\n+    @VisibleForTesting final SynchronizationContext.ScheduledHandle scheduledHandle;\n+\n+    private RefreshCertificateTask(long delayInSeconds) {\n+      scheduledHandle =\n+          syncContext.schedule(this, delayInSeconds, TimeUnit.SECONDS, scheduledExecutorService);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29db1bf035e50c4729511c68e44916c518db6fa1"}, "originalPosition": 343}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE4MjE2OA==", "bodyText": "Always call Thread.currentThread().interrupt() to re-mark the thread as interrupted. Ditto elsewhere.", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466182168", "createdAt": "2020-08-06T06:50:07Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -17,35 +17,349 @@\n package io.grpc.xds.internal.certprovider;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.Status.Code.ABORTED;\n+import static io.grpc.Status.Code.CANCELLED;\n+import static io.grpc.Status.Code.DEADLINE_EXCEEDED;\n+import static io.grpc.Status.Code.INTERNAL;\n+import static io.grpc.Status.Code.RESOURCE_EXHAUSTED;\n+import static io.grpc.Status.Code.UNAVAILABLE;\n+import static io.grpc.Status.Code.UNKNOWN;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Duration;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener;\n+import io.grpc.InternalLogId;\n import io.grpc.ManagedChannel;\n import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.auth.MoreCallCredentials;\n import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n+import javax.security.auth.x500.X500Principal;\n+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequest;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;\n+import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;\n+import org.bouncycastle.util.io.pem.PemObject;\n \n /** Implementation of {@link CertificateProvider} for the Google Mesh CA. */\n final class MeshCaCertificateProvider extends CertificateProvider {\n   private static final Logger logger = Logger.getLogger(MeshCaCertificateProvider.class.getName());\n \n-  protected MeshCaCertificateProvider(DistributorWatcher watcher, boolean notifyCertUpdates,\n-      String meshCaUrl, String zone, long validitySeconds,\n-      int keySize, String alg, String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n-      BackoffPolicy.Provider backoffPolicyProvider, long renewalGracePeriodSeconds,\n-      int maxRetryAttempts, GoogleCredentials oauth2Creds) {\n+  protected MeshCaCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String meshCaUrl,\n+      String zone,\n+      long validitySeconds,\n+      int keySize,\n+      String alg,\n+      String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      long renewalGracePeriodSeconds,\n+      int maxRetryAttempts,\n+      GoogleCredentials oauth2Creds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider,\n+      long rpcTimeoutMillis) {\n     super(watcher, notifyCertUpdates);\n+    this.meshCaUrl = checkNotNull(meshCaUrl, \"meshCaUrl\");\n+    checkArgument(\n+        validitySeconds > INITIAL_DELAY_SECONDS,\n+        \"validitySeconds must be greater than \" + INITIAL_DELAY_SECONDS);\n+    this.validitySeconds = validitySeconds;\n+    this.keySize = keySize;\n+    this.alg = checkNotNull(alg, \"alg\");\n+    this.signatureAlg = checkNotNull(signatureAlg, \"signatureAlg\");\n+    this.meshCaChannelFactory = checkNotNull(meshCaChannelFactory, \"meshCaChannelFactory\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    checkArgument(\n+        renewalGracePeriodSeconds > 0L && renewalGracePeriodSeconds < validitySeconds,\n+        \"renewalGracePeriodSeconds should be between 0 and \" + validitySeconds);\n+    this.renewalGracePeriodSeconds = renewalGracePeriodSeconds;\n+    checkArgument(maxRetryAttempts >= 0, \"maxRetryAttempts must be >= 0\");\n+    this.maxRetryAttempts = maxRetryAttempts;\n+    this.oauth2Creds = checkNotNull(oauth2Creds, \"oauth2Creds\");\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.headerInterceptor = new ZoneInfoClientInterceptor(checkNotNull(zone, \"zone\"));\n+    this.syncContext = createSynchronizationContext(meshCaUrl);\n+    this.rpcTimeoutMillis = rpcTimeoutMillis;\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"XdsClientWrapperForServerSds\", details);\n+    return new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          private boolean panicMode;\n+\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                \"[\" + logId + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                e);\n+            panic(e);\n+          }\n+\n+          void panic(final Throwable t) {\n+            if (panicMode) {\n+              // Preserve the first panic information\n+              return;\n+            }\n+            panicMode = true;\n+            close();\n+          }\n+        });\n   }\n \n   @Override\n   public void start() {\n-    // TODO implement\n+    scheduleNextRefreshCertificate(INITIAL_DELAY_SECONDS);\n   }\n \n   @Override\n   public void close() {\n-    // TODO implement\n+    if (scheduledTask != null) {\n+      scheduledTask.scheduledHandle.cancel();\n+      scheduledTask = null;\n+    }\n+    getWatcher().close();\n+  }\n+\n+  private void scheduleNextRefreshCertificate(long delayInSeconds) {\n+    if (scheduledTask != null) {\n+      if (scheduledTask.scheduledHandle.isPending()) {\n+        logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n+        scheduledTask.scheduledHandle.cancel();\n+      }\n+    }\n+    scheduledTask = new RefreshCertificateTask(delayInSeconds);\n+  }\n+\n+  @VisibleForTesting\n+  void refreshCertificate()\n+      throws NoSuchAlgorithmException, IOException, OperatorCreationException {\n+    long refreshDelaySeconds = computeRefreshSecondsFromCurrentCertExpiry();\n+    ManagedChannel channel = meshCaChannelFactory.createChannel(meshCaUrl);\n+    try {\n+      String uniqueReqIdForAllRetries = UUID.randomUUID().toString();\n+      Duration duration = Duration.newBuilder().setSeconds(validitySeconds).build();\n+      KeyPair keyPair = generateKeyPair();\n+      String csr = generateCsr(keyPair);\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub =\n+          createStubToMeshCa(channel);\n+      List<X509Certificate> x509Chain = makeRequestWithRetries(stub, uniqueReqIdForAllRetries,\n+          duration, csr);\n+      if (x509Chain != null) {\n+        refreshDelaySeconds =\n+            computeDelaySecondsToCertExpiry(x509Chain.get(0)) - renewalGracePeriodSeconds;\n+        getWatcher().updateCertificate(keyPair.getPrivate(), x509Chain);\n+        getWatcher().updateTrustedRoots(ImmutableList.of(x509Chain.get(x509Chain.size() - 1)));\n+      }\n+    } finally {\n+      shutdownChannel(channel);\n+      scheduleNextRefreshCertificate(refreshDelaySeconds);\n+    }\n+  }\n+\n+  private MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub createStubToMeshCa(\n+      ManagedChannel channel) {\n+    return MeshCertificateServiceGrpc\n+        .newBlockingStub(channel)\n+        .withCallCredentials(MoreCallCredentials.from(oauth2Creds))\n+        .withInterceptors(headerInterceptor);\n+  }\n+\n+  private List<X509Certificate> makeRequestWithRetries(\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub,\n+      String reqId,\n+      Duration duration,\n+      String csr) {\n+    Meshca.MeshCertificateRequest request =\n+        Meshca.MeshCertificateRequest.newBuilder()\n+            .setValidity(duration)\n+            .setCsr(csr)\n+            .setRequestId(reqId)\n+            .build();\n+\n+    BackoffPolicy backoffPolicy = backoffPolicyProvider.get();\n+    Throwable lastException = null;\n+    for (int i = 0; i <= maxRetryAttempts; i++) {\n+      try {\n+        Meshca.MeshCertificateResponse response =\n+            stub.withDeadlineAfter(rpcTimeoutMillis, TimeUnit.MILLISECONDS)\n+                .createCertificate(request);\n+        return getX509CertificatesFromResponse(response);\n+      } catch (Throwable t) {\n+        if (!retriable(t)) {\n+          generateErrorIfCurrentCertExpired(t);\n+          return null;\n+        }\n+        lastException = t;\n+        sleepForNanos(backoffPolicy.nextBackoffNanos());\n+      }\n+    }\n+    generateErrorIfCurrentCertExpired(lastException);\n+    return null;\n+  }\n+\n+  private void sleepForNanos(long nanos) {\n+    ScheduledFuture<?> future = scheduledExecutorService.schedule(new Runnable() {\n+      @Override\n+      public void run() {\n+        // do nothing\n+      }\n+    }, nanos, TimeUnit.NANOSECONDS);\n+    try {\n+      future.get(nanos, TimeUnit.NANOSECONDS);\n+    } catch (InterruptedException | ExecutionException | TimeoutException ex) {\n+      logger.log(Level.SEVERE, \"Inside sleep\", ex);\n+    }\n+  }\n+\n+  private static boolean retriable(Throwable t) {\n+    if (t instanceof StatusRuntimeException) {\n+      return retriable(((StatusRuntimeException) t).getStatus());\n+    } else if (t.getCause() instanceof StatusRuntimeException) {\n+      return retriable(((StatusRuntimeException) t.getCause()).getStatus());\n+    }\n+    return false;\n+  }\n+\n+  private static boolean retriable(Status status) {\n+    return RETRIABLE_CODES.contains(status.getCode());\n+  }\n+\n+  private void generateErrorIfCurrentCertExpired(Throwable t) {\n+    X509Certificate currentCert = getWatcher().getLastIdentityCert();\n+    if (currentCert != null) {\n+      long delaySeconds = computeDelaySecondsToCertExpiry(currentCert);\n+      if (delaySeconds > INITIAL_DELAY_SECONDS) {\n+        return;\n+      }\n+      getWatcher().cleanupLastValues();\n+    }\n+    getWatcher().onError(Status.fromThrowable(t));\n+  }\n+\n+  private KeyPair generateKeyPair() throws NoSuchAlgorithmException {\n+    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(alg);\n+    keyPairGenerator.initialize(keySize);\n+    return keyPairGenerator.generateKeyPair();\n+  }\n+\n+  private String generateCsr(KeyPair pair) throws IOException, OperatorCreationException {\n+    PKCS10CertificationRequestBuilder p10Builder =\n+        new JcaPKCS10CertificationRequestBuilder(\n+            new X500Principal(\"CN=EXAMPLE.COM\"), pair.getPublic());\n+    JcaContentSignerBuilder csBuilder = new JcaContentSignerBuilder(signatureAlg);\n+    ContentSigner signer = csBuilder.build(pair.getPrivate());\n+    PKCS10CertificationRequest csr = p10Builder.build(signer);\n+    PemObject pemObject = new PemObject(\"NEW CERTIFICATE REQUEST\", csr.getEncoded());\n+    StringWriter str = new StringWriter();\n+    JcaPEMWriter pemWriter = new JcaPEMWriter(str);\n+    pemWriter.writeObject(pemObject);\n+    pemWriter.close();\n+    str.close();\n+    return str.toString();\n+  }\n+\n+  /** Compute refresh interval as half of interval to current cert expiry. */\n+  private long computeRefreshSecondsFromCurrentCertExpiry() {\n+    X509Certificate lastCert = getWatcher().getLastIdentityCert();\n+    if (lastCert == null) {\n+      return INITIAL_DELAY_SECONDS;\n+    }\n+    long delayToCertExpirySeconds = computeDelaySecondsToCertExpiry(lastCert) / 2;\n+    return Math.max(delayToCertExpirySeconds, INITIAL_DELAY_SECONDS);\n+  }\n+\n+  private long computeDelaySecondsToCertExpiry(X509Certificate lastCert) {\n+    checkNotNull(lastCert, \"lastCert\");\n+    return TimeUnit.NANOSECONDS.toSeconds(\n+        TimeUnit.MILLISECONDS.toNanos(lastCert.getNotAfter().getTime()) - timeProvider\n+            .currentTimeNanos());\n+  }\n+\n+  private static void shutdownChannel(ManagedChannel channel) {\n+    channel.shutdown();\n+    try {\n+      channel.awaitTermination(10, TimeUnit.SECONDS);\n+    } catch (InterruptedException ex) {\n+      logger.log(Level.SEVERE, \"awaiting channel Termination\", ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29db1bf035e50c4729511c68e44916c518db6fa1"}, "originalPosition": 320}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE4MzUzNg==", "bodyText": "If you don't override any method of the listener, no need to wrap.", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466183536", "createdAt": "2020-08-06T06:53:03Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -129,6 +449,67 @@ abstract MeshCaCertificateProvider create(\n         BackoffPolicy.Provider backoffPolicyProvider,\n         long renewalGracePeriodSeconds,\n         int maxRetryAttempts,\n-        GoogleCredentials oauth2Creds);\n+        GoogleCredentials oauth2Creds,\n+        ScheduledExecutorService scheduledExecutorService,\n+        TimeProvider timeProvider,\n+        long rpcTimeoutMillis);\n   }\n+\n+  private class ZoneInfoClientInterceptor implements ClientInterceptor {\n+    private final String zone;\n+\n+    ZoneInfoClientInterceptor(String zone) {\n+      this.zone = zone;\n+    }\n+\n+    @Override\n+    public <ReqT, RespT> ClientCall<ReqT, RespT> interceptCall(\n+        MethodDescriptor<ReqT, RespT> method, CallOptions callOptions, Channel next) {\n+      return new ForwardingClientCall.SimpleForwardingClientCall<ReqT, RespT>(\n+          next.newCall(method, callOptions)) {\n+\n+        @Override\n+        public void start(Listener<RespT> responseListener, Metadata headers) {\n+          headers.put(KEY_FOR_ZONE_INFO, zone);\n+          super.start(\n+              new ForwardingClientCallListener.SimpleForwardingClientCallListener<RespT>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29db1bf035e50c4729511c68e44916c518db6fa1"}, "originalPosition": 409}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b98bfdeefd52572c16f5f9e9b111a87ec2459d5f", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/b98bfdeefd52572c16f5f9e9b111a87ec2459d5f", "committedDate": "2020-08-06T17:52:07Z", "message": "xds: implement MeshCACertificateProvider"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02ac14272e7ce874545765eae09f00b0c18e82de", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/02ac14272e7ce874545765eae09f00b0c18e82de", "committedDate": "2020-08-06T17:52:13Z", "message": "fix a windows specific error due to CRLF differences"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bda0e3f78177ec44f16ea2f11f3439a7f837004e", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/bda0e3f78177ec44f16ea2f11f3439a7f837004e", "committedDate": "2020-08-06T17:52:13Z", "message": "refactor to move some fuctions to a utils class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "623a79871bfccc4c49b2181ff505cd3f1eb6751e", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/623a79871bfccc4c49b2181ff505cd3f1eb6751e", "committedDate": "2020-08-06T17:52:13Z", "message": "Use a factory for ScheduledExecutorService"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42853d5a6324474ca729dcf3392ff39151993b25", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/42853d5a6324474ca729dcf3392ff39151993b25", "committedDate": "2020-08-06T17:52:13Z", "message": "address review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "526467d08fea137866235f879225d479a7fb468a", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/526467d08fea137866235f879225d479a7fb468a", "committedDate": "2020-08-06T17:46:11Z", "message": "address review comments"}, "afterCommit": {"oid": "42853d5a6324474ca729dcf3392ff39151993b25", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/42853d5a6324474ca729dcf3392ff39151993b25", "committedDate": "2020-08-06T17:52:13Z", "message": "address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e750e12e6513d286b63525ea295d6402b29461b", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/0e750e12e6513d286b63525ea295d6402b29461b", "committedDate": "2020-08-06T21:23:49Z", "message": "Add suppresswarnings for JdkObsolete"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNzE4ODEz", "url": "https://github.com/grpc/grpc-java/pull/7274#pullrequestreview-462718813", "createdAt": "2020-08-06T17:14:46Z", "commit": {"oid": "29db1bf035e50c4729511c68e44916c518db6fa1"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzoxNDo0NlrOG88tNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQyMjo1MjoxM1rOG9Gxrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2MjM1OQ==", "bodyText": "Could recreating a channel every time cost too much? How about creating just one channel and one stub as well per Provider, and shutdown() at Provider.close()? How often is the refresh typically?", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466562359", "createdAt": "2020-08-06T17:14:46Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -17,35 +17,349 @@\n package io.grpc.xds.internal.certprovider;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.Status.Code.ABORTED;\n+import static io.grpc.Status.Code.CANCELLED;\n+import static io.grpc.Status.Code.DEADLINE_EXCEEDED;\n+import static io.grpc.Status.Code.INTERNAL;\n+import static io.grpc.Status.Code.RESOURCE_EXHAUSTED;\n+import static io.grpc.Status.Code.UNAVAILABLE;\n+import static io.grpc.Status.Code.UNKNOWN;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Duration;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener;\n+import io.grpc.InternalLogId;\n import io.grpc.ManagedChannel;\n import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.auth.MoreCallCredentials;\n import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n+import javax.security.auth.x500.X500Principal;\n+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequest;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;\n+import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;\n+import org.bouncycastle.util.io.pem.PemObject;\n \n /** Implementation of {@link CertificateProvider} for the Google Mesh CA. */\n final class MeshCaCertificateProvider extends CertificateProvider {\n   private static final Logger logger = Logger.getLogger(MeshCaCertificateProvider.class.getName());\n \n-  protected MeshCaCertificateProvider(DistributorWatcher watcher, boolean notifyCertUpdates,\n-      String meshCaUrl, String zone, long validitySeconds,\n-      int keySize, String alg, String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n-      BackoffPolicy.Provider backoffPolicyProvider, long renewalGracePeriodSeconds,\n-      int maxRetryAttempts, GoogleCredentials oauth2Creds) {\n+  protected MeshCaCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String meshCaUrl,\n+      String zone,\n+      long validitySeconds,\n+      int keySize,\n+      String alg,\n+      String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      long renewalGracePeriodSeconds,\n+      int maxRetryAttempts,\n+      GoogleCredentials oauth2Creds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider,\n+      long rpcTimeoutMillis) {\n     super(watcher, notifyCertUpdates);\n+    this.meshCaUrl = checkNotNull(meshCaUrl, \"meshCaUrl\");\n+    checkArgument(\n+        validitySeconds > INITIAL_DELAY_SECONDS,\n+        \"validitySeconds must be greater than \" + INITIAL_DELAY_SECONDS);\n+    this.validitySeconds = validitySeconds;\n+    this.keySize = keySize;\n+    this.alg = checkNotNull(alg, \"alg\");\n+    this.signatureAlg = checkNotNull(signatureAlg, \"signatureAlg\");\n+    this.meshCaChannelFactory = checkNotNull(meshCaChannelFactory, \"meshCaChannelFactory\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    checkArgument(\n+        renewalGracePeriodSeconds > 0L && renewalGracePeriodSeconds < validitySeconds,\n+        \"renewalGracePeriodSeconds should be between 0 and \" + validitySeconds);\n+    this.renewalGracePeriodSeconds = renewalGracePeriodSeconds;\n+    checkArgument(maxRetryAttempts >= 0, \"maxRetryAttempts must be >= 0\");\n+    this.maxRetryAttempts = maxRetryAttempts;\n+    this.oauth2Creds = checkNotNull(oauth2Creds, \"oauth2Creds\");\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.headerInterceptor = new ZoneInfoClientInterceptor(checkNotNull(zone, \"zone\"));\n+    this.syncContext = createSynchronizationContext(meshCaUrl);\n+    this.rpcTimeoutMillis = rpcTimeoutMillis;\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"XdsClientWrapperForServerSds\", details);\n+    return new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          private boolean panicMode;\n+\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                \"[\" + logId + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                e);\n+            panic(e);\n+          }\n+\n+          void panic(final Throwable t) {\n+            if (panicMode) {\n+              // Preserve the first panic information\n+              return;\n+            }\n+            panicMode = true;\n+            close();\n+          }\n+        });\n   }\n \n   @Override\n   public void start() {\n-    // TODO implement\n+    scheduleNextRefreshCertificate(INITIAL_DELAY_SECONDS);\n   }\n \n   @Override\n   public void close() {\n-    // TODO implement\n+    if (scheduledTask != null) {\n+      scheduledTask.scheduledHandle.cancel();\n+      scheduledTask = null;\n+    }\n+    getWatcher().close();\n+  }\n+\n+  private void scheduleNextRefreshCertificate(long delayInSeconds) {\n+    if (scheduledTask != null) {\n+      if (scheduledTask.scheduledHandle.isPending()) {\n+        logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n+        scheduledTask.scheduledHandle.cancel();\n+      }\n+    }\n+    scheduledTask = new RefreshCertificateTask(delayInSeconds);\n+  }\n+\n+  @VisibleForTesting\n+  void refreshCertificate()\n+      throws NoSuchAlgorithmException, IOException, OperatorCreationException {\n+    long refreshDelaySeconds = computeRefreshSecondsFromCurrentCertExpiry();\n+    ManagedChannel channel = meshCaChannelFactory.createChannel(meshCaUrl);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29db1bf035e50c4729511c68e44916c518db6fa1"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3MjQ4Nw==", "bodyText": "trustedRoots is always a single-element list?", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466572487", "createdAt": "2020-08-06T17:28:34Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -17,35 +17,349 @@\n package io.grpc.xds.internal.certprovider;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.Status.Code.ABORTED;\n+import static io.grpc.Status.Code.CANCELLED;\n+import static io.grpc.Status.Code.DEADLINE_EXCEEDED;\n+import static io.grpc.Status.Code.INTERNAL;\n+import static io.grpc.Status.Code.RESOURCE_EXHAUSTED;\n+import static io.grpc.Status.Code.UNAVAILABLE;\n+import static io.grpc.Status.Code.UNKNOWN;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Duration;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener;\n+import io.grpc.InternalLogId;\n import io.grpc.ManagedChannel;\n import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.auth.MoreCallCredentials;\n import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n+import javax.security.auth.x500.X500Principal;\n+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequest;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;\n+import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;\n+import org.bouncycastle.util.io.pem.PemObject;\n \n /** Implementation of {@link CertificateProvider} for the Google Mesh CA. */\n final class MeshCaCertificateProvider extends CertificateProvider {\n   private static final Logger logger = Logger.getLogger(MeshCaCertificateProvider.class.getName());\n \n-  protected MeshCaCertificateProvider(DistributorWatcher watcher, boolean notifyCertUpdates,\n-      String meshCaUrl, String zone, long validitySeconds,\n-      int keySize, String alg, String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n-      BackoffPolicy.Provider backoffPolicyProvider, long renewalGracePeriodSeconds,\n-      int maxRetryAttempts, GoogleCredentials oauth2Creds) {\n+  protected MeshCaCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String meshCaUrl,\n+      String zone,\n+      long validitySeconds,\n+      int keySize,\n+      String alg,\n+      String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      long renewalGracePeriodSeconds,\n+      int maxRetryAttempts,\n+      GoogleCredentials oauth2Creds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider,\n+      long rpcTimeoutMillis) {\n     super(watcher, notifyCertUpdates);\n+    this.meshCaUrl = checkNotNull(meshCaUrl, \"meshCaUrl\");\n+    checkArgument(\n+        validitySeconds > INITIAL_DELAY_SECONDS,\n+        \"validitySeconds must be greater than \" + INITIAL_DELAY_SECONDS);\n+    this.validitySeconds = validitySeconds;\n+    this.keySize = keySize;\n+    this.alg = checkNotNull(alg, \"alg\");\n+    this.signatureAlg = checkNotNull(signatureAlg, \"signatureAlg\");\n+    this.meshCaChannelFactory = checkNotNull(meshCaChannelFactory, \"meshCaChannelFactory\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    checkArgument(\n+        renewalGracePeriodSeconds > 0L && renewalGracePeriodSeconds < validitySeconds,\n+        \"renewalGracePeriodSeconds should be between 0 and \" + validitySeconds);\n+    this.renewalGracePeriodSeconds = renewalGracePeriodSeconds;\n+    checkArgument(maxRetryAttempts >= 0, \"maxRetryAttempts must be >= 0\");\n+    this.maxRetryAttempts = maxRetryAttempts;\n+    this.oauth2Creds = checkNotNull(oauth2Creds, \"oauth2Creds\");\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.headerInterceptor = new ZoneInfoClientInterceptor(checkNotNull(zone, \"zone\"));\n+    this.syncContext = createSynchronizationContext(meshCaUrl);\n+    this.rpcTimeoutMillis = rpcTimeoutMillis;\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"XdsClientWrapperForServerSds\", details);\n+    return new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          private boolean panicMode;\n+\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                \"[\" + logId + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                e);\n+            panic(e);\n+          }\n+\n+          void panic(final Throwable t) {\n+            if (panicMode) {\n+              // Preserve the first panic information\n+              return;\n+            }\n+            panicMode = true;\n+            close();\n+          }\n+        });\n   }\n \n   @Override\n   public void start() {\n-    // TODO implement\n+    scheduleNextRefreshCertificate(INITIAL_DELAY_SECONDS);\n   }\n \n   @Override\n   public void close() {\n-    // TODO implement\n+    if (scheduledTask != null) {\n+      scheduledTask.scheduledHandle.cancel();\n+      scheduledTask = null;\n+    }\n+    getWatcher().close();\n+  }\n+\n+  private void scheduleNextRefreshCertificate(long delayInSeconds) {\n+    if (scheduledTask != null) {\n+      if (scheduledTask.scheduledHandle.isPending()) {\n+        logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n+        scheduledTask.scheduledHandle.cancel();\n+      }\n+    }\n+    scheduledTask = new RefreshCertificateTask(delayInSeconds);\n+  }\n+\n+  @VisibleForTesting\n+  void refreshCertificate()\n+      throws NoSuchAlgorithmException, IOException, OperatorCreationException {\n+    long refreshDelaySeconds = computeRefreshSecondsFromCurrentCertExpiry();\n+    ManagedChannel channel = meshCaChannelFactory.createChannel(meshCaUrl);\n+    try {\n+      String uniqueReqIdForAllRetries = UUID.randomUUID().toString();\n+      Duration duration = Duration.newBuilder().setSeconds(validitySeconds).build();\n+      KeyPair keyPair = generateKeyPair();\n+      String csr = generateCsr(keyPair);\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub =\n+          createStubToMeshCa(channel);\n+      List<X509Certificate> x509Chain = makeRequestWithRetries(stub, uniqueReqIdForAllRetries,\n+          duration, csr);\n+      if (x509Chain != null) {\n+        refreshDelaySeconds =\n+            computeDelaySecondsToCertExpiry(x509Chain.get(0)) - renewalGracePeriodSeconds;\n+        getWatcher().updateCertificate(keyPair.getPrivate(), x509Chain);\n+        getWatcher().updateTrustedRoots(ImmutableList.of(x509Chain.get(x509Chain.size() - 1)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29db1bf035e50c4729511c68e44916c518db6fa1"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU3ODM2MQ==", "bodyText": "return RETRIABLE_CODES.contains(Status.fromThrowable(t));", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466578361", "createdAt": "2020-08-06T17:38:41Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -17,35 +17,349 @@\n package io.grpc.xds.internal.certprovider;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.Status.Code.ABORTED;\n+import static io.grpc.Status.Code.CANCELLED;\n+import static io.grpc.Status.Code.DEADLINE_EXCEEDED;\n+import static io.grpc.Status.Code.INTERNAL;\n+import static io.grpc.Status.Code.RESOURCE_EXHAUSTED;\n+import static io.grpc.Status.Code.UNAVAILABLE;\n+import static io.grpc.Status.Code.UNKNOWN;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Duration;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.ForwardingClientCallListener;\n+import io.grpc.InternalLogId;\n import io.grpc.ManagedChannel;\n import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.auth.MoreCallCredentials;\n import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n+import javax.security.auth.x500.X500Principal;\n+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequest;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;\n+import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;\n+import org.bouncycastle.util.io.pem.PemObject;\n \n /** Implementation of {@link CertificateProvider} for the Google Mesh CA. */\n final class MeshCaCertificateProvider extends CertificateProvider {\n   private static final Logger logger = Logger.getLogger(MeshCaCertificateProvider.class.getName());\n \n-  protected MeshCaCertificateProvider(DistributorWatcher watcher, boolean notifyCertUpdates,\n-      String meshCaUrl, String zone, long validitySeconds,\n-      int keySize, String alg, String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n-      BackoffPolicy.Provider backoffPolicyProvider, long renewalGracePeriodSeconds,\n-      int maxRetryAttempts, GoogleCredentials oauth2Creds) {\n+  protected MeshCaCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String meshCaUrl,\n+      String zone,\n+      long validitySeconds,\n+      int keySize,\n+      String alg,\n+      String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      long renewalGracePeriodSeconds,\n+      int maxRetryAttempts,\n+      GoogleCredentials oauth2Creds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider,\n+      long rpcTimeoutMillis) {\n     super(watcher, notifyCertUpdates);\n+    this.meshCaUrl = checkNotNull(meshCaUrl, \"meshCaUrl\");\n+    checkArgument(\n+        validitySeconds > INITIAL_DELAY_SECONDS,\n+        \"validitySeconds must be greater than \" + INITIAL_DELAY_SECONDS);\n+    this.validitySeconds = validitySeconds;\n+    this.keySize = keySize;\n+    this.alg = checkNotNull(alg, \"alg\");\n+    this.signatureAlg = checkNotNull(signatureAlg, \"signatureAlg\");\n+    this.meshCaChannelFactory = checkNotNull(meshCaChannelFactory, \"meshCaChannelFactory\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    checkArgument(\n+        renewalGracePeriodSeconds > 0L && renewalGracePeriodSeconds < validitySeconds,\n+        \"renewalGracePeriodSeconds should be between 0 and \" + validitySeconds);\n+    this.renewalGracePeriodSeconds = renewalGracePeriodSeconds;\n+    checkArgument(maxRetryAttempts >= 0, \"maxRetryAttempts must be >= 0\");\n+    this.maxRetryAttempts = maxRetryAttempts;\n+    this.oauth2Creds = checkNotNull(oauth2Creds, \"oauth2Creds\");\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.headerInterceptor = new ZoneInfoClientInterceptor(checkNotNull(zone, \"zone\"));\n+    this.syncContext = createSynchronizationContext(meshCaUrl);\n+    this.rpcTimeoutMillis = rpcTimeoutMillis;\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"XdsClientWrapperForServerSds\", details);\n+    return new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          private boolean panicMode;\n+\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                \"[\" + logId + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                e);\n+            panic(e);\n+          }\n+\n+          void panic(final Throwable t) {\n+            if (panicMode) {\n+              // Preserve the first panic information\n+              return;\n+            }\n+            panicMode = true;\n+            close();\n+          }\n+        });\n   }\n \n   @Override\n   public void start() {\n-    // TODO implement\n+    scheduleNextRefreshCertificate(INITIAL_DELAY_SECONDS);\n   }\n \n   @Override\n   public void close() {\n-    // TODO implement\n+    if (scheduledTask != null) {\n+      scheduledTask.scheduledHandle.cancel();\n+      scheduledTask = null;\n+    }\n+    getWatcher().close();\n+  }\n+\n+  private void scheduleNextRefreshCertificate(long delayInSeconds) {\n+    if (scheduledTask != null) {\n+      if (scheduledTask.scheduledHandle.isPending()) {\n+        logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n+        scheduledTask.scheduledHandle.cancel();\n+      }\n+    }\n+    scheduledTask = new RefreshCertificateTask(delayInSeconds);\n+  }\n+\n+  @VisibleForTesting\n+  void refreshCertificate()\n+      throws NoSuchAlgorithmException, IOException, OperatorCreationException {\n+    long refreshDelaySeconds = computeRefreshSecondsFromCurrentCertExpiry();\n+    ManagedChannel channel = meshCaChannelFactory.createChannel(meshCaUrl);\n+    try {\n+      String uniqueReqIdForAllRetries = UUID.randomUUID().toString();\n+      Duration duration = Duration.newBuilder().setSeconds(validitySeconds).build();\n+      KeyPair keyPair = generateKeyPair();\n+      String csr = generateCsr(keyPair);\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub =\n+          createStubToMeshCa(channel);\n+      List<X509Certificate> x509Chain = makeRequestWithRetries(stub, uniqueReqIdForAllRetries,\n+          duration, csr);\n+      if (x509Chain != null) {\n+        refreshDelaySeconds =\n+            computeDelaySecondsToCertExpiry(x509Chain.get(0)) - renewalGracePeriodSeconds;\n+        getWatcher().updateCertificate(keyPair.getPrivate(), x509Chain);\n+        getWatcher().updateTrustedRoots(ImmutableList.of(x509Chain.get(x509Chain.size() - 1)));\n+      }\n+    } finally {\n+      shutdownChannel(channel);\n+      scheduleNextRefreshCertificate(refreshDelaySeconds);\n+    }\n+  }\n+\n+  private MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub createStubToMeshCa(\n+      ManagedChannel channel) {\n+    return MeshCertificateServiceGrpc\n+        .newBlockingStub(channel)\n+        .withCallCredentials(MoreCallCredentials.from(oauth2Creds))\n+        .withInterceptors(headerInterceptor);\n+  }\n+\n+  private List<X509Certificate> makeRequestWithRetries(\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub,\n+      String reqId,\n+      Duration duration,\n+      String csr) {\n+    Meshca.MeshCertificateRequest request =\n+        Meshca.MeshCertificateRequest.newBuilder()\n+            .setValidity(duration)\n+            .setCsr(csr)\n+            .setRequestId(reqId)\n+            .build();\n+\n+    BackoffPolicy backoffPolicy = backoffPolicyProvider.get();\n+    Throwable lastException = null;\n+    for (int i = 0; i <= maxRetryAttempts; i++) {\n+      try {\n+        Meshca.MeshCertificateResponse response =\n+            stub.withDeadlineAfter(rpcTimeoutMillis, TimeUnit.MILLISECONDS)\n+                .createCertificate(request);\n+        return getX509CertificatesFromResponse(response);\n+      } catch (Throwable t) {\n+        if (!retriable(t)) {\n+          generateErrorIfCurrentCertExpired(t);\n+          return null;\n+        }\n+        lastException = t;\n+        sleepForNanos(backoffPolicy.nextBackoffNanos());\n+      }\n+    }\n+    generateErrorIfCurrentCertExpired(lastException);\n+    return null;\n+  }\n+\n+  private void sleepForNanos(long nanos) {\n+    ScheduledFuture<?> future = scheduledExecutorService.schedule(new Runnable() {\n+      @Override\n+      public void run() {\n+        // do nothing\n+      }\n+    }, nanos, TimeUnit.NANOSECONDS);\n+    try {\n+      future.get(nanos, TimeUnit.NANOSECONDS);\n+    } catch (InterruptedException | ExecutionException | TimeoutException ex) {\n+      logger.log(Level.SEVERE, \"Inside sleep\", ex);\n+    }\n+  }\n+\n+  private static boolean retriable(Throwable t) {\n+    if (t instanceof StatusRuntimeException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29db1bf035e50c4729511c68e44916c518db6fa1"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU4NTQ1NA==", "bodyText": "need a white space", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466585454", "createdAt": "2020-08-06T17:51:29Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/sds/trust/CertificateUtils.java", "diffHunk": "@@ -61,5 +61,17 @@ private static synchronized void initInstance() throws CertificateException {\n     }\n   }\n \n+  /** See {@link CertificateFactory#generateCertificate(InputStream)} enerateCertificate}. */\n+  public static synchronized X509Certificate toX509Certificate(InputStream inputStream)\n+          throws CertificateException, IOException {\n+    initInstance();\n+    try {\n+      Certificate cert = factory.generateCertificate(inputStream);\n+      return (X509Certificate)cert;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29db1bf035e50c4729511c68e44916c518db6fa1"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyNDY4MA==", "bodyText": "Seems we can use java7's try-with-resource now.", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466724680", "createdAt": "2020-08-06T22:44:08Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/sds/trust/CertificateUtils.java", "diffHunk": "@@ -61,5 +61,17 @@ private static synchronized void initInstance() throws CertificateException {\n     }\n   }\n \n+  /** See {@link CertificateFactory#generateCertificate(InputStream)} enerateCertificate}. */\n+  public static synchronized X509Certificate toX509Certificate(InputStream inputStream)\n+          throws CertificateException, IOException {\n+    initInstance();\n+    try {\n+      Certificate cert = factory.generateCertificate(inputStream);\n+      return (X509Certificate)cert;\n+    } finally {\n+      inputStream.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e750e12e6513d286b63525ea295d6402b29461b"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjcyNzM0Mw==", "bodyText": "Seems we can use java7's try-with-resource now.", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r466727343", "createdAt": "2020-08-06T22:52:13Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProvider.java", "diffHunk": "@@ -17,35 +17,346 @@\n package io.grpc.xds.internal.certprovider;\n \n import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.Status.Code.ABORTED;\n+import static io.grpc.Status.Code.CANCELLED;\n+import static io.grpc.Status.Code.DEADLINE_EXCEEDED;\n+import static io.grpc.Status.Code.INTERNAL;\n+import static io.grpc.Status.Code.RESOURCE_EXHAUSTED;\n+import static io.grpc.Status.Code.UNAVAILABLE;\n+import static io.grpc.Status.Code.UNKNOWN;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n \n import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableList;\n+import com.google.protobuf.Duration;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.CallOptions;\n+import io.grpc.Channel;\n+import io.grpc.ClientCall;\n+import io.grpc.ClientInterceptor;\n+import io.grpc.ForwardingClientCall;\n+import io.grpc.InternalLogId;\n import io.grpc.ManagedChannel;\n import io.grpc.ManagedChannelBuilder;\n+import io.grpc.Metadata;\n+import io.grpc.MethodDescriptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.auth.MoreCallCredentials;\n import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.xds.internal.sds.trust.CertificateUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n+import javax.security.auth.x500.X500Principal;\n+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;\n+import org.bouncycastle.operator.ContentSigner;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequest;\n+import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;\n+import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;\n+import org.bouncycastle.util.io.pem.PemObject;\n \n /** Implementation of {@link CertificateProvider} for the Google Mesh CA. */\n final class MeshCaCertificateProvider extends CertificateProvider {\n   private static final Logger logger = Logger.getLogger(MeshCaCertificateProvider.class.getName());\n \n-  MeshCaCertificateProvider(DistributorWatcher watcher, boolean notifyCertUpdates,\n-      String meshCaUrl, String zone, long validitySeconds,\n-      int keySize, String alg, String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n-      BackoffPolicy.Provider backoffPolicyProvider, long renewalGracePeriodSeconds,\n-      int maxRetryAttempts, GoogleCredentials oauth2Creds) {\n+  MeshCaCertificateProvider(\n+      DistributorWatcher watcher,\n+      boolean notifyCertUpdates,\n+      String meshCaUrl,\n+      String zone,\n+      long validitySeconds,\n+      int keySize,\n+      String alg,\n+      String signatureAlg, MeshCaChannelFactory meshCaChannelFactory,\n+      BackoffPolicy.Provider backoffPolicyProvider,\n+      long renewalGracePeriodSeconds,\n+      int maxRetryAttempts,\n+      GoogleCredentials oauth2Creds,\n+      ScheduledExecutorService scheduledExecutorService,\n+      TimeProvider timeProvider,\n+      long rpcTimeoutMillis) {\n     super(watcher, notifyCertUpdates);\n+    this.meshCaUrl = checkNotNull(meshCaUrl, \"meshCaUrl\");\n+    checkArgument(\n+        validitySeconds > INITIAL_DELAY_SECONDS,\n+        \"validitySeconds must be greater than \" + INITIAL_DELAY_SECONDS);\n+    this.validitySeconds = validitySeconds;\n+    this.keySize = keySize;\n+    this.alg = checkNotNull(alg, \"alg\");\n+    this.signatureAlg = checkNotNull(signatureAlg, \"signatureAlg\");\n+    this.meshCaChannelFactory = checkNotNull(meshCaChannelFactory, \"meshCaChannelFactory\");\n+    this.backoffPolicyProvider = checkNotNull(backoffPolicyProvider, \"backoffPolicyProvider\");\n+    checkArgument(\n+        renewalGracePeriodSeconds > 0L && renewalGracePeriodSeconds < validitySeconds,\n+        \"renewalGracePeriodSeconds should be between 0 and \" + validitySeconds);\n+    this.renewalGracePeriodSeconds = renewalGracePeriodSeconds;\n+    checkArgument(maxRetryAttempts >= 0, \"maxRetryAttempts must be >= 0\");\n+    this.maxRetryAttempts = maxRetryAttempts;\n+    this.oauth2Creds = checkNotNull(oauth2Creds, \"oauth2Creds\");\n+    this.scheduledExecutorService =\n+        checkNotNull(scheduledExecutorService, \"scheduledExecutorService\");\n+    this.timeProvider = checkNotNull(timeProvider, \"timeProvider\");\n+    this.headerInterceptor = new ZoneInfoClientInterceptor(checkNotNull(zone, \"zone\"));\n+    this.syncContext = createSynchronizationContext(meshCaUrl);\n+    this.rpcTimeoutMillis = rpcTimeoutMillis;\n+  }\n+\n+  private SynchronizationContext createSynchronizationContext(String details) {\n+    final InternalLogId logId = InternalLogId.allocate(\"MeshCaCertificateProvider\", details);\n+    return new SynchronizationContext(\n+        new Thread.UncaughtExceptionHandler() {\n+          private boolean panicMode;\n+\n+          @Override\n+          public void uncaughtException(Thread t, Throwable e) {\n+            logger.log(\n+                Level.SEVERE,\n+                \"[\" + logId + \"] Uncaught exception in the SynchronizationContext. Panic!\",\n+                e);\n+            panic(e);\n+          }\n+\n+          void panic(final Throwable t) {\n+            if (panicMode) {\n+              // Preserve the first panic information\n+              return;\n+            }\n+            panicMode = true;\n+            close();\n+          }\n+        });\n   }\n \n   @Override\n   public void start() {\n-    // TODO implement\n+    scheduleNextRefreshCertificate(INITIAL_DELAY_SECONDS);\n   }\n \n   @Override\n   public void close() {\n-    // TODO implement\n+    if (scheduledHandle != null) {\n+      scheduledHandle.cancel();\n+      scheduledHandle = null;\n+    }\n+    getWatcher().close();\n+  }\n+\n+  private void scheduleNextRefreshCertificate(long delayInSeconds) {\n+    if (scheduledHandle != null && scheduledHandle.isPending()) {\n+      logger.log(Level.SEVERE, \"Pending task found: inconsistent state in scheduledHandle!\");\n+      scheduledHandle.cancel();\n+    }\n+    RefreshCertificateTask runnable = new RefreshCertificateTask();\n+    scheduledHandle = syncContext.schedule(\n+            runnable, delayInSeconds, TimeUnit.SECONDS, scheduledExecutorService);\n+  }\n+\n+  @VisibleForTesting\n+  void refreshCertificate()\n+      throws NoSuchAlgorithmException, IOException, OperatorCreationException {\n+    long refreshDelaySeconds = computeRefreshSecondsFromCurrentCertExpiry();\n+    ManagedChannel channel = meshCaChannelFactory.createChannel(meshCaUrl);\n+    try {\n+      String uniqueReqIdForAllRetries = UUID.randomUUID().toString();\n+      Duration duration = Duration.newBuilder().setSeconds(validitySeconds).build();\n+      KeyPair keyPair = generateKeyPair();\n+      String csr = generateCsr(keyPair);\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub =\n+          createStubToMeshCa(channel);\n+      List<X509Certificate> x509Chain = makeRequestWithRetries(stub, uniqueReqIdForAllRetries,\n+          duration, csr);\n+      if (x509Chain != null) {\n+        refreshDelaySeconds =\n+            computeDelaySecondsToCertExpiry(x509Chain.get(0)) - renewalGracePeriodSeconds;\n+        getWatcher().updateCertificate(keyPair.getPrivate(), x509Chain);\n+        getWatcher().updateTrustedRoots(ImmutableList.of(x509Chain.get(x509Chain.size() - 1)));\n+      }\n+    } finally {\n+      shutdownChannel(channel);\n+      scheduleNextRefreshCertificate(refreshDelaySeconds);\n+    }\n+  }\n+\n+  private MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub createStubToMeshCa(\n+      ManagedChannel channel) {\n+    return MeshCertificateServiceGrpc\n+        .newBlockingStub(channel)\n+        .withCallCredentials(MoreCallCredentials.from(oauth2Creds))\n+        .withInterceptors(headerInterceptor);\n+  }\n+\n+  private List<X509Certificate> makeRequestWithRetries(\n+      MeshCertificateServiceGrpc.MeshCertificateServiceBlockingStub stub,\n+      String reqId,\n+      Duration duration,\n+      String csr) {\n+    Meshca.MeshCertificateRequest request =\n+        Meshca.MeshCertificateRequest.newBuilder()\n+            .setValidity(duration)\n+            .setCsr(csr)\n+            .setRequestId(reqId)\n+            .build();\n+\n+    BackoffPolicy backoffPolicy = backoffPolicyProvider.get();\n+    Throwable lastException = null;\n+    for (int i = 0; i <= maxRetryAttempts; i++) {\n+      try {\n+        Meshca.MeshCertificateResponse response =\n+            stub.withDeadlineAfter(rpcTimeoutMillis, TimeUnit.MILLISECONDS)\n+                .createCertificate(request);\n+        return getX509CertificatesFromResponse(response);\n+      } catch (Throwable t) {\n+        if (!retriable(t)) {\n+          generateErrorIfCurrentCertExpired(t);\n+          return null;\n+        }\n+        lastException = t;\n+        sleepForNanos(backoffPolicy.nextBackoffNanos());\n+      }\n+    }\n+    generateErrorIfCurrentCertExpired(lastException);\n+    return null;\n+  }\n+\n+  private void sleepForNanos(long nanos) {\n+    ScheduledFuture<?> future = scheduledExecutorService.schedule(new Runnable() {\n+      @Override\n+      public void run() {\n+        // do nothing\n+      }\n+    }, nanos, TimeUnit.NANOSECONDS);\n+    try {\n+      future.get(nanos, TimeUnit.NANOSECONDS);\n+    } catch (InterruptedException ie) {\n+      logger.log(Level.SEVERE, \"Inside sleep\", ie);\n+      Thread.currentThread().interrupt();\n+    } catch (ExecutionException | TimeoutException ex) {\n+      logger.log(Level.SEVERE, \"Inside sleep\", ex);\n+    }\n+  }\n+\n+  private static boolean retriable(Throwable t) {\n+    if (t instanceof StatusRuntimeException) {\n+      return retriable(((StatusRuntimeException) t).getStatus());\n+    } else if (t.getCause() instanceof StatusRuntimeException) {\n+      return retriable(((StatusRuntimeException) t.getCause()).getStatus());\n+    }\n+    return false;\n+  }\n+\n+  private static boolean retriable(Status status) {\n+    return RETRIABLE_CODES.contains(status.getCode());\n+  }\n+\n+  private void generateErrorIfCurrentCertExpired(Throwable t) {\n+    X509Certificate currentCert = getWatcher().getLastIdentityCert();\n+    if (currentCert != null) {\n+      long delaySeconds = computeDelaySecondsToCertExpiry(currentCert);\n+      if (delaySeconds > INITIAL_DELAY_SECONDS) {\n+        return;\n+      }\n+      getWatcher().clearValues();\n+    }\n+    getWatcher().onError(Status.fromThrowable(t));\n+  }\n+\n+  private KeyPair generateKeyPair() throws NoSuchAlgorithmException {\n+    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(alg);\n+    keyPairGenerator.initialize(keySize);\n+    return keyPairGenerator.generateKeyPair();\n+  }\n+\n+  private String generateCsr(KeyPair pair) throws IOException, OperatorCreationException {\n+    PKCS10CertificationRequestBuilder p10Builder =\n+        new JcaPKCS10CertificationRequestBuilder(\n+            new X500Principal(\"CN=EXAMPLE.COM\"), pair.getPublic());\n+    JcaContentSignerBuilder csBuilder = new JcaContentSignerBuilder(signatureAlg);\n+    ContentSigner signer = csBuilder.build(pair.getPrivate());\n+    PKCS10CertificationRequest csr = p10Builder.build(signer);\n+    PemObject pemObject = new PemObject(\"NEW CERTIFICATE REQUEST\", csr.getEncoded());\n+    StringWriter str = new StringWriter();\n+    JcaPEMWriter pemWriter = new JcaPEMWriter(str);\n+    pemWriter.writeObject(pemObject);\n+    pemWriter.close();\n+    str.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e750e12e6513d286b63525ea295d6402b29461b"}, "originalPosition": 296}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "648338305428b51a8055a1589cfb7200866d78c5", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/648338305428b51a8055a1589cfb7200866d78c5", "committedDate": "2020-08-07T05:59:28Z", "message": "address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3550d5af09ae2dc8d9e3749e946f0b6988b766b", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/e3550d5af09ae2dc8d9e3749e946f0b6988b766b", "committedDate": "2020-08-07T06:03:39Z", "message": "white space fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "021a0edfe33bd3abd467a4c45c6d5cd2e8814471", "author": {"user": {"login": "sanjaypujare", "name": null}}, "url": "https://github.com/grpc/grpc-java/commit/021a0edfe33bd3abd467a4c45c6d5cd2e8814471", "committedDate": "2020-08-07T06:27:59Z", "message": "misc fixes/format issues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNjcwMjgz", "url": "https://github.com/grpc/grpc-java/pull/7274#pullrequestreview-463670283", "createdAt": "2020-08-07T22:25:31Z", "commit": {"oid": "021a0edfe33bd3abd467a4c45c6d5cd2e8814471"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMjoyNTozMVrOG9qcag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMjoyNjo0NlrOG9qdlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMTcyMg==", "bodyText": "Why not just implement an extension of GoogleCredentials(it has a public and a protected constructor) and override refreshAccessToken()", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r467311722", "createdAt": "2020-08-07T22:25:31Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProviderTest.java", "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_PEM_FILE;\n+import static org.mockito.AdditionalAnswers.delegatesTo;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.auth.http.AuthHttpConstants;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.Context;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+import io.grpc.ServerCallHandler;\n+import io.grpc.ServerInterceptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.inprocess.InProcessChannelBuilder;\n+import io.grpc.inprocess.InProcessServerBuilder;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.DistributorWatcher;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import java.io.IOException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayDeque;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+/** Unit tests for {@link MeshCaCertificateProvider}. */\n+@RunWith(JUnit4.class)\n+public class MeshCaCertificateProviderTest {\n+\n+  private static final String TEST_STS_TOKEN = \"test-stsToken\";\n+  private static final long RENEWAL_GRACE_PERIOD_SECONDS = TimeUnit.HOURS.toSeconds(1L);\n+  private static final Metadata.Key<String> KEY_FOR_AUTHORIZATION =\n+      Metadata.Key.of(AuthHttpConstants.AUTHORIZATION, Metadata.ASCII_STRING_MARSHALLER);\n+  private static final String ZONE = \"us-west2-a\";\n+  private static final long START_DELAY = 200_000_000L;  // 0.2 seconds\n+  private static final long[] DELAY_VALUES = {START_DELAY, START_DELAY * 2, START_DELAY * 4};\n+  private static final long RPC_TIMEOUT_MILLIS = 100L;\n+  /**\n+   * Expire time of cert SERVER_0_PEM_FILE.\n+   */\n+  private static final long CERT0_EXPIRY_TIME_MILLIS = 1899853658000L;\n+  /**\n+   * Cert validity of 12 hours for the above cert.\n+   */\n+  private static final long CERT0_VALIDITY_MILLIS = TimeUnit.MILLISECONDS\n+      .convert(12, TimeUnit.HOURS);\n+  /**\n+   * Compute current time based on cert expiry and cert validity.\n+   */\n+  private static final long CURRENT_TIME_NANOS =\n+      TimeUnit.MILLISECONDS.toNanos(CERT0_EXPIRY_TIME_MILLIS - CERT0_VALIDITY_MILLIS);\n+  @Rule\n+  public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+\n+  private static class ResponseToSend {\n+    Throwable getThrowable() {\n+      throw new UnsupportedOperationException(\"Called on \" + getClass().getCanonicalName());\n+    }\n+\n+    List<String> getList() {\n+      throw new UnsupportedOperationException(\"Called on \" + getClass().getCanonicalName());\n+    }\n+  }\n+\n+  private static class ResponseThrowable extends ResponseToSend {\n+    final Throwable throwableToSend;\n+\n+    ResponseThrowable(Throwable throwable) {\n+      throwableToSend = throwable;\n+    }\n+\n+    @Override\n+    Throwable getThrowable() {\n+      return throwableToSend;\n+    }\n+  }\n+\n+  private static class ResponseList extends ResponseToSend {\n+    final List<String> listToSend;\n+\n+    ResponseList(List<String> list) {\n+      listToSend = list;\n+    }\n+\n+    @Override\n+    List<String> getList() {\n+      return listToSend;\n+    }\n+  }\n+\n+  private final Queue<Meshca.MeshCertificateRequest> receivedRequests = new ArrayDeque<>();\n+  private final Queue<String> receivedStsCreds = new ArrayDeque<>();\n+  private final Queue<String> receivedZoneValues = new ArrayDeque<>();\n+  private final Queue<ResponseToSend> responsesToSend = new ArrayDeque<>();\n+  private final Queue<String> oauth2Tokens = new ArrayDeque<>();\n+  private final AtomicBoolean callEnded = new AtomicBoolean(true);\n+\n+  @Mock private MeshCertificateServiceGrpc.MeshCertificateServiceImplBase mockedMeshCaService;\n+  @Mock private CertificateProvider.Watcher mockWatcher;\n+  @Mock private BackoffPolicy.Provider backoffPolicyProvider;\n+  @Mock private BackoffPolicy backoffPolicy;\n+  @Spy private GoogleCredentials oauth2Creds;\n+  @Mock private ScheduledExecutorService timeService;\n+  @Mock private TimeProvider timeProvider;\n+\n+  private ManagedChannel channel;\n+  private MeshCaCertificateProvider provider;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+    when(backoffPolicyProvider.get()).thenReturn(backoffPolicy);\n+    when(backoffPolicy.nextBackoffNanos())\n+        .thenReturn(DELAY_VALUES[0], DELAY_VALUES[1], DELAY_VALUES[2]);\n+    doAnswer(\n+        new Answer<AccessToken>() {\n+          @Override\n+          public AccessToken answer(InvocationOnMock invocation) throws Throwable {\n+            return new AccessToken(\n+                oauth2Tokens.poll(), new Date(System.currentTimeMillis() + 1000L));\n+          }\n+        })\n+        .when(oauth2Creds)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "021a0edfe33bd3abd467a4c45c6d5cd2e8814471"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMxMjAyMg==", "bodyText": "nit/optional: you can implement real ones instead of mocks. Might be more readable. But I'm also okay with as-is.", "url": "https://github.com/grpc/grpc-java/pull/7274#discussion_r467312022", "createdAt": "2020-08-07T22:26:46Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/internal/certprovider/MeshCaCertificateProviderTest.java", "diffHunk": "@@ -0,0 +1,538 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds.internal.certprovider;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.CA_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_0_PEM_FILE;\n+import static io.grpc.xds.internal.sds.CommonTlsContextTestsUtil.SERVER_1_PEM_FILE;\n+import static org.mockito.AdditionalAnswers.delegatesTo;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.reset;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.auth.http.AuthHttpConstants;\n+import com.google.auth.oauth2.AccessToken;\n+import com.google.auth.oauth2.GoogleCredentials;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.util.concurrent.MoreExecutors;\n+import google.security.meshca.v1.MeshCertificateServiceGrpc;\n+import google.security.meshca.v1.Meshca;\n+import io.grpc.Context;\n+import io.grpc.ManagedChannel;\n+import io.grpc.Metadata;\n+import io.grpc.ServerCall;\n+import io.grpc.ServerCallHandler;\n+import io.grpc.ServerInterceptor;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.inprocess.InProcessChannelBuilder;\n+import io.grpc.inprocess.InProcessServerBuilder;\n+import io.grpc.internal.BackoffPolicy;\n+import io.grpc.internal.TimeProvider;\n+import io.grpc.testing.GrpcCleanupRule;\n+import io.grpc.xds.internal.certprovider.CertificateProvider.DistributorWatcher;\n+import io.grpc.xds.internal.sds.CommonTlsContextTestsUtil;\n+import java.io.IOException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayDeque;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.bouncycastle.operator.OperatorCreationException;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import org.mockito.Spy;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+\n+/** Unit tests for {@link MeshCaCertificateProvider}. */\n+@RunWith(JUnit4.class)\n+public class MeshCaCertificateProviderTest {\n+\n+  private static final String TEST_STS_TOKEN = \"test-stsToken\";\n+  private static final long RENEWAL_GRACE_PERIOD_SECONDS = TimeUnit.HOURS.toSeconds(1L);\n+  private static final Metadata.Key<String> KEY_FOR_AUTHORIZATION =\n+      Metadata.Key.of(AuthHttpConstants.AUTHORIZATION, Metadata.ASCII_STRING_MARSHALLER);\n+  private static final String ZONE = \"us-west2-a\";\n+  private static final long START_DELAY = 200_000_000L;  // 0.2 seconds\n+  private static final long[] DELAY_VALUES = {START_DELAY, START_DELAY * 2, START_DELAY * 4};\n+  private static final long RPC_TIMEOUT_MILLIS = 100L;\n+  /**\n+   * Expire time of cert SERVER_0_PEM_FILE.\n+   */\n+  private static final long CERT0_EXPIRY_TIME_MILLIS = 1899853658000L;\n+  /**\n+   * Cert validity of 12 hours for the above cert.\n+   */\n+  private static final long CERT0_VALIDITY_MILLIS = TimeUnit.MILLISECONDS\n+      .convert(12, TimeUnit.HOURS);\n+  /**\n+   * Compute current time based on cert expiry and cert validity.\n+   */\n+  private static final long CURRENT_TIME_NANOS =\n+      TimeUnit.MILLISECONDS.toNanos(CERT0_EXPIRY_TIME_MILLIS - CERT0_VALIDITY_MILLIS);\n+  @Rule\n+  public final GrpcCleanupRule cleanupRule = new GrpcCleanupRule();\n+\n+  private static class ResponseToSend {\n+    Throwable getThrowable() {\n+      throw new UnsupportedOperationException(\"Called on \" + getClass().getCanonicalName());\n+    }\n+\n+    List<String> getList() {\n+      throw new UnsupportedOperationException(\"Called on \" + getClass().getCanonicalName());\n+    }\n+  }\n+\n+  private static class ResponseThrowable extends ResponseToSend {\n+    final Throwable throwableToSend;\n+\n+    ResponseThrowable(Throwable throwable) {\n+      throwableToSend = throwable;\n+    }\n+\n+    @Override\n+    Throwable getThrowable() {\n+      return throwableToSend;\n+    }\n+  }\n+\n+  private static class ResponseList extends ResponseToSend {\n+    final List<String> listToSend;\n+\n+    ResponseList(List<String> list) {\n+      listToSend = list;\n+    }\n+\n+    @Override\n+    List<String> getList() {\n+      return listToSend;\n+    }\n+  }\n+\n+  private final Queue<Meshca.MeshCertificateRequest> receivedRequests = new ArrayDeque<>();\n+  private final Queue<String> receivedStsCreds = new ArrayDeque<>();\n+  private final Queue<String> receivedZoneValues = new ArrayDeque<>();\n+  private final Queue<ResponseToSend> responsesToSend = new ArrayDeque<>();\n+  private final Queue<String> oauth2Tokens = new ArrayDeque<>();\n+  private final AtomicBoolean callEnded = new AtomicBoolean(true);\n+\n+  @Mock private MeshCertificateServiceGrpc.MeshCertificateServiceImplBase mockedMeshCaService;\n+  @Mock private CertificateProvider.Watcher mockWatcher;\n+  @Mock private BackoffPolicy.Provider backoffPolicyProvider;\n+  @Mock private BackoffPolicy backoffPolicy;\n+  @Spy private GoogleCredentials oauth2Creds;\n+  @Mock private ScheduledExecutorService timeService;\n+  @Mock private TimeProvider timeProvider;\n+\n+  private ManagedChannel channel;\n+  private MeshCaCertificateProvider provider;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    MockitoAnnotations.initMocks(this);\n+    when(backoffPolicyProvider.get()).thenReturn(backoffPolicy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "021a0edfe33bd3abd467a4c45c6d5cd2e8814471"}, "originalPosition": 173}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4135, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}