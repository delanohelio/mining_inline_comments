{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1MzI5NjM4", "number": 6944, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzoyMTozMFrODz1lBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzozNTowN1rODz17Yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjgxNzk5OnYy", "diffSide": "RIGHT", "path": "context/src/main/java/io/grpc/Context.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzoyMTozMFrOGIfTjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxOTowMDoyNlrOGIjI4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1NDcwMQ==", "bodyText": "Please revert these useless changes. This is just a style change, which just adds noise and can flip/flop each time a different person touches the code.", "url": "https://github.com/grpc/grpc-java/pull/6944#discussion_r411554701", "createdAt": "2020-04-20T17:21:30Z", "author": {"login": "ejona86"}, "path": "context/src/main/java/io/grpc/Context.java", "diffHunk": "@@ -459,9 +453,8 @@ boolean isCurrent() {\n   public boolean isCancelled() {\n     if (cancellableAncestor == null) {\n       return false;\n-    } else {\n-      return cancellableAncestor.isCancelled();\n     }\n+    return cancellableAncestor.isCancelled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d103226b84074212dc434e356209474e32e39b6"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYxNzUwNQ==", "bodyText": "Agreed, reverted, I did it mostly for consistency with other methods (but not important for this PR).", "url": "https://github.com/grpc/grpc-java/pull/6944#discussion_r411617505", "createdAt": "2020-04-20T19:00:26Z", "author": {"login": "bogdandrutu"}, "path": "context/src/main/java/io/grpc/Context.java", "diffHunk": "@@ -459,9 +453,8 @@ boolean isCurrent() {\n   public boolean isCancelled() {\n     if (cancellableAncestor == null) {\n       return false;\n-    } else {\n-      return cancellableAncestor.isCancelled();\n     }\n+    return cancellableAncestor.isCancelled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1NDcwMQ=="}, "originalCommit": {"oid": "5d103226b84074212dc434e356209474e32e39b6"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Njg3NTIzOnYy", "diffSide": "RIGHT", "path": "context/src/main/java/io/grpc/Context.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzozNTowN1rOGIf2Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxOToxODoxMlrOGIjxxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2MzU4Ng==", "bodyText": "This is broken. The same Listener could be used for multiple Contexts. It could then remove the Listener for the wrong Context.", "url": "https://github.com/grpc/grpc-java/pull/6944#discussion_r411563586", "createdAt": "2020-04-20T17:35:07Z", "author": {"login": "ejona86"}, "path": "context/src/main/java/io/grpc/Context.java", "diffHunk": "@@ -498,98 +490,30 @@ public void addListener(final CancellationListener cancellationListener,\n                           final Executor executor) {\n     checkNotNull(cancellationListener, \"cancellationListener\");\n     checkNotNull(executor, \"executor\");\n-    if (canBeCancelled()) {\n-      ExecutableListener executableListener =\n-          new ExecutableListener(executor, cancellationListener);\n-      synchronized (this) {\n-        if (isCancelled()) {\n-          executableListener.deliver();\n-        } else {\n-          if (listeners == null) {\n-            // Now that we have a listener we need to listen to our parent so\n-            // we can cascade listener notification.\n-            listeners = new ArrayList<>();\n-            listeners.add(executableListener);\n-            if (cancellableAncestor != null) {\n-              cancellableAncestor.addListener(parentListener, DirectExecutor.INSTANCE);\n-            }\n-          } else {\n-            listeners.add(executableListener);\n-          }\n-        }\n-      }\n+    if (cancellableAncestor == null) {\n+      return;\n     }\n+    cancellableAncestor.addListenerInternal(\n+        new ExecutableListener(executor, cancellationListener, this));\n   }\n \n   /**\n    * Remove a {@link CancellationListener}.\n    */\n   public void removeListener(CancellationListener cancellationListener) {\n-    if (!canBeCancelled()) {\n-      return;\n-    }\n-    synchronized (this) {\n-      if (listeners != null) {\n-        for (int i = listeners.size() - 1; i >= 0; i--) {\n-          if (listeners.get(i).listener == cancellationListener) {\n-            listeners.remove(i);\n-            // Just remove the first matching listener, given that we allow duplicate\n-            // adds we should allow for duplicates after remove.\n-            break;\n-          }\n-        }\n-        // We have no listeners so no need to listen to our parent\n-        if (listeners.isEmpty()) {\n-          if (cancellableAncestor != null) {\n-            cancellableAncestor.removeListener(parentListener);\n-          }\n-          listeners = null;\n-        }\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Notify all listeners that this context has been cancelled and immediately release\n-   * any reference to them so that they may be garbage collected.\n-   */\n-  void notifyAndClearListeners() {\n-    if (!canBeCancelled()) {\n+    if (cancellableAncestor == null) {\n       return;\n     }\n-    ArrayList<ExecutableListener> tmpListeners;\n-    synchronized (this) {\n-      if (listeners == null) {\n-        return;\n-      }\n-      tmpListeners = listeners;\n-      listeners = null;\n-    }\n-    // Deliver events to non-child context listeners before we notify child contexts. We do this\n-    // to cancel higher level units of work before child units. This allows for a better error\n-    // handling paradigm where the higher level unit of work knows it is cancelled and so can\n-    // ignore errors that bubble up as a result of cancellation of lower level units.\n-    for (int i = 0; i < tmpListeners.size(); i++) {\n-      if (!(tmpListeners.get(i).listener instanceof ParentListener)) {\n-        tmpListeners.get(i).deliver();\n-      }\n-    }\n-    for (int i = 0; i < tmpListeners.size(); i++) {\n-      if (tmpListeners.get(i).listener instanceof ParentListener) {\n-        tmpListeners.get(i).deliver();\n-      }\n-    }\n-    if (cancellableAncestor != null) {\n-      cancellableAncestor.removeListener(parentListener);\n-    }\n+    cancellableAncestor.removeListener(cancellationListener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d103226b84074212dc434e356209474e32e39b6"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyNzk3NA==", "bodyText": "Good catch, added test to confirm it works.", "url": "https://github.com/grpc/grpc-java/pull/6944#discussion_r411627974", "createdAt": "2020-04-20T19:18:12Z", "author": {"login": "bogdandrutu"}, "path": "context/src/main/java/io/grpc/Context.java", "diffHunk": "@@ -498,98 +490,30 @@ public void addListener(final CancellationListener cancellationListener,\n                           final Executor executor) {\n     checkNotNull(cancellationListener, \"cancellationListener\");\n     checkNotNull(executor, \"executor\");\n-    if (canBeCancelled()) {\n-      ExecutableListener executableListener =\n-          new ExecutableListener(executor, cancellationListener);\n-      synchronized (this) {\n-        if (isCancelled()) {\n-          executableListener.deliver();\n-        } else {\n-          if (listeners == null) {\n-            // Now that we have a listener we need to listen to our parent so\n-            // we can cascade listener notification.\n-            listeners = new ArrayList<>();\n-            listeners.add(executableListener);\n-            if (cancellableAncestor != null) {\n-              cancellableAncestor.addListener(parentListener, DirectExecutor.INSTANCE);\n-            }\n-          } else {\n-            listeners.add(executableListener);\n-          }\n-        }\n-      }\n+    if (cancellableAncestor == null) {\n+      return;\n     }\n+    cancellableAncestor.addListenerInternal(\n+        new ExecutableListener(executor, cancellationListener, this));\n   }\n \n   /**\n    * Remove a {@link CancellationListener}.\n    */\n   public void removeListener(CancellationListener cancellationListener) {\n-    if (!canBeCancelled()) {\n-      return;\n-    }\n-    synchronized (this) {\n-      if (listeners != null) {\n-        for (int i = listeners.size() - 1; i >= 0; i--) {\n-          if (listeners.get(i).listener == cancellationListener) {\n-            listeners.remove(i);\n-            // Just remove the first matching listener, given that we allow duplicate\n-            // adds we should allow for duplicates after remove.\n-            break;\n-          }\n-        }\n-        // We have no listeners so no need to listen to our parent\n-        if (listeners.isEmpty()) {\n-          if (cancellableAncestor != null) {\n-            cancellableAncestor.removeListener(parentListener);\n-          }\n-          listeners = null;\n-        }\n-      }\n-    }\n-  }\n-\n-  /**\n-   * Notify all listeners that this context has been cancelled and immediately release\n-   * any reference to them so that they may be garbage collected.\n-   */\n-  void notifyAndClearListeners() {\n-    if (!canBeCancelled()) {\n+    if (cancellableAncestor == null) {\n       return;\n     }\n-    ArrayList<ExecutableListener> tmpListeners;\n-    synchronized (this) {\n-      if (listeners == null) {\n-        return;\n-      }\n-      tmpListeners = listeners;\n-      listeners = null;\n-    }\n-    // Deliver events to non-child context listeners before we notify child contexts. We do this\n-    // to cancel higher level units of work before child units. This allows for a better error\n-    // handling paradigm where the higher level unit of work knows it is cancelled and so can\n-    // ignore errors that bubble up as a result of cancellation of lower level units.\n-    for (int i = 0; i < tmpListeners.size(); i++) {\n-      if (!(tmpListeners.get(i).listener instanceof ParentListener)) {\n-        tmpListeners.get(i).deliver();\n-      }\n-    }\n-    for (int i = 0; i < tmpListeners.size(); i++) {\n-      if (tmpListeners.get(i).listener instanceof ParentListener) {\n-        tmpListeners.get(i).deliver();\n-      }\n-    }\n-    if (cancellableAncestor != null) {\n-      cancellableAncestor.removeListener(parentListener);\n-    }\n+    cancellableAncestor.removeListener(cancellationListener);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2MzU4Ng=="}, "originalCommit": {"oid": "5d103226b84074212dc434e356209474e32e39b6"}, "originalPosition": 135}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2805, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}