{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2ODg3OTQz", "number": 7031, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMzoxNTozMVrOD722gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMDowNjoyNFrOD9C3Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDkxMjY0OnYy", "diffSide": "LEFT", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMzoxNTozMVrOGUcL2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMzoxNTozMVrOGUcL2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NjQ4OQ==", "bodyText": "Justification: a valid Route should always have a valid matcher and a valid action.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r424086489", "createdAt": "2020-05-12T23:15:31Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -342,7 +425,6 @@ public String toString() {\n   /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.Route}. */\n   static final class Route {\n     private final RouteMatch routeMatch;\n-    @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed0415c7004a91bd787b7fadbfbc8605cf57649d"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MDkxNzYwOnYy", "diffSide": "LEFT", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQyMzoxODoxNlrOGUcPAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwMDowNjoxMFrOGUdHKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NzI5OQ==", "bodyText": "Justification: use null for unset values as in proto only one of prefix, path, regex can be set. It is ambiguous for converted objects to use \"\" for unset fields given that \"\" itself can be a set value.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r424087299", "createdAt": "2020-05-12T23:18:16Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -386,55 +471,98 @@ public String toString() {\n           .toString();\n     }\n \n-    static Route fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n-      RouteMatch routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n-      RouteAction routeAction = null;\n-      if (proto.hasRoute()) {\n-        routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+    @Nullable\n+    static StructOrError<Route> fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n+      StructOrError<RouteMatch> routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n+      if (routeMatch == null) {\n+        return null;\n+      }\n+      if (routeMatch.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeMatch.getErrorDetail());\n+      }\n+\n+      StructOrError<RouteAction> routeAction;\n+      switch (proto.getActionCase()) {\n+        case ROUTE:\n+          routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+          break;\n+        case REDIRECT:\n+          return StructOrError.fromError(\"Unsupported action type: redirect\");\n+        case DIRECT_RESPONSE:\n+          return StructOrError.fromError(\"Unsupported action type: direct_response\");\n+        case FILTER_ACTION:\n+          return StructOrError.fromError(\"Unsupported action type: filter_action\");\n+        case ACTION_NOT_SET:\n+          // fall through\n+        default:\n+          return StructOrError.fromError(\"Unknown action type: \" + proto.getActionCase());\n       }\n-      return new Route(routeMatch, routeAction);\n+      if (routeAction.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeAction.getErrorDetail());\n+      }\n+      return StructOrError.fromStruct(new Route(routeMatch.getStruct(), routeAction.getStruct()));\n     }\n   }\n \n   /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.RouteMatch}. */\n   static final class RouteMatch {\n-    private final String prefix;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed0415c7004a91bd787b7fadbfbc8605cf57649d"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5Njg4NQ==", "bodyText": "\"\" is ambiguous anyway. If someone sets a nonempty value and then sets it to empty value, they probably mean to unset it.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r424096885", "createdAt": "2020-05-12T23:48:49Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -386,55 +471,98 @@ public String toString() {\n           .toString();\n     }\n \n-    static Route fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n-      RouteMatch routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n-      RouteAction routeAction = null;\n-      if (proto.hasRoute()) {\n-        routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+    @Nullable\n+    static StructOrError<Route> fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n+      StructOrError<RouteMatch> routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n+      if (routeMatch == null) {\n+        return null;\n+      }\n+      if (routeMatch.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeMatch.getErrorDetail());\n+      }\n+\n+      StructOrError<RouteAction> routeAction;\n+      switch (proto.getActionCase()) {\n+        case ROUTE:\n+          routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+          break;\n+        case REDIRECT:\n+          return StructOrError.fromError(\"Unsupported action type: redirect\");\n+        case DIRECT_RESPONSE:\n+          return StructOrError.fromError(\"Unsupported action type: direct_response\");\n+        case FILTER_ACTION:\n+          return StructOrError.fromError(\"Unsupported action type: filter_action\");\n+        case ACTION_NOT_SET:\n+          // fall through\n+        default:\n+          return StructOrError.fromError(\"Unknown action type: \" + proto.getActionCase());\n       }\n-      return new Route(routeMatch, routeAction);\n+      if (routeAction.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeAction.getErrorDetail());\n+      }\n+      return StructOrError.fromStruct(new Route(routeMatch.getStruct(), routeAction.getStruct()));\n     }\n   }\n \n   /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.RouteMatch}. */\n   static final class RouteMatch {\n-    private final String prefix;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NzI5OQ=="}, "originalCommit": {"oid": "ed0415c7004a91bd787b7fadbfbc8605cf57649d"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5ODg4OA==", "bodyText": "That's why I changed to use null if the corresponding filed in the proto is unset.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r424098888", "createdAt": "2020-05-12T23:55:47Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -386,55 +471,98 @@ public String toString() {\n           .toString();\n     }\n \n-    static Route fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n-      RouteMatch routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n-      RouteAction routeAction = null;\n-      if (proto.hasRoute()) {\n-        routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+    @Nullable\n+    static StructOrError<Route> fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n+      StructOrError<RouteMatch> routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n+      if (routeMatch == null) {\n+        return null;\n+      }\n+      if (routeMatch.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeMatch.getErrorDetail());\n+      }\n+\n+      StructOrError<RouteAction> routeAction;\n+      switch (proto.getActionCase()) {\n+        case ROUTE:\n+          routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+          break;\n+        case REDIRECT:\n+          return StructOrError.fromError(\"Unsupported action type: redirect\");\n+        case DIRECT_RESPONSE:\n+          return StructOrError.fromError(\"Unsupported action type: direct_response\");\n+        case FILTER_ACTION:\n+          return StructOrError.fromError(\"Unsupported action type: filter_action\");\n+        case ACTION_NOT_SET:\n+          // fall through\n+        default:\n+          return StructOrError.fromError(\"Unknown action type: \" + proto.getActionCase());\n       }\n-      return new Route(routeMatch, routeAction);\n+      if (routeAction.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeAction.getErrorDetail());\n+      }\n+      return StructOrError.fromStruct(new Route(routeMatch.getStruct(), routeAction.getStruct()));\n     }\n   }\n \n   /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.RouteMatch}. */\n   static final class RouteMatch {\n-    private final String prefix;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NzI5OQ=="}, "originalCommit": {"oid": "ed0415c7004a91bd787b7fadbfbc8605cf57649d"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEwMDY0OA==", "bodyText": "Sorry I replied to the wrong thread, I thought this was a comment about the environment variable in another PR", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r424100648", "createdAt": "2020-05-13T00:02:11Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -386,55 +471,98 @@ public String toString() {\n           .toString();\n     }\n \n-    static Route fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n-      RouteMatch routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n-      RouteAction routeAction = null;\n-      if (proto.hasRoute()) {\n-        routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+    @Nullable\n+    static StructOrError<Route> fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n+      StructOrError<RouteMatch> routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n+      if (routeMatch == null) {\n+        return null;\n+      }\n+      if (routeMatch.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeMatch.getErrorDetail());\n+      }\n+\n+      StructOrError<RouteAction> routeAction;\n+      switch (proto.getActionCase()) {\n+        case ROUTE:\n+          routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+          break;\n+        case REDIRECT:\n+          return StructOrError.fromError(\"Unsupported action type: redirect\");\n+        case DIRECT_RESPONSE:\n+          return StructOrError.fromError(\"Unsupported action type: direct_response\");\n+        case FILTER_ACTION:\n+          return StructOrError.fromError(\"Unsupported action type: filter_action\");\n+        case ACTION_NOT_SET:\n+          // fall through\n+        default:\n+          return StructOrError.fromError(\"Unknown action type: \" + proto.getActionCase());\n       }\n-      return new Route(routeMatch, routeAction);\n+      if (routeAction.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeAction.getErrorDetail());\n+      }\n+      return StructOrError.fromStruct(new Route(routeMatch.getStruct(), routeAction.getStruct()));\n     }\n   }\n \n   /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.RouteMatch}. */\n   static final class RouteMatch {\n-    private final String prefix;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NzI5OQ=="}, "originalCommit": {"oid": "ed0415c7004a91bd787b7fadbfbc8605cf57649d"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEwMTY3NA==", "bodyText": "Ok, for that. You do not need to consider that much. Out implementation should be based on normal usage and is not intended to be failsafe in terms of undocumented usage.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r424101674", "createdAt": "2020-05-13T00:06:10Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -386,55 +471,98 @@ public String toString() {\n           .toString();\n     }\n \n-    static Route fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n-      RouteMatch routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n-      RouteAction routeAction = null;\n-      if (proto.hasRoute()) {\n-        routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+    @Nullable\n+    static StructOrError<Route> fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n+      StructOrError<RouteMatch> routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n+      if (routeMatch == null) {\n+        return null;\n+      }\n+      if (routeMatch.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeMatch.getErrorDetail());\n+      }\n+\n+      StructOrError<RouteAction> routeAction;\n+      switch (proto.getActionCase()) {\n+        case ROUTE:\n+          routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+          break;\n+        case REDIRECT:\n+          return StructOrError.fromError(\"Unsupported action type: redirect\");\n+        case DIRECT_RESPONSE:\n+          return StructOrError.fromError(\"Unsupported action type: direct_response\");\n+        case FILTER_ACTION:\n+          return StructOrError.fromError(\"Unsupported action type: filter_action\");\n+        case ACTION_NOT_SET:\n+          // fall through\n+        default:\n+          return StructOrError.fromError(\"Unknown action type: \" + proto.getActionCase());\n       }\n-      return new Route(routeMatch, routeAction);\n+      if (routeAction.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeAction.getErrorDetail());\n+      }\n+      return StructOrError.fromStruct(new Route(routeMatch.getStruct(), routeAction.getStruct()));\n     }\n   }\n \n   /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.RouteMatch}. */\n   static final class RouteMatch {\n-    private final String prefix;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NzI5OQ=="}, "originalCommit": {"oid": "ed0415c7004a91bd787b7fadbfbc8605cf57649d"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjMwMTcwOnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNjo0NDoyMFrOGWMT3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMzo1NDoyNVrOGWWmcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyMzU1MQ==", "bodyText": "s/\"] : \"/\"]: \"", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r425923551", "createdAt": "2020-05-15T16:44:20Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -386,55 +471,98 @@ public String toString() {\n           .toString();\n     }\n \n-    static Route fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n-      RouteMatch routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n-      RouteAction routeAction = null;\n-      if (proto.hasRoute()) {\n-        routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+    @Nullable\n+    static StructOrError<Route> fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n+      StructOrError<RouteMatch> routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n+      if (routeMatch == null) {\n+        return null;\n+      }\n+      if (routeMatch.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeMatch.getErrorDetail());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3dd2b6ed6a298fc9c73383c399b3fedb0585f83"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5MjE0NQ==", "bodyText": "Done. Not a big issue, I may use that pattern previously somewhere else. But I changed to \"]: \" as you prefer for changes made in this PR.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426092145", "createdAt": "2020-05-15T23:54:25Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -386,55 +471,98 @@ public String toString() {\n           .toString();\n     }\n \n-    static Route fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n-      RouteMatch routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n-      RouteAction routeAction = null;\n-      if (proto.hasRoute()) {\n-        routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+    @Nullable\n+    static StructOrError<Route> fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n+      StructOrError<RouteMatch> routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n+      if (routeMatch == null) {\n+        return null;\n+      }\n+      if (routeMatch.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeMatch.getErrorDetail());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyMzU1MQ=="}, "originalCommit": {"oid": "d3dd2b6ed6a298fc9c73383c399b3fedb0585f83"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjMwMzkwOnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxNjo0NDo1N1rOGWMVNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMzo1NDozMFrOGWWmgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyMzg5NQ==", "bodyText": "Comment not necessary. The code explains itself. For google java style, this special comment is not required in the last statement group of the switch block.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r425923895", "createdAt": "2020-05-15T16:44:57Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -386,55 +471,98 @@ public String toString() {\n           .toString();\n     }\n \n-    static Route fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n-      RouteMatch routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n-      RouteAction routeAction = null;\n-      if (proto.hasRoute()) {\n-        routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+    @Nullable\n+    static StructOrError<Route> fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n+      StructOrError<RouteMatch> routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n+      if (routeMatch == null) {\n+        return null;\n+      }\n+      if (routeMatch.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeMatch.getErrorDetail());\n+      }\n+\n+      StructOrError<RouteAction> routeAction;\n+      switch (proto.getActionCase()) {\n+        case ROUTE:\n+          routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+          break;\n+        case REDIRECT:\n+          return StructOrError.fromError(\"Unsupported action type: redirect\");\n+        case DIRECT_RESPONSE:\n+          return StructOrError.fromError(\"Unsupported action type: direct_response\");\n+        case FILTER_ACTION:\n+          return StructOrError.fromError(\"Unsupported action type: filter_action\");\n+        case ACTION_NOT_SET:\n+          // fall through", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3dd2b6ed6a298fc9c73383c399b3fedb0585f83"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5MjE2Mg==", "bodyText": "Done.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426092162", "createdAt": "2020-05-15T23:54:30Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -386,55 +471,98 @@ public String toString() {\n           .toString();\n     }\n \n-    static Route fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n-      RouteMatch routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n-      RouteAction routeAction = null;\n-      if (proto.hasRoute()) {\n-        routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+    @Nullable\n+    static StructOrError<Route> fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n+      StructOrError<RouteMatch> routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n+      if (routeMatch == null) {\n+        return null;\n+      }\n+      if (routeMatch.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeMatch.getErrorDetail());\n+      }\n+\n+      StructOrError<RouteAction> routeAction;\n+      switch (proto.getActionCase()) {\n+        case ROUTE:\n+          routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+          break;\n+        case REDIRECT:\n+          return StructOrError.fromError(\"Unsupported action type: redirect\");\n+        case DIRECT_RESPONSE:\n+          return StructOrError.fromError(\"Unsupported action type: direct_response\");\n+        case FILTER_ACTION:\n+          return StructOrError.fromError(\"Unsupported action type: filter_action\");\n+        case ACTION_NOT_SET:\n+          // fall through", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyMzg5NQ=="}, "originalCommit": {"oid": "d3dd2b6ed6a298fc9c73383c399b3fedb0585f83"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1Mjg2NzA1OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxOTo1MTozMlrOGWR7PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMzo1NjowMVrOGWWngw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxNTU0OQ==", "bodyText": "It shouldn't.  The above is the only case for default matcher. It's not practical to check if a regex can match all.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426015549", "createdAt": "2020-05-15T19:51:32Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -386,55 +471,98 @@ public String toString() {\n           .toString();\n     }\n \n-    static Route fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n-      RouteMatch routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n-      RouteAction routeAction = null;\n-      if (proto.hasRoute()) {\n-        routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+    @Nullable\n+    static StructOrError<Route> fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n+      StructOrError<RouteMatch> routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n+      if (routeMatch == null) {\n+        return null;\n+      }\n+      if (routeMatch.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeMatch.getErrorDetail());\n+      }\n+\n+      StructOrError<RouteAction> routeAction;\n+      switch (proto.getActionCase()) {\n+        case ROUTE:\n+          routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+          break;\n+        case REDIRECT:\n+          return StructOrError.fromError(\"Unsupported action type: redirect\");\n+        case DIRECT_RESPONSE:\n+          return StructOrError.fromError(\"Unsupported action type: direct_response\");\n+        case FILTER_ACTION:\n+          return StructOrError.fromError(\"Unsupported action type: filter_action\");\n+        case ACTION_NOT_SET:\n+          // fall through\n+        default:\n+          return StructOrError.fromError(\"Unknown action type: \" + proto.getActionCase());\n       }\n-      return new Route(routeMatch, routeAction);\n+      if (routeAction.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeAction.getErrorDetail());\n+      }\n+      return StructOrError.fromStruct(new Route(routeMatch.getStruct(), routeAction.getStruct()));\n     }\n   }\n \n   /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.RouteMatch}. */\n   static final class RouteMatch {\n-    private final String prefix;\n-    private final String path;\n-    private final boolean hasRegex;\n-    private final boolean caseSensitive;\n-\n-    @VisibleForTesting\n-    RouteMatch(String prefix, String path, boolean hasRegex, boolean caseSensitive) {\n-      this.prefix = prefix;\n-      this.path = path;\n-      this.hasRegex = hasRegex;\n-      this.caseSensitive = caseSensitive;\n-    }\n+    // Exactly one of the following fields is non-null.\n+    @Nullable\n+    private final String pathPrefixMatch;\n+    @Nullable\n+    private final String pathExactMatch;\n+    @Nullable\n+    private final String pathSafeRegExMatch;\n \n-    String getPrefix() {\n-      return prefix;\n-    }\n+    private final List<HeaderMatcher> headerMatchers;\n+    @Nullable\n+    private final Fraction fractionMatch;\n \n-    String getPath() {\n-      return path;\n+    @VisibleForTesting\n+    RouteMatch(\n+        @Nullable String pathPrefixMatch, @Nullable String pathExactMatch,\n+        @Nullable String pathSafeRegExMatch, @Nullable Fraction fractionMatch,\n+        List<HeaderMatcher> headerMatchers) {\n+      this.pathPrefixMatch = pathPrefixMatch;\n+      this.pathExactMatch = pathExactMatch;\n+      this.pathSafeRegExMatch = pathSafeRegExMatch;\n+      this.fractionMatch = fractionMatch;\n+      this.headerMatchers = headerMatchers;\n+    }\n+\n+    RouteMatch(@Nullable String pathPrefixMatch, @Nullable String pathExactMatch) {\n+      this(\n+          pathPrefixMatch, pathExactMatch, null, null,\n+          Collections.<HeaderMatcher>emptyList());\n     }\n \n-    boolean hasRegex() {\n-      return hasRegex;\n+    @Nullable\n+    String getPathPrefixMatch() {\n+      return pathPrefixMatch;\n     }\n \n-    boolean isCaseSensitive() {\n-      return caseSensitive;\n+    @Nullable\n+    String getPathExactMatch() {\n+      return pathExactMatch;\n     }\n \n-    boolean isDefaultMatcher() {\n-      if (hasRegex) {\n+    boolean isMatchAll() {\n+      if (pathSafeRegExMatch != null || fractionMatch != null) {\n         return false;\n       }\n-      if (!path.isEmpty()) {\n+      if (headerMatchers != null && !headerMatchers.isEmpty()) {\n         return false;\n       }\n-      return prefix.isEmpty() || prefix.equals(\"/\");\n+      if (pathExactMatch != null) {\n+        return pathExactMatch.isEmpty();\n+      }\n+      if (pathPrefixMatch != null) {\n+        return pathPrefixMatch.isEmpty() || pathPrefixMatch.equals(\"/\");\n+      }\n+      // TODO (chengyuanzhang): can path match with regex be a default route?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3dd2b6ed6a298fc9c73383c399b3fedb0585f83"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5MjQxOQ==", "bodyText": "Done.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426092419", "createdAt": "2020-05-15T23:56:01Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -386,55 +471,98 @@ public String toString() {\n           .toString();\n     }\n \n-    static Route fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n-      RouteMatch routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n-      RouteAction routeAction = null;\n-      if (proto.hasRoute()) {\n-        routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+    @Nullable\n+    static StructOrError<Route> fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n+      StructOrError<RouteMatch> routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n+      if (routeMatch == null) {\n+        return null;\n+      }\n+      if (routeMatch.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeMatch.getErrorDetail());\n+      }\n+\n+      StructOrError<RouteAction> routeAction;\n+      switch (proto.getActionCase()) {\n+        case ROUTE:\n+          routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+          break;\n+        case REDIRECT:\n+          return StructOrError.fromError(\"Unsupported action type: redirect\");\n+        case DIRECT_RESPONSE:\n+          return StructOrError.fromError(\"Unsupported action type: direct_response\");\n+        case FILTER_ACTION:\n+          return StructOrError.fromError(\"Unsupported action type: filter_action\");\n+        case ACTION_NOT_SET:\n+          // fall through\n+        default:\n+          return StructOrError.fromError(\"Unknown action type: \" + proto.getActionCase());\n       }\n-      return new Route(routeMatch, routeAction);\n+      if (routeAction.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeAction.getErrorDetail());\n+      }\n+      return StructOrError.fromStruct(new Route(routeMatch.getStruct(), routeAction.getStruct()));\n     }\n   }\n \n   /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.RouteMatch}. */\n   static final class RouteMatch {\n-    private final String prefix;\n-    private final String path;\n-    private final boolean hasRegex;\n-    private final boolean caseSensitive;\n-\n-    @VisibleForTesting\n-    RouteMatch(String prefix, String path, boolean hasRegex, boolean caseSensitive) {\n-      this.prefix = prefix;\n-      this.path = path;\n-      this.hasRegex = hasRegex;\n-      this.caseSensitive = caseSensitive;\n-    }\n+    // Exactly one of the following fields is non-null.\n+    @Nullable\n+    private final String pathPrefixMatch;\n+    @Nullable\n+    private final String pathExactMatch;\n+    @Nullable\n+    private final String pathSafeRegExMatch;\n \n-    String getPrefix() {\n-      return prefix;\n-    }\n+    private final List<HeaderMatcher> headerMatchers;\n+    @Nullable\n+    private final Fraction fractionMatch;\n \n-    String getPath() {\n-      return path;\n+    @VisibleForTesting\n+    RouteMatch(\n+        @Nullable String pathPrefixMatch, @Nullable String pathExactMatch,\n+        @Nullable String pathSafeRegExMatch, @Nullable Fraction fractionMatch,\n+        List<HeaderMatcher> headerMatchers) {\n+      this.pathPrefixMatch = pathPrefixMatch;\n+      this.pathExactMatch = pathExactMatch;\n+      this.pathSafeRegExMatch = pathSafeRegExMatch;\n+      this.fractionMatch = fractionMatch;\n+      this.headerMatchers = headerMatchers;\n+    }\n+\n+    RouteMatch(@Nullable String pathPrefixMatch, @Nullable String pathExactMatch) {\n+      this(\n+          pathPrefixMatch, pathExactMatch, null, null,\n+          Collections.<HeaderMatcher>emptyList());\n     }\n \n-    boolean hasRegex() {\n-      return hasRegex;\n+    @Nullable\n+    String getPathPrefixMatch() {\n+      return pathPrefixMatch;\n     }\n \n-    boolean isCaseSensitive() {\n-      return caseSensitive;\n+    @Nullable\n+    String getPathExactMatch() {\n+      return pathExactMatch;\n     }\n \n-    boolean isDefaultMatcher() {\n-      if (hasRegex) {\n+    boolean isMatchAll() {\n+      if (pathSafeRegExMatch != null || fractionMatch != null) {\n         return false;\n       }\n-      if (!path.isEmpty()) {\n+      if (headerMatchers != null && !headerMatchers.isEmpty()) {\n         return false;\n       }\n-      return prefix.isEmpty() || prefix.equals(\"/\");\n+      if (pathExactMatch != null) {\n+        return pathExactMatch.isEmpty();\n+      }\n+      if (pathPrefixMatch != null) {\n+        return pathPrefixMatch.isEmpty() || pathPrefixMatch.equals(\"/\");\n+      }\n+      // TODO (chengyuanzhang): can path match with regex be a default route?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxNTU0OQ=="}, "originalCommit": {"oid": "d3dd2b6ed6a298fc9c73383c399b3fedb0585f83"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1Mjg2OTE4OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxOTo1MjoyMVrOGWR8nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODowMDozOFrOGXB8-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxNTkwMQ==", "bodyText": "Seems headerMatchers is never null. It's not a oneof element.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426015901", "createdAt": "2020-05-15T19:52:21Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -386,55 +471,98 @@ public String toString() {\n           .toString();\n     }\n \n-    static Route fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n-      RouteMatch routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n-      RouteAction routeAction = null;\n-      if (proto.hasRoute()) {\n-        routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+    @Nullable\n+    static StructOrError<Route> fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n+      StructOrError<RouteMatch> routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n+      if (routeMatch == null) {\n+        return null;\n+      }\n+      if (routeMatch.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeMatch.getErrorDetail());\n+      }\n+\n+      StructOrError<RouteAction> routeAction;\n+      switch (proto.getActionCase()) {\n+        case ROUTE:\n+          routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+          break;\n+        case REDIRECT:\n+          return StructOrError.fromError(\"Unsupported action type: redirect\");\n+        case DIRECT_RESPONSE:\n+          return StructOrError.fromError(\"Unsupported action type: direct_response\");\n+        case FILTER_ACTION:\n+          return StructOrError.fromError(\"Unsupported action type: filter_action\");\n+        case ACTION_NOT_SET:\n+          // fall through\n+        default:\n+          return StructOrError.fromError(\"Unknown action type: \" + proto.getActionCase());\n       }\n-      return new Route(routeMatch, routeAction);\n+      if (routeAction.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeAction.getErrorDetail());\n+      }\n+      return StructOrError.fromStruct(new Route(routeMatch.getStruct(), routeAction.getStruct()));\n     }\n   }\n \n   /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.RouteMatch}. */\n   static final class RouteMatch {\n-    private final String prefix;\n-    private final String path;\n-    private final boolean hasRegex;\n-    private final boolean caseSensitive;\n-\n-    @VisibleForTesting\n-    RouteMatch(String prefix, String path, boolean hasRegex, boolean caseSensitive) {\n-      this.prefix = prefix;\n-      this.path = path;\n-      this.hasRegex = hasRegex;\n-      this.caseSensitive = caseSensitive;\n-    }\n+    // Exactly one of the following fields is non-null.\n+    @Nullable\n+    private final String pathPrefixMatch;\n+    @Nullable\n+    private final String pathExactMatch;\n+    @Nullable\n+    private final String pathSafeRegExMatch;\n \n-    String getPrefix() {\n-      return prefix;\n-    }\n+    private final List<HeaderMatcher> headerMatchers;\n+    @Nullable\n+    private final Fraction fractionMatch;\n \n-    String getPath() {\n-      return path;\n+    @VisibleForTesting\n+    RouteMatch(\n+        @Nullable String pathPrefixMatch, @Nullable String pathExactMatch,\n+        @Nullable String pathSafeRegExMatch, @Nullable Fraction fractionMatch,\n+        List<HeaderMatcher> headerMatchers) {\n+      this.pathPrefixMatch = pathPrefixMatch;\n+      this.pathExactMatch = pathExactMatch;\n+      this.pathSafeRegExMatch = pathSafeRegExMatch;\n+      this.fractionMatch = fractionMatch;\n+      this.headerMatchers = headerMatchers;\n+    }\n+\n+    RouteMatch(@Nullable String pathPrefixMatch, @Nullable String pathExactMatch) {\n+      this(\n+          pathPrefixMatch, pathExactMatch, null, null,\n+          Collections.<HeaderMatcher>emptyList());\n     }\n \n-    boolean hasRegex() {\n-      return hasRegex;\n+    @Nullable\n+    String getPathPrefixMatch() {\n+      return pathPrefixMatch;\n     }\n \n-    boolean isCaseSensitive() {\n-      return caseSensitive;\n+    @Nullable\n+    String getPathExactMatch() {\n+      return pathExactMatch;\n     }\n \n-    boolean isDefaultMatcher() {\n-      if (hasRegex) {\n+    boolean isMatchAll() {\n+      if (pathSafeRegExMatch != null || fractionMatch != null) {\n         return false;\n       }\n-      if (!path.isEmpty()) {\n+      if (headerMatchers != null && !headerMatchers.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3dd2b6ed6a298fc9c73383c399b3fedb0585f83"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwMjQyNg==", "bodyText": "Done.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426802426", "createdAt": "2020-05-18T18:00:38Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -386,55 +471,98 @@ public String toString() {\n           .toString();\n     }\n \n-    static Route fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n-      RouteMatch routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n-      RouteAction routeAction = null;\n-      if (proto.hasRoute()) {\n-        routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+    @Nullable\n+    static StructOrError<Route> fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n+      StructOrError<RouteMatch> routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n+      if (routeMatch == null) {\n+        return null;\n+      }\n+      if (routeMatch.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeMatch.getErrorDetail());\n+      }\n+\n+      StructOrError<RouteAction> routeAction;\n+      switch (proto.getActionCase()) {\n+        case ROUTE:\n+          routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+          break;\n+        case REDIRECT:\n+          return StructOrError.fromError(\"Unsupported action type: redirect\");\n+        case DIRECT_RESPONSE:\n+          return StructOrError.fromError(\"Unsupported action type: direct_response\");\n+        case FILTER_ACTION:\n+          return StructOrError.fromError(\"Unsupported action type: filter_action\");\n+        case ACTION_NOT_SET:\n+          // fall through\n+        default:\n+          return StructOrError.fromError(\"Unknown action type: \" + proto.getActionCase());\n       }\n-      return new Route(routeMatch, routeAction);\n+      if (routeAction.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeAction.getErrorDetail());\n+      }\n+      return StructOrError.fromStruct(new Route(routeMatch.getStruct(), routeAction.getStruct()));\n     }\n   }\n \n   /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.RouteMatch}. */\n   static final class RouteMatch {\n-    private final String prefix;\n-    private final String path;\n-    private final boolean hasRegex;\n-    private final boolean caseSensitive;\n-\n-    @VisibleForTesting\n-    RouteMatch(String prefix, String path, boolean hasRegex, boolean caseSensitive) {\n-      this.prefix = prefix;\n-      this.path = path;\n-      this.hasRegex = hasRegex;\n-      this.caseSensitive = caseSensitive;\n-    }\n+    // Exactly one of the following fields is non-null.\n+    @Nullable\n+    private final String pathPrefixMatch;\n+    @Nullable\n+    private final String pathExactMatch;\n+    @Nullable\n+    private final String pathSafeRegExMatch;\n \n-    String getPrefix() {\n-      return prefix;\n-    }\n+    private final List<HeaderMatcher> headerMatchers;\n+    @Nullable\n+    private final Fraction fractionMatch;\n \n-    String getPath() {\n-      return path;\n+    @VisibleForTesting\n+    RouteMatch(\n+        @Nullable String pathPrefixMatch, @Nullable String pathExactMatch,\n+        @Nullable String pathSafeRegExMatch, @Nullable Fraction fractionMatch,\n+        List<HeaderMatcher> headerMatchers) {\n+      this.pathPrefixMatch = pathPrefixMatch;\n+      this.pathExactMatch = pathExactMatch;\n+      this.pathSafeRegExMatch = pathSafeRegExMatch;\n+      this.fractionMatch = fractionMatch;\n+      this.headerMatchers = headerMatchers;\n+    }\n+\n+    RouteMatch(@Nullable String pathPrefixMatch, @Nullable String pathExactMatch) {\n+      this(\n+          pathPrefixMatch, pathExactMatch, null, null,\n+          Collections.<HeaderMatcher>emptyList());\n     }\n \n-    boolean hasRegex() {\n-      return hasRegex;\n+    @Nullable\n+    String getPathPrefixMatch() {\n+      return pathPrefixMatch;\n     }\n \n-    boolean isCaseSensitive() {\n-      return caseSensitive;\n+    @Nullable\n+    String getPathExactMatch() {\n+      return pathExactMatch;\n     }\n \n-    boolean isDefaultMatcher() {\n-      if (hasRegex) {\n+    boolean isMatchAll() {\n+      if (pathSafeRegExMatch != null || fractionMatch != null) {\n         return false;\n       }\n-      if (!path.isEmpty()) {\n+      if (headerMatchers != null && !headerMatchers.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjAxNTkwMQ=="}, "originalCommit": {"oid": "d3dd2b6ed6a298fc9c73383c399b3fedb0585f83"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzE1Mjc2OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMTo0NjoxM1rOGWUt4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMzo1Nzo1M1rOGWWowg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MTI4MA==", "bodyText": "Should return false.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426061280", "createdAt": "2020-05-15T21:46:13Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -386,55 +471,98 @@ public String toString() {\n           .toString();\n     }\n \n-    static Route fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n-      RouteMatch routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n-      RouteAction routeAction = null;\n-      if (proto.hasRoute()) {\n-        routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+    @Nullable\n+    static StructOrError<Route> fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n+      StructOrError<RouteMatch> routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n+      if (routeMatch == null) {\n+        return null;\n+      }\n+      if (routeMatch.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeMatch.getErrorDetail());\n+      }\n+\n+      StructOrError<RouteAction> routeAction;\n+      switch (proto.getActionCase()) {\n+        case ROUTE:\n+          routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+          break;\n+        case REDIRECT:\n+          return StructOrError.fromError(\"Unsupported action type: redirect\");\n+        case DIRECT_RESPONSE:\n+          return StructOrError.fromError(\"Unsupported action type: direct_response\");\n+        case FILTER_ACTION:\n+          return StructOrError.fromError(\"Unsupported action type: filter_action\");\n+        case ACTION_NOT_SET:\n+          // fall through\n+        default:\n+          return StructOrError.fromError(\"Unknown action type: \" + proto.getActionCase());\n       }\n-      return new Route(routeMatch, routeAction);\n+      if (routeAction.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeAction.getErrorDetail());\n+      }\n+      return StructOrError.fromStruct(new Route(routeMatch.getStruct(), routeAction.getStruct()));\n     }\n   }\n \n   /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.RouteMatch}. */\n   static final class RouteMatch {\n-    private final String prefix;\n-    private final String path;\n-    private final boolean hasRegex;\n-    private final boolean caseSensitive;\n-\n-    @VisibleForTesting\n-    RouteMatch(String prefix, String path, boolean hasRegex, boolean caseSensitive) {\n-      this.prefix = prefix;\n-      this.path = path;\n-      this.hasRegex = hasRegex;\n-      this.caseSensitive = caseSensitive;\n-    }\n+    // Exactly one of the following fields is non-null.\n+    @Nullable\n+    private final String pathPrefixMatch;\n+    @Nullable\n+    private final String pathExactMatch;\n+    @Nullable\n+    private final String pathSafeRegExMatch;\n \n-    String getPrefix() {\n-      return prefix;\n-    }\n+    private final List<HeaderMatcher> headerMatchers;\n+    @Nullable\n+    private final Fraction fractionMatch;\n \n-    String getPath() {\n-      return path;\n+    @VisibleForTesting\n+    RouteMatch(\n+        @Nullable String pathPrefixMatch, @Nullable String pathExactMatch,\n+        @Nullable String pathSafeRegExMatch, @Nullable Fraction fractionMatch,\n+        List<HeaderMatcher> headerMatchers) {\n+      this.pathPrefixMatch = pathPrefixMatch;\n+      this.pathExactMatch = pathExactMatch;\n+      this.pathSafeRegExMatch = pathSafeRegExMatch;\n+      this.fractionMatch = fractionMatch;\n+      this.headerMatchers = headerMatchers;\n+    }\n+\n+    RouteMatch(@Nullable String pathPrefixMatch, @Nullable String pathExactMatch) {\n+      this(\n+          pathPrefixMatch, pathExactMatch, null, null,\n+          Collections.<HeaderMatcher>emptyList());\n     }\n \n-    boolean hasRegex() {\n-      return hasRegex;\n+    @Nullable\n+    String getPathPrefixMatch() {\n+      return pathPrefixMatch;\n     }\n \n-    boolean isCaseSensitive() {\n-      return caseSensitive;\n+    @Nullable\n+    String getPathExactMatch() {\n+      return pathExactMatch;\n     }\n \n-    boolean isDefaultMatcher() {\n-      if (hasRegex) {\n+    boolean isMatchAll() {\n+      if (pathSafeRegExMatch != null || fractionMatch != null) {\n         return false;\n       }\n-      if (!path.isEmpty()) {\n+      if (headerMatchers != null && !headerMatchers.isEmpty()) {\n         return false;\n       }\n-      return prefix.isEmpty() || prefix.equals(\"/\");\n+      if (pathExactMatch != null) {\n+        return pathExactMatch.isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3dd2b6ed6a298fc9c73383c399b3fedb0585f83"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5MjczOA==", "bodyText": "Done. You are right, I miss interpreted your previous code.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426092738", "createdAt": "2020-05-15T23:57:53Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -386,55 +471,98 @@ public String toString() {\n           .toString();\n     }\n \n-    static Route fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n-      RouteMatch routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n-      RouteAction routeAction = null;\n-      if (proto.hasRoute()) {\n-        routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+    @Nullable\n+    static StructOrError<Route> fromEnvoyProtoRoute(io.envoyproxy.envoy.api.v2.route.Route proto) {\n+      StructOrError<RouteMatch> routeMatch = RouteMatch.fromEnvoyProtoRouteMatch(proto.getMatch());\n+      if (routeMatch == null) {\n+        return null;\n+      }\n+      if (routeMatch.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeMatch.getErrorDetail());\n+      }\n+\n+      StructOrError<RouteAction> routeAction;\n+      switch (proto.getActionCase()) {\n+        case ROUTE:\n+          routeAction = RouteAction.fromEnvoyProtoRouteAction(proto.getRoute());\n+          break;\n+        case REDIRECT:\n+          return StructOrError.fromError(\"Unsupported action type: redirect\");\n+        case DIRECT_RESPONSE:\n+          return StructOrError.fromError(\"Unsupported action type: direct_response\");\n+        case FILTER_ACTION:\n+          return StructOrError.fromError(\"Unsupported action type: filter_action\");\n+        case ACTION_NOT_SET:\n+          // fall through\n+        default:\n+          return StructOrError.fromError(\"Unknown action type: \" + proto.getActionCase());\n       }\n-      return new Route(routeMatch, routeAction);\n+      if (routeAction.getErrorDetail() != null) {\n+        return StructOrError.fromError(\n+            \"Invalid route [\" + proto.getName() + \"] : \" + routeAction.getErrorDetail());\n+      }\n+      return StructOrError.fromStruct(new Route(routeMatch.getStruct(), routeAction.getStruct()));\n     }\n   }\n \n   /** See corresponding Envoy proto message {@link io.envoyproxy.envoy.api.v2.route.RouteMatch}. */\n   static final class RouteMatch {\n-    private final String prefix;\n-    private final String path;\n-    private final boolean hasRegex;\n-    private final boolean caseSensitive;\n-\n-    @VisibleForTesting\n-    RouteMatch(String prefix, String path, boolean hasRegex, boolean caseSensitive) {\n-      this.prefix = prefix;\n-      this.path = path;\n-      this.hasRegex = hasRegex;\n-      this.caseSensitive = caseSensitive;\n-    }\n+    // Exactly one of the following fields is non-null.\n+    @Nullable\n+    private final String pathPrefixMatch;\n+    @Nullable\n+    private final String pathExactMatch;\n+    @Nullable\n+    private final String pathSafeRegExMatch;\n \n-    String getPrefix() {\n-      return prefix;\n-    }\n+    private final List<HeaderMatcher> headerMatchers;\n+    @Nullable\n+    private final Fraction fractionMatch;\n \n-    String getPath() {\n-      return path;\n+    @VisibleForTesting\n+    RouteMatch(\n+        @Nullable String pathPrefixMatch, @Nullable String pathExactMatch,\n+        @Nullable String pathSafeRegExMatch, @Nullable Fraction fractionMatch,\n+        List<HeaderMatcher> headerMatchers) {\n+      this.pathPrefixMatch = pathPrefixMatch;\n+      this.pathExactMatch = pathExactMatch;\n+      this.pathSafeRegExMatch = pathSafeRegExMatch;\n+      this.fractionMatch = fractionMatch;\n+      this.headerMatchers = headerMatchers;\n+    }\n+\n+    RouteMatch(@Nullable String pathPrefixMatch, @Nullable String pathExactMatch) {\n+      this(\n+          pathPrefixMatch, pathExactMatch, null, null,\n+          Collections.<HeaderMatcher>emptyList());\n     }\n \n-    boolean hasRegex() {\n-      return hasRegex;\n+    @Nullable\n+    String getPathPrefixMatch() {\n+      return pathPrefixMatch;\n     }\n \n-    boolean isCaseSensitive() {\n-      return caseSensitive;\n+    @Nullable\n+    String getPathExactMatch() {\n+      return pathExactMatch;\n     }\n \n-    boolean isDefaultMatcher() {\n-      if (hasRegex) {\n+    boolean isMatchAll() {\n+      if (pathSafeRegExMatch != null || fractionMatch != null) {\n         return false;\n       }\n-      if (!path.isEmpty()) {\n+      if (headerMatchers != null && !headerMatchers.isEmpty()) {\n         return false;\n       }\n-      return prefix.isEmpty() || prefix.equals(\"/\");\n+      if (pathExactMatch != null) {\n+        return pathExactMatch.isEmpty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MTI4MA=="}, "originalCommit": {"oid": "d3dd2b6ed6a298fc9c73383c399b3fedb0585f83"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzE1NjA1OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMTo0Nzo1OVrOGWUv4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMzo1ODowMFrOGWWo1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MTc5NA==", "bodyText": "\"\" in path is not default. It's not valid.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426061794", "createdAt": "2020-05-15T21:47:59Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -446,62 +574,357 @@ public boolean equals(Object o) {\n         return false;\n       }\n       RouteMatch that = (RouteMatch) o;\n-      return hasRegex == that.hasRegex\n-          && caseSensitive == that.caseSensitive\n-          && Objects.equals(prefix, that.prefix)\n-          && Objects.equals(path, that.path);\n+      return Objects.equals(pathPrefixMatch, that.pathPrefixMatch)\n+          && Objects.equals(pathExactMatch, that.pathExactMatch)\n+          && Objects.equals(pathSafeRegExMatch, that.pathSafeRegExMatch)\n+          && Objects.equals(fractionMatch, that.fractionMatch)\n+          && Objects.equals(headerMatchers, that.headerMatchers);\n     }\n \n     @Override\n     public int hashCode() {\n-      return Objects.hash(prefix, path, caseSensitive, hasRegex);\n+      return Objects.hash(pathPrefixMatch, pathExactMatch, headerMatchers, fractionMatch);\n     }\n \n     @Override\n     public String toString() {\n       return MoreObjects.toStringHelper(this)\n-          .add(\"prefix\", prefix)\n-          .add(\"path\", path)\n-          .add(\"hasRegex\", hasRegex)\n-          .add(\"caseSensitive\", caseSensitive)\n+          .add(\"prefixPathMatch\", pathPrefixMatch)\n+          .add(\"exactPathMatch\", pathExactMatch)\n+          .add(\"safeRegExPathMatch\", pathSafeRegExMatch)\n+          .add(\"headerMatchers\", headerMatchers)\n+          .add(\"fractionMatch\", fractionMatch)\n           .toString();\n     }\n \n     @VisibleForTesting\n-    static RouteMatch fromEnvoyProtoRouteMatch(\n+    @SuppressWarnings(\"deprecation\")\n+    @Nullable\n+    static StructOrError<RouteMatch> fromEnvoyProtoRouteMatch(\n         io.envoyproxy.envoy.api.v2.route.RouteMatch proto) {\n-      return new RouteMatch(\n-          /* prefix= */ proto.getPrefix(),\n-          /* path= */ proto.getPath(),\n-          /* hasRegex= */ !proto.getRegex().isEmpty() || proto.hasSafeRegex(),\n-          // case_sensitive defaults to true if the field is not set\n-          /*caseSensitive= */ !proto.hasCaseSensitive() || proto.getCaseSensitive().getValue());\n+      if (proto.getQueryParametersCount() != 0) {\n+        return null;\n+      }\n+      if (proto.hasCaseSensitive() && !proto.getCaseSensitive().getValue()) {\n+        return StructOrError.fromError(\"Unsupported match option: case insensitive\");\n+      }\n+\n+      Fraction fraction = null;\n+      if (proto.hasRuntimeFraction()) {\n+        io.envoyproxy.envoy.type.FractionalPercent percent =\n+            proto.getRuntimeFraction().getDefaultValue();\n+        int numerator = percent.getNumerator();\n+        int denominator = 0;\n+        switch (percent.getDenominator()) {\n+          case HUNDRED:\n+            denominator = 100;\n+            break;\n+          case TEN_THOUSAND:\n+            denominator = 10_000;\n+            break;\n+          case MILLION:\n+            denominator = 1_000_000;\n+            break;\n+          case UNRECOGNIZED:\n+            // fall through\n+          default:\n+            return StructOrError.fromError(\n+                \"Unrecognized fractional percent denominator: \" + percent.getDenominator());\n+        }\n+        fraction = new Fraction(numerator, denominator);\n+      }\n+\n+      String prefixPathMatch = null;\n+      String exactPathMatch = null;\n+      String safeRegExPathMatch = null;\n+      switch (proto.getPathSpecifierCase()) {\n+        case PREFIX:\n+          prefixPathMatch = proto.getPrefix();\n+          // Supported prefix match format:\n+          // \"\", \"/\" (default)\n+          // \"/service/\"\n+          if (!prefixPathMatch.isEmpty() && !prefixPathMatch.equals(\"/\")) {\n+            if (!prefixPathMatch.startsWith(\"/\") || !prefixPathMatch.endsWith(\"/\")\n+                || prefixPathMatch.length() < 3) {\n+              return StructOrError.fromError(\n+                  \"Invalid format of prefix path match: \" + prefixPathMatch);\n+            }\n+          }\n+          break;\n+        case PATH:\n+          exactPathMatch = proto.getPath();\n+          int lastSlash = exactPathMatch.lastIndexOf('/');\n+          // Supported exact match format:\n+          // \"\" (default)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3dd2b6ed6a298fc9c73383c399b3fedb0585f83"}, "originalPosition": 359}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5Mjc1OA==", "bodyText": "Done.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426092758", "createdAt": "2020-05-15T23:58:00Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -446,62 +574,357 @@ public boolean equals(Object o) {\n         return false;\n       }\n       RouteMatch that = (RouteMatch) o;\n-      return hasRegex == that.hasRegex\n-          && caseSensitive == that.caseSensitive\n-          && Objects.equals(prefix, that.prefix)\n-          && Objects.equals(path, that.path);\n+      return Objects.equals(pathPrefixMatch, that.pathPrefixMatch)\n+          && Objects.equals(pathExactMatch, that.pathExactMatch)\n+          && Objects.equals(pathSafeRegExMatch, that.pathSafeRegExMatch)\n+          && Objects.equals(fractionMatch, that.fractionMatch)\n+          && Objects.equals(headerMatchers, that.headerMatchers);\n     }\n \n     @Override\n     public int hashCode() {\n-      return Objects.hash(prefix, path, caseSensitive, hasRegex);\n+      return Objects.hash(pathPrefixMatch, pathExactMatch, headerMatchers, fractionMatch);\n     }\n \n     @Override\n     public String toString() {\n       return MoreObjects.toStringHelper(this)\n-          .add(\"prefix\", prefix)\n-          .add(\"path\", path)\n-          .add(\"hasRegex\", hasRegex)\n-          .add(\"caseSensitive\", caseSensitive)\n+          .add(\"prefixPathMatch\", pathPrefixMatch)\n+          .add(\"exactPathMatch\", pathExactMatch)\n+          .add(\"safeRegExPathMatch\", pathSafeRegExMatch)\n+          .add(\"headerMatchers\", headerMatchers)\n+          .add(\"fractionMatch\", fractionMatch)\n           .toString();\n     }\n \n     @VisibleForTesting\n-    static RouteMatch fromEnvoyProtoRouteMatch(\n+    @SuppressWarnings(\"deprecation\")\n+    @Nullable\n+    static StructOrError<RouteMatch> fromEnvoyProtoRouteMatch(\n         io.envoyproxy.envoy.api.v2.route.RouteMatch proto) {\n-      return new RouteMatch(\n-          /* prefix= */ proto.getPrefix(),\n-          /* path= */ proto.getPath(),\n-          /* hasRegex= */ !proto.getRegex().isEmpty() || proto.hasSafeRegex(),\n-          // case_sensitive defaults to true if the field is not set\n-          /*caseSensitive= */ !proto.hasCaseSensitive() || proto.getCaseSensitive().getValue());\n+      if (proto.getQueryParametersCount() != 0) {\n+        return null;\n+      }\n+      if (proto.hasCaseSensitive() && !proto.getCaseSensitive().getValue()) {\n+        return StructOrError.fromError(\"Unsupported match option: case insensitive\");\n+      }\n+\n+      Fraction fraction = null;\n+      if (proto.hasRuntimeFraction()) {\n+        io.envoyproxy.envoy.type.FractionalPercent percent =\n+            proto.getRuntimeFraction().getDefaultValue();\n+        int numerator = percent.getNumerator();\n+        int denominator = 0;\n+        switch (percent.getDenominator()) {\n+          case HUNDRED:\n+            denominator = 100;\n+            break;\n+          case TEN_THOUSAND:\n+            denominator = 10_000;\n+            break;\n+          case MILLION:\n+            denominator = 1_000_000;\n+            break;\n+          case UNRECOGNIZED:\n+            // fall through\n+          default:\n+            return StructOrError.fromError(\n+                \"Unrecognized fractional percent denominator: \" + percent.getDenominator());\n+        }\n+        fraction = new Fraction(numerator, denominator);\n+      }\n+\n+      String prefixPathMatch = null;\n+      String exactPathMatch = null;\n+      String safeRegExPathMatch = null;\n+      switch (proto.getPathSpecifierCase()) {\n+        case PREFIX:\n+          prefixPathMatch = proto.getPrefix();\n+          // Supported prefix match format:\n+          // \"\", \"/\" (default)\n+          // \"/service/\"\n+          if (!prefixPathMatch.isEmpty() && !prefixPathMatch.equals(\"/\")) {\n+            if (!prefixPathMatch.startsWith(\"/\") || !prefixPathMatch.endsWith(\"/\")\n+                || prefixPathMatch.length() < 3) {\n+              return StructOrError.fromError(\n+                  \"Invalid format of prefix path match: \" + prefixPathMatch);\n+            }\n+          }\n+          break;\n+        case PATH:\n+          exactPathMatch = proto.getPath();\n+          int lastSlash = exactPathMatch.lastIndexOf('/');\n+          // Supported exact match format:\n+          // \"\" (default)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA2MTc5NA=="}, "originalCommit": {"oid": "d3dd2b6ed6a298fc9c73383c399b3fedb0585f83"}, "originalPosition": 359}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzIxNDcyOnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMjoxODo1OFrOGWVTQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMzo1OToyOVrOGWWp1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3MDg0OA==", "bodyText": "@Nullable", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426070848", "createdAt": "2020-05-15T22:18:58Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -824,34 +811,89 @@ private void handleRdsResponse(DiscoveryResponse rdsResponse) {\n         rdsRespTimer.cancel();\n         rdsRespTimer = null;\n       }\n-\n-      // Found routes in the in-lined RouteConfiguration.\n-      ConfigUpdate configUpdate;\n-      if (!enableExperimentalRouting) {\n-        EnvoyProtoData.Route defaultRoute = Iterables.getLast(routes);\n-        configUpdate =\n-            ConfigUpdate.newBuilder()\n-                .addRoutes(ImmutableList.of(defaultRoute))\n-                .build();\n-        logger.log(\n-            XdsLogLevel.INFO,\n-            \"Found cluster name: {0}\",\n-            defaultRoute.getRouteAction().getCluster());\n-      } else {\n-        configUpdate = ConfigUpdate.newBuilder().addRoutes(routes).build();\n-        logger.log(XdsLogLevel.INFO, \"Found {0} routes\", routes.size());\n-        logger.log(XdsLogLevel.DEBUG, \"Found routes: {0}\", routes);\n-      }\n+      logger.log(XdsLogLevel.DEBUG, \"Found routes: {0}\", routes);\n+      ConfigUpdate configUpdate  =\n+          ConfigUpdate.newBuilder().addRoutes(routes).build();\n       configWatcher.onConfigChanged(configUpdate);\n     }\n   }\n \n   /**\n    * Processes a RouteConfiguration message to find the routes that requests for the given host will\n    * be routed to.\n+   *\n+   * @throws InvalidProtoDataException if the message contains invalid data.\n    */\n   @VisibleForTesting\n-  static List<EnvoyProtoData.Route> findRoutesInRouteConfig(\n+  private static List<EnvoyProtoData.Route> findRoutesInRouteConfig(\n+      RouteConfiguration config, String hostName) throws InvalidProtoDataException {\n+    VirtualHost targetVirtualHost = findVirtualHostForHostName(config, hostName);\n+    if (targetVirtualHost == null) {\n+      throw new InvalidProtoDataException(\"Unable to find virtual host for \" + hostName);\n+    }\n+\n+    // Note we would consider upstream cluster not found if the virtual host is not configured\n+    // correctly for gRPC, even if there exist other virtual hosts with (lower priority)\n+    // matching domains.\n+    return populateRoutesInVirtualHost(targetVirtualHost);\n+  }\n+\n+  @VisibleForTesting\n+  static List<EnvoyProtoData.Route> populateRoutesInVirtualHost(VirtualHost virtualHost)\n+      throws InvalidProtoDataException {\n+    List<EnvoyProtoData.Route> routes = new ArrayList<>();\n+    List<Route> routesProto = virtualHost.getRoutesList();\n+    for (Route routeProto : routesProto) {\n+      StructOrError<EnvoyProtoData.Route> route =\n+          EnvoyProtoData.Route.fromEnvoyProtoRoute(routeProto);\n+      if (route == null) {\n+        continue;\n+      } else if (route.getErrorDetail() != null) {\n+        throw new InvalidProtoDataException(\n+            \"Virtual host [\" + virtualHost.getName() + \"] contains invalid route : \"\n+                + route.getErrorDetail());\n+      }\n+      routes.add(route.getStruct());\n+    }\n+    if (routes.isEmpty()) {\n+      throw new InvalidProtoDataException(\n+          \"Virtual host [\" + virtualHost.getName() + \"] contains no usable route\");\n+    }\n+    // The last route must be a default route.\n+    if (!Iterables.getLast(routes).isDefaultRoute()) {\n+      throw new InvalidProtoDataException(\n+          \"Virtual host [\" + virtualHost.getName()\n+              + \"] contains non-default route as the last route\");\n+    }\n+    // We only validate the default route unless path matching is enabled.\n+    if (!enableExperimentalRouting) {\n+      EnvoyProtoData.Route defaultRoute = Iterables.getLast(routes);\n+      if (defaultRoute.getRouteAction().getCluster() == null) {\n+        throw new InvalidProtoDataException(\n+            \"Virtual host [\" + virtualHost.getName()\n+                + \"] default route contains no cluster name\");\n+      }\n+      return Collections.singletonList(defaultRoute);\n+    }\n+\n+    // We do more validation if path matching is enabled, but whether every single route is\n+    // required to be valid for grpc is TBD.\n+    // For now we consider the whole list invalid if anything invalid for grpc is found.\n+    // TODO(zdapeng): Fix it if the decision is different from current implementation.\n+    // TODO(zdapeng): Add test for validation.\n+    for (EnvoyProtoData.Route route : routes) {\n+      if (route.getRouteAction().getCluster() == null\n+          && route.getRouteAction().getWeightedCluster() == null) {\n+        throw new InvalidProtoDataException(\n+            \"Virtual host [\" + virtualHost.getName()\n+                + \"] contains route without cluster or weighted cluster\");\n+      }\n+    }\n+    return Collections.unmodifiableList(routes);\n+  }\n+\n+  @VisibleForTesting\n+  static VirtualHost findVirtualHostForHostName(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3dd2b6ed6a298fc9c73383c399b3fedb0585f83"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5MzAxNA==", "bodyText": "Added.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426093014", "createdAt": "2020-05-15T23:59:29Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -824,34 +811,89 @@ private void handleRdsResponse(DiscoveryResponse rdsResponse) {\n         rdsRespTimer.cancel();\n         rdsRespTimer = null;\n       }\n-\n-      // Found routes in the in-lined RouteConfiguration.\n-      ConfigUpdate configUpdate;\n-      if (!enableExperimentalRouting) {\n-        EnvoyProtoData.Route defaultRoute = Iterables.getLast(routes);\n-        configUpdate =\n-            ConfigUpdate.newBuilder()\n-                .addRoutes(ImmutableList.of(defaultRoute))\n-                .build();\n-        logger.log(\n-            XdsLogLevel.INFO,\n-            \"Found cluster name: {0}\",\n-            defaultRoute.getRouteAction().getCluster());\n-      } else {\n-        configUpdate = ConfigUpdate.newBuilder().addRoutes(routes).build();\n-        logger.log(XdsLogLevel.INFO, \"Found {0} routes\", routes.size());\n-        logger.log(XdsLogLevel.DEBUG, \"Found routes: {0}\", routes);\n-      }\n+      logger.log(XdsLogLevel.DEBUG, \"Found routes: {0}\", routes);\n+      ConfigUpdate configUpdate  =\n+          ConfigUpdate.newBuilder().addRoutes(routes).build();\n       configWatcher.onConfigChanged(configUpdate);\n     }\n   }\n \n   /**\n    * Processes a RouteConfiguration message to find the routes that requests for the given host will\n    * be routed to.\n+   *\n+   * @throws InvalidProtoDataException if the message contains invalid data.\n    */\n   @VisibleForTesting\n-  static List<EnvoyProtoData.Route> findRoutesInRouteConfig(\n+  private static List<EnvoyProtoData.Route> findRoutesInRouteConfig(\n+      RouteConfiguration config, String hostName) throws InvalidProtoDataException {\n+    VirtualHost targetVirtualHost = findVirtualHostForHostName(config, hostName);\n+    if (targetVirtualHost == null) {\n+      throw new InvalidProtoDataException(\"Unable to find virtual host for \" + hostName);\n+    }\n+\n+    // Note we would consider upstream cluster not found if the virtual host is not configured\n+    // correctly for gRPC, even if there exist other virtual hosts with (lower priority)\n+    // matching domains.\n+    return populateRoutesInVirtualHost(targetVirtualHost);\n+  }\n+\n+  @VisibleForTesting\n+  static List<EnvoyProtoData.Route> populateRoutesInVirtualHost(VirtualHost virtualHost)\n+      throws InvalidProtoDataException {\n+    List<EnvoyProtoData.Route> routes = new ArrayList<>();\n+    List<Route> routesProto = virtualHost.getRoutesList();\n+    for (Route routeProto : routesProto) {\n+      StructOrError<EnvoyProtoData.Route> route =\n+          EnvoyProtoData.Route.fromEnvoyProtoRoute(routeProto);\n+      if (route == null) {\n+        continue;\n+      } else if (route.getErrorDetail() != null) {\n+        throw new InvalidProtoDataException(\n+            \"Virtual host [\" + virtualHost.getName() + \"] contains invalid route : \"\n+                + route.getErrorDetail());\n+      }\n+      routes.add(route.getStruct());\n+    }\n+    if (routes.isEmpty()) {\n+      throw new InvalidProtoDataException(\n+          \"Virtual host [\" + virtualHost.getName() + \"] contains no usable route\");\n+    }\n+    // The last route must be a default route.\n+    if (!Iterables.getLast(routes).isDefaultRoute()) {\n+      throw new InvalidProtoDataException(\n+          \"Virtual host [\" + virtualHost.getName()\n+              + \"] contains non-default route as the last route\");\n+    }\n+    // We only validate the default route unless path matching is enabled.\n+    if (!enableExperimentalRouting) {\n+      EnvoyProtoData.Route defaultRoute = Iterables.getLast(routes);\n+      if (defaultRoute.getRouteAction().getCluster() == null) {\n+        throw new InvalidProtoDataException(\n+            \"Virtual host [\" + virtualHost.getName()\n+                + \"] default route contains no cluster name\");\n+      }\n+      return Collections.singletonList(defaultRoute);\n+    }\n+\n+    // We do more validation if path matching is enabled, but whether every single route is\n+    // required to be valid for grpc is TBD.\n+    // For now we consider the whole list invalid if anything invalid for grpc is found.\n+    // TODO(zdapeng): Fix it if the decision is different from current implementation.\n+    // TODO(zdapeng): Add test for validation.\n+    for (EnvoyProtoData.Route route : routes) {\n+      if (route.getRouteAction().getCluster() == null\n+          && route.getRouteAction().getWeightedCluster() == null) {\n+        throw new InvalidProtoDataException(\n+            \"Virtual host [\" + virtualHost.getName()\n+                + \"] contains route without cluster or weighted cluster\");\n+      }\n+    }\n+    return Collections.unmodifiableList(routes);\n+  }\n+\n+  @VisibleForTesting\n+  static VirtualHost findVirtualHostForHostName(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3MDg0OA=="}, "originalCommit": {"oid": "d3dd2b6ed6a298fc9c73383c399b3fedb0585f83"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzIzODc2OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMjozMzowN1rOGWViDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMzo1OTozNVrOGWWp6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NDYzNg==", "bodyText": "Remove @VisibleForTesting", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426074636", "createdAt": "2020-05-15T22:33:07Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -824,34 +811,89 @@ private void handleRdsResponse(DiscoveryResponse rdsResponse) {\n         rdsRespTimer.cancel();\n         rdsRespTimer = null;\n       }\n-\n-      // Found routes in the in-lined RouteConfiguration.\n-      ConfigUpdate configUpdate;\n-      if (!enableExperimentalRouting) {\n-        EnvoyProtoData.Route defaultRoute = Iterables.getLast(routes);\n-        configUpdate =\n-            ConfigUpdate.newBuilder()\n-                .addRoutes(ImmutableList.of(defaultRoute))\n-                .build();\n-        logger.log(\n-            XdsLogLevel.INFO,\n-            \"Found cluster name: {0}\",\n-            defaultRoute.getRouteAction().getCluster());\n-      } else {\n-        configUpdate = ConfigUpdate.newBuilder().addRoutes(routes).build();\n-        logger.log(XdsLogLevel.INFO, \"Found {0} routes\", routes.size());\n-        logger.log(XdsLogLevel.DEBUG, \"Found routes: {0}\", routes);\n-      }\n+      logger.log(XdsLogLevel.DEBUG, \"Found routes: {0}\", routes);\n+      ConfigUpdate configUpdate  =\n+          ConfigUpdate.newBuilder().addRoutes(routes).build();\n       configWatcher.onConfigChanged(configUpdate);\n     }\n   }\n \n   /**\n    * Processes a RouteConfiguration message to find the routes that requests for the given host will\n    * be routed to.\n+   *\n+   * @throws InvalidProtoDataException if the message contains invalid data.\n    */\n   @VisibleForTesting\n-  static List<EnvoyProtoData.Route> findRoutesInRouteConfig(\n+  private static List<EnvoyProtoData.Route> findRoutesInRouteConfig(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3dd2b6ed6a298fc9c73383c399b3fedb0585f83"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5MzAzMg==", "bodyText": "Removed.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426093032", "createdAt": "2020-05-15T23:59:35Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -824,34 +811,89 @@ private void handleRdsResponse(DiscoveryResponse rdsResponse) {\n         rdsRespTimer.cancel();\n         rdsRespTimer = null;\n       }\n-\n-      // Found routes in the in-lined RouteConfiguration.\n-      ConfigUpdate configUpdate;\n-      if (!enableExperimentalRouting) {\n-        EnvoyProtoData.Route defaultRoute = Iterables.getLast(routes);\n-        configUpdate =\n-            ConfigUpdate.newBuilder()\n-                .addRoutes(ImmutableList.of(defaultRoute))\n-                .build();\n-        logger.log(\n-            XdsLogLevel.INFO,\n-            \"Found cluster name: {0}\",\n-            defaultRoute.getRouteAction().getCluster());\n-      } else {\n-        configUpdate = ConfigUpdate.newBuilder().addRoutes(routes).build();\n-        logger.log(XdsLogLevel.INFO, \"Found {0} routes\", routes.size());\n-        logger.log(XdsLogLevel.DEBUG, \"Found routes: {0}\", routes);\n-      }\n+      logger.log(XdsLogLevel.DEBUG, \"Found routes: {0}\", routes);\n+      ConfigUpdate configUpdate  =\n+          ConfigUpdate.newBuilder().addRoutes(routes).build();\n       configWatcher.onConfigChanged(configUpdate);\n     }\n   }\n \n   /**\n    * Processes a RouteConfiguration message to find the routes that requests for the given host will\n    * be routed to.\n+   *\n+   * @throws InvalidProtoDataException if the message contains invalid data.\n    */\n   @VisibleForTesting\n-  static List<EnvoyProtoData.Route> findRoutesInRouteConfig(\n+  private static List<EnvoyProtoData.Route> findRoutesInRouteConfig(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3NDYzNg=="}, "originalCommit": {"oid": "d3dd2b6ed6a298fc9c73383c399b3fedb0585f83"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzMwNzMwOnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMzoxODoyNVrOGWWLXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQyMzo1OTo0NVrOGWWqCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA4NTIxMw==", "bodyText": "Might better to disable stacktrace which causes a lot of memory allocation.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426085213", "createdAt": "2020-05-15T23:18:25Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -1792,4 +1750,13 @@ String print(MessageOrBuilder message) {\n       return res;\n     }\n   }\n+\n+  @VisibleForTesting\n+  static final class InvalidProtoDataException extends RuntimeException {\n+    private static final long serialVersionUID = 1L;\n+\n+    private InvalidProtoDataException(String message) {\n+      super(message);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2178d014f2ee4c7a9f265b5cfaaa81266aac8d3"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5MzA2Ng==", "bodyText": "Yes, thanks for the suggestion.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426093066", "createdAt": "2020-05-15T23:59:45Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -1792,4 +1750,13 @@ String print(MessageOrBuilder message) {\n       return res;\n     }\n   }\n+\n+  @VisibleForTesting\n+  static final class InvalidProtoDataException extends RuntimeException {\n+    private static final long serialVersionUID = 1L;\n+\n+    private InvalidProtoDataException(String message) {\n+      super(message);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA4NTIxMw=="}, "originalCommit": {"oid": "c2178d014f2ee4c7a9f265b5cfaaa81266aac8d3"}, "originalPosition": 289}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzM2Njc4OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMDowNjoyNFrOGWWuMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNzoyODozMFrOGXA5iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NDEzMQ==", "bodyText": "Equal objects must have equal hashCode.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426094131", "createdAt": "2020-05-16T00:06:24Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -574,7 +576,9 @@ public boolean equals(Object o) {\n       RouteMatch that = (RouteMatch) o;\n       return Objects.equals(pathPrefixMatch, that.pathPrefixMatch)\n           && Objects.equals(pathExactMatch, that.pathExactMatch)\n-          && Objects.equals(pathSafeRegExMatch, that.pathSafeRegExMatch)\n+          && Objects.equals(\n+              pathSafeRegExMatch == null ? null : pathSafeRegExMatch.pattern(),\n+              that.pathSafeRegExMatch == null  ? null : that.pathSafeRegExMatch.pattern())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "213388b3a98a836afa8826a12fae832955435d83"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4NTE2MQ==", "bodyText": "Fixed. Good catch. Thanks.", "url": "https://github.com/grpc/grpc-java/pull/7031#discussion_r426785161", "createdAt": "2020-05-18T17:28:30Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/EnvoyProtoData.java", "diffHunk": "@@ -574,7 +576,9 @@ public boolean equals(Object o) {\n       RouteMatch that = (RouteMatch) o;\n       return Objects.equals(pathPrefixMatch, that.pathPrefixMatch)\n           && Objects.equals(pathExactMatch, that.pathExactMatch)\n-          && Objects.equals(pathSafeRegExMatch, that.pathSafeRegExMatch)\n+          && Objects.equals(\n+              pathSafeRegExMatch == null ? null : pathSafeRegExMatch.pattern(),\n+              that.pathSafeRegExMatch == null  ? null : that.pathSafeRegExMatch.pattern())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5NDEzMQ=="}, "originalCommit": {"oid": "213388b3a98a836afa8826a12fae832955435d83"}, "originalPosition": 34}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2685, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}