{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwNjAyMzYx", "number": 7446, "title": "netty: BDP ping accounting should occur after flow control", "bodyText": "It's hoped that this resolves the \"too_many_pings\" issue some users are\nseeing that is worked around by GRPC_EXPERIMENTAL_AUTOFLOWCONTROL=false.\nThis change also avoids resetting the ping count for empty data frames\n(which shouldn't really happen with gRPC).\nThe previous code failed to reset the ping count on HEADERS and\nWINDOW_UPDATE. The code appeared to have callbacks for WINDOW_UPDATE,\nbut was layered above the Http2Connection so was never called. Thus,\nthis version is much more aggressive then the previous version while\nalso addressing the correctness issue.", "createdAt": "2020-09-21T22:58:13Z", "url": "https://github.com/grpc/grpc-java/pull/7446", "merged": true, "mergeCommit": {"oid": "00e2d717a2d0a8c898357a5894c0f614dda50cb6"}, "closed": true, "closedAt": "2020-09-28T22:23:13Z", "author": {"login": "ejona86"}, "timelineItems": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdLLepdAH2gAyNDkwNjAyMzYxOjYwNDU0ZTViYzI3NmE1MmJlNjgwY2E5ODQ2Y2YwMDBkMTI3YjE1NDg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdNbHhNAFqTQ5NzkzNTg3MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "60454e5bc276a52be680ca9846cf000d127b1548", "author": {"user": {"login": "ejona86", "name": "Eric Anderson"}}, "url": "https://github.com/grpc/grpc-java/commit/60454e5bc276a52be680ca9846cf000d127b1548", "committedDate": "2020-09-21T22:52:50Z", "message": "netty: BDP ping accounting should occur after flow control\n\nIt's hoped that this resolves the \"too_many_pings\" issue some users are\nseeing that is worked around by GRPC_EXPERIMENTAL_AUTOFLOWCONTROL=false.\nThis change also avoids resetting the ping count for empty data frames\n(which shouldn't really happen with gRPC).\n\nThe previous code failed to reset the ping count on HEADERS and\nWINDOW_UPDATE. The code _appeared_ to have callbacks for WINDOW_UPDATE,\nbut was layered above the Http2Connection so was never called. Thus,\nthis version is much more aggressive then the previous version while\nalso addressing the correctness issue."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3OTM1ODcw", "url": "https://github.com/grpc/grpc-java/pull/7446#pullrequestreview-497935870", "createdAt": "2020-09-28T22:12:50Z", "commit": {"oid": "60454e5bc276a52be680ca9846cf000d127b1548"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMjoxMjo1MFrOHZRoGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMjoxMjo1MFrOHZRoGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI2NTI0Mg==", "bodyText": "Why checking isReadable() while the old implementation did not?", "url": "https://github.com/grpc/grpc-java/pull/7446#discussion_r496265242", "createdAt": "2020-09-28T22:12:50Z", "author": {"login": "dapengzhang0"}, "path": "netty/src/main/java/io/grpc/netty/NettyClientHandler.java", "diffHunk": "@@ -912,4 +917,63 @@ public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Excepti\n       }\n     }\n   }\n+\n+  private static class PingCountingFrameWriter extends DecoratingHttp2FrameWriter\n+      implements AbstractNettyHandler.PingLimiter {\n+    private int pingCount;\n+\n+    public PingCountingFrameWriter(Http2FrameWriter delegate) {\n+      super(delegate);\n+    }\n+\n+    @Override\n+    public boolean isPingAllowed() {\n+      // \"3 strikes\" may cause the server to complain, so we limit ourselves to 2 or below.\n+      return pingCount < 2;\n+    }\n+\n+    @Override\n+    public ChannelFuture writeHeaders(\n+        ChannelHandlerContext ctx, int streamId, Http2Headers headers,\n+        int padding, boolean endStream, ChannelPromise promise) {\n+      pingCount = 0;\n+      return super.writeHeaders(ctx, streamId, headers, padding, endStream, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writeHeaders(\n+        ChannelHandlerContext ctx, int streamId, Http2Headers headers,\n+        int streamDependency, short weight, boolean exclusive,\n+        int padding, boolean endStream, ChannelPromise promise) {\n+      pingCount = 0;\n+      return super.writeHeaders(ctx, streamId, headers, streamDependency, weight, exclusive,\n+          padding, endStream, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writeWindowUpdate(\n+        ChannelHandlerContext ctx, int streamId, int windowSizeIncrement, ChannelPromise promise) {\n+      pingCount = 0;\n+      return super.writeWindowUpdate(ctx, streamId, windowSizeIncrement, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writePing(\n+        ChannelHandlerContext ctx, boolean ack, long data, ChannelPromise promise) {\n+      if (!ack) {\n+        pingCount++;\n+      }\n+      return super.writePing(ctx, ack, data, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writeData(\n+        ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endStream,\n+        ChannelPromise promise) {\n+      if (data.isReadable()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60454e5bc276a52be680ca9846cf000d127b1548"}, "originalPosition": 108}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4054, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}