{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4MjI3MjE3", "number": 7432, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMTo1ODoyNlrOEkvY3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMjowMzozM1rOEkveAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTYwNjA1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ServerImplBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMTo1ODoyNlrOHT29cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMTo1ODoyNlrOHT29cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NTQ1OA==", "bodyText": "s/mean/meant/", "url": "https://github.com/grpc/grpc-java/pull/7432#discussion_r490585458", "createdAt": "2020-09-17T21:58:26Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ServerImplBuilder.java", "diffHunk": "@@ -44,62 +105,234 @@\n    * Creates a new server builder with given transport servers provider.\n    */\n   public ServerImplBuilder(ClientTransportServersBuilder clientTransportServersBuilder) {\n-    this.clientTransportServersBuilder = Preconditions\n-        .checkNotNull(clientTransportServersBuilder, \"clientTransportServersBuilder\");\n+    this.clientTransportServersBuilder = checkNotNull(clientTransportServersBuilder,\n+        \"clientTransportServersBuilder\");\n   }\n \n   @Override\n-  protected List<? extends InternalServer> buildTransportServers(\n-      List<? extends ServerStreamTracer.Factory> streamTracerFactories) {\n-    return clientTransportServersBuilder.buildClientTransportServers(streamTracerFactories);\n+  public ServerImplBuilder directExecutor() {\n+    return executor(MoreExecutors.directExecutor());\n   }\n \n   @Override\n-  public void setDeadlineTicker(Deadline.Ticker ticker) {\n-    super.setDeadlineTicker(ticker);\n+  public ServerImplBuilder executor(@Nullable Executor executor) {\n+    this.executorPool = executor != null ? new FixedObjectPool<>(executor) : DEFAULT_EXECUTOR_POOL;\n+    return this;\n   }\n \n   @Override\n-  public void setTracingEnabled(boolean value) {\n-    super.setTracingEnabled(value);\n+  public ServerImplBuilder addService(ServerServiceDefinition service) {\n+    registryBuilder.addService(checkNotNull(service, \"service\"));\n+    return this;\n   }\n \n   @Override\n-  public void setStatsEnabled(boolean value) {\n-    super.setStatsEnabled(value);\n+  public ServerImplBuilder addService(BindableService bindableService) {\n+    return addService(checkNotNull(bindableService, \"bindableService\").bindService());\n   }\n \n   @Override\n-  public void setStatsRecordStartedRpcs(boolean value) {\n-    super.setStatsRecordStartedRpcs(value);\n+  public ServerImplBuilder addTransportFilter(ServerTransportFilter filter) {\n+    transportFilters.add(checkNotNull(filter, \"filter\"));\n+    return this;\n   }\n \n   @Override\n-  public void setStatsRecordFinishedRpcs(boolean value) {\n-    super.setStatsRecordFinishedRpcs(value);\n+  public ServerImplBuilder intercept(ServerInterceptor interceptor) {\n+    interceptors.add(checkNotNull(interceptor, \"interceptor\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder addStreamTracerFactory(ServerStreamTracer.Factory factory) {\n+    streamTracerFactories.add(checkNotNull(factory, \"factory\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder fallbackHandlerRegistry(@Nullable HandlerRegistry registry) {\n+    this.fallbackRegistry = registry != null ? registry : DEFAULT_FALLBACK_REGISTRY;\n+    return this;\n   }\n \n   @Override\n+  public ServerImplBuilder decompressorRegistry(@Nullable DecompressorRegistry registry) {\n+    this.decompressorRegistry = registry != null ? registry : DEFAULT_DECOMPRESSOR_REGISTRY;\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder compressorRegistry(@Nullable CompressorRegistry registry) {\n+    this.compressorRegistry = registry != null ? registry : DEFAULT_COMPRESSOR_REGISTRY;\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder handshakeTimeout(long timeout, TimeUnit unit) {\n+    checkArgument(timeout > 0, \"handshake timeout is %s, but must be positive\", timeout);\n+    this.handshakeTimeoutMillis = checkNotNull(unit, \"unit\").toMillis(timeout);\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder setBinaryLog(@Nullable BinaryLog binaryLog) {\n+    this.binlog = binaryLog;\n+    return this;\n+  }\n+\n+  /**\n+   * Disable or enable stats features.  Enabled by default.\n+   */\n+  public void setStatsEnabled(boolean value) {\n+    this.statsEnabled = value;\n+  }\n+\n+  /**\n+   * Disable or enable stats recording for RPC upstarts.  Effective only if {@link\n+   * #setStatsEnabled} is set to true.  Enabled by default.\n+   */\n+  public void setStatsRecordStartedRpcs(boolean value) {\n+    recordStartedRpcs = value;\n+  }\n+\n+  /**\n+   * Disable or enable stats recording for RPC completions.  Effective only if {@link\n+   * #setStatsEnabled} is set to true.  Enabled by default.\n+   */\n+  public void setStatsRecordFinishedRpcs(boolean value) {\n+    recordFinishedRpcs = value;\n+  }\n+\n+  /**\n+   * Disable or enable real-time metrics recording.  Effective only if {@link #setStatsEnabled} is\n+   * set to true.  Disabled by default.\n+   */\n   public void setStatsRecordRealTimeMetrics(boolean value) {\n-    super.setStatsRecordRealTimeMetrics(value);\n+    recordRealTimeMetrics = value;\n+  }\n+\n+  /**\n+   * Disable or enable tracing features.  Enabled by default.\n+   */\n+  public void setTracingEnabled(boolean value) {\n+    tracingEnabled = value;\n+  }\n+\n+  /**\n+   * Sets a custom deadline ticker.  This should only be called from InProcessServerBuilder.\n+   */\n+  public void setDeadlineTicker(Deadline.Ticker ticker) {\n+    this.ticker = checkNotNull(ticker, \"ticker\");\n   }\n \n   @Override\n+  public Server build() {\n+    return new ServerImpl(this, buildTransportServers(getTracerFactories()), Context.ROOT);\n+  }\n+\n+  @VisibleForTesting\n+  List<? extends ServerStreamTracer.Factory> getTracerFactories() {\n+    ArrayList<ServerStreamTracer.Factory> tracerFactories = new ArrayList<>();\n+    if (statsEnabled) {\n+      ServerStreamTracer.Factory censusStatsTracerFactory = null;\n+      try {\n+        Class<?> censusStatsAccessor =\n+            Class.forName(\"io.grpc.census.InternalCensusStatsAccessor\");\n+        Method getServerStreamTracerFactoryMethod =\n+            censusStatsAccessor.getDeclaredMethod(\n+                \"getServerStreamTracerFactory\",\n+                boolean.class,\n+                boolean.class,\n+                boolean.class);\n+        censusStatsTracerFactory =\n+            (ServerStreamTracer.Factory) getServerStreamTracerFactoryMethod\n+                .invoke(\n+                    null,\n+                    recordStartedRpcs,\n+                    recordFinishedRpcs,\n+                    recordRealTimeMetrics);\n+      } catch (ClassNotFoundException e) {\n+        // Replace these separate catch statements with multicatch when Android min-API >= 19\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (NoSuchMethodException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (IllegalAccessException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (InvocationTargetException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      }\n+      if (censusStatsTracerFactory != null) {\n+        tracerFactories.add(censusStatsTracerFactory);\n+      }\n+    }\n+    if (tracingEnabled) {\n+      ServerStreamTracer.Factory tracingStreamTracerFactory = null;\n+      try {\n+        Class<?> censusTracingAccessor =\n+            Class.forName(\"io.grpc.census.InternalCensusTracingAccessor\");\n+        Method getServerStreamTracerFactoryMethod =\n+            censusTracingAccessor.getDeclaredMethod(\"getServerStreamTracerFactory\");\n+        tracingStreamTracerFactory =\n+            (ServerStreamTracer.Factory) getServerStreamTracerFactoryMethod.invoke(null);\n+      } catch (ClassNotFoundException e) {\n+        // Replace these separate catch statements with multicatch when Android min-API >= 19\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (NoSuchMethodException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (IllegalAccessException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (InvocationTargetException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      }\n+      if (tracingStreamTracerFactory != null) {\n+        tracerFactories.add(tracingStreamTracerFactory);\n+      }\n+    }\n+    tracerFactories.addAll(streamTracerFactories);\n+    tracerFactories.trimToSize();\n+    return Collections.unmodifiableList(tracerFactories);\n+  }\n+\n   public InternalChannelz getChannelz() {\n-    return super.getChannelz();\n+    return channelz;\n   }\n \n-  @Override\n+  /**\n+   * Transport implementors must implement {@link ClientTransportServersBuilder} to transport\n+   * specific information for the server. This method is mean for Transport implementors and should", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98a944d6b0a49e04af0c80a7af5975052ad49b75"}, "originalPosition": 300}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2OTYxOTIwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/io/grpc/internal/ServerImplBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QyMjowMzozM1rOHT3FXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNTo1MTo1NFrOHUSvJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NzQ4Ng==", "bodyText": "I wouldn't expect any transports to need this method and I don't see any references. It seems it could be made private or inlined into build(). If you want to keep it for ServerImplBuilderTest, then the javadoc comment isn't really appropriate.", "url": "https://github.com/grpc/grpc-java/pull/7432#discussion_r490587486", "createdAt": "2020-09-17T22:03:33Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ServerImplBuilder.java", "diffHunk": "@@ -44,62 +105,234 @@\n    * Creates a new server builder with given transport servers provider.\n    */\n   public ServerImplBuilder(ClientTransportServersBuilder clientTransportServersBuilder) {\n-    this.clientTransportServersBuilder = Preconditions\n-        .checkNotNull(clientTransportServersBuilder, \"clientTransportServersBuilder\");\n+    this.clientTransportServersBuilder = checkNotNull(clientTransportServersBuilder,\n+        \"clientTransportServersBuilder\");\n   }\n \n   @Override\n-  protected List<? extends InternalServer> buildTransportServers(\n-      List<? extends ServerStreamTracer.Factory> streamTracerFactories) {\n-    return clientTransportServersBuilder.buildClientTransportServers(streamTracerFactories);\n+  public ServerImplBuilder directExecutor() {\n+    return executor(MoreExecutors.directExecutor());\n   }\n \n   @Override\n-  public void setDeadlineTicker(Deadline.Ticker ticker) {\n-    super.setDeadlineTicker(ticker);\n+  public ServerImplBuilder executor(@Nullable Executor executor) {\n+    this.executorPool = executor != null ? new FixedObjectPool<>(executor) : DEFAULT_EXECUTOR_POOL;\n+    return this;\n   }\n \n   @Override\n-  public void setTracingEnabled(boolean value) {\n-    super.setTracingEnabled(value);\n+  public ServerImplBuilder addService(ServerServiceDefinition service) {\n+    registryBuilder.addService(checkNotNull(service, \"service\"));\n+    return this;\n   }\n \n   @Override\n-  public void setStatsEnabled(boolean value) {\n-    super.setStatsEnabled(value);\n+  public ServerImplBuilder addService(BindableService bindableService) {\n+    return addService(checkNotNull(bindableService, \"bindableService\").bindService());\n   }\n \n   @Override\n-  public void setStatsRecordStartedRpcs(boolean value) {\n-    super.setStatsRecordStartedRpcs(value);\n+  public ServerImplBuilder addTransportFilter(ServerTransportFilter filter) {\n+    transportFilters.add(checkNotNull(filter, \"filter\"));\n+    return this;\n   }\n \n   @Override\n-  public void setStatsRecordFinishedRpcs(boolean value) {\n-    super.setStatsRecordFinishedRpcs(value);\n+  public ServerImplBuilder intercept(ServerInterceptor interceptor) {\n+    interceptors.add(checkNotNull(interceptor, \"interceptor\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder addStreamTracerFactory(ServerStreamTracer.Factory factory) {\n+    streamTracerFactories.add(checkNotNull(factory, \"factory\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder fallbackHandlerRegistry(@Nullable HandlerRegistry registry) {\n+    this.fallbackRegistry = registry != null ? registry : DEFAULT_FALLBACK_REGISTRY;\n+    return this;\n   }\n \n   @Override\n+  public ServerImplBuilder decompressorRegistry(@Nullable DecompressorRegistry registry) {\n+    this.decompressorRegistry = registry != null ? registry : DEFAULT_DECOMPRESSOR_REGISTRY;\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder compressorRegistry(@Nullable CompressorRegistry registry) {\n+    this.compressorRegistry = registry != null ? registry : DEFAULT_COMPRESSOR_REGISTRY;\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder handshakeTimeout(long timeout, TimeUnit unit) {\n+    checkArgument(timeout > 0, \"handshake timeout is %s, but must be positive\", timeout);\n+    this.handshakeTimeoutMillis = checkNotNull(unit, \"unit\").toMillis(timeout);\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder setBinaryLog(@Nullable BinaryLog binaryLog) {\n+    this.binlog = binaryLog;\n+    return this;\n+  }\n+\n+  /**\n+   * Disable or enable stats features.  Enabled by default.\n+   */\n+  public void setStatsEnabled(boolean value) {\n+    this.statsEnabled = value;\n+  }\n+\n+  /**\n+   * Disable or enable stats recording for RPC upstarts.  Effective only if {@link\n+   * #setStatsEnabled} is set to true.  Enabled by default.\n+   */\n+  public void setStatsRecordStartedRpcs(boolean value) {\n+    recordStartedRpcs = value;\n+  }\n+\n+  /**\n+   * Disable or enable stats recording for RPC completions.  Effective only if {@link\n+   * #setStatsEnabled} is set to true.  Enabled by default.\n+   */\n+  public void setStatsRecordFinishedRpcs(boolean value) {\n+    recordFinishedRpcs = value;\n+  }\n+\n+  /**\n+   * Disable or enable real-time metrics recording.  Effective only if {@link #setStatsEnabled} is\n+   * set to true.  Disabled by default.\n+   */\n   public void setStatsRecordRealTimeMetrics(boolean value) {\n-    super.setStatsRecordRealTimeMetrics(value);\n+    recordRealTimeMetrics = value;\n+  }\n+\n+  /**\n+   * Disable or enable tracing features.  Enabled by default.\n+   */\n+  public void setTracingEnabled(boolean value) {\n+    tracingEnabled = value;\n+  }\n+\n+  /**\n+   * Sets a custom deadline ticker.  This should only be called from InProcessServerBuilder.\n+   */\n+  public void setDeadlineTicker(Deadline.Ticker ticker) {\n+    this.ticker = checkNotNull(ticker, \"ticker\");\n   }\n \n   @Override\n+  public Server build() {\n+    return new ServerImpl(this, buildTransportServers(getTracerFactories()), Context.ROOT);\n+  }\n+\n+  @VisibleForTesting\n+  List<? extends ServerStreamTracer.Factory> getTracerFactories() {\n+    ArrayList<ServerStreamTracer.Factory> tracerFactories = new ArrayList<>();\n+    if (statsEnabled) {\n+      ServerStreamTracer.Factory censusStatsTracerFactory = null;\n+      try {\n+        Class<?> censusStatsAccessor =\n+            Class.forName(\"io.grpc.census.InternalCensusStatsAccessor\");\n+        Method getServerStreamTracerFactoryMethod =\n+            censusStatsAccessor.getDeclaredMethod(\n+                \"getServerStreamTracerFactory\",\n+                boolean.class,\n+                boolean.class,\n+                boolean.class);\n+        censusStatsTracerFactory =\n+            (ServerStreamTracer.Factory) getServerStreamTracerFactoryMethod\n+                .invoke(\n+                    null,\n+                    recordStartedRpcs,\n+                    recordFinishedRpcs,\n+                    recordRealTimeMetrics);\n+      } catch (ClassNotFoundException e) {\n+        // Replace these separate catch statements with multicatch when Android min-API >= 19\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (NoSuchMethodException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (IllegalAccessException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (InvocationTargetException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      }\n+      if (censusStatsTracerFactory != null) {\n+        tracerFactories.add(censusStatsTracerFactory);\n+      }\n+    }\n+    if (tracingEnabled) {\n+      ServerStreamTracer.Factory tracingStreamTracerFactory = null;\n+      try {\n+        Class<?> censusTracingAccessor =\n+            Class.forName(\"io.grpc.census.InternalCensusTracingAccessor\");\n+        Method getServerStreamTracerFactoryMethod =\n+            censusTracingAccessor.getDeclaredMethod(\"getServerStreamTracerFactory\");\n+        tracingStreamTracerFactory =\n+            (ServerStreamTracer.Factory) getServerStreamTracerFactoryMethod.invoke(null);\n+      } catch (ClassNotFoundException e) {\n+        // Replace these separate catch statements with multicatch when Android min-API >= 19\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (NoSuchMethodException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (IllegalAccessException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (InvocationTargetException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      }\n+      if (tracingStreamTracerFactory != null) {\n+        tracerFactories.add(tracingStreamTracerFactory);\n+      }\n+    }\n+    tracerFactories.addAll(streamTracerFactories);\n+    tracerFactories.trimToSize();\n+    return Collections.unmodifiableList(tracerFactories);\n+  }\n+\n   public InternalChannelz getChannelz() {\n-    return super.getChannelz();\n+    return channelz;\n   }\n \n-  @Override\n+  /**\n+   * Transport implementors must implement {@link ClientTransportServersBuilder} to transport\n+   * specific information for the server. This method is mean for Transport implementors and should\n+   * not be used by normal users.\n+   *\n+   * @param streamTracerFactories an immutable list of stream tracer factories\n+   */\n+  @VisibleForTesting\n+  List<? extends InternalServer> buildTransportServers(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98a944d6b0a49e04af0c80a7af5975052ad49b75"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTA0MDU0OA==", "bodyText": "I don't think that single test valuable anymore, so I went with removing the test, and inlining buildTransportServers into build.", "url": "https://github.com/grpc/grpc-java/pull/7432#discussion_r491040548", "createdAt": "2020-09-18T15:51:54Z", "author": {"login": "sergiitk"}, "path": "core/src/main/java/io/grpc/internal/ServerImplBuilder.java", "diffHunk": "@@ -44,62 +105,234 @@\n    * Creates a new server builder with given transport servers provider.\n    */\n   public ServerImplBuilder(ClientTransportServersBuilder clientTransportServersBuilder) {\n-    this.clientTransportServersBuilder = Preconditions\n-        .checkNotNull(clientTransportServersBuilder, \"clientTransportServersBuilder\");\n+    this.clientTransportServersBuilder = checkNotNull(clientTransportServersBuilder,\n+        \"clientTransportServersBuilder\");\n   }\n \n   @Override\n-  protected List<? extends InternalServer> buildTransportServers(\n-      List<? extends ServerStreamTracer.Factory> streamTracerFactories) {\n-    return clientTransportServersBuilder.buildClientTransportServers(streamTracerFactories);\n+  public ServerImplBuilder directExecutor() {\n+    return executor(MoreExecutors.directExecutor());\n   }\n \n   @Override\n-  public void setDeadlineTicker(Deadline.Ticker ticker) {\n-    super.setDeadlineTicker(ticker);\n+  public ServerImplBuilder executor(@Nullable Executor executor) {\n+    this.executorPool = executor != null ? new FixedObjectPool<>(executor) : DEFAULT_EXECUTOR_POOL;\n+    return this;\n   }\n \n   @Override\n-  public void setTracingEnabled(boolean value) {\n-    super.setTracingEnabled(value);\n+  public ServerImplBuilder addService(ServerServiceDefinition service) {\n+    registryBuilder.addService(checkNotNull(service, \"service\"));\n+    return this;\n   }\n \n   @Override\n-  public void setStatsEnabled(boolean value) {\n-    super.setStatsEnabled(value);\n+  public ServerImplBuilder addService(BindableService bindableService) {\n+    return addService(checkNotNull(bindableService, \"bindableService\").bindService());\n   }\n \n   @Override\n-  public void setStatsRecordStartedRpcs(boolean value) {\n-    super.setStatsRecordStartedRpcs(value);\n+  public ServerImplBuilder addTransportFilter(ServerTransportFilter filter) {\n+    transportFilters.add(checkNotNull(filter, \"filter\"));\n+    return this;\n   }\n \n   @Override\n-  public void setStatsRecordFinishedRpcs(boolean value) {\n-    super.setStatsRecordFinishedRpcs(value);\n+  public ServerImplBuilder intercept(ServerInterceptor interceptor) {\n+    interceptors.add(checkNotNull(interceptor, \"interceptor\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder addStreamTracerFactory(ServerStreamTracer.Factory factory) {\n+    streamTracerFactories.add(checkNotNull(factory, \"factory\"));\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder fallbackHandlerRegistry(@Nullable HandlerRegistry registry) {\n+    this.fallbackRegistry = registry != null ? registry : DEFAULT_FALLBACK_REGISTRY;\n+    return this;\n   }\n \n   @Override\n+  public ServerImplBuilder decompressorRegistry(@Nullable DecompressorRegistry registry) {\n+    this.decompressorRegistry = registry != null ? registry : DEFAULT_DECOMPRESSOR_REGISTRY;\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder compressorRegistry(@Nullable CompressorRegistry registry) {\n+    this.compressorRegistry = registry != null ? registry : DEFAULT_COMPRESSOR_REGISTRY;\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder handshakeTimeout(long timeout, TimeUnit unit) {\n+    checkArgument(timeout > 0, \"handshake timeout is %s, but must be positive\", timeout);\n+    this.handshakeTimeoutMillis = checkNotNull(unit, \"unit\").toMillis(timeout);\n+    return this;\n+  }\n+\n+  @Override\n+  public ServerImplBuilder setBinaryLog(@Nullable BinaryLog binaryLog) {\n+    this.binlog = binaryLog;\n+    return this;\n+  }\n+\n+  /**\n+   * Disable or enable stats features.  Enabled by default.\n+   */\n+  public void setStatsEnabled(boolean value) {\n+    this.statsEnabled = value;\n+  }\n+\n+  /**\n+   * Disable or enable stats recording for RPC upstarts.  Effective only if {@link\n+   * #setStatsEnabled} is set to true.  Enabled by default.\n+   */\n+  public void setStatsRecordStartedRpcs(boolean value) {\n+    recordStartedRpcs = value;\n+  }\n+\n+  /**\n+   * Disable or enable stats recording for RPC completions.  Effective only if {@link\n+   * #setStatsEnabled} is set to true.  Enabled by default.\n+   */\n+  public void setStatsRecordFinishedRpcs(boolean value) {\n+    recordFinishedRpcs = value;\n+  }\n+\n+  /**\n+   * Disable or enable real-time metrics recording.  Effective only if {@link #setStatsEnabled} is\n+   * set to true.  Disabled by default.\n+   */\n   public void setStatsRecordRealTimeMetrics(boolean value) {\n-    super.setStatsRecordRealTimeMetrics(value);\n+    recordRealTimeMetrics = value;\n+  }\n+\n+  /**\n+   * Disable or enable tracing features.  Enabled by default.\n+   */\n+  public void setTracingEnabled(boolean value) {\n+    tracingEnabled = value;\n+  }\n+\n+  /**\n+   * Sets a custom deadline ticker.  This should only be called from InProcessServerBuilder.\n+   */\n+  public void setDeadlineTicker(Deadline.Ticker ticker) {\n+    this.ticker = checkNotNull(ticker, \"ticker\");\n   }\n \n   @Override\n+  public Server build() {\n+    return new ServerImpl(this, buildTransportServers(getTracerFactories()), Context.ROOT);\n+  }\n+\n+  @VisibleForTesting\n+  List<? extends ServerStreamTracer.Factory> getTracerFactories() {\n+    ArrayList<ServerStreamTracer.Factory> tracerFactories = new ArrayList<>();\n+    if (statsEnabled) {\n+      ServerStreamTracer.Factory censusStatsTracerFactory = null;\n+      try {\n+        Class<?> censusStatsAccessor =\n+            Class.forName(\"io.grpc.census.InternalCensusStatsAccessor\");\n+        Method getServerStreamTracerFactoryMethod =\n+            censusStatsAccessor.getDeclaredMethod(\n+                \"getServerStreamTracerFactory\",\n+                boolean.class,\n+                boolean.class,\n+                boolean.class);\n+        censusStatsTracerFactory =\n+            (ServerStreamTracer.Factory) getServerStreamTracerFactoryMethod\n+                .invoke(\n+                    null,\n+                    recordStartedRpcs,\n+                    recordFinishedRpcs,\n+                    recordRealTimeMetrics);\n+      } catch (ClassNotFoundException e) {\n+        // Replace these separate catch statements with multicatch when Android min-API >= 19\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (NoSuchMethodException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (IllegalAccessException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (InvocationTargetException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      }\n+      if (censusStatsTracerFactory != null) {\n+        tracerFactories.add(censusStatsTracerFactory);\n+      }\n+    }\n+    if (tracingEnabled) {\n+      ServerStreamTracer.Factory tracingStreamTracerFactory = null;\n+      try {\n+        Class<?> censusTracingAccessor =\n+            Class.forName(\"io.grpc.census.InternalCensusTracingAccessor\");\n+        Method getServerStreamTracerFactoryMethod =\n+            censusTracingAccessor.getDeclaredMethod(\"getServerStreamTracerFactory\");\n+        tracingStreamTracerFactory =\n+            (ServerStreamTracer.Factory) getServerStreamTracerFactoryMethod.invoke(null);\n+      } catch (ClassNotFoundException e) {\n+        // Replace these separate catch statements with multicatch when Android min-API >= 19\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (NoSuchMethodException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (IllegalAccessException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      } catch (InvocationTargetException e) {\n+        log.log(Level.FINE, \"Unable to apply census stats\", e);\n+      }\n+      if (tracingStreamTracerFactory != null) {\n+        tracerFactories.add(tracingStreamTracerFactory);\n+      }\n+    }\n+    tracerFactories.addAll(streamTracerFactories);\n+    tracerFactories.trimToSize();\n+    return Collections.unmodifiableList(tracerFactories);\n+  }\n+\n   public InternalChannelz getChannelz() {\n-    return super.getChannelz();\n+    return channelz;\n   }\n \n-  @Override\n+  /**\n+   * Transport implementors must implement {@link ClientTransportServersBuilder} to transport\n+   * specific information for the server. This method is mean for Transport implementors and should\n+   * not be used by normal users.\n+   *\n+   * @param streamTracerFactories an immutable list of stream tracer factories\n+   */\n+  @VisibleForTesting\n+  List<? extends InternalServer> buildTransportServers(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NzQ4Ng=="}, "originalCommit": {"oid": "98a944d6b0a49e04af0c80a7af5975052ad49b75"}, "originalPosition": 306}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2346, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}