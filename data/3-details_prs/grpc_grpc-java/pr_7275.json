{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU5OTQwOTU1", "number": 7275, "title": "xds: implement routing in xDS resolver with config selector API", "bodyText": "Implement xDS request routing with new architecture: make route decision in a config selector emitted by the xDS resolver.\nTests are subtle. Refactored to use a fake XdsClient for testing, which significantly reduces the complexity for triggering code under test. Further cleanup might be necessary.\nShould not be merged until Channel/ClientCall's integration of config selector is done. Otherwise, the whole xDS LB code path will be broken.", "createdAt": "2020-07-31T09:02:08Z", "url": "https://github.com/grpc/grpc-java/pull/7275", "merged": true, "mergeCommit": {"oid": "292f3b954af6af2f6097f729c9794aa2d4ffca15"}, "closed": true, "closedAt": "2020-08-24T22:42:19Z", "author": {"login": "voidzcy"}, "timelineItems": {"totalCount": 58, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc6QSuAgH2gAyNDU5OTQwOTU1OjU0MTFmZjg5MTdhZjdlYzQwZGU0MDc3OTc3ZjgyZDQ5YTI0YzYyY2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCKbcxgFqTQ3MzkzMDExNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5411ff8917af7ec40de4077977f82d49a24c62ce", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/5411ff8917af7ec40de4077977f82d49a24c62ce", "committedDate": "2020-07-31T08:52:37Z", "message": "Implement routing logic with ConfigSelector API inside the xDS resolver."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1ba6b14595d1707a3e0af79ef8ff67e3a3eea1e", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/e1ba6b14595d1707a3e0af79ef8ff67e3a3eea1e", "committedDate": "2020-07-31T08:53:00Z", "message": "Eliminate Gson dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "275eb07237ccfabae580618607d7f83440f8b8b5", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/275eb07237ccfabae580618607d7f83440f8b8b5", "committedDate": "2020-07-31T08:53:15Z", "message": "Clean up tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b02c66e42691dc92914dac5757d60952293cfa0e", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/b02c66e42691dc92914dac5757d60952293cfa0e", "committedDate": "2020-07-31T09:00:42Z", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/resolver_routing_with_config_selector"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23ed13ae910c87f25297076cef1cfd80a58fa353", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/23ed13ae910c87f25297076cef1cfd80a58fa353", "committedDate": "2020-07-31T19:13:02Z", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/resolver_routing_with_config_selector"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3788dfb75d7fe9274878cfac87027e5b9e66e2ae", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/3788dfb75d7fe9274878cfac87027e5b9e66e2ae", "committedDate": "2020-07-31T21:31:13Z", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/resolver_routing_with_config_selector"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb2fa57478a8ed9d79f6c8812d61d26d871a9cc2", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/bb2fa57478a8ed9d79f6c8812d61d26d871a9cc2", "committedDate": "2020-08-01T01:12:03Z", "message": "Delete old xDS name resolver tests, which involves very complicated interaction with xDS server."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e88dcf1433dad1fea546dc64ca1bef072b7f49e0", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/e88dcf1433dad1fea546dc64ca1bef072b7f49e0", "committedDate": "2020-08-01T02:02:30Z", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/resolver_routing_with_config_selector"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27259466e2b0d4d9f58c787d8be6d802c014c479", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/27259466e2b0d4d9f58c787d8be6d802c014c479", "committedDate": "2020-08-03T09:41:25Z", "message": "Change ConfigSelector result's config to type ConfigOrError."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "251a723abef740ad31c652d2a292bd4cbab1906d", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/251a723abef740ad31c652d2a292bd4cbab1906d", "committedDate": "2020-08-03T09:42:27Z", "message": "Expose the simple constructor of RouteMatch for testing."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d0e485ae04e04d4a1774e906255ce7d70fee03a", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/6d0e485ae04e04d4a1774e906255ce7d70fee03a", "committedDate": "2020-08-03T09:43:43Z", "message": "Introduce XdsClientPoolFactory interface for injecting a mock XdsClient for testing purposes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bcf1ed0cc08e7e4736a7fbc731dfe0b39d2d915", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/9bcf1ed0cc08e7e4736a7fbc731dfe0b39d2d915", "committedDate": "2020-08-03T09:44:56Z", "message": "Completes xDS config selector for per-method timeout and add tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5aaedd6f8bfdbc5b57fa759b3341cc959596e4a", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/a5aaedd6f8bfdbc5b57fa759b3341cc959596e4a", "committedDate": "2020-08-03T17:38:56Z", "message": "Fix style."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a553bf7e74eea746cf2e206036ed1f563f32c260", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/a553bf7e74eea746cf2e206036ed1f563f32c260", "committedDate": "2020-08-03T18:08:46Z", "message": "Add comments for some important checkpoints."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f51d1d4b7616e790adae22ecc6bf994ff4bb0502", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/f51d1d4b7616e790adae22ecc6bf994ff4bb0502", "committedDate": "2020-08-03T18:30:27Z", "message": "Add test coverage for cases routing to weighted clusters."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b26e9d47dcd104beebaa9c4afbc3888e447decae", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/b26e9d47dcd104beebaa9c4afbc3888e447decae", "committedDate": "2020-08-03T18:36:13Z", "message": "Clean up the CallOption key for passing selected cluster name to top-level load balancer."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f5bf8b47ee345147efcb767c5b926b9feb59c99", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/1f5bf8b47ee345147efcb767c5b926b9feb59c99", "committedDate": "2020-08-03T18:42:17Z", "message": "Add TODO for further cleanup."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjU3NTA4", "url": "https://github.com/grpc/grpc-java/pull/7275#pullrequestreview-461257508", "createdAt": "2020-08-05T00:12:39Z", "commit": {"oid": "1f5bf8b47ee345147efcb767c5b926b9feb59c99"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMDoxMjozOVrOG71sBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMDozMTo1OVrOG72AhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5ODc5MA==", "bodyText": "Why not just have ConfigOrError instead of Status and ConfigOrError? Although one is before parsing the other is after parsing, for the user of Result, they don't seem like to check error twice and distinguish between error from Status and error from ConfigOrError.\nResult.forError(error) can just create a result with Result.config.getError() being that error.", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r465398790", "createdAt": "2020-08-05T00:12:39Z", "author": {"login": "dapengzhang0"}, "path": "api/src/main/java/io/grpc/InternalConfigSelector.java", "diffHunk": "@@ -41,14 +42,14 @@\n   public static final class Result {\n     private final Status status;\n     @Nullable\n-    private final Object config;\n+    private final ConfigOrError config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f5bf8b47ee345147efcb767c5b926b9feb59c99"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwNDAzNg==", "bodyText": "Why adding this method to a Factory class? Why not pass bootstrapInfo object to the constructor of XdsClientPoolFactory implementation?", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r465404036", "createdAt": "2020-08-05T00:31:59Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsClient.java", "diffHunk": "@@ -671,4 +673,11 @@ boolean isUseProtocolV3() {\n       return useProtocolV3;\n     }\n   }\n+\n+  interface XdsClientPoolFactory {\n+\n+    void bootstrap() throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f5bf8b47ee345147efcb767c5b926b9feb59c99"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27a49060def9e01fe8393ac666a83ce9d3c1201e", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/27a49060def9e01fe8393ac666a83ce9d3c1201e", "committedDate": "2020-08-05T23:07:07Z", "message": "Change back to have ConfigSelector's Result contain the real config."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb0b541454eb990c1dcf0307e403043f8bd2c702", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/bb0b541454eb990c1dcf0307e403043f8bd2c702", "committedDate": "2020-08-05T23:07:58Z", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/resolver_routing_with_config_selector"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48d43cde64692c52c19ddce845376c177483b0d8", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/48d43cde64692c52c19ddce845376c177483b0d8", "committedDate": "2020-08-07T08:56:16Z", "message": "Pass bootstrap info as arguement for creating an XdsClient pool."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed739200c167c950fa164888618bf394d707cffb", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/ed739200c167c950fa164888618bf394d707cffb", "committedDate": "2020-08-07T09:07:33Z", "message": "Move new name resolver implementations into separate files and restore the old implementation."}, "afterCommit": {"oid": "afc450b9e627fefe7904a2f9a0054e445b20fa0b", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/afc450b9e627fefe7904a2f9a0054e445b20fa0b", "committedDate": "2020-08-07T09:09:20Z", "message": "Move new name resolver implementations into separate files and restore the old implementation."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "afc450b9e627fefe7904a2f9a0054e445b20fa0b", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/afc450b9e627fefe7904a2f9a0054e445b20fa0b", "committedDate": "2020-08-07T09:09:20Z", "message": "Move new name resolver implementations into separate files and restore the old implementation."}, "afterCommit": {"oid": "86fb85f82ff3d40be38c85ec60bd86a59354c40f", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/86fb85f82ff3d40be38c85ec60bd86a59354c40f", "committedDate": "2020-08-07T09:10:04Z", "message": "Move new name resolver implementations into separate files and restore the old implementation."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "86fb85f82ff3d40be38c85ec60bd86a59354c40f", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/86fb85f82ff3d40be38c85ec60bd86a59354c40f", "committedDate": "2020-08-07T09:10:04Z", "message": "Move new name resolver implementations into separate files and restore the old implementation."}, "afterCommit": {"oid": "5e4629090621b0bac94ab653ce4fb600c2b04c80", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/5e4629090621b0bac94ab653ce4fb600c2b04c80", "committedDate": "2020-08-07T09:13:02Z", "message": "Move new name resolver implementations into separate files and restore the old implementation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d6a13705e63a21d40bb57942df70d36a39053a2", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/1d6a13705e63a21d40bb57942df70d36a39053a2", "committedDate": "2020-08-07T09:14:28Z", "message": "Move new name resolver implementations into separate files and restore the old implementation."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5e4629090621b0bac94ab653ce4fb600c2b04c80", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/5e4629090621b0bac94ab653ce4fb600c2b04c80", "committedDate": "2020-08-07T09:13:02Z", "message": "Move new name resolver implementations into separate files and restore the old implementation."}, "afterCommit": {"oid": "1d6a13705e63a21d40bb57942df70d36a39053a2", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/1d6a13705e63a21d40bb57942df70d36a39053a2", "committedDate": "2020-08-07T09:14:28Z", "message": "Move new name resolver implementations into separate files and restore the old implementation."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDg2NTA0", "url": "https://github.com/grpc/grpc-java/pull/7275#pullrequestreview-463486504", "createdAt": "2020-08-07T17:34:27Z", "commit": {"oid": "1d6a13705e63a21d40bb57942df70d36a39053a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzozNDoyN1rOG9iNsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzozNDoyN1rOG9iNsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3Njg4Mg==", "bodyText": "Could this refCount be null? A serious problem is that routes and clusterRefs are not updated atomically. retainCluster() is not run in synchronization context, so it's hard for me to verify the correctness.", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r467176882", "createdAt": "2020-08-07T17:34:27Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final Map<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      String serviceConfigJson =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      ConfigOrError parsedServiceConfig = parseServiceConfig(serviceConfigJson);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d6a13705e63a21d40bb57942df70d36a39053a2"}, "originalPosition": 206}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab0eda90a6356f6c13cb35c0c49636e21805bf67", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/ab0eda90a6356f6c13cb35c0c49636e21805bf67", "committedDate": "2020-08-07T17:34:41Z", "message": "Suppress warning for modifying in the loop of concurrent map."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09e5276429b949546dc7e310c11c88a0c29428d7", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/09e5276429b949546dc7e310c11c88a0c29428d7", "committedDate": "2020-08-07T17:59:42Z", "message": "Fix race for cluster being removed while adding new clusters."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a043483e59aab3c471c5069bed96815971a6f89", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/0a043483e59aab3c471c5069bed96815971a6f89", "committedDate": "2020-08-07T17:52:31Z", "message": "Fix race for cluster being removed while adding new clusters."}, "afterCommit": {"oid": "09e5276429b949546dc7e310c11c88a0c29428d7", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/09e5276429b949546dc7e310c11c88a0c29428d7", "committedDate": "2020-08-07T17:59:42Z", "message": "Fix race for cluster being removed while adding new clusters."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNTkxOTE5", "url": "https://github.com/grpc/grpc-java/pull/7275#pullrequestreview-463591919", "createdAt": "2020-08-07T20:27:54Z", "commit": {"oid": "09e5276429b949546dc7e310c11c88a0c29428d7"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMDoyNzo1NVrOG9m6Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QyMDozNDowMlrOG9nD8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1Mzg1MA==", "bodyText": "Why all these INFO logs? We shouldn't be logging anything in normal flows.", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r467253850", "createdAt": "2020-08-07T20:27:55Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09e5276429b949546dc7e310c11c88a0c29428d7"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NTQ1Mg==", "bodyText": "Why generate a JSON string? Why not the data structure directly?", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r467255452", "createdAt": "2020-08-07T20:31:52Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      String serviceConfigJson =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      ConfigOrError parsedServiceConfig = parseServiceConfig(serviceConfigJson);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    String serviceConfigJson = generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    logger.log(XdsLogLevel.INFO, \"Generated service config:\\n{0}\", serviceConfigJson);\n+    ConfigOrError parsedServiceConfig = parseServiceConfig(serviceConfigJson);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Set<String> clusters = new HashSet<>();\n+      for (Route route : update.getRoutes()) {\n+        RouteAction action = route.getRouteAction();\n+        if (action.getCluster() != null) {\n+          clusters.add(action.getCluster());\n+        } else if (action.getWeightedCluster() != null) {\n+          for (ClusterWeight weighedCluster : action.getWeightedCluster()) {\n+            clusters.add(weighedCluster.getName());\n+          }\n+        }\n+      }\n+      boolean receivedNewCluster = false;\n+      for (String newCluster : clusters) {\n+        if (clusterRefs.putIfAbsent(newCluster, new AtomicInteger(1)) == null) {\n+          receivedNewCluster = true;\n+        }\n+      }\n+      // Update service config to include newly added clusters.\n+      if (receivedNewCluster) {\n+        updateResolutionResult();\n+      }\n+      // Make newly added clusters selectable by config selector.\n+      routes = update.getRoutes();\n+      // Drops reference for deleted clusters, update service config to remove deleted clusters\n+      // not in use.\n+      boolean shouldUpdateResult = false;\n+      for (Map.Entry<String, AtomicInteger> entry : clusterRefs.entrySet()) {\n+        if (!clusters.contains(entry.getKey())) {\n+          int count = entry.getValue().decrementAndGet();\n+          if (count == 0) {\n+            clusterRefs.remove(entry.getKey());\n+            shouldUpdateResult = true;\n+          }\n+        }\n+      }\n+      if (shouldUpdateResult) {\n+        updateResolutionResult();\n+      }\n+    }\n+\n+    @Override\n+    public void onResourceDoesNotExist(String resourceName) {\n+      logger.log(XdsLogLevel.INFO, \"Resource {0} is unavailable\", resourceName);\n+      ConfigOrError parsedServiceConfig =\n+          serviceConfigParser.parseServiceConfig(Collections.<String, Object>emptyMap());\n+      ResolutionResult result =\n+          ResolutionResult.newBuilder()\n+              .setServiceConfig(parsedServiceConfig)\n+              // let channel take action for no config selector\n+              .build();\n+      listener.onResult(result);\n+    }\n+\n+    @Override\n+    public void onError(Status error) {\n+      logger.log(\n+          XdsLogLevel.WARNING,\n+          \"Received error from xDS client {0}: {1}\", xdsClient, error.getDescription());\n+      listener.onError(error);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private ConfigOrError parseServiceConfig(String serviceConfigJson) {\n+    Map<String, ?> serviceConfig;\n+    try {\n+      serviceConfig = (Map<String, ?>) JsonParser.parse(serviceConfigJson);\n+    } catch (IOException e) {\n+      return ConfigOrError.fromError(\n+          Status.INTERNAL.withCause(e).withDescription(\"bug: malformed service config\"));\n+    }\n+    return serviceConfigParser.parseServiceConfig(serviceConfig);\n+  }\n+\n+  @VisibleForTesting\n+  static String generateServiceConfigWithMethodConfig(\n+      String fullMethodName, long timeoutNano) {\n+    int index = fullMethodName.lastIndexOf('/');\n+    String serviceName = fullMethodName.substring(0, index);\n+    String methodName = fullMethodName.substring(index + 1);\n+    StringBuilder sb = new StringBuilder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09e5276429b949546dc7e310c11c88a0c29428d7"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NTc0Nw==", "bodyText": "Just use wildcard service/method?", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r467255747", "createdAt": "2020-08-07T20:32:33Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      String serviceConfigJson =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      ConfigOrError parsedServiceConfig = parseServiceConfig(serviceConfigJson);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    String serviceConfigJson = generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    logger.log(XdsLogLevel.INFO, \"Generated service config:\\n{0}\", serviceConfigJson);\n+    ConfigOrError parsedServiceConfig = parseServiceConfig(serviceConfigJson);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Set<String> clusters = new HashSet<>();\n+      for (Route route : update.getRoutes()) {\n+        RouteAction action = route.getRouteAction();\n+        if (action.getCluster() != null) {\n+          clusters.add(action.getCluster());\n+        } else if (action.getWeightedCluster() != null) {\n+          for (ClusterWeight weighedCluster : action.getWeightedCluster()) {\n+            clusters.add(weighedCluster.getName());\n+          }\n+        }\n+      }\n+      boolean receivedNewCluster = false;\n+      for (String newCluster : clusters) {\n+        if (clusterRefs.putIfAbsent(newCluster, new AtomicInteger(1)) == null) {\n+          receivedNewCluster = true;\n+        }\n+      }\n+      // Update service config to include newly added clusters.\n+      if (receivedNewCluster) {\n+        updateResolutionResult();\n+      }\n+      // Make newly added clusters selectable by config selector.\n+      routes = update.getRoutes();\n+      // Drops reference for deleted clusters, update service config to remove deleted clusters\n+      // not in use.\n+      boolean shouldUpdateResult = false;\n+      for (Map.Entry<String, AtomicInteger> entry : clusterRefs.entrySet()) {\n+        if (!clusters.contains(entry.getKey())) {\n+          int count = entry.getValue().decrementAndGet();\n+          if (count == 0) {\n+            clusterRefs.remove(entry.getKey());\n+            shouldUpdateResult = true;\n+          }\n+        }\n+      }\n+      if (shouldUpdateResult) {\n+        updateResolutionResult();\n+      }\n+    }\n+\n+    @Override\n+    public void onResourceDoesNotExist(String resourceName) {\n+      logger.log(XdsLogLevel.INFO, \"Resource {0} is unavailable\", resourceName);\n+      ConfigOrError parsedServiceConfig =\n+          serviceConfigParser.parseServiceConfig(Collections.<String, Object>emptyMap());\n+      ResolutionResult result =\n+          ResolutionResult.newBuilder()\n+              .setServiceConfig(parsedServiceConfig)\n+              // let channel take action for no config selector\n+              .build();\n+      listener.onResult(result);\n+    }\n+\n+    @Override\n+    public void onError(Status error) {\n+      logger.log(\n+          XdsLogLevel.WARNING,\n+          \"Received error from xDS client {0}: {1}\", xdsClient, error.getDescription());\n+      listener.onError(error);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private ConfigOrError parseServiceConfig(String serviceConfigJson) {\n+    Map<String, ?> serviceConfig;\n+    try {\n+      serviceConfig = (Map<String, ?>) JsonParser.parse(serviceConfigJson);\n+    } catch (IOException e) {\n+      return ConfigOrError.fromError(\n+          Status.INTERNAL.withCause(e).withDescription(\"bug: malformed service config\"));\n+    }\n+    return serviceConfigParser.parseServiceConfig(serviceConfig);\n+  }\n+\n+  @VisibleForTesting\n+  static String generateServiceConfigWithMethodConfig(\n+      String fullMethodName, long timeoutNano) {\n+    int index = fullMethodName.lastIndexOf('/');\n+    String serviceName = fullMethodName.substring(0, index);\n+    String methodName = fullMethodName.substring(index + 1);\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"{\\n\");\n+    sb.append(\"  \\\"methodConfig\\\": [{\\n\");\n+    sb.append(\"    \\\"name\\\": [{\\n\");\n+    sb.append(\"      \\\"service\\\": \\\"\" + serviceName + \"\\\",\\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09e5276429b949546dc7e310c11c88a0c29428d7"}, "originalPosition": 340}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NjMwNA==", "bodyText": "Cluster is not escaped properly. Are we sure it doesn't contain special characters?", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r467256304", "createdAt": "2020-08-07T20:34:02Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      String serviceConfigJson =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      ConfigOrError parsedServiceConfig = parseServiceConfig(serviceConfigJson);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    String serviceConfigJson = generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    logger.log(XdsLogLevel.INFO, \"Generated service config:\\n{0}\", serviceConfigJson);\n+    ConfigOrError parsedServiceConfig = parseServiceConfig(serviceConfigJson);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Set<String> clusters = new HashSet<>();\n+      for (Route route : update.getRoutes()) {\n+        RouteAction action = route.getRouteAction();\n+        if (action.getCluster() != null) {\n+          clusters.add(action.getCluster());\n+        } else if (action.getWeightedCluster() != null) {\n+          for (ClusterWeight weighedCluster : action.getWeightedCluster()) {\n+            clusters.add(weighedCluster.getName());\n+          }\n+        }\n+      }\n+      boolean receivedNewCluster = false;\n+      for (String newCluster : clusters) {\n+        if (clusterRefs.putIfAbsent(newCluster, new AtomicInteger(1)) == null) {\n+          receivedNewCluster = true;\n+        }\n+      }\n+      // Update service config to include newly added clusters.\n+      if (receivedNewCluster) {\n+        updateResolutionResult();\n+      }\n+      // Make newly added clusters selectable by config selector.\n+      routes = update.getRoutes();\n+      // Drops reference for deleted clusters, update service config to remove deleted clusters\n+      // not in use.\n+      boolean shouldUpdateResult = false;\n+      for (Map.Entry<String, AtomicInteger> entry : clusterRefs.entrySet()) {\n+        if (!clusters.contains(entry.getKey())) {\n+          int count = entry.getValue().decrementAndGet();\n+          if (count == 0) {\n+            clusterRefs.remove(entry.getKey());\n+            shouldUpdateResult = true;\n+          }\n+        }\n+      }\n+      if (shouldUpdateResult) {\n+        updateResolutionResult();\n+      }\n+    }\n+\n+    @Override\n+    public void onResourceDoesNotExist(String resourceName) {\n+      logger.log(XdsLogLevel.INFO, \"Resource {0} is unavailable\", resourceName);\n+      ConfigOrError parsedServiceConfig =\n+          serviceConfigParser.parseServiceConfig(Collections.<String, Object>emptyMap());\n+      ResolutionResult result =\n+          ResolutionResult.newBuilder()\n+              .setServiceConfig(parsedServiceConfig)\n+              // let channel take action for no config selector\n+              .build();\n+      listener.onResult(result);\n+    }\n+\n+    @Override\n+    public void onError(Status error) {\n+      logger.log(\n+          XdsLogLevel.WARNING,\n+          \"Received error from xDS client {0}: {1}\", xdsClient, error.getDescription());\n+      listener.onError(error);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private ConfigOrError parseServiceConfig(String serviceConfigJson) {\n+    Map<String, ?> serviceConfig;\n+    try {\n+      serviceConfig = (Map<String, ?>) JsonParser.parse(serviceConfigJson);\n+    } catch (IOException e) {\n+      return ConfigOrError.fromError(\n+          Status.INTERNAL.withCause(e).withDescription(\"bug: malformed service config\"));\n+    }\n+    return serviceConfigParser.parseServiceConfig(serviceConfig);\n+  }\n+\n+  @VisibleForTesting\n+  static String generateServiceConfigWithMethodConfig(\n+      String fullMethodName, long timeoutNano) {\n+    int index = fullMethodName.lastIndexOf('/');\n+    String serviceName = fullMethodName.substring(0, index);\n+    String methodName = fullMethodName.substring(index + 1);\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"{\\n\");\n+    sb.append(\"  \\\"methodConfig\\\": [{\\n\");\n+    sb.append(\"    \\\"name\\\": [{\\n\");\n+    sb.append(\"      \\\"service\\\": \\\"\" + serviceName + \"\\\",\\n\");\n+    sb.append(\"      \\\"method\\\": \\\"\" + methodName + \"\\\"\\n\");\n+    sb.append(\"    }],\\n\");\n+    sb.append(\"    \\\"timeout\\\": \\\"\" + timeoutNano / 1_000_000_000.0 + \"s\\\"\\n\");\n+    sb.append(\"  }]\\n\");\n+    sb.append(\"}\");\n+    return sb.toString();\n+  }\n+\n+  @VisibleForTesting\n+  static String generateServiceConfigWithLoadBalancingConfig(Collection<String> clusters) {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"{\\n\");\n+    sb.append(\"  \\\"loadBalancingConfig\\\": [{\\n\");\n+    sb.append(\"    \\\"cluster_manager_experimental\\\": {\\n\");\n+    sb.append(\"      \\\"childPolicy\\\": {\\n\");\n+    int i = 0;\n+    for (String cluster : clusters) {\n+      sb.append(\"        \\\"\" + cluster + \"\\\": {\\n\");\n+      sb.append(\"          \\\"lbPolicy\\\": [{\\n\");\n+      sb.append(\"            \\\"cds_experimental\\\": {\\n\");\n+      sb.append(\"              \\\"cluster\\\": \\\"\" + cluster + \"\\\"\\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09e5276429b949546dc7e310c11c88a0c29428d7"}, "originalPosition": 361}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ad3313c6d4aac296c3b24f7d8bcfa8abb83c7cc", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/8ad3313c6d4aac296c3b24f7d8bcfa8abb83c7cc", "committedDate": "2020-08-12T22:45:22Z", "message": "Generate Java service config struct instead of doing string concatenation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fda028939f53058885e0050d103c0d43d26316bb", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/fda028939f53058885e0050d103c0d43d26316bb", "committedDate": "2020-08-13T21:29:28Z", "message": "Delete unused variable."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjM2MTky", "url": "https://github.com/grpc/grpc-java/pull/7275#pullrequestreview-464636192", "createdAt": "2020-08-10T22:42:16Z", "commit": {"oid": "09e5276429b949546dc7e310c11c88a0c29428d7"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMjo0MjoxN1rOG-iOeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNTozMDo0NFrOHA5KGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNTY1Nw==", "bodyText": "\"route\" can mean a lot of things. Should we say \"Could not find xDS route matching RPC\"?", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r468225657", "createdAt": "2020-08-10T22:42:17Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09e5276429b949546dc7e310c11c88a0c29428d7"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNjU4NA==", "bodyText": "How is it possible to get here with a null cluster? Aren't we guaranteed to have a cluster result here? How is it possible to go through the if or the else and not choose a cluster?", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r468226584", "createdAt": "2020-08-10T22:45:01Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09e5276429b949546dc7e310c11c88a0c29428d7"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNzc0MA==", "bodyText": "I don't think we want to do the service config generation and parsing for each RPC. That code should not be placed on the critical path, as we don't want performance pressure placed on it. It seems we should generate them ahead-of-time and just use the config object here.\nThis can be fine as a first cut, but we should consider when we'll improve it.", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r468227740", "createdAt": "2020-08-10T22:48:32Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,391 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.JsonParser;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      String serviceConfigJson =\n+          generateServiceConfigWithMethodConfig(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09e5276429b949546dc7e310c11c88a0c29428d7"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MTk4Ng==", "bodyText": "\"Failed to load xds bootstrap\" or \"xds failed to bootstrap\"\nWe need \"xds\" or something like that in the message. Otherwise there's no clue what this is talking about.", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470661986", "createdAt": "2020-08-14T14:35:28Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fda028939f53058885e0050d103c0d43d26316bb"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2NDA3NA==", "bodyText": "This seems a weird place for this class. I'd expect it to be either near its usage (start()) or after the normal methods (shutdown()).", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470664074", "createdAt": "2020-08-14T14:39:27Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    Map<String, ?> rawServiceConfig =\n+        generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(\n+          XdsLogLevel.INFO, \"Generated service config:\\n{0}\", new Gson().toJson(rawServiceConfig));\n+    }\n+    ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fda028939f53058885e0050d103c0d43d26316bb"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3MzAwMw==", "bodyText": "This seems unnecessarily brittle. It seems we could really easily just fail the one RPC instead of bringing down the entire channel. I could understand doing this if we were really confident in our service config generation, but given user data is placed inside it it seems very possible that it is broken for just some inputs.", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470673003", "createdAt": "2020-08-14T14:50:21Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fda028939f53058885e0050d103c0d43d26316bb"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3NjA2OA==", "bodyText": "I know it isn't necessary, but for sanity's sake can we do this within the syncContext?", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470676068", "createdAt": "2020-08-14T14:55:24Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fda028939f53058885e0050d103c0d43d26316bb"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY3ODY3Ng==", "bodyText": "Reuse the same config selector? That would allow ManagedChannelImpl to avoid the AtomicReference.set() when the selector is identical to the previous version, if it wants to. It also makes it more obvious that it doesn't have internal state.", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470678676", "createdAt": "2020-08-14T14:59:48Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    Map<String, ?> rawServiceConfig =\n+        generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(\n+          XdsLogLevel.INFO, \"Generated service config:\\n{0}\", new Gson().toJson(rawServiceConfig));\n+    }\n+    ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fda028939f53058885e0050d103c0d43d26316bb"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY4MDA3OA==", "bodyText": "Put google/error-prone#1767 as the comment.", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470680078", "createdAt": "2020-08-14T15:02:15Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    Map<String, ?> rawServiceConfig =\n+        generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(\n+          XdsLogLevel.INFO, \"Generated service config:\\n{0}\", new Gson().toJson(rawServiceConfig));\n+    }\n+    ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fda028939f53058885e0050d103c0d43d26316bb"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY4NjY1Nw==", "bodyText": "This says what it does but does not provide a hint as to why. The ordering here is very important.\n\"Make newly added clusters selectable by config selector.\" could maybe change to \"Make newly added clusters selectable by config selector and deleted clusters no longer selectable.\"", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470686657", "createdAt": "2020-08-14T15:13:43Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    Map<String, ?> rawServiceConfig =\n+        generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(\n+          XdsLogLevel.INFO, \"Generated service config:\\n{0}\", new Gson().toJson(rawServiceConfig));\n+    }\n+    ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Set<String> clusters = new HashSet<>();\n+      for (Route route : update.getRoutes()) {\n+        RouteAction action = route.getRouteAction();\n+        if (action.getCluster() != null) {\n+          clusters.add(action.getCluster());\n+        } else if (action.getWeightedCluster() != null) {\n+          for (ClusterWeight weighedCluster : action.getWeightedCluster()) {\n+            clusters.add(weighedCluster.getName());\n+          }\n+        }\n+      }\n+      boolean receivedNewCluster = false;\n+      for (String newCluster : clusters) {\n+        if (clusterRefs.putIfAbsent(newCluster, new AtomicInteger(1)) == null) {\n+          receivedNewCluster = true;\n+        }\n+      }\n+      // Update service config to include newly added clusters.\n+      if (receivedNewCluster) {\n+        updateResolutionResult();\n+      }\n+      // Make newly added clusters selectable by config selector.\n+      routes = update.getRoutes();\n+      // Drops reference for deleted clusters, update service config to remove deleted clusters", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fda028939f53058885e0050d103c0d43d26316bb"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY4OTM4Ng==", "bodyText": "This isn't right. This loops through \"all deleted clusters,\" not \"all newly deleted clusters.\" Consider receiving the same update twice; both updates will run decrementAndGet() for the same clusters.", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470689386", "createdAt": "2020-08-14T15:18:40Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    Map<String, ?> rawServiceConfig =\n+        generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(\n+          XdsLogLevel.INFO, \"Generated service config:\\n{0}\", new Gson().toJson(rawServiceConfig));\n+    }\n+    ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Set<String> clusters = new HashSet<>();\n+      for (Route route : update.getRoutes()) {\n+        RouteAction action = route.getRouteAction();\n+        if (action.getCluster() != null) {\n+          clusters.add(action.getCluster());\n+        } else if (action.getWeightedCluster() != null) {\n+          for (ClusterWeight weighedCluster : action.getWeightedCluster()) {\n+            clusters.add(weighedCluster.getName());\n+          }\n+        }\n+      }\n+      boolean receivedNewCluster = false;\n+      for (String newCluster : clusters) {\n+        if (clusterRefs.putIfAbsent(newCluster, new AtomicInteger(1)) == null) {\n+          receivedNewCluster = true;\n+        }\n+      }\n+      // Update service config to include newly added clusters.\n+      if (receivedNewCluster) {\n+        updateResolutionResult();\n+      }\n+      // Make newly added clusters selectable by config selector.\n+      routes = update.getRoutes();\n+      // Drops reference for deleted clusters, update service config to remove deleted clusters\n+      // not in use.\n+      boolean shouldUpdateResult = false;\n+      for (Map.Entry<String, AtomicInteger> entry : clusterRefs.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fda028939f53058885e0050d103c0d43d26316bb"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY5MjczOA==", "bodyText": "What happened to the nanosecond portion? Was it just dropped on the floor?", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470692738", "createdAt": "2020-08-14T15:23:13Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    Map<String, ?> rawServiceConfig =\n+        generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(\n+          XdsLogLevel.INFO, \"Generated service config:\\n{0}\", new Gson().toJson(rawServiceConfig));\n+    }\n+    ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Set<String> clusters = new HashSet<>();\n+      for (Route route : update.getRoutes()) {\n+        RouteAction action = route.getRouteAction();\n+        if (action.getCluster() != null) {\n+          clusters.add(action.getCluster());\n+        } else if (action.getWeightedCluster() != null) {\n+          for (ClusterWeight weighedCluster : action.getWeightedCluster()) {\n+            clusters.add(weighedCluster.getName());\n+          }\n+        }\n+      }\n+      boolean receivedNewCluster = false;\n+      for (String newCluster : clusters) {\n+        if (clusterRefs.putIfAbsent(newCluster, new AtomicInteger(1)) == null) {\n+          receivedNewCluster = true;\n+        }\n+      }\n+      // Update service config to include newly added clusters.\n+      if (receivedNewCluster) {\n+        updateResolutionResult();\n+      }\n+      // Make newly added clusters selectable by config selector.\n+      routes = update.getRoutes();\n+      // Drops reference for deleted clusters, update service config to remove deleted clusters\n+      // not in use.\n+      boolean shouldUpdateResult = false;\n+      for (Map.Entry<String, AtomicInteger> entry : clusterRefs.entrySet()) {\n+        if (!clusters.contains(entry.getKey())) {\n+          int count = entry.getValue().decrementAndGet();\n+          if (count == 0) {\n+            clusterRefs.remove(entry.getKey());\n+            shouldUpdateResult = true;\n+          }\n+        }\n+      }\n+      if (shouldUpdateResult) {\n+        updateResolutionResult();\n+      }\n+    }\n+\n+    @Override\n+    public void onResourceDoesNotExist(String resourceName) {\n+      logger.log(XdsLogLevel.INFO, \"Resource {0} is unavailable\", resourceName);\n+      ConfigOrError parsedServiceConfig =\n+          serviceConfigParser.parseServiceConfig(Collections.<String, Object>emptyMap());\n+      ResolutionResult result =\n+          ResolutionResult.newBuilder()\n+              .setServiceConfig(parsedServiceConfig)\n+              // let channel take action for no config selector\n+              .build();\n+      listener.onResult(result);\n+    }\n+\n+    @Override\n+    public void onError(Status error) {\n+      logger.log(\n+          XdsLogLevel.WARNING,\n+          \"Received error from xDS client {0}: {1}\", xdsClient, error.getDescription());\n+      listener.onError(error);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  static Map<String, ?> generateServiceConfigWithMethodConfig(\n+      String fullMethodName, long timeoutNano) {\n+    int index = fullMethodName.lastIndexOf('/');\n+    String serviceName = fullMethodName.substring(0, index);\n+    String methodName = fullMethodName.substring(index + 1);\n+    String timeout = timeoutNano / 1_000_000_000.0 + \"s\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fda028939f53058885e0050d103c0d43d26316bb"}, "originalPosition": 331}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY5NjUwOQ==", "bodyText": "As I mentioned before, why not use wildcard service/method name?", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470696509", "createdAt": "2020-08-14T15:27:11Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    Map<String, ?> rawServiceConfig =\n+        generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(\n+          XdsLogLevel.INFO, \"Generated service config:\\n{0}\", new Gson().toJson(rawServiceConfig));\n+    }\n+    ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Set<String> clusters = new HashSet<>();\n+      for (Route route : update.getRoutes()) {\n+        RouteAction action = route.getRouteAction();\n+        if (action.getCluster() != null) {\n+          clusters.add(action.getCluster());\n+        } else if (action.getWeightedCluster() != null) {\n+          for (ClusterWeight weighedCluster : action.getWeightedCluster()) {\n+            clusters.add(weighedCluster.getName());\n+          }\n+        }\n+      }\n+      boolean receivedNewCluster = false;\n+      for (String newCluster : clusters) {\n+        if (clusterRefs.putIfAbsent(newCluster, new AtomicInteger(1)) == null) {\n+          receivedNewCluster = true;\n+        }\n+      }\n+      // Update service config to include newly added clusters.\n+      if (receivedNewCluster) {\n+        updateResolutionResult();\n+      }\n+      // Make newly added clusters selectable by config selector.\n+      routes = update.getRoutes();\n+      // Drops reference for deleted clusters, update service config to remove deleted clusters\n+      // not in use.\n+      boolean shouldUpdateResult = false;\n+      for (Map.Entry<String, AtomicInteger> entry : clusterRefs.entrySet()) {\n+        if (!clusters.contains(entry.getKey())) {\n+          int count = entry.getValue().decrementAndGet();\n+          if (count == 0) {\n+            clusterRefs.remove(entry.getKey());\n+            shouldUpdateResult = true;\n+          }\n+        }\n+      }\n+      if (shouldUpdateResult) {\n+        updateResolutionResult();\n+      }\n+    }\n+\n+    @Override\n+    public void onResourceDoesNotExist(String resourceName) {\n+      logger.log(XdsLogLevel.INFO, \"Resource {0} is unavailable\", resourceName);\n+      ConfigOrError parsedServiceConfig =\n+          serviceConfigParser.parseServiceConfig(Collections.<String, Object>emptyMap());\n+      ResolutionResult result =\n+          ResolutionResult.newBuilder()\n+              .setServiceConfig(parsedServiceConfig)\n+              // let channel take action for no config selector\n+              .build();\n+      listener.onResult(result);\n+    }\n+\n+    @Override\n+    public void onError(Status error) {\n+      logger.log(\n+          XdsLogLevel.WARNING,\n+          \"Received error from xDS client {0}: {1}\", xdsClient, error.getDescription());\n+      listener.onError(error);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  static Map<String, ?> generateServiceConfigWithMethodConfig(\n+      String fullMethodName, long timeoutNano) {\n+    int index = fullMethodName.lastIndexOf('/');\n+    String serviceName = fullMethodName.substring(0, index);\n+    String methodName = fullMethodName.substring(index + 1);\n+    String timeout = timeoutNano / 1_000_000_000.0 + \"s\";\n+    Map<String, String> serviceMethod = new HashMap<>();\n+    serviceMethod.put(\"service\", serviceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fda028939f53058885e0050d103c0d43d26316bb"}, "originalPosition": 333}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY5ODUyMA==", "bodyText": "Delete?", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r470698520", "createdAt": "2020-08-14T15:30:44Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(Status.UNAVAILABLE.withDescription(\"Failed to bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(Status.UNAVAILABLE.withDescription(\"Failed to route the RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+        if (cluster == null) {  // should not happen if routing rules are configured correctly\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Failed to route the RPC with selected action\"));\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodConfig(\n+              args.getMethodDescriptor().getFullMethodName(),\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        clusterRefs.remove(cluster);\n+        syncContext.execute(new Runnable() {\n+          @Override\n+          public void run() {\n+            updateResolutionResult();\n+          }\n+        });\n+      }\n+    }\n+  }\n+\n+  private void updateResolutionResult() {\n+    Map<String, ?> rawServiceConfig =\n+        generateServiceConfigWithLoadBalancingConfig(clusterRefs.keySet());\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(\n+          XdsLogLevel.INFO, \"Generated service config:\\n{0}\", new Gson().toJson(rawServiceConfig));\n+    }\n+    ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+    Attributes attrs =\n+        Attributes.newBuilder()\n+            .set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool)\n+            .set(InternalConfigSelector.KEY, new ConfigSelector())\n+            .build();\n+    ResolutionResult result =\n+        ResolutionResult.newBuilder()\n+            .setAttributes(attrs)\n+            .setServiceConfig(parsedServiceConfig)\n+            .build();\n+    listener.onResult(result);\n+  }\n+\n+  @SuppressWarnings(\"ModifyCollectionInEnhancedForLoop\")  // ok for concurrent map\n+  private class ConfigWatcherImpl implements ConfigWatcher {\n+    @Override\n+    public void onConfigChanged(ConfigUpdate update) {\n+      Set<String> clusters = new HashSet<>();\n+      for (Route route : update.getRoutes()) {\n+        RouteAction action = route.getRouteAction();\n+        if (action.getCluster() != null) {\n+          clusters.add(action.getCluster());\n+        } else if (action.getWeightedCluster() != null) {\n+          for (ClusterWeight weighedCluster : action.getWeightedCluster()) {\n+            clusters.add(weighedCluster.getName());\n+          }\n+        }\n+      }\n+      boolean receivedNewCluster = false;\n+      for (String newCluster : clusters) {\n+        if (clusterRefs.putIfAbsent(newCluster, new AtomicInteger(1)) == null) {\n+          receivedNewCluster = true;\n+        }\n+      }\n+      // Update service config to include newly added clusters.\n+      if (receivedNewCluster) {\n+        updateResolutionResult();\n+      }\n+      // Make newly added clusters selectable by config selector.\n+      routes = update.getRoutes();\n+      // Drops reference for deleted clusters, update service config to remove deleted clusters\n+      // not in use.\n+      boolean shouldUpdateResult = false;\n+      for (Map.Entry<String, AtomicInteger> entry : clusterRefs.entrySet()) {\n+        if (!clusters.contains(entry.getKey())) {\n+          int count = entry.getValue().decrementAndGet();\n+          if (count == 0) {\n+            clusterRefs.remove(entry.getKey());\n+            shouldUpdateResult = true;\n+          }\n+        }\n+      }\n+      if (shouldUpdateResult) {\n+        updateResolutionResult();\n+      }\n+    }\n+\n+    @Override\n+    public void onResourceDoesNotExist(String resourceName) {\n+      logger.log(XdsLogLevel.INFO, \"Resource {0} is unavailable\", resourceName);\n+      ConfigOrError parsedServiceConfig =\n+          serviceConfigParser.parseServiceConfig(Collections.<String, Object>emptyMap());\n+      ResolutionResult result =\n+          ResolutionResult.newBuilder()\n+              .setServiceConfig(parsedServiceConfig)\n+              // let channel take action for no config selector\n+              .build();\n+      listener.onResult(result);\n+    }\n+\n+    @Override\n+    public void onError(Status error) {\n+      logger.log(\n+          XdsLogLevel.WARNING,\n+          \"Received error from xDS client {0}: {1}\", xdsClient, error.getDescription());\n+      listener.onError(error);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  static Map<String, ?> generateServiceConfigWithMethodConfig(\n+      String fullMethodName, long timeoutNano) {\n+    int index = fullMethodName.lastIndexOf('/');\n+    String serviceName = fullMethodName.substring(0, index);\n+    String methodName = fullMethodName.substring(index + 1);\n+    String timeout = timeoutNano / 1_000_000_000.0 + \"s\";\n+    Map<String, String> serviceMethod = new HashMap<>();\n+    serviceMethod.put(\"service\", serviceName);\n+    serviceMethod.put(\"method\", methodName);\n+    Map<String, Object> methodConfig = new HashMap<>();\n+    methodConfig.put(\n+        \"name\", Collections.singletonList(Collections.unmodifiableMap(serviceMethod)));\n+    methodConfig.put(\"timeout\", timeout);\n+    return Collections.singletonMap(\n+        \"methodConfig\", Collections.singletonList(Collections.unmodifiableMap(methodConfig)));\n+  }\n+\n+  @VisibleForTesting\n+  static Map<String, ?> generateServiceConfigWithLoadBalancingConfig(Collection<String> clusters) {\n+    StringBuilder sb = new StringBuilder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fda028939f53058885e0050d103c0d43d26316bb"}, "originalPosition": 345}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e385a1f1e5691e5a52465c5b320ed0bd4ddbe34", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/5e385a1f1e5691e5a52465c5b320ed0bd4ddbe34", "committedDate": "2020-08-14T18:28:59Z", "message": "Delete unused code."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "484bf6322858c28091219385c8fca6326564d3f4", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/484bf6322858c28091219385c8fca6326564d3f4", "committedDate": "2020-08-14T20:05:24Z", "message": "Delete should-never-happen code and improve status message."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e337a996eb9fa5ef01f9ba53eaa6d856d2023fa9", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/e337a996eb9fa5ef01f9ba53eaa6d856d2023fa9", "committedDate": "2020-08-14T20:14:03Z", "message": "Do not need to specify service/method for the generated method config."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b90b55beaaed35acac8d23f02ef2587ac716893", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/4b90b55beaaed35acac8d23f02ef2587ac716893", "committedDate": "2020-08-14T20:14:05Z", "message": "Improve bootstrap failure message."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb739f294b0ddebff352a94b325400f8be42c6ed", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/bb739f294b0ddebff352a94b325400f8be42c6ed", "committedDate": "2020-08-14T20:14:05Z", "message": "Add github issue link for error prone warning."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d31a06b21122fe606b433c74f04d5b3dd0679e94", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/d31a06b21122fe606b433c74f04d5b3dd0679e94", "committedDate": "2020-08-14T20:25:57Z", "message": "Add TODO comment for ensuring received weighted cluster contains at least one cluster."}, "afterCommit": {"oid": "f7c6bd8edd534ccf24ad547ea9bbdc7ae9c69543", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/f7c6bd8edd534ccf24ad547ea9bbdc7ae9c69543", "committedDate": "2020-08-14T20:33:24Z", "message": "Ensure weighed clusters list contains at least one cluster."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5049c29d2230f0ade4005f3f6d56b0891b2b34d3", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/5049c29d2230f0ade4005f3f6d56b0891b2b34d3", "committedDate": "2020-08-14T21:10:20Z", "message": "Use the same ConfigSelector instance."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a178a47c5a0b4be0b9609658ee16780f735de81", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/0a178a47c5a0b4be0b9609658ee16780f735de81", "committedDate": "2020-08-14T21:10:22Z", "message": "Improve comment to reflect the ordering of updating selectable clusters before deleting non-selectable clusters."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d6c6cf63606256e7c6544491a75ea25e0bc3a07", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/6d6c6cf63606256e7c6544491a75ea25e0bc3a07", "committedDate": "2020-08-14T21:10:22Z", "message": "Ensure weighed clusters list contains at least one cluster."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f7c6bd8edd534ccf24ad547ea9bbdc7ae9c69543", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/f7c6bd8edd534ccf24ad547ea9bbdc7ae9c69543", "committedDate": "2020-08-14T20:33:24Z", "message": "Ensure weighed clusters list contains at least one cluster."}, "afterCommit": {"oid": "8c9409428ab54c7a74d4831332e045ddc3ad67b6", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/8c9409428ab54c7a74d4831332e045ddc3ad67b6", "committedDate": "2020-08-14T21:48:08Z", "message": "Should only mutate ref count for newly added/deleted clusters."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8c9409428ab54c7a74d4831332e045ddc3ad67b6", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/8c9409428ab54c7a74d4831332e045ddc3ad67b6", "committedDate": "2020-08-14T21:48:08Z", "message": "Should only mutate ref count for newly added/deleted clusters."}, "afterCommit": {"oid": "5baf3f10ade958a68a7ff08303c3973ea36d491b", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/5baf3f10ade958a68a7ff08303c3973ea36d491b", "committedDate": "2020-08-14T21:51:15Z", "message": "Should only mutate ref count for newly added/deleted clusters."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "922373baea2e025ebb13a5f743edcc1123564b07", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/922373baea2e025ebb13a5f743edcc1123564b07", "committedDate": "2020-08-14T22:04:04Z", "message": "Should only mutate ref count for newly added/deleted clusters."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "391c2e4909f1f9d5307db4bda3d8eefcb128f003", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/391c2e4909f1f9d5307db4bda3d8eefcb128f003", "committedDate": "2020-08-14T22:04:06Z", "message": "Run cluster removal operation in sync context."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5baf3f10ade958a68a7ff08303c3973ea36d491b", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/5baf3f10ade958a68a7ff08303c3973ea36d491b", "committedDate": "2020-08-14T21:51:15Z", "message": "Should only mutate ref count for newly added/deleted clusters."}, "afterCommit": {"oid": "391c2e4909f1f9d5307db4bda3d8eefcb128f003", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/391c2e4909f1f9d5307db4bda3d8eefcb128f003", "committedDate": "2020-08-14T22:04:06Z", "message": "Run cluster removal operation in sync context."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4NzkyODc3", "url": "https://github.com/grpc/grpc-java/pull/7275#pullrequestreview-468792877", "createdAt": "2020-08-17T20:00:32Z", "commit": {"oid": "391c2e4909f1f9d5307db4bda3d8eefcb128f003"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMDowMDozMlrOHB46zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QyMTo0Mjo0OVrOHB721g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc0MzE4MA==", "bodyText": "nit: XdsNameResolverProvider2", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r471743180", "createdAt": "2020-08-17T20:00:32Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Sets;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "391c2e4909f1f9d5307db4bda3d8eefcb128f003"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc0NzgxOQ==", "bodyText": "nit: move this to top. Usage of boostrapInfo should be put together.", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r471747819", "createdAt": "2020-08-17T20:09:50Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Sets;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+  private final ConfigSelector configSelector = new ConfigSelector();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(\n+          Status.UNAVAILABLE.withDescription(\"Failed to load xDS bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "391c2e4909f1f9d5307db4bda3d8eefcb128f003"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc5MTMxOA==", "bodyText": "If the cluster is added back by onConfigChanged() in between above two lines, it will not putIfAbsent() to clusterRefs, and will be removed later by this runnable.", "url": "https://github.com/grpc/grpc-java/pull/7275#discussion_r471791318", "createdAt": "2020-08-17T21:42:49Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver2.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Sets;\n+import com.google.gson.Gson;\n+import io.grpc.Attributes;\n+import io.grpc.CallOptions;\n+import io.grpc.InternalConfigSelector;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.Metadata;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.GrpcUtil;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.xds.Bootstrapper.BootstrapInfo;\n+import io.grpc.xds.EnvoyProtoData.ClusterWeight;\n+import io.grpc.xds.EnvoyProtoData.Route;\n+import io.grpc.xds.EnvoyProtoData.RouteAction;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.XdsClient.ConfigUpdate;\n+import io.grpc.xds.XdsClient.ConfigWatcher;\n+import io.grpc.xds.XdsClient.XdsClientPoolFactory;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link NameResolver} for resolving gRPC target names with \"xds:\" scheme.\n+ *\n+ * <p>Resolving a gRPC target involves contacting the control plane management server via xDS\n+ * protocol to retrieve service information and produce a service config to the caller.\n+ *\n+ * @see XdsNameResolverProvider\n+ */\n+final class XdsNameResolver2 extends NameResolver {\n+\n+  static final CallOptions.Key<String> CLUSTER_SELECTION_KEY =\n+      CallOptions.Key.create(\"io.grpc.xds.CLUSTER_SELECTION_KEY\");\n+\n+  private final XdsLogger logger;\n+  private final String authority;\n+  private final ServiceConfigParser serviceConfigParser;\n+  private final SynchronizationContext syncContext;\n+  private final Bootstrapper bootstrapper;\n+  private final XdsClientPoolFactory xdsClientPoolFactory;\n+  private final ThreadSafeRandom random;\n+  private final ConcurrentMap<String, AtomicInteger> clusterRefs = new ConcurrentHashMap<>();\n+  private final ConfigSelector configSelector = new ConfigSelector();\n+\n+  private volatile List<Route> routes = Collections.emptyList();\n+  private Listener2 listener;\n+  @Nullable\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  @Nullable\n+  private XdsClient xdsClient;\n+\n+  XdsNameResolver2(String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      XdsClientPoolFactory xdsClientPoolFactory) {\n+    this(name, serviceConfigParser, syncContext, Bootstrapper.getInstance(),\n+        xdsClientPoolFactory, ThreadSafeRandomImpl.instance);\n+  }\n+\n+  XdsNameResolver2(\n+      String name,\n+      ServiceConfigParser serviceConfigParser,\n+      SynchronizationContext syncContext,\n+      Bootstrapper bootstrapper,\n+      XdsClientPoolFactory xdsClientPoolFactory,\n+      ThreadSafeRandom random) {\n+    authority = GrpcUtil.checkAuthority(checkNotNull(name, \"name\"));\n+    this.serviceConfigParser = checkNotNull(serviceConfigParser, \"serviceConfigParser\");\n+    this.syncContext = checkNotNull(syncContext, \"syncContext\");\n+    this.bootstrapper = checkNotNull(bootstrapper, \"bootstrapper\");\n+    this.xdsClientPoolFactory = checkNotNull(xdsClientPoolFactory, \"xdsClientPoolFactory\");\n+    this.random = checkNotNull(random, \"random\");\n+    logger = XdsLogger.withLogId(InternalLogId.allocate(\"xds-resolver\", name));\n+    logger.log(XdsLogLevel.INFO, \"Created resolver for {0}\", name);\n+  }\n+\n+  @Override\n+  public String getServiceAuthority() {\n+    return authority;\n+  }\n+\n+  @Override\n+  public void start(Listener2 listener) {\n+    BootstrapInfo bootstrapInfo;\n+    try {\n+      bootstrapInfo = bootstrapper.readBootstrap();\n+    } catch (Exception e) {\n+      listener.onError(\n+          Status.UNAVAILABLE.withDescription(\"Failed to load xDS bootstrap\").withCause(e));\n+      return;\n+    }\n+    this.listener = checkNotNull(listener, \"listener\");\n+    xdsClientPool = xdsClientPoolFactory.newXdsClientObjectPool(bootstrapInfo);\n+    xdsClient = xdsClientPool.getObject();\n+    xdsClient.watchConfigData(authority, new ConfigWatcherImpl());\n+  }\n+\n+  @VisibleForTesting\n+  final class ConfigSelector extends InternalConfigSelector {\n+    @Override\n+    public Result selectConfig(PickSubchannelArgs args) {\n+      // Index ASCII headers by keys.\n+      Map<String, Iterable<String>> asciiHeaders = new HashMap<>();\n+      Metadata headers = args.getHeaders();\n+      for (String headerName : headers.keys()) {\n+        if (headerName.endsWith(Metadata.BINARY_HEADER_SUFFIX)) {\n+          continue;\n+        }\n+        Metadata.Key<String> key = Metadata.Key.of(headerName, Metadata.ASCII_STRING_MARSHALLER);\n+        asciiHeaders.put(headerName, headers.getAll(key));\n+      }\n+      String cluster = null;\n+      Route selectedRoute = null;\n+      do {\n+        for (Route route : routes) {\n+          if (route.getRouteMatch().matches(\n+              \"/\" + args.getMethodDescriptor().getFullMethodName(), asciiHeaders)) {\n+            selectedRoute = route;\n+            break;\n+          }\n+        }\n+        if (selectedRoute == null) {\n+          return Result.forError(\n+              Status.UNAVAILABLE.withDescription(\"Could not find xDS route matching RPC\"));\n+        }\n+        RouteAction action = selectedRoute.getRouteAction();\n+        if (action.getCluster() != null) {\n+          cluster = action.getCluster();\n+        } else if (action.getWeightedCluster() != null) {\n+          int totalWeight = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            totalWeight += weightedCluster.getWeight();\n+          }\n+          int select = random.nextInt(totalWeight);\n+          int accumulator = 0;\n+          for (ClusterWeight weightedCluster : action.getWeightedCluster()) {\n+            accumulator += weightedCluster.getWeight();\n+            if (select < accumulator) {\n+              cluster = weightedCluster.getName();\n+              break;\n+            }\n+          }\n+        }\n+      } while (!retainCluster(cluster));\n+      final String finalCluster = cluster;\n+      class SelectionCompleted implements Runnable {\n+        @Override\n+        public void run() {\n+          releaseCluster(finalCluster);\n+        }\n+      }\n+\n+      Map<String, ?> rawServiceConfig =\n+          generateServiceConfigWithMethodTimeoutConfig(\n+              selectedRoute.getRouteAction().getTimeoutNano());\n+      if (logger.isLoggable(XdsLogLevel.INFO)) {\n+        logger.log(XdsLogLevel.INFO,\n+            \"Generated service config (method config):\\n{0}\", new Gson().toJson(rawServiceConfig));\n+      }\n+      ConfigOrError parsedServiceConfig = serviceConfigParser.parseServiceConfig(rawServiceConfig);\n+      Object config = parsedServiceConfig.getConfig();\n+      if (config == null) {\n+        throw new AssertionError(\n+            \"Bug: invalid config\", parsedServiceConfig.getError().asException());\n+      }\n+      return\n+          Result.newBuilder()\n+              .setCallOptions(args.getCallOptions().withOption(CLUSTER_SELECTION_KEY, cluster))\n+              .setConfig(config)\n+              .setCommittedCallback(new SelectionCompleted())\n+              .build();\n+    }\n+\n+    private boolean retainCluster(String cluster) {\n+      AtomicInteger refCount = clusterRefs.get(cluster);\n+      if (refCount == null) {\n+        return false;\n+      }\n+      int count;\n+      do {\n+        count = refCount.get();\n+        if (count == 0) {\n+          return false;\n+        }\n+      } while (!refCount.compareAndSet(count, count + 1));\n+      return true;\n+    }\n+\n+    private void releaseCluster(final String cluster) {\n+      int count = clusterRefs.get(cluster).decrementAndGet();\n+      if (count == 0) {\n+        syncContext.execute(new Runnable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "391c2e4909f1f9d5307db4bda3d8eefcb128f003"}, "originalPosition": 226}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "594dee0849c4d3d2cade702eafa0fab992ab1010", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/594dee0849c4d3d2cade702eafa0fab992ab1010", "committedDate": "2020-08-18T00:53:24Z", "message": "style and typo."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8138651f3ff7ba9e3c9d557b81e5b189eb8e499c", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/8138651f3ff7ba9e3c9d557b81e5b189eb8e499c", "committedDate": "2020-08-18T20:28:15Z", "message": "Fix the race between a released cluster being removed and it is being added back in a new update."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "549da8959ff8b6345e0ae60fe9db5d07dfbb3fdd", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/549da8959ff8b6345e0ae60fe9db5d07dfbb3fdd", "committedDate": "2020-08-18T20:31:19Z", "message": "Add test covering the case when a call is made such that a cluster is retained, and the cluster is removed and added back before the call finishes."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1aaff29f954e16c0cd490167377157ec4aa4e0e2", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/1aaff29f954e16c0cd490167377157ec4aa4e0e2", "committedDate": "2020-08-18T20:29:35Z", "message": "Add test covering the case when a call is made such that a cluster is retained, and the cluster is removed and added back before the call finishes."}, "afterCommit": {"oid": "549da8959ff8b6345e0ae60fe9db5d07dfbb3fdd", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/549da8959ff8b6345e0ae60fe9db5d07dfbb3fdd", "committedDate": "2020-08-18T20:31:19Z", "message": "Add test covering the case when a call is made such that a cluster is retained, and the cluster is removed and added back before the call finishes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3e37c47cfad4f32a4a63e8b31669e115e96d946", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/a3e37c47cfad4f32a4a63e8b31669e115e96d946", "committedDate": "2020-08-18T23:23:37Z", "message": "Fail config selection if parsing the generated config encounters error."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d114bf4f3acd2ef5645dc38ccbcb398629dc0ae4", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/d114bf4f3acd2ef5645dc38ccbcb398629dc0ae4", "committedDate": "2020-08-18T23:27:10Z", "message": "Add TODO for addressing the issue of generating and parsing config for each call."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMDcwMTAy", "url": "https://github.com/grpc/grpc-java/pull/7275#pullrequestreview-472070102", "createdAt": "2020-08-21T00:31:44Z", "commit": {"oid": "d114bf4f3acd2ef5645dc38ccbcb398629dc0ae4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebb5b5a955e9ee88e06aede7d0ff69cc0d660574", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/ebb5b5a955e9ee88e06aede7d0ff69cc0d660574", "committedDate": "2020-08-24T20:14:12Z", "message": "Fixed style: rearrage methods/inner class, remove unnecessary annotations."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczOTMwMTE1", "url": "https://github.com/grpc/grpc-java/pull/7275#pullrequestreview-473930115", "createdAt": "2020-08-24T22:34:07Z", "commit": {"oid": "ebb5b5a955e9ee88e06aede7d0ff69cc0d660574"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4140, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}