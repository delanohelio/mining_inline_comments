{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4NzczNTc0", "number": 7391, "title": "xds: reimplement EDS LB policy with downstream LB config generations that migrate to hierarchical LB tree codepath", "bodyText": "", "createdAt": "2020-09-03T17:16:06Z", "url": "https://github.com/grpc/grpc-java/pull/7391", "merged": true, "mergeCommit": {"oid": "e6b61ea207f7f962a179e2dc61fad95d99685d1c"}, "closed": true, "closedAt": "2020-09-18T23:37:56Z", "author": {"login": "voidzcy"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdFTzgtgH2gAyNDc4NzczNTc0OmRiOTQ3MDhlNDMxNTJkMmZhMWMyNjNhOWFlN2YzZmIxNTAxMmNmMzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJ6O7OgH2gAyNDc4NzczNTc0OmM1NzRjNWRkYjhhNzNlM2U4MmFiYzYwYmZlMTExNzc3ZTY0MjBkYmI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "db94708e43152d2fa1c263a9ae7f3fb15012cf31", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/db94708e43152d2fa1c263a9ae7f3fb15012cf31", "committedDate": "2020-09-03T17:11:19Z", "message": "Add locality_pickinig_policy field to EdsConfig."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "309a77908fb35e8b0151e8ade5d50d8997e7a381", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/309a77908fb35e8b0151e8ade5d50d8997e7a381", "committedDate": "2020-09-03T17:11:47Z", "message": "Clean up EdsLoadBalancerProvider test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79b65a6c8754b8f6f3f05d5805db78784b2347f5", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/79b65a6c8754b8f6f3f05d5805db78784b2347f5", "committedDate": "2020-09-03T17:13:31Z", "message": "Add missing LB policies for service loading."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94feec55cba5fba25dfc4a647978356ba53d8ef1", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/94feec55cba5fba25dfc4a647978356ba53d8ef1", "committedDate": "2020-09-03T17:14:26Z", "message": "Reimplement EDS LB policy with downstream LB policy config generations that migrates to hierarchical LB tree codepath."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2db7335fba894626792d93072d7eb14edaef94f5", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/2db7335fba894626792d93072d7eb14edaef94f5", "committedDate": "2020-09-03T17:15:04Z", "message": "WIP: EDS LB policy tests."}, "afterCommit": {"oid": "ae61247717b5289b9d11589a667b9ef9c9edada8", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/ae61247717b5289b9d11589a667b9ef9c9edada8", "committedDate": "2020-09-03T19:01:32Z", "message": "Fix child balancer's helper not wrapped by GracefulSwitchLoadBalancer."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55606fc817c5b000d026b11743e42ff46792f0d9", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/55606fc817c5b000d026b11743e42ff46792f0d9", "committedDate": "2020-09-03T19:03:05Z", "message": "Fix child balancer's helper not wrapped by GracefulSwitchLoadBalancer."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ae61247717b5289b9d11589a667b9ef9c9edada8", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/ae61247717b5289b9d11589a667b9ef9c9edada8", "committedDate": "2020-09-03T19:01:32Z", "message": "Fix child balancer's helper not wrapped by GracefulSwitchLoadBalancer."}, "afterCommit": {"oid": "a6b6206d9e4e9f1a16af6069b2784c93985b94a8", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/a6b6206d9e4e9f1a16af6069b2784c93985b94a8", "committedDate": "2020-09-03T19:03:05Z", "message": "WIP: EDS LB policy tests."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a6b6206d9e4e9f1a16af6069b2784c93985b94a8", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/a6b6206d9e4e9f1a16af6069b2784c93985b94a8", "committedDate": "2020-09-03T19:03:05Z", "message": "WIP: EDS LB policy tests."}, "afterCommit": {"oid": "19771099b520080050dc1ed8985b111e48bab003", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/19771099b520080050dc1ed8985b111e48bab003", "committedDate": "2020-09-03T19:25:17Z", "message": "Add EDS LB policy tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7286d5c5b7854d39fffc63af5a4279e84482b773", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/7286d5c5b7854d39fffc63af5a4279e84482b773", "committedDate": "2020-09-03T19:32:00Z", "message": "Add EDS LB policy tests."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "19771099b520080050dc1ed8985b111e48bab003", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/19771099b520080050dc1ed8985b111e48bab003", "committedDate": "2020-09-03T19:25:17Z", "message": "Add EDS LB policy tests."}, "afterCommit": {"oid": "7286d5c5b7854d39fffc63af5a4279e84482b773", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/7286d5c5b7854d39fffc63af5a4279e84482b773", "committedDate": "2020-09-03T19:32:00Z", "message": "Add EDS LB policy tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MzgyODQ4", "url": "https://github.com/grpc/grpc-java/pull/7391#pullrequestreview-486382848", "createdAt": "2020-09-10T23:45:16Z", "commit": {"oid": "7286d5c5b7854d39fffc63af5a4279e84482b773"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMzo0NToxNlrOHQJYRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMDoxMjoxN1rOHQJ2CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5MjkzNA==", "bodyText": "The comment is not necessary as with edsServiceName", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r486692934", "createdAt": "2020-09-10T23:45:16Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EndpointUpdate;\n+import io.grpc.xds.XdsClient.EndpointWatcher;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+final class EdsLoadBalancer2 extends LoadBalancer {\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final LoadBalancer.Helper helper;\n+  private final ThreadSafeRandom random;\n+  private final GracefulSwitchLoadBalancer switchingLoadBalancer;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private String cluster;\n+  private ResolvedAddresses resolvedAddresses;\n+\n+  EdsLoadBalancer2(LoadBalancer.Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(), ThreadSafeRandomImpl.instance);\n+  }\n+\n+  @VisibleForTesting\n+  EdsLoadBalancer2(\n+      LoadBalancer.Helper helper, LoadBalancerRegistry lbRegistry, ThreadSafeRandom random) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.random = checkNotNull(random, \"random\");\n+    switchingLoadBalancer = new GracefulSwitchLoadBalancer(helper);\n+    logId = InternalLogId.allocate(\"eds-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(XdsLogLevel.INFO, \"Received EDS lb config: cluster={0}, \"\n+              + \"eds_service_name={1}, endpoint_picking_policy={2}, report_load={3}\",\n+          config.clusterName, config.edsServiceName,\n+          config.endpointPickingPolicy.getProvider().getPolicyName(),\n+          config.lrsServerName != null);\n+    }\n+    if (cluster == null) {\n+      cluster = config.clusterName;\n+    }\n+    switchingLoadBalancer.switchTo(new EdsLbState(config.edsServiceName, config.lrsServerName));\n+    switchingLoadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    switchingLoadBalancer.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    switchingLoadBalancer.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class EdsLbState extends LoadBalancer.Factory {\n+    @Nullable\n+    private final String edsServiceName;\n+    @Nullable\n+    private final String lrsServerName;  // assume LRS server never change", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7286d5c5b7854d39fffc63af5a4279e84482b773"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5NjI5NA==", "bodyText": "The attribute should be updated each time handleResolvedAddresses().", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r486696294", "createdAt": "2020-09-10T23:56:41Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EndpointUpdate;\n+import io.grpc.xds.XdsClient.EndpointWatcher;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+final class EdsLoadBalancer2 extends LoadBalancer {\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final LoadBalancer.Helper helper;\n+  private final ThreadSafeRandom random;\n+  private final GracefulSwitchLoadBalancer switchingLoadBalancer;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private String cluster;\n+  private ResolvedAddresses resolvedAddresses;\n+\n+  EdsLoadBalancer2(LoadBalancer.Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(), ThreadSafeRandomImpl.instance);\n+  }\n+\n+  @VisibleForTesting\n+  EdsLoadBalancer2(\n+      LoadBalancer.Helper helper, LoadBalancerRegistry lbRegistry, ThreadSafeRandom random) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.random = checkNotNull(random, \"random\");\n+    switchingLoadBalancer = new GracefulSwitchLoadBalancer(helper);\n+    logId = InternalLogId.allocate(\"eds-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(XdsLogLevel.INFO, \"Received EDS lb config: cluster={0}, \"\n+              + \"eds_service_name={1}, endpoint_picking_policy={2}, report_load={3}\",\n+          config.clusterName, config.edsServiceName,\n+          config.endpointPickingPolicy.getProvider().getPolicyName(),\n+          config.lrsServerName != null);\n+    }\n+    if (cluster == null) {\n+      cluster = config.clusterName;\n+    }\n+    switchingLoadBalancer.switchTo(new EdsLbState(config.edsServiceName, config.lrsServerName));\n+    switchingLoadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    switchingLoadBalancer.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    switchingLoadBalancer.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class EdsLbState extends LoadBalancer.Factory {\n+    @Nullable\n+    private final String edsServiceName;\n+    @Nullable\n+    private final String lrsServerName;  // assume LRS server never change\n+    private final String resourceName;\n+\n+    private EdsLbState(@Nullable String edsServiceName, @Nullable String lrsServerName) {\n+      this.edsServiceName = edsServiceName;\n+      this.lrsServerName = lrsServerName;\n+      resourceName = edsServiceName == null ? cluster : edsServiceName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      return new ChildLbState(helper);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(edsServiceName, lrsServerName);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+      if (!(obj instanceof EdsLbState)) {\n+        return false;\n+      }\n+      EdsLbState that = (EdsLbState) obj;\n+      return Objects.equals(edsServiceName, that.edsServiceName)\n+          && Objects.equals(lrsServerName, that.lrsServerName);\n+    }\n+\n+    private final class ChildLbState extends LoadBalancer implements EndpointWatcher {\n+      @Nullable\n+      private final LoadStatsStore loadStatsStore;\n+      private final Attributes attributes;\n+      private final DropHandlingLbHelper lbHelper;\n+      private List<EquivalentAddressGroup> endpointAddresses = Collections.emptyList();\n+      private Map<Integer, Map<Locality, Integer>> prioritizedLocalityWeights\n+          = Collections.emptyMap();\n+      private PolicySelection localityPickingPolicy;\n+      private PolicySelection endpointPickingPolicy;\n+      @Nullable\n+      private LoadBalancer lb;\n+\n+      private ChildLbState(Helper helper) {\n+        logger.log(\n+            XdsLogLevel.INFO,\n+            \"Start endpoint watcher on {0} with xDS client {1}\", resourceName, xdsClient);\n+        xdsClient.watchEndpointData(resourceName, this);\n+        if (lrsServerName != null) {\n+          loadStatsStore = xdsClient.addClientStats(cluster, edsServiceName);\n+          xdsClient.reportClientStats();\n+          attributes =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7286d5c5b7854d39fffc63af5a4279e84482b773"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcwMDU1Mw==", "bodyText": "This is the wrong helper. The right helper should be the helper from the constructor ChildLbState(Helper helper) that the GracefulSwitchingLoadBalancer passes to it, which could be a pendingHelper that does not propagate TRANSIENT_FAILURE upstream. Even forget about the above technical details, the right helper should still be the wrapped helper in the direct layer, and allow that layer to intercept update.\nSame for onResourceDoesNotExist() and onError().", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r486700553", "createdAt": "2020-09-11T00:12:17Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EndpointUpdate;\n+import io.grpc.xds.XdsClient.EndpointWatcher;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+final class EdsLoadBalancer2 extends LoadBalancer {\n+  private final InternalLogId logId;\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final LoadBalancer.Helper helper;\n+  private final ThreadSafeRandom random;\n+  private final GracefulSwitchLoadBalancer switchingLoadBalancer;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private String cluster;\n+  private ResolvedAddresses resolvedAddresses;\n+\n+  EdsLoadBalancer2(LoadBalancer.Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(), ThreadSafeRandomImpl.instance);\n+  }\n+\n+  @VisibleForTesting\n+  EdsLoadBalancer2(\n+      LoadBalancer.Helper helper, LoadBalancerRegistry lbRegistry, ThreadSafeRandom random) {\n+    this.helper = checkNotNull(helper, \"helper\");\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.random = checkNotNull(random, \"random\");\n+    switchingLoadBalancer = new GracefulSwitchLoadBalancer(helper);\n+    logId = InternalLogId.allocate(\"eds-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(XdsLogLevel.INFO, \"Received EDS lb config: cluster={0}, \"\n+              + \"eds_service_name={1}, endpoint_picking_policy={2}, report_load={3}\",\n+          config.clusterName, config.edsServiceName,\n+          config.endpointPickingPolicy.getProvider().getPolicyName(),\n+          config.lrsServerName != null);\n+    }\n+    if (cluster == null) {\n+      cluster = config.clusterName;\n+    }\n+    switchingLoadBalancer.switchTo(new EdsLbState(config.edsServiceName, config.lrsServerName));\n+    switchingLoadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    switchingLoadBalancer.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    switchingLoadBalancer.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class EdsLbState extends LoadBalancer.Factory {\n+    @Nullable\n+    private final String edsServiceName;\n+    @Nullable\n+    private final String lrsServerName;  // assume LRS server never change\n+    private final String resourceName;\n+\n+    private EdsLbState(@Nullable String edsServiceName, @Nullable String lrsServerName) {\n+      this.edsServiceName = edsServiceName;\n+      this.lrsServerName = lrsServerName;\n+      resourceName = edsServiceName == null ? cluster : edsServiceName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      return new ChildLbState(helper);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(edsServiceName, lrsServerName);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+      if (!(obj instanceof EdsLbState)) {\n+        return false;\n+      }\n+      EdsLbState that = (EdsLbState) obj;\n+      return Objects.equals(edsServiceName, that.edsServiceName)\n+          && Objects.equals(lrsServerName, that.lrsServerName);\n+    }\n+\n+    private final class ChildLbState extends LoadBalancer implements EndpointWatcher {\n+      @Nullable\n+      private final LoadStatsStore loadStatsStore;\n+      private final Attributes attributes;\n+      private final DropHandlingLbHelper lbHelper;\n+      private List<EquivalentAddressGroup> endpointAddresses = Collections.emptyList();\n+      private Map<Integer, Map<Locality, Integer>> prioritizedLocalityWeights\n+          = Collections.emptyMap();\n+      private PolicySelection localityPickingPolicy;\n+      private PolicySelection endpointPickingPolicy;\n+      @Nullable\n+      private LoadBalancer lb;\n+\n+      private ChildLbState(Helper helper) {\n+        logger.log(\n+            XdsLogLevel.INFO,\n+            \"Start endpoint watcher on {0} with xDS client {1}\", resourceName, xdsClient);\n+        xdsClient.watchEndpointData(resourceName, this);\n+        if (lrsServerName != null) {\n+          loadStatsStore = xdsClient.addClientStats(cluster, edsServiceName);\n+          xdsClient.reportClientStats();\n+          attributes =\n+              resolvedAddresses.getAttributes().toBuilder()\n+                  .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadStatsStore)\n+                  .build();\n+        } else {\n+          loadStatsStore = null;\n+          attributes = resolvedAddresses.getAttributes();\n+        }\n+        lbHelper = new DropHandlingLbHelper(helper);\n+      }\n+\n+      @Override\n+      public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+        EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+        if (lb != null) {\n+          if (!config.localityPickingPolicy.equals(localityPickingPolicy)\n+              || !config.endpointPickingPolicy.equals(endpointPickingPolicy)) {\n+            PriorityLbConfig childConfig =\n+                generatePriorityLbConfig(cluster, edsServiceName, lrsServerName,\n+                    config.localityPickingPolicy, config.endpointPickingPolicy, lbRegistry,\n+                    prioritizedLocalityWeights);\n+            lb.handleResolvedAddresses(\n+                resolvedAddresses.toBuilder()\n+                    .setAddresses(endpointAddresses)\n+                    .setAttributes(attributes)\n+                    .setLoadBalancingPolicyConfig(childConfig)\n+                    .build());\n+          }\n+        }\n+        localityPickingPolicy = config.localityPickingPolicy;\n+        endpointPickingPolicy = config.endpointPickingPolicy;\n+      }\n+\n+      @Override\n+      public void handleNameResolutionError(Status error) {\n+        if (lb != null) {\n+          lb.handleNameResolutionError(error);\n+        } else {\n+          helper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7286d5c5b7854d39fffc63af5a4279e84482b773"}, "originalPosition": 224}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef67f6a8b5d64638695cb1df91054eb9f947d2c9", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/ef67f6a8b5d64638695cb1df91054eb9f947d2c9", "committedDate": "2020-09-11T00:51:10Z", "message": "Delete unnecessary comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c02bf061a2be8a329a7319d2b995f61e6c1a9920", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/c02bf061a2be8a329a7319d2b995f61e6c1a9920", "committedDate": "2020-09-11T01:45:24Z", "message": "Fix to use a single reference of attributes and downstream policies should be initialized before watching the endpoint info."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe8372fdd21df6254d95494116e6baba83bd3ca1", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/fe8372fdd21df6254d95494116e6baba83bd3ca1", "committedDate": "2020-09-11T02:05:12Z", "message": "Fix using the wrong helper."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "380af006ff4b68bf1391277e7069e5fbdbe8132f", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/380af006ff4b68bf1391277e7069e5fbdbe8132f", "committedDate": "2020-09-11T01:49:00Z", "message": "Fix using the wrong helper."}, "afterCommit": {"oid": "fe8372fdd21df6254d95494116e6baba83bd3ca1", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/fe8372fdd21df6254d95494116e6baba83bd3ca1", "committedDate": "2020-09-11T02:05:12Z", "message": "Fix using the wrong helper."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MjE0MjI4", "url": "https://github.com/grpc/grpc-java/pull/7391#pullrequestreview-488214228", "createdAt": "2020-09-14T23:05:52Z", "commit": {"oid": "c02bf061a2be8a329a7319d2b995f61e6c1a9920"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzowNTo1MlrOHRqn9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMzowNTo1MlrOHRqn9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4NjE5OQ==", "bodyText": "This looks more than a fix. You changed the definition of EdsLbState, why? But EdsLbState equals()andhashCode()` are not changed accordingly.", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r488286199", "createdAt": "2020-09-14T23:05:52Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -105,7 +105,9 @@ public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n     if (cluster == null) {\n       cluster = config.clusterName;\n     }\n-    switchingLoadBalancer.switchTo(new EdsLbState(config.edsServiceName, config.lrsServerName));\n+    switchingLoadBalancer.switchTo(new EdsLbState(\n+        config.edsServiceName, config.lrsServerName, config.localityPickingPolicy,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c02bf061a2be8a329a7319d2b995f61e6c1a9920"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59da20b9b7a4793a0e037ecf4cf42676d40a7a31", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/59da20b9b7a4793a0e037ecf4cf42676d40a7a31", "committedDate": "2020-09-16T20:05:39Z", "message": "Merge branch 'master' of github.com:grpc/grpc-java into impl/migrate_to_hierarchical_downstream_lb_tree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef13175023900a0170a5503aca9e953cddfad7bc", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/ef13175023900a0170a5503aca9e953cddfad7bc", "committedDate": "2020-09-16T21:08:34Z", "message": "Save current endpoint_picking_policy and locality_picking_policy in ChildLbState."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79b0c92cc2e78f2c704d8733786445dbc6ee7be0", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/79b0c92cc2e78f2c704d8733786445dbc6ee7be0", "committedDate": "2020-09-16T21:32:43Z", "message": "Switch EDS instance only when eds_service_name changes, assuming the lrs server for the same cluster (eds_service_name) does not change."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f191f854e6b0a4fcfcc5a51f80af96addbab055f", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/f191f854e6b0a4fcfcc5a51f80af96addbab055f", "committedDate": "2020-09-16T21:33:18Z", "message": "Remove unnecessary field."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMDkzMTkw", "url": "https://github.com/grpc/grpc-java/pull/7391#pullrequestreview-490093190", "createdAt": "2020-09-16T23:54:42Z", "commit": {"oid": "f191f854e6b0a4fcfcc5a51f80af96addbab055f"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQyMzo1NDo0MlrOHTIAaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwMDowMjoxNlrOHTIJEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNjE3MQ==", "bodyText": "Does the order matter?", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r489816171", "createdAt": "2020-09-16T23:54:42Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EndpointUpdate;\n+import io.grpc.xds.XdsClient.EndpointWatcher;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+final class EdsLoadBalancer2 extends LoadBalancer {\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final ThreadSafeRandom random;\n+  private final GracefulSwitchLoadBalancer switchingLoadBalancer;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private String cluster;\n+  private ResolvedAddresses resolvedAddresses;\n+  private EdsLbState edsLbState;\n+\n+  EdsLoadBalancer2(LoadBalancer.Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(), ThreadSafeRandomImpl.instance);\n+  }\n+\n+  @VisibleForTesting\n+  EdsLoadBalancer2(\n+      LoadBalancer.Helper helper, LoadBalancerRegistry lbRegistry, ThreadSafeRandom random) {\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.random = checkNotNull(random, \"random\");\n+    switchingLoadBalancer = new GracefulSwitchLoadBalancer(checkNotNull(helper, \"helper\"));\n+    InternalLogId logId = InternalLogId.allocate(\"eds-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(XdsLogLevel.INFO, \"Received EDS lb config: cluster={0}, \"\n+              + \"eds_service_name={1}, endpoint_picking_policy={2}, report_load={3}\",\n+          config.clusterName, config.edsServiceName,\n+          config.endpointPickingPolicy.getProvider().getPolicyName(),\n+          config.lrsServerName != null);\n+    }\n+    if (cluster == null) {\n+      cluster = config.clusterName;\n+    }\n+    if (edsLbState == null || !Objects.equals(edsLbState.edsServiceName, config.edsServiceName)) {\n+      edsLbState = new EdsLbState(config.edsServiceName, config.lrsServerName);\n+      switchingLoadBalancer.switchTo(edsLbState);\n+    }\n+    switchingLoadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    switchingLoadBalancer.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    switchingLoadBalancer.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class EdsLbState extends LoadBalancer.Factory {\n+    @Nullable\n+    private final String edsServiceName;\n+    @Nullable\n+    private final String lrsServerName;\n+    private final String resourceName;\n+\n+    private EdsLbState(@Nullable String edsServiceName, @Nullable String lrsServerName) {\n+      this.edsServiceName = edsServiceName;\n+      this.lrsServerName = lrsServerName;\n+      resourceName = edsServiceName == null ? cluster : edsServiceName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      return new ChildLbState(helper);\n+    }\n+\n+    private final class ChildLbState extends LoadBalancer implements EndpointWatcher {\n+      @Nullable\n+      private final LoadStatsStore loadStatsStore;\n+      private final DropHandlingLbHelper lbHelper;\n+      private List<EquivalentAddressGroup> endpointAddresses = Collections.emptyList();\n+      private Map<Integer, Map<Locality, Integer>> prioritizedLocalityWeights\n+          = Collections.emptyMap();\n+      private PolicySelection localityPickingPolicy;\n+      private PolicySelection endpointPickingPolicy;\n+      @Nullable\n+      private LoadBalancer lb;\n+\n+      private ChildLbState(Helper helper) {\n+        if (lrsServerName != null) {\n+          loadStatsStore = xdsClient.addClientStats(cluster, edsServiceName);\n+          xdsClient.reportClientStats();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f191f854e6b0a4fcfcc5a51f80af96addbab055f"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxNjg2Mw==", "bodyText": "Is this duplicate code?", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r489816863", "createdAt": "2020-09-16T23:56:59Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EndpointUpdate;\n+import io.grpc.xds.XdsClient.EndpointWatcher;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+final class EdsLoadBalancer2 extends LoadBalancer {\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final ThreadSafeRandom random;\n+  private final GracefulSwitchLoadBalancer switchingLoadBalancer;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private String cluster;\n+  private ResolvedAddresses resolvedAddresses;\n+  private EdsLbState edsLbState;\n+\n+  EdsLoadBalancer2(LoadBalancer.Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(), ThreadSafeRandomImpl.instance);\n+  }\n+\n+  @VisibleForTesting\n+  EdsLoadBalancer2(\n+      LoadBalancer.Helper helper, LoadBalancerRegistry lbRegistry, ThreadSafeRandom random) {\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.random = checkNotNull(random, \"random\");\n+    switchingLoadBalancer = new GracefulSwitchLoadBalancer(checkNotNull(helper, \"helper\"));\n+    InternalLogId logId = InternalLogId.allocate(\"eds-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(XdsLogLevel.INFO, \"Received EDS lb config: cluster={0}, \"\n+              + \"eds_service_name={1}, endpoint_picking_policy={2}, report_load={3}\",\n+          config.clusterName, config.edsServiceName,\n+          config.endpointPickingPolicy.getProvider().getPolicyName(),\n+          config.lrsServerName != null);\n+    }\n+    if (cluster == null) {\n+      cluster = config.clusterName;\n+    }\n+    if (edsLbState == null || !Objects.equals(edsLbState.edsServiceName, config.edsServiceName)) {\n+      edsLbState = new EdsLbState(config.edsServiceName, config.lrsServerName);\n+      switchingLoadBalancer.switchTo(edsLbState);\n+    }\n+    switchingLoadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    switchingLoadBalancer.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    switchingLoadBalancer.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class EdsLbState extends LoadBalancer.Factory {\n+    @Nullable\n+    private final String edsServiceName;\n+    @Nullable\n+    private final String lrsServerName;\n+    private final String resourceName;\n+\n+    private EdsLbState(@Nullable String edsServiceName, @Nullable String lrsServerName) {\n+      this.edsServiceName = edsServiceName;\n+      this.lrsServerName = lrsServerName;\n+      resourceName = edsServiceName == null ? cluster : edsServiceName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      return new ChildLbState(helper);\n+    }\n+\n+    private final class ChildLbState extends LoadBalancer implements EndpointWatcher {\n+      @Nullable\n+      private final LoadStatsStore loadStatsStore;\n+      private final DropHandlingLbHelper lbHelper;\n+      private List<EquivalentAddressGroup> endpointAddresses = Collections.emptyList();\n+      private Map<Integer, Map<Locality, Integer>> prioritizedLocalityWeights\n+          = Collections.emptyMap();\n+      private PolicySelection localityPickingPolicy;\n+      private PolicySelection endpointPickingPolicy;\n+      @Nullable\n+      private LoadBalancer lb;\n+\n+      private ChildLbState(Helper helper) {\n+        if (lrsServerName != null) {\n+          loadStatsStore = xdsClient.addClientStats(cluster, edsServiceName);\n+          xdsClient.reportClientStats();\n+        } else {\n+          loadStatsStore = null;\n+        }\n+        lbHelper = new DropHandlingLbHelper(helper);\n+        logger.log(\n+            XdsLogLevel.INFO,\n+            \"Start endpoint watcher on {0} with xDS client {1}\", resourceName, xdsClient);\n+        xdsClient.watchEndpointData(resourceName, this);\n+      }\n+\n+      @Override\n+      public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+        EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+        if (lb != null) {\n+          if (!config.localityPickingPolicy.equals(localityPickingPolicy)\n+              || !config.endpointPickingPolicy.equals(endpointPickingPolicy)) {\n+            PriorityLbConfig childConfig =\n+                generatePriorityLbConfig(cluster, edsServiceName, lrsServerName,\n+                    config.localityPickingPolicy, config.endpointPickingPolicy, lbRegistry,\n+                    prioritizedLocalityWeights);\n+            // TODO(chengyuanzhang): to be deleted after migrating to use XdsClient API.\n+            Attributes attributes;\n+            if (lrsServerName != null) {\n+              attributes =\n+                  resolvedAddresses.getAttributes().toBuilder()\n+                      .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadStatsStore)\n+                      .build();\n+            } else {\n+              attributes = resolvedAddresses.getAttributes();\n+            }\n+            lb.handleResolvedAddresses(\n+                resolvedAddresses.toBuilder()\n+                    .setAddresses(endpointAddresses)\n+                    .setAttributes(attributes)\n+                    .setLoadBalancingPolicyConfig(childConfig)\n+                    .build());\n+          }\n+        }\n+        localityPickingPolicy = config.localityPickingPolicy;\n+        endpointPickingPolicy = config.endpointPickingPolicy;\n+      }\n+\n+      @Override\n+      public void handleNameResolutionError(Status error) {\n+        if (lb != null) {\n+          lb.handleNameResolutionError(error);\n+        } else {\n+          lbHelper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));\n+        }\n+      }\n+\n+      @Override\n+      public void shutdown() {\n+        if (lrsServerName != null) {\n+          xdsClient.cancelClientStatsReport();\n+          xdsClient.removeClientStats(cluster, edsServiceName);\n+        }\n+        xdsClient.cancelEndpointDataWatch(resourceName, this);\n+        logger.log(\n+            XdsLogLevel.INFO,\n+            \"Cancelled endpoint watcher on {0} with xDS client {1}\", resourceName, xdsClient);\n+        if (lb != null) {\n+          lb.shutdown();\n+        }\n+      }\n+\n+      @Override\n+      public boolean canHandleEmptyAddressListFromNameResolution() {\n+        return true;\n+      }\n+\n+      @Override\n+      public void onEndpointChanged(EndpointUpdate update) {\n+        logger.log(XdsLogLevel.DEBUG,\n+            \"Received endpoint update from xDS client {0}: {1}\", xdsClient, update);\n+        if (logger.isLoggable(XdsLogLevel.INFO)) {\n+          logger.log(\n+              XdsLogLevel.INFO,\n+              \"Received endpoint update: cluster_name={0}, {1} localities, {2} drop categories\",\n+              update.getClusterName(), update.getLocalityLbEndpointsMap().size(),\n+              update.getDropPolicies().size());\n+        }\n+        lbHelper.updateDropPolicies(update.getDropPolicies());\n+        Map<Locality, LocalityLbEndpoints> localityLbEndpoints = update.getLocalityLbEndpointsMap();\n+        endpointAddresses = new ArrayList<>();\n+        prioritizedLocalityWeights = new HashMap<>();\n+        for (Locality locality : localityLbEndpoints.keySet()) {\n+          LocalityLbEndpoints localityLbInfo = localityLbEndpoints.get(locality);\n+          int priority = localityLbInfo.getPriority();\n+          for (LbEndpoint endpoint : localityLbInfo.getEndpoints()) {\n+            if (endpoint.isHealthy()) {\n+              EquivalentAddressGroup eag =\n+                  AddressFilter.setPathFilter(\n+                      endpoint.getAddress(),\n+                      Arrays.asList(priorityName(priority), localityName(locality)));\n+              endpointAddresses.add(eag);\n+            }\n+          }\n+          if (!prioritizedLocalityWeights.containsKey(priority)) {\n+            prioritizedLocalityWeights.put(priority, new HashMap<Locality, Integer>());\n+          }\n+          prioritizedLocalityWeights.get(priority).put(\n+              locality, localityLbInfo.getLocalityWeight());\n+        }\n+        if (lb == null) {\n+          lb = lbRegistry.getProvider(PRIORITY_POLICY_NAME).newLoadBalancer(lbHelper);\n+        }\n+        if (localityPickingPolicy != null && endpointPickingPolicy != null) {\n+          PriorityLbConfig config = generatePriorityLbConfig(cluster, edsServiceName,\n+              lrsServerName, localityPickingPolicy, endpointPickingPolicy, lbRegistry,\n+              prioritizedLocalityWeights);\n+          // TODO(chengyuanzhang): to be deleted after migrating to use XdsClient API.\n+          Attributes attributes;\n+          if (lrsServerName != null) {\n+            attributes =\n+                resolvedAddresses.getAttributes().toBuilder()\n+                    .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadStatsStore)\n+                    .build();\n+          } else {\n+            attributes = resolvedAddresses.getAttributes();\n+          }\n+          lb.handleResolvedAddresses(\n+              resolvedAddresses.toBuilder()\n+                  .setAddresses(endpointAddresses)\n+                  .setAttributes(attributes)\n+                  .setLoadBalancingPolicyConfig(config)\n+                  .build());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f191f854e6b0a4fcfcc5a51f80af96addbab055f"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgxODM4NA==", "bodyText": "It shouldn't be this DropHandlingLbHelper  lbHelper either, that's for lb with dropping logic, it's too downstream. The right one should be the helper in ChildLbState(Helper helper).", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r489818384", "createdAt": "2020-09-17T00:02:16Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/EdsLoadBalancer2.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.grpc.ConnectivityState.TRANSIENT_FAILURE;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.grpc.Attributes;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.InternalLogId;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.Status;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.util.ForwardingLoadBalancerHelper;\n+import io.grpc.util.GracefulSwitchLoadBalancer;\n+import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.ThreadSafeRandom.ThreadSafeRandomImpl;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import io.grpc.xds.XdsClient.EndpointUpdate;\n+import io.grpc.xds.XdsClient.EndpointWatcher;\n+import io.grpc.xds.XdsLogger.XdsLogLevel;\n+import io.grpc.xds.XdsSubchannelPickers.ErrorPicker;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import javax.annotation.Nullable;\n+\n+final class EdsLoadBalancer2 extends LoadBalancer {\n+  private final XdsLogger logger;\n+  private final LoadBalancerRegistry lbRegistry;\n+  private final ThreadSafeRandom random;\n+  private final GracefulSwitchLoadBalancer switchingLoadBalancer;\n+  private ObjectPool<XdsClient> xdsClientPool;\n+  private XdsClient xdsClient;\n+  private String cluster;\n+  private ResolvedAddresses resolvedAddresses;\n+  private EdsLbState edsLbState;\n+\n+  EdsLoadBalancer2(LoadBalancer.Helper helper) {\n+    this(helper, LoadBalancerRegistry.getDefaultRegistry(), ThreadSafeRandomImpl.instance);\n+  }\n+\n+  @VisibleForTesting\n+  EdsLoadBalancer2(\n+      LoadBalancer.Helper helper, LoadBalancerRegistry lbRegistry, ThreadSafeRandom random) {\n+    this.lbRegistry = checkNotNull(lbRegistry, \"lbRegistry\");\n+    this.random = checkNotNull(random, \"random\");\n+    switchingLoadBalancer = new GracefulSwitchLoadBalancer(checkNotNull(helper, \"helper\"));\n+    InternalLogId logId = InternalLogId.allocate(\"eds-lb\", helper.getAuthority());\n+    logger = XdsLogger.withLogId(logId);\n+    logger.log(XdsLogLevel.INFO, \"Created\");\n+  }\n+\n+  @Override\n+  public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+    logger.log(XdsLogLevel.DEBUG, \"Received resolution result: {0}\", resolvedAddresses);\n+    this.resolvedAddresses = resolvedAddresses;\n+    if (xdsClientPool == null) {\n+      xdsClientPool = resolvedAddresses.getAttributes().get(XdsAttributes.XDS_CLIENT_POOL);\n+      xdsClient = xdsClientPool.getObject();\n+    }\n+    EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+    if (logger.isLoggable(XdsLogLevel.INFO)) {\n+      logger.log(XdsLogLevel.INFO, \"Received EDS lb config: cluster={0}, \"\n+              + \"eds_service_name={1}, endpoint_picking_policy={2}, report_load={3}\",\n+          config.clusterName, config.edsServiceName,\n+          config.endpointPickingPolicy.getProvider().getPolicyName(),\n+          config.lrsServerName != null);\n+    }\n+    if (cluster == null) {\n+      cluster = config.clusterName;\n+    }\n+    if (edsLbState == null || !Objects.equals(edsLbState.edsServiceName, config.edsServiceName)) {\n+      edsLbState = new EdsLbState(config.edsServiceName, config.lrsServerName);\n+      switchingLoadBalancer.switchTo(edsLbState);\n+    }\n+    switchingLoadBalancer.handleResolvedAddresses(resolvedAddresses);\n+  }\n+\n+  @Override\n+  public void handleNameResolutionError(Status error) {\n+    logger.log(XdsLogLevel.WARNING, \"Received name resolution error: {0}\", error);\n+    switchingLoadBalancer.handleNameResolutionError(error);\n+  }\n+\n+  @Override\n+  public boolean canHandleEmptyAddressListFromNameResolution() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    logger.log(XdsLogLevel.INFO, \"Shutdown\");\n+    switchingLoadBalancer.shutdown();\n+    if (xdsClientPool != null) {\n+      xdsClientPool.returnObject(xdsClient);\n+    }\n+  }\n+\n+  private final class EdsLbState extends LoadBalancer.Factory {\n+    @Nullable\n+    private final String edsServiceName;\n+    @Nullable\n+    private final String lrsServerName;\n+    private final String resourceName;\n+\n+    private EdsLbState(@Nullable String edsServiceName, @Nullable String lrsServerName) {\n+      this.edsServiceName = edsServiceName;\n+      this.lrsServerName = lrsServerName;\n+      resourceName = edsServiceName == null ? cluster : edsServiceName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      return new ChildLbState(helper);\n+    }\n+\n+    private final class ChildLbState extends LoadBalancer implements EndpointWatcher {\n+      @Nullable\n+      private final LoadStatsStore loadStatsStore;\n+      private final DropHandlingLbHelper lbHelper;\n+      private List<EquivalentAddressGroup> endpointAddresses = Collections.emptyList();\n+      private Map<Integer, Map<Locality, Integer>> prioritizedLocalityWeights\n+          = Collections.emptyMap();\n+      private PolicySelection localityPickingPolicy;\n+      private PolicySelection endpointPickingPolicy;\n+      @Nullable\n+      private LoadBalancer lb;\n+\n+      private ChildLbState(Helper helper) {\n+        if (lrsServerName != null) {\n+          loadStatsStore = xdsClient.addClientStats(cluster, edsServiceName);\n+          xdsClient.reportClientStats();\n+        } else {\n+          loadStatsStore = null;\n+        }\n+        lbHelper = new DropHandlingLbHelper(helper);\n+        logger.log(\n+            XdsLogLevel.INFO,\n+            \"Start endpoint watcher on {0} with xDS client {1}\", resourceName, xdsClient);\n+        xdsClient.watchEndpointData(resourceName, this);\n+      }\n+\n+      @Override\n+      public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+        EdsConfig config = (EdsConfig) resolvedAddresses.getLoadBalancingPolicyConfig();\n+        if (lb != null) {\n+          if (!config.localityPickingPolicy.equals(localityPickingPolicy)\n+              || !config.endpointPickingPolicy.equals(endpointPickingPolicy)) {\n+            PriorityLbConfig childConfig =\n+                generatePriorityLbConfig(cluster, edsServiceName, lrsServerName,\n+                    config.localityPickingPolicy, config.endpointPickingPolicy, lbRegistry,\n+                    prioritizedLocalityWeights);\n+            // TODO(chengyuanzhang): to be deleted after migrating to use XdsClient API.\n+            Attributes attributes;\n+            if (lrsServerName != null) {\n+              attributes =\n+                  resolvedAddresses.getAttributes().toBuilder()\n+                      .set(XdsAttributes.ATTR_CLUSTER_SERVICE_LOAD_STATS_STORE, loadStatsStore)\n+                      .build();\n+            } else {\n+              attributes = resolvedAddresses.getAttributes();\n+            }\n+            lb.handleResolvedAddresses(\n+                resolvedAddresses.toBuilder()\n+                    .setAddresses(endpointAddresses)\n+                    .setAttributes(attributes)\n+                    .setLoadBalancingPolicyConfig(childConfig)\n+                    .build());\n+          }\n+        }\n+        localityPickingPolicy = config.localityPickingPolicy;\n+        endpointPickingPolicy = config.endpointPickingPolicy;\n+      }\n+\n+      @Override\n+      public void handleNameResolutionError(Status error) {\n+        if (lb != null) {\n+          lb.handleNameResolutionError(error);\n+        } else {\n+          lbHelper.updateBalancingState(TRANSIENT_FAILURE, new ErrorPicker(error));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f191f854e6b0a4fcfcc5a51f80af96addbab055f"}, "originalPosition": 214}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "844488296215d11df28c0b0bf78c83e57fb253b7", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/844488296215d11df28c0b0bf78c83e57fb253b7", "committedDate": "2020-09-17T08:41:23Z", "message": "Use the right Helper precisely."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb32bbebca81487e7235612b6e39817597c338b5", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/fb32bbebca81487e7235612b6e39817597c338b5", "committedDate": "2020-09-17T08:46:13Z", "message": "Move ResolvedAddresses into each ChildLbState component."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwMjAyODY2", "url": "https://github.com/grpc/grpc-java/pull/7391#pullrequestreview-490202866", "createdAt": "2020-09-17T02:36:22Z", "commit": {"oid": "f191f854e6b0a4fcfcc5a51f80af96addbab055f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QwMjozNjoyMlrOHTM_Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo1NDoyMVrOHTshoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTg5NzgzMQ==", "bodyText": "Can just return mock(Subchannel.class). The test does not depend on anything of Subchannel", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r489897831", "createdAt": "2020-09-17T02:36:22Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/EdsLoadBalancer2Test.java", "diffHunk": "@@ -0,0 +1,836 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.WEIGHTED_TARGET_POLICY_NAME;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import io.grpc.Attributes;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.CreateSubchannelArgs;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.ManagedChannel;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.Status.Code;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.FakeClock;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/**\n+ * Tests for {@link EdsLoadBalancer2}.\n+ */\n+@RunWith(JUnit4.class)\n+public class EdsLoadBalancer2Test {\n+  private static final String CLUSTER = \"cluster-foo.googleapis.com\";\n+  private static final String AUTHORITY = \"api.google.com\";\n+  private static final String EDS_SERVICE_NAME = \"service.googleapis.com\";\n+  private static final String LRS_SERVER_NAME = \"lrs.googleapis.com\";\n+  private final Locality locality1 =\n+      new Locality(\"test-region-1\", \"test-zone-1\", \"test-subzone-1\");\n+  private final Locality locality2 =\n+      new Locality(\"test-region-2\", \"test-zone-2\", \"test-subzone-2\");\n+  private final Locality locality3 =\n+      new Locality(\"test-region-3\", \"test-zone-3\", \"test-subzone-3\");\n+  private final SynchronizationContext syncContext = new SynchronizationContext(\n+      new Thread.UncaughtExceptionHandler() {\n+        @Override\n+        public void uncaughtException(Thread t, Throwable e) {\n+          throw new AssertionError(e);\n+        }\n+      });\n+\n+  private final FakeClock fakeClock = new FakeClock();\n+  private final LoadBalancerRegistry registry = new LoadBalancerRegistry();\n+  private final PolicySelection roundRobin =\n+      new PolicySelection(new FakeLoadBalancerProvider(\"round_robin\"), null, null);\n+  private final PolicySelection weightedTarget =\n+      new PolicySelection(new FakeLoadBalancerProvider(WEIGHTED_TARGET_POLICY_NAME), null, null);\n+  private final List<FakeLoadBalancer> downstreamBalancers = new ArrayList<>();\n+  private final FakeXdsClient xdsClient = new FakeXdsClient();\n+  private final ObjectPool<XdsClient> xdsClientPool = new ObjectPool<XdsClient>() {\n+    @Override\n+    public XdsClient getObject() {\n+      xdsClientRefs++;\n+      return xdsClient;\n+    }\n+\n+    @Override\n+    public XdsClient returnObject(Object object) {\n+      xdsClientRefs--;\n+      return null;\n+    }\n+  };\n+  private LoadBalancer.Helper helper = new FakeLbHelper();\n+  @Mock\n+  private ThreadSafeRandom mockRandom;\n+  private int xdsClientRefs;\n+  private ConnectivityState currentState;\n+  private SubchannelPicker currentPicker;\n+  private EdsLoadBalancer2 loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    MockitoAnnotations.initMocks(this);\n+\n+    registry.register(new FakeLoadBalancerProvider(PRIORITY_POLICY_NAME));\n+    registry.register(new FakeLoadBalancerProvider(LRS_POLICY_NAME));\n+    loadBalancer = new EdsLoadBalancer2(helper, registry, mockRandom);\n+    loadBalancer.handleResolvedAddresses(\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+            .setAttributes(\n+                Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+            .setLoadBalancingPolicyConfig(\n+                new EdsConfig(\n+                    CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, weightedTarget, roundRobin))\n+            .build());\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(xdsClient.watchers).isEmpty();\n+    assertThat(xdsClient.dropStats).isEmpty();\n+    assertThat(xdsClientRefs).isEqualTo(0);\n+    assertThat(downstreamBalancers).isEmpty();\n+  }\n+\n+  @Test\n+  public void receiveFirstEndpointResource() {\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr-1\");\n+    EquivalentAddressGroup endpoint2 = makeAddress(\"endpoint-addr-2\");\n+    EquivalentAddressGroup endpoint3 = makeAddress(\"endpoint-addr-3\");\n+    EquivalentAddressGroup endpoint4 = makeAddress(\"endpoint-addr-4\");\n+    LocalityLbEndpoints localityLbEndpoints1 =\n+        buildLocalityLbEndpoints(1, 70, Arrays.asList(endpoint1, endpoint2));\n+    LocalityLbEndpoints localityLbEndpoints2 =\n+        buildLocalityLbEndpoints(1, 10, Collections.singletonList(endpoint3));\n+    LocalityLbEndpoints localityLbEndpoints3 =\n+        buildLocalityLbEndpoints(2, 20, Collections.singletonList(endpoint4));\n+    xdsClient.deliverClusterLoadAssignment(\n+        EDS_SERVICE_NAME,\n+        ImmutableMap.of(\n+            locality1, localityLbEndpoints1,\n+            locality2, localityLbEndpoints2,\n+            locality3, localityLbEndpoints3));\n+    assertThat(downstreamBalancers).hasSize(1);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(childBalancer.name).isEqualTo(PRIORITY_POLICY_NAME);\n+    PriorityLbConfig config = (PriorityLbConfig) childBalancer.config;\n+    assertThat(config.priorities).containsExactly(\"priority1\", \"priority2\");\n+    PolicySelection child1 = config.childConfigs.get(\"priority1\");\n+    assertThat(child1.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig childConfig1 = (WeightedTargetConfig) child1.getConfig();\n+    assertThat(childConfig1.targets).hasSize(2);\n+    WeightedPolicySelection target1 = childConfig1.targets.get(locality1.toString());\n+    assertThat(target1.weight).isEqualTo(70);\n+    assertThat(target1.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target1.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality1, \"round_robin\");\n+    WeightedPolicySelection target2 = childConfig1.targets.get(locality2.toString());\n+    assertThat(target2.weight).isEqualTo(10);\n+    assertThat(target2.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target2.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality2, \"round_robin\");\n+\n+    PolicySelection child2 = config.childConfigs.get(\"priority2\");\n+    assertThat(child2.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig childConfig2 = (WeightedTargetConfig) child2.getConfig();\n+    assertThat(childConfig2.targets).hasSize(1);\n+    WeightedPolicySelection target3 = childConfig2.targets.get(locality3.toString());\n+    assertThat(target3.weight).isEqualTo(20);\n+    assertThat(target3.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target3.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality3, \"round_robin\");\n+\n+    List<EquivalentAddressGroup> priorityAddr1 =\n+        AddressFilter.filter(childBalancer.addresses, \"priority1\");\n+    assertThat(priorityAddr1).hasSize(3);\n+    assertAddressesEqual(\n+        Arrays.asList(endpoint1, endpoint2, endpoint3),\n+        priorityAddr1);\n+    assertAddressesEqual(\n+        Arrays.asList(endpoint1, endpoint2),\n+        AddressFilter.filter(priorityAddr1, locality1.toString()));\n+    assertAddressesEqual(\n+        Collections.singletonList(endpoint3),\n+        AddressFilter.filter(priorityAddr1, locality2.toString()));\n+\n+    List<EquivalentAddressGroup> priorityAddr2 =\n+        AddressFilter.filter(childBalancer.addresses, \"priority2\");\n+    assertThat(priorityAddr2).hasSize(1);\n+    assertAddressesEqual(Collections.singletonList(endpoint4), priorityAddr2);\n+    assertAddressesEqual(\n+        Collections.singletonList(endpoint4),\n+        AddressFilter.filter(priorityAddr2, locality3.toString()));\n+  }\n+\n+  @Test\n+  public void endpointResourceUpdated() {\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr-1\");\n+    LocalityLbEndpoints localityLbEndpoints1 =\n+        buildLocalityLbEndpoints(1, 10, Collections.singletonList(endpoint1));\n+    xdsClient.deliverClusterLoadAssignment(\n+        EDS_SERVICE_NAME, ImmutableMap.of(locality1, localityLbEndpoints1));\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+\n+    assertThat(childBalancer.name).isEqualTo(PRIORITY_POLICY_NAME);\n+    PriorityLbConfig config = (PriorityLbConfig) childBalancer.config;\n+    assertThat(config.priorities).containsExactly(\"priority1\");\n+    PolicySelection child = config.childConfigs.get(\"priority1\");\n+    assertThat(child.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig childConfig = (WeightedTargetConfig) child.getConfig();\n+    assertThat(childConfig.targets).hasSize(1);\n+    WeightedPolicySelection target = childConfig.targets.get(locality1.toString());\n+    assertThat(target.weight).isEqualTo(10);\n+    assertThat(target.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality1, \"round_robin\");\n+\n+    List<EquivalentAddressGroup> priorityAddr =\n+        AddressFilter.filter(childBalancer.addresses, \"priority1\");\n+    assertThat(priorityAddr).hasSize(1);\n+    assertAddressesEqual(Collections.singletonList(endpoint1), priorityAddr);\n+    assertAddressesEqual(\n+        Collections.singletonList(endpoint1),\n+        AddressFilter.filter(priorityAddr, locality1.toString()));\n+\n+    EquivalentAddressGroup endpoint2 = makeAddress(\"endpoint-addr-2\");\n+    LocalityLbEndpoints localityLbEndpoints2 =\n+        buildLocalityLbEndpoints(1, 30, Collections.singletonList(endpoint2));\n+    xdsClient.deliverClusterLoadAssignment(\n+        EDS_SERVICE_NAME, ImmutableMap.of(locality2, localityLbEndpoints2));\n+\n+    config = (PriorityLbConfig) childBalancer.config;\n+    assertThat(config.priorities).containsExactly(\"priority1\");\n+    child = config.childConfigs.get(\"priority1\");\n+    assertThat(child.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    childConfig = (WeightedTargetConfig) child.getConfig();\n+    assertThat(childConfig.targets).hasSize(1);\n+    target = childConfig.targets.get(locality2.toString());\n+    assertThat(target.weight).isEqualTo(30);\n+    assertThat(target.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality2, \"round_robin\");\n+\n+    priorityAddr = AddressFilter.filter(childBalancer.addresses, \"priority1\");\n+    assertThat(priorityAddr).hasSize(1);\n+    assertAddressesEqual(Collections.singletonList(endpoint2), priorityAddr);\n+    assertAddressesEqual(\n+        Collections.singletonList(endpoint2),\n+        AddressFilter.filter(priorityAddr, locality2.toString()));\n+  }\n+\n+  @Test\n+  public void endpointResourceNeverExist() {\n+    xdsClient.deliverResourceNotFound(EDS_SERVICE_NAME);\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription())\n+        .isEqualTo(\"Resource \" + EDS_SERVICE_NAME + \" is unavailable\");\n+  }\n+\n+  @Test\n+  public void endpointResourceRemoved() {\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(childBalancer.shutdown).isFalse();\n+\n+    xdsClient.deliverResourceNotFound(EDS_SERVICE_NAME);\n+    assertThat(childBalancer.shutdown).isTrue();\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription())\n+        .isEqualTo(\"Resource \" + EDS_SERVICE_NAME + \" is unavailable\");\n+  }\n+\n+  @Test\n+  public void handleDrops() {\n+    FakeLoadBalancerProvider fakeRoundRobinProvider = new FakeLoadBalancerProvider(\"round_robin\");\n+    recreateLoadBalancerWithRealDownstreamLbPolicies(fakeRoundRobinProvider);\n+    when(mockRandom.nextInt(anyInt())).thenReturn(499_999, 1_000_000);\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr-1\");\n+    LocalityLbEndpoints localityLbEndpoints1 =\n+        buildLocalityLbEndpoints(1, 10, Collections.singletonList(endpoint1));\n+    xdsClient.deliverClusterLoadAssignment(\n+        EDS_SERVICE_NAME,\n+        Collections.singletonList(new DropOverload(\"throttle\", 500_000)),\n+        Collections.singletonMap(locality1, localityLbEndpoints1));\n+    assertThat(downstreamBalancers).hasSize(1);  // one leaf balancer\n+    FakeLoadBalancer leafBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(leafBalancer.name).isEqualTo(\"round_robin\");\n+    assertAddressesEqual(Collections.singletonList(makeAddress(\"endpoint-addr-1\")),\n+        leafBalancer.addresses);\n+    Subchannel subchannel = leafBalancer.helper.createSubchannel(\n+        CreateSubchannelArgs.newBuilder().setAddresses(leafBalancer.addresses).build());\n+    leafBalancer.deliverSubchannelState(subchannel, ConnectivityState.READY);\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isFalse();\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription()).isEqualTo(\"Dropped: throttle\");\n+    assertThat(xdsClient.dropStats.get(EDS_SERVICE_NAME).get(\"throttle\").get()).isEqualTo(1);\n+\n+    result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isTrue();\n+    assertThat(result.getSubchannel()).isSameInstanceAs(subchannel);\n+  }\n+\n+  @Test\n+  public void configUpdate_changeEdsServiceName_afterChildPolicyReady_switchGracefully() {\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);  // downstream LB polices instantiated\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    Subchannel subchannel1 = mock(Subchannel.class);\n+    childBalancer.deliverSubchannelState(subchannel1, ConnectivityState.READY);\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getSubchannel()).isSameInstanceAs(subchannel1);\n+\n+    String newEdsServiceName = \"service-foo.googleapis.com\";\n+    loadBalancer.handleResolvedAddresses(\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+            .setAttributes(\n+                Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+            .setLoadBalancingPolicyConfig(\n+                new EdsConfig(\n+                    CLUSTER, newEdsServiceName, LRS_SERVER_NAME, weightedTarget, roundRobin))\n+            .build());\n+    deliverSimpleClusterLoadAssignment(newEdsServiceName);  // instantiate the new subtree\n+    assertThat(downstreamBalancers).hasSize(2);\n+    FakeLoadBalancer newChildBalancer = downstreamBalancers.get(1);\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n+    result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getSubchannel()).isSameInstanceAs(subchannel1);\n+    Subchannel subchannel2 = mock(Subchannel.class);\n+    newChildBalancer.deliverSubchannelState(subchannel2, ConnectivityState.READY);\n+    assertThat(childBalancer.shutdown).isTrue();\n+    result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getSubchannel()).isSameInstanceAs(subchannel2);\n+  }\n+\n+  @Test\n+  public void configUpdate_changeEndpointPickingPolicy() {\n+    FakeLoadBalancerProvider fakeRoundRobinProvider = new FakeLoadBalancerProvider(\"round_robin\");\n+    recreateLoadBalancerWithRealDownstreamLbPolicies(fakeRoundRobinProvider);\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);  // downstream LB policies instantiated\n+    FakeLoadBalancer leafBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(leafBalancer.name).isEqualTo(\"round_robin\");\n+    FakeLoadBalancerProvider fakePickFirstProvider = new FakeLoadBalancerProvider(\"pick_first\");\n+    PolicySelection fakePickFirstSelection =\n+        new PolicySelection(fakePickFirstProvider, null, null);\n+    loadBalancer.handleResolvedAddresses(ResolvedAddresses.newBuilder()\n+        .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+        .setAttributes(\n+            Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+        .setLoadBalancingPolicyConfig(\n+            new EdsConfig(\n+                CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, weightedTarget, fakePickFirstSelection))\n+        .build());\n+    assertThat(leafBalancer.shutdown).isTrue();\n+    leafBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(leafBalancer.name).isEqualTo(\"pick_first\");\n+  }\n+\n+  @Test\n+  public void endpointDiscoveryError_beforeChildPolicyInstantiated_propagateToUpstream() {\n+    xdsClient.deliverError(Status.UNAUTHENTICATED.withDescription(\"permission denied\"));\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isFalse();\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAUTHENTICATED);\n+    assertThat(result.getStatus().getDescription()).isEqualTo(\"permission denied\");\n+  }\n+\n+  @Test\n+  public void endpointDiscoveryError_afterChildPolicyInstantiated_keepUsingCurrentEndpoints() {\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    xdsClient.deliverError(Status.UNAVAILABLE.withDescription(\"not found\"));\n+\n+    assertThat(currentState).isEqualTo(ConnectivityState.CONNECTING);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isTrue();\n+    assertThat(childBalancer.shutdown).isFalse();\n+  }\n+\n+  @Test\n+  public void nameResolutionError_beforeChildPolicyInstantiated_returnErrorPickerToUpstream() {\n+    loadBalancer.handleNameResolutionError(Status.UNIMPLEMENTED.withDescription(\"not found\"));\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isFalse();\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNIMPLEMENTED);\n+    assertThat(result.getStatus().getDescription()).isEqualTo(\"not found\");\n+  }\n+\n+  @Test\n+  public void nameResolutionError_afterChildPolicyInstantiated_propagateToDownstream() {\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+\n+    loadBalancer.handleNameResolutionError(\n+        Status.UNAVAILABLE.withDescription(\"cannot reach server\"));\n+    assertThat(childBalancer.upstreamError.getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(childBalancer.upstreamError.getDescription())\n+        .isEqualTo(\"cannot reach server\");\n+  }\n+\n+  @Test\n+  public void generatePriorityLbConfig() {\n+    Map<Integer, Map<Locality, Integer>> prioritizedLocalityWeights = new HashMap<>();\n+    prioritizedLocalityWeights.put(1, ImmutableMap.of(locality1, 20, locality2, 50));\n+    prioritizedLocalityWeights.put(2, ImmutableMap.of(locality3, 30));\n+    PriorityLbConfig config =\n+        EdsLoadBalancer2.generatePriorityLbConfig(\n+            CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, weightedTarget, roundRobin, registry,\n+            prioritizedLocalityWeights);\n+    assertThat(config.childConfigs).hasSize(2);\n+    assertThat(config.priorities).containsExactly(\"priority1\", \"priority2\");\n+    PolicySelection child1 = config.childConfigs.get(\"priority1\");\n+    assertThat(child1.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig weightedTargetConfig1 = (WeightedTargetConfig) child1.getConfig();\n+    assertThat(weightedTargetConfig1.targets).hasSize(2);\n+    WeightedPolicySelection childTarget1 = weightedTargetConfig1.targets.get(locality1.toString());\n+    assertThat(childTarget1.weight).isEqualTo(20);\n+    assertThat(childTarget1.policySelection.getProvider().getPolicyName())\n+        .isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) childTarget1.policySelection.getConfig(), CLUSTER,\n+        EDS_SERVICE_NAME, LRS_SERVER_NAME, locality1, \"round_robin\");\n+    WeightedPolicySelection childTarget2 = weightedTargetConfig1.targets.get(locality2.toString());\n+    assertThat(childTarget2.weight).isEqualTo(50);\n+    assertThat(childTarget2.policySelection.getProvider().getPolicyName())\n+        .isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) childTarget2.policySelection.getConfig(), CLUSTER,\n+        EDS_SERVICE_NAME, LRS_SERVER_NAME, locality2, \"round_robin\");\n+\n+    PolicySelection child2 = config.childConfigs.get(\"priority2\");\n+    assertThat(child2.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig weightedTargetConfig2 = (WeightedTargetConfig) child2.getConfig();\n+    assertThat(weightedTargetConfig2.targets).hasSize(1);\n+    WeightedPolicySelection childTarget3 = weightedTargetConfig2.targets.get(locality3.toString());\n+    assertThat(childTarget3.weight).isEqualTo(30);\n+    assertThat(childTarget3.policySelection.getProvider().getPolicyName())\n+        .isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) childTarget3.policySelection.getConfig(), CLUSTER,\n+        EDS_SERVICE_NAME, LRS_SERVER_NAME, locality3, \"round_robin\");\n+  }\n+\n+  @Test\n+  public void generateWeightedTargetLbConfig_withLrsPolicy() {\n+    Map<Locality, Integer> localityWeights = ImmutableMap.of(locality1, 30, locality2, 40);\n+    WeightedTargetConfig config =\n+        EdsLoadBalancer2.generateWeightedTargetLbConfig(\n+            CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, roundRobin, registry, localityWeights);\n+    assertThat(config.targets).hasSize(2);\n+    WeightedPolicySelection target1 = config.targets.get(locality1.toString());\n+    assertThat(target1.weight).isEqualTo(30);\n+    assertThat(target1.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target1.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality1, \"round_robin\");\n+\n+    WeightedPolicySelection target2 = config.targets.get(locality2.toString());\n+    assertThat(target2.weight).isEqualTo(40);\n+    assertThat(target2.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target2.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality2, \"round_robin\");\n+  }\n+\n+  @Test\n+  public void generateWeightedTargetLbConfig_withoutLrsPolicy() {\n+    Map<Locality, Integer> localityWeights = ImmutableMap.of(locality1, 30, locality2, 40);\n+    WeightedTargetConfig config =\n+        EdsLoadBalancer2.generateWeightedTargetLbConfig(\n+            CLUSTER, EDS_SERVICE_NAME, null, roundRobin, registry, localityWeights);\n+    assertThat(config.targets).hasSize(2);\n+    WeightedPolicySelection target1 = config.targets.get(locality1.toString());\n+    assertThat(target1.weight).isEqualTo(30);\n+    assertThat(target1.policySelection.getProvider().getPolicyName()).isEqualTo(\"round_robin\");\n+\n+    WeightedPolicySelection target2 = config.targets.get(locality2.toString());\n+    assertThat(target2.weight).isEqualTo(40);\n+    assertThat(target2.policySelection.getProvider().getPolicyName()).isEqualTo(\"round_robin\");\n+  }\n+\n+  private void deliverSimpleClusterLoadAssignment(String resourceName) {\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr-1\");\n+    LocalityLbEndpoints localityLbEndpoints1 =\n+        buildLocalityLbEndpoints(1, 10, Collections.singletonList(endpoint1));\n+    xdsClient.deliverClusterLoadAssignment(\n+        resourceName,\n+        Collections.singletonMap(locality1, localityLbEndpoints1));\n+  }\n+\n+  /**\n+   * Recreate a new {@link EdsLoadBalancer2} that will instantiate its downstream LB policies with\n+   * real implementations, except the leaf policy is replaced with a fake implementation to avoid\n+   * creating connections.\n+   */\n+  private void recreateLoadBalancerWithRealDownstreamLbPolicies(\n+      FakeLoadBalancerProvider fakeLeafPolicyProvider) {\n+    LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+    lbRegistry.deregister(lbRegistry.getProvider(fakeLeafPolicyProvider.getPolicyName()));\n+    lbRegistry.register(fakeLeafPolicyProvider);\n+    loadBalancer.shutdown();\n+    loadBalancer = new EdsLoadBalancer2(helper, lbRegistry, mockRandom);\n+    PolicySelection weightedTargetSelection =\n+        new PolicySelection(lbRegistry.getProvider(WEIGHTED_TARGET_POLICY_NAME), null, null);\n+    PolicySelection fakeLeafPolicySelection =\n+        new PolicySelection(fakeLeafPolicyProvider, null, null);\n+    loadBalancer.handleResolvedAddresses(\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+            .setAttributes(\n+                Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+            .setLoadBalancingPolicyConfig(\n+                new EdsConfig(CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, weightedTargetSelection,\n+                    fakeLeafPolicySelection))\n+            .build());\n+  }\n+\n+  private static void assertLrsConfig(\n+      LrsConfig config, String cluster, String edsServiceName, String lrsServerName,\n+      Locality locality, String childPolicy) {\n+    assertThat(config.clusterName).isEqualTo(cluster);\n+    assertThat(config.edsServiceName).isEqualTo(edsServiceName);\n+    assertThat(config.lrsServerName).isEqualTo(lrsServerName);\n+    assertThat(config.locality).isEqualTo(locality);\n+    assertThat(config.childPolicy.getProvider().getPolicyName()).isEqualTo(childPolicy);\n+  }\n+\n+  /** Asserts two list of EAGs contains same addresses, regardless of attributes. */\n+  private static void assertAddressesEqual(\n+      List<EquivalentAddressGroup> expected, List<EquivalentAddressGroup> actual) {\n+    assertThat(actual.size()).isEqualTo(expected.size());\n+    for (int i = 0; i < actual.size(); i++) {\n+      assertThat(actual.get(i).getAddresses()).isEqualTo(expected.get(i).getAddresses());\n+    }\n+  }\n+\n+  private static LocalityLbEndpoints buildLocalityLbEndpoints(\n+      int priority, int localityWeight, List<EquivalentAddressGroup> endpointAddresses) {\n+    List<LbEndpoint> endpoints = new ArrayList<>();\n+    for (EquivalentAddressGroup addr : endpointAddresses) {\n+      endpoints.add(new LbEndpoint(addr, 100, true));\n+    }\n+    return new LocalityLbEndpoints(endpoints, localityWeight, priority);\n+  }\n+\n+  private static EquivalentAddressGroup makeAddress(final String name) {\n+    class FakeSocketAddress extends SocketAddress {\n+      private final String name;\n+\n+      private FakeSocketAddress(String name) {\n+        this.name = name;\n+      }\n+\n+      @Override\n+      public int hashCode() {\n+        return Objects.hash(name);\n+      }\n+\n+      @Override\n+      public boolean equals(Object o) {\n+        if (this == o) {\n+          return true;\n+        }\n+        if (!(o instanceof FakeSocketAddress)) {\n+          return false;\n+        }\n+        FakeSocketAddress that = (FakeSocketAddress) o;\n+        return Objects.equals(name, that.name);\n+      }\n+\n+      @Override\n+      public String toString() {\n+        return name;\n+      }\n+    }\n+\n+    return new EquivalentAddressGroup(new FakeSocketAddress(name));\n+  }\n+\n+  private final class FakeXdsClient extends XdsClient {\n+    private final Map<String, EndpointWatcher> watchers = new HashMap<>();\n+    private final Map<String, ConcurrentMap<String, AtomicLong>> dropStats = new HashMap<>();\n+\n+    @Override\n+    void shutdown() {\n+      // no-op\n+    }\n+\n+    @Override\n+    void watchEndpointData(String clusterName, EndpointWatcher watcher) {\n+      watchers.put(clusterName, watcher);\n+    }\n+\n+    @Override\n+    void cancelEndpointDataWatch(String clusterName, EndpointWatcher watcher) {\n+      watchers.remove(clusterName);\n+    }\n+\n+    @Override\n+    LoadStatsStore addClientStats(String clusterName, @Nullable String clusterServiceName) {\n+      ConcurrentMap<String, AtomicLong> dropCounters = new ConcurrentHashMap<>();\n+      dropStats.put(clusterServiceName, dropCounters);\n+      return new LoadStatsStoreImpl(clusterName, clusterServiceName,\n+          fakeClock.getStopwatchSupplier().get(), dropCounters);\n+    }\n+\n+    @Override\n+    void removeClientStats(String clusterName, @Nullable String clusterServiceName) {\n+      dropStats.remove(clusterServiceName);\n+    }\n+\n+    void deliverClusterLoadAssignment(\n+        String resource, Map<Locality, LocalityLbEndpoints> localityLbEndpointsMap) {\n+      deliverClusterLoadAssignment(\n+          resource, Collections.<DropOverload>emptyList(), localityLbEndpointsMap);\n+    }\n+\n+    void deliverClusterLoadAssignment(\n+        final String resource, final List<DropOverload> dropOverloads,\n+        final Map<Locality, LocalityLbEndpoints> localityLbEndpointsMap) {\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (watchers.containsKey(resource)) {\n+            EndpointUpdate.Builder builder  = EndpointUpdate.newBuilder().setClusterName(resource);\n+            for (DropOverload dropOverload : dropOverloads) {\n+              builder.addDropPolicy(dropOverload);\n+            }\n+            for (Locality locality : localityLbEndpointsMap.keySet()) {\n+              builder.addLocalityLbEndpoints(locality, localityLbEndpointsMap.get(locality));\n+            }\n+            watchers.get(resource).onEndpointChanged(builder.build());\n+          }\n+        }\n+      });\n+    }\n+\n+    void deliverResourceNotFound(final String resource) {\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          if (watchers.containsKey(resource)) {\n+            watchers.get(resource).onResourceDoesNotExist(resource);\n+          }\n+        }\n+      });\n+    }\n+\n+    void deliverError(final Status error) {\n+      syncContext.execute(new Runnable() {\n+        @Override\n+        public void run() {\n+          for (EndpointWatcher watcher : watchers.values()) {\n+            watcher.onError(error);\n+          }\n+        }\n+      });\n+    }\n+  }\n+\n+  private final class FakeLoadBalancerProvider extends LoadBalancerProvider {\n+    private final String policyName;\n+\n+    FakeLoadBalancerProvider(String policyName) {\n+      this.policyName = policyName;\n+    }\n+\n+    @Override\n+    public LoadBalancer newLoadBalancer(Helper helper) {\n+      FakeLoadBalancer balancer = new FakeLoadBalancer(policyName, helper);\n+      downstreamBalancers.add(balancer);\n+      return balancer;\n+    }\n+\n+    @Override\n+    public boolean isAvailable() {\n+      return true;\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+      return 0;  // doesn't matter\n+    }\n+\n+    @Override\n+    public String getPolicyName() {\n+      return policyName;\n+    }\n+  }\n+\n+  private final class FakeLoadBalancer extends LoadBalancer {\n+    private final String name;\n+    private final Helper helper;\n+    private List<EquivalentAddressGroup> addresses;\n+    private Object config;\n+    private Status upstreamError;\n+    private boolean shutdown;\n+\n+    FakeLoadBalancer(String name, Helper helper) {\n+      this.name = name;\n+      this.helper = helper;\n+    }\n+\n+    @Override\n+    public void handleResolvedAddresses(ResolvedAddresses resolvedAddresses) {\n+      addresses = resolvedAddresses.getAddresses();\n+      config = resolvedAddresses.getLoadBalancingPolicyConfig();\n+    }\n+\n+    @Override\n+    public void handleNameResolutionError(Status error) {\n+      upstreamError = error;\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+      shutdown = true;\n+      downstreamBalancers.remove(this);\n+    }\n+\n+    void deliverSubchannelState(final Subchannel subchannel, ConnectivityState state) {\n+      SubchannelPicker picker = new SubchannelPicker() {\n+        @Override\n+        public PickResult pickSubchannel(PickSubchannelArgs args) {\n+          return PickResult.withSubchannel(subchannel);\n+        }\n+      };\n+      helper.updateBalancingState(state, picker);\n+    }\n+  }\n+\n+  private final class FakeLbHelper extends LoadBalancer.Helper {\n+\n+    @Override\n+    public void updateBalancingState(\n+        @Nonnull ConnectivityState newState, @Nonnull SubchannelPicker newPicker) {\n+      currentState = newState;\n+      currentPicker = newPicker;\n+    }\n+\n+    @Override\n+    public Subchannel createSubchannel(CreateSubchannelArgs args) {\n+      return new FakeSubchannel(args.getAddresses());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f191f854e6b0a4fcfcc5a51f80af96addbab055f"}, "originalPosition": 781}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNDQ5Ng==", "bodyText": "An alternative is: deregister all the fake providers in the setUp(), and re-register those policies with real providers. Then the benefit is you don't need to shutdown the balancer and create a new balancer.\n    registry.deregister(registry.getProvider(PRIORITY_POLICY_NAME));\n    registry.register(new PriorityLoadBalancerProvider());\n    registry.deregister(registry.getProvider(LRS_POLICY_NAME));\n    registry.register(new LrsLoadBalancerProvider());\n    registry.register(fakeLeafPolicyProvider);\n    PolicySelection weightedTargetSelection =\n        new PolicySelection(new WeightedTargetLoadBalancerProvider(), null, null);", "url": "https://github.com/grpc/grpc-java/pull/7391#discussion_r490414496", "createdAt": "2020-09-17T16:54:21Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/test/java/io/grpc/xds/EdsLoadBalancer2Test.java", "diffHunk": "@@ -0,0 +1,836 @@\n+/*\n+ * Copyright 2019 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.grpc.xds.XdsLbPolicies.LRS_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.PRIORITY_POLICY_NAME;\n+import static io.grpc.xds.XdsLbPolicies.WEIGHTED_TARGET_POLICY_NAME;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import io.grpc.Attributes;\n+import io.grpc.ConnectivityState;\n+import io.grpc.EquivalentAddressGroup;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.CreateSubchannelArgs;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancer.PickResult;\n+import io.grpc.LoadBalancer.PickSubchannelArgs;\n+import io.grpc.LoadBalancer.ResolvedAddresses;\n+import io.grpc.LoadBalancer.Subchannel;\n+import io.grpc.LoadBalancer.SubchannelPicker;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.ManagedChannel;\n+import io.grpc.NameResolver;\n+import io.grpc.Status;\n+import io.grpc.Status.Code;\n+import io.grpc.SynchronizationContext;\n+import io.grpc.internal.FakeClock;\n+import io.grpc.internal.ObjectPool;\n+import io.grpc.internal.ServiceConfigUtil.PolicySelection;\n+import io.grpc.xds.EdsLoadBalancerProvider.EdsConfig;\n+import io.grpc.xds.EnvoyProtoData.DropOverload;\n+import io.grpc.xds.EnvoyProtoData.LbEndpoint;\n+import io.grpc.xds.EnvoyProtoData.Locality;\n+import io.grpc.xds.EnvoyProtoData.LocalityLbEndpoints;\n+import io.grpc.xds.LoadStatsManager.LoadStatsStore;\n+import io.grpc.xds.LrsLoadBalancerProvider.LrsConfig;\n+import io.grpc.xds.PriorityLoadBalancerProvider.PriorityLbConfig;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedPolicySelection;\n+import io.grpc.xds.WeightedTargetLoadBalancerProvider.WeightedTargetConfig;\n+import java.net.SocketAddress;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+/**\n+ * Tests for {@link EdsLoadBalancer2}.\n+ */\n+@RunWith(JUnit4.class)\n+public class EdsLoadBalancer2Test {\n+  private static final String CLUSTER = \"cluster-foo.googleapis.com\";\n+  private static final String AUTHORITY = \"api.google.com\";\n+  private static final String EDS_SERVICE_NAME = \"service.googleapis.com\";\n+  private static final String LRS_SERVER_NAME = \"lrs.googleapis.com\";\n+  private final Locality locality1 =\n+      new Locality(\"test-region-1\", \"test-zone-1\", \"test-subzone-1\");\n+  private final Locality locality2 =\n+      new Locality(\"test-region-2\", \"test-zone-2\", \"test-subzone-2\");\n+  private final Locality locality3 =\n+      new Locality(\"test-region-3\", \"test-zone-3\", \"test-subzone-3\");\n+  private final SynchronizationContext syncContext = new SynchronizationContext(\n+      new Thread.UncaughtExceptionHandler() {\n+        @Override\n+        public void uncaughtException(Thread t, Throwable e) {\n+          throw new AssertionError(e);\n+        }\n+      });\n+\n+  private final FakeClock fakeClock = new FakeClock();\n+  private final LoadBalancerRegistry registry = new LoadBalancerRegistry();\n+  private final PolicySelection roundRobin =\n+      new PolicySelection(new FakeLoadBalancerProvider(\"round_robin\"), null, null);\n+  private final PolicySelection weightedTarget =\n+      new PolicySelection(new FakeLoadBalancerProvider(WEIGHTED_TARGET_POLICY_NAME), null, null);\n+  private final List<FakeLoadBalancer> downstreamBalancers = new ArrayList<>();\n+  private final FakeXdsClient xdsClient = new FakeXdsClient();\n+  private final ObjectPool<XdsClient> xdsClientPool = new ObjectPool<XdsClient>() {\n+    @Override\n+    public XdsClient getObject() {\n+      xdsClientRefs++;\n+      return xdsClient;\n+    }\n+\n+    @Override\n+    public XdsClient returnObject(Object object) {\n+      xdsClientRefs--;\n+      return null;\n+    }\n+  };\n+  private LoadBalancer.Helper helper = new FakeLbHelper();\n+  @Mock\n+  private ThreadSafeRandom mockRandom;\n+  private int xdsClientRefs;\n+  private ConnectivityState currentState;\n+  private SubchannelPicker currentPicker;\n+  private EdsLoadBalancer2 loadBalancer;\n+\n+  @Before\n+  public void setUp() {\n+    MockitoAnnotations.initMocks(this);\n+\n+    registry.register(new FakeLoadBalancerProvider(PRIORITY_POLICY_NAME));\n+    registry.register(new FakeLoadBalancerProvider(LRS_POLICY_NAME));\n+    loadBalancer = new EdsLoadBalancer2(helper, registry, mockRandom);\n+    loadBalancer.handleResolvedAddresses(\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+            .setAttributes(\n+                Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+            .setLoadBalancingPolicyConfig(\n+                new EdsConfig(\n+                    CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, weightedTarget, roundRobin))\n+            .build());\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    loadBalancer.shutdown();\n+    assertThat(xdsClient.watchers).isEmpty();\n+    assertThat(xdsClient.dropStats).isEmpty();\n+    assertThat(xdsClientRefs).isEqualTo(0);\n+    assertThat(downstreamBalancers).isEmpty();\n+  }\n+\n+  @Test\n+  public void receiveFirstEndpointResource() {\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr-1\");\n+    EquivalentAddressGroup endpoint2 = makeAddress(\"endpoint-addr-2\");\n+    EquivalentAddressGroup endpoint3 = makeAddress(\"endpoint-addr-3\");\n+    EquivalentAddressGroup endpoint4 = makeAddress(\"endpoint-addr-4\");\n+    LocalityLbEndpoints localityLbEndpoints1 =\n+        buildLocalityLbEndpoints(1, 70, Arrays.asList(endpoint1, endpoint2));\n+    LocalityLbEndpoints localityLbEndpoints2 =\n+        buildLocalityLbEndpoints(1, 10, Collections.singletonList(endpoint3));\n+    LocalityLbEndpoints localityLbEndpoints3 =\n+        buildLocalityLbEndpoints(2, 20, Collections.singletonList(endpoint4));\n+    xdsClient.deliverClusterLoadAssignment(\n+        EDS_SERVICE_NAME,\n+        ImmutableMap.of(\n+            locality1, localityLbEndpoints1,\n+            locality2, localityLbEndpoints2,\n+            locality3, localityLbEndpoints3));\n+    assertThat(downstreamBalancers).hasSize(1);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(childBalancer.name).isEqualTo(PRIORITY_POLICY_NAME);\n+    PriorityLbConfig config = (PriorityLbConfig) childBalancer.config;\n+    assertThat(config.priorities).containsExactly(\"priority1\", \"priority2\");\n+    PolicySelection child1 = config.childConfigs.get(\"priority1\");\n+    assertThat(child1.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig childConfig1 = (WeightedTargetConfig) child1.getConfig();\n+    assertThat(childConfig1.targets).hasSize(2);\n+    WeightedPolicySelection target1 = childConfig1.targets.get(locality1.toString());\n+    assertThat(target1.weight).isEqualTo(70);\n+    assertThat(target1.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target1.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality1, \"round_robin\");\n+    WeightedPolicySelection target2 = childConfig1.targets.get(locality2.toString());\n+    assertThat(target2.weight).isEqualTo(10);\n+    assertThat(target2.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target2.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality2, \"round_robin\");\n+\n+    PolicySelection child2 = config.childConfigs.get(\"priority2\");\n+    assertThat(child2.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig childConfig2 = (WeightedTargetConfig) child2.getConfig();\n+    assertThat(childConfig2.targets).hasSize(1);\n+    WeightedPolicySelection target3 = childConfig2.targets.get(locality3.toString());\n+    assertThat(target3.weight).isEqualTo(20);\n+    assertThat(target3.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target3.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality3, \"round_robin\");\n+\n+    List<EquivalentAddressGroup> priorityAddr1 =\n+        AddressFilter.filter(childBalancer.addresses, \"priority1\");\n+    assertThat(priorityAddr1).hasSize(3);\n+    assertAddressesEqual(\n+        Arrays.asList(endpoint1, endpoint2, endpoint3),\n+        priorityAddr1);\n+    assertAddressesEqual(\n+        Arrays.asList(endpoint1, endpoint2),\n+        AddressFilter.filter(priorityAddr1, locality1.toString()));\n+    assertAddressesEqual(\n+        Collections.singletonList(endpoint3),\n+        AddressFilter.filter(priorityAddr1, locality2.toString()));\n+\n+    List<EquivalentAddressGroup> priorityAddr2 =\n+        AddressFilter.filter(childBalancer.addresses, \"priority2\");\n+    assertThat(priorityAddr2).hasSize(1);\n+    assertAddressesEqual(Collections.singletonList(endpoint4), priorityAddr2);\n+    assertAddressesEqual(\n+        Collections.singletonList(endpoint4),\n+        AddressFilter.filter(priorityAddr2, locality3.toString()));\n+  }\n+\n+  @Test\n+  public void endpointResourceUpdated() {\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr-1\");\n+    LocalityLbEndpoints localityLbEndpoints1 =\n+        buildLocalityLbEndpoints(1, 10, Collections.singletonList(endpoint1));\n+    xdsClient.deliverClusterLoadAssignment(\n+        EDS_SERVICE_NAME, ImmutableMap.of(locality1, localityLbEndpoints1));\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+\n+    assertThat(childBalancer.name).isEqualTo(PRIORITY_POLICY_NAME);\n+    PriorityLbConfig config = (PriorityLbConfig) childBalancer.config;\n+    assertThat(config.priorities).containsExactly(\"priority1\");\n+    PolicySelection child = config.childConfigs.get(\"priority1\");\n+    assertThat(child.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig childConfig = (WeightedTargetConfig) child.getConfig();\n+    assertThat(childConfig.targets).hasSize(1);\n+    WeightedPolicySelection target = childConfig.targets.get(locality1.toString());\n+    assertThat(target.weight).isEqualTo(10);\n+    assertThat(target.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality1, \"round_robin\");\n+\n+    List<EquivalentAddressGroup> priorityAddr =\n+        AddressFilter.filter(childBalancer.addresses, \"priority1\");\n+    assertThat(priorityAddr).hasSize(1);\n+    assertAddressesEqual(Collections.singletonList(endpoint1), priorityAddr);\n+    assertAddressesEqual(\n+        Collections.singletonList(endpoint1),\n+        AddressFilter.filter(priorityAddr, locality1.toString()));\n+\n+    EquivalentAddressGroup endpoint2 = makeAddress(\"endpoint-addr-2\");\n+    LocalityLbEndpoints localityLbEndpoints2 =\n+        buildLocalityLbEndpoints(1, 30, Collections.singletonList(endpoint2));\n+    xdsClient.deliverClusterLoadAssignment(\n+        EDS_SERVICE_NAME, ImmutableMap.of(locality2, localityLbEndpoints2));\n+\n+    config = (PriorityLbConfig) childBalancer.config;\n+    assertThat(config.priorities).containsExactly(\"priority1\");\n+    child = config.childConfigs.get(\"priority1\");\n+    assertThat(child.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    childConfig = (WeightedTargetConfig) child.getConfig();\n+    assertThat(childConfig.targets).hasSize(1);\n+    target = childConfig.targets.get(locality2.toString());\n+    assertThat(target.weight).isEqualTo(30);\n+    assertThat(target.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality2, \"round_robin\");\n+\n+    priorityAddr = AddressFilter.filter(childBalancer.addresses, \"priority1\");\n+    assertThat(priorityAddr).hasSize(1);\n+    assertAddressesEqual(Collections.singletonList(endpoint2), priorityAddr);\n+    assertAddressesEqual(\n+        Collections.singletonList(endpoint2),\n+        AddressFilter.filter(priorityAddr, locality2.toString()));\n+  }\n+\n+  @Test\n+  public void endpointResourceNeverExist() {\n+    xdsClient.deliverResourceNotFound(EDS_SERVICE_NAME);\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription())\n+        .isEqualTo(\"Resource \" + EDS_SERVICE_NAME + \" is unavailable\");\n+  }\n+\n+  @Test\n+  public void endpointResourceRemoved() {\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(childBalancer.shutdown).isFalse();\n+\n+    xdsClient.deliverResourceNotFound(EDS_SERVICE_NAME);\n+    assertThat(childBalancer.shutdown).isTrue();\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription())\n+        .isEqualTo(\"Resource \" + EDS_SERVICE_NAME + \" is unavailable\");\n+  }\n+\n+  @Test\n+  public void handleDrops() {\n+    FakeLoadBalancerProvider fakeRoundRobinProvider = new FakeLoadBalancerProvider(\"round_robin\");\n+    recreateLoadBalancerWithRealDownstreamLbPolicies(fakeRoundRobinProvider);\n+    when(mockRandom.nextInt(anyInt())).thenReturn(499_999, 1_000_000);\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr-1\");\n+    LocalityLbEndpoints localityLbEndpoints1 =\n+        buildLocalityLbEndpoints(1, 10, Collections.singletonList(endpoint1));\n+    xdsClient.deliverClusterLoadAssignment(\n+        EDS_SERVICE_NAME,\n+        Collections.singletonList(new DropOverload(\"throttle\", 500_000)),\n+        Collections.singletonMap(locality1, localityLbEndpoints1));\n+    assertThat(downstreamBalancers).hasSize(1);  // one leaf balancer\n+    FakeLoadBalancer leafBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(leafBalancer.name).isEqualTo(\"round_robin\");\n+    assertAddressesEqual(Collections.singletonList(makeAddress(\"endpoint-addr-1\")),\n+        leafBalancer.addresses);\n+    Subchannel subchannel = leafBalancer.helper.createSubchannel(\n+        CreateSubchannelArgs.newBuilder().setAddresses(leafBalancer.addresses).build());\n+    leafBalancer.deliverSubchannelState(subchannel, ConnectivityState.READY);\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isFalse();\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(result.getStatus().getDescription()).isEqualTo(\"Dropped: throttle\");\n+    assertThat(xdsClient.dropStats.get(EDS_SERVICE_NAME).get(\"throttle\").get()).isEqualTo(1);\n+\n+    result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isTrue();\n+    assertThat(result.getSubchannel()).isSameInstanceAs(subchannel);\n+  }\n+\n+  @Test\n+  public void configUpdate_changeEdsServiceName_afterChildPolicyReady_switchGracefully() {\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);  // downstream LB polices instantiated\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    Subchannel subchannel1 = mock(Subchannel.class);\n+    childBalancer.deliverSubchannelState(subchannel1, ConnectivityState.READY);\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getSubchannel()).isSameInstanceAs(subchannel1);\n+\n+    String newEdsServiceName = \"service-foo.googleapis.com\";\n+    loadBalancer.handleResolvedAddresses(\n+        ResolvedAddresses.newBuilder()\n+            .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+            .setAttributes(\n+                Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+            .setLoadBalancingPolicyConfig(\n+                new EdsConfig(\n+                    CLUSTER, newEdsServiceName, LRS_SERVER_NAME, weightedTarget, roundRobin))\n+            .build());\n+    deliverSimpleClusterLoadAssignment(newEdsServiceName);  // instantiate the new subtree\n+    assertThat(downstreamBalancers).hasSize(2);\n+    FakeLoadBalancer newChildBalancer = downstreamBalancers.get(1);\n+    assertThat(currentState).isEqualTo(ConnectivityState.READY);\n+    result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getSubchannel()).isSameInstanceAs(subchannel1);\n+    Subchannel subchannel2 = mock(Subchannel.class);\n+    newChildBalancer.deliverSubchannelState(subchannel2, ConnectivityState.READY);\n+    assertThat(childBalancer.shutdown).isTrue();\n+    result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getSubchannel()).isSameInstanceAs(subchannel2);\n+  }\n+\n+  @Test\n+  public void configUpdate_changeEndpointPickingPolicy() {\n+    FakeLoadBalancerProvider fakeRoundRobinProvider = new FakeLoadBalancerProvider(\"round_robin\");\n+    recreateLoadBalancerWithRealDownstreamLbPolicies(fakeRoundRobinProvider);\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);  // downstream LB policies instantiated\n+    FakeLoadBalancer leafBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(leafBalancer.name).isEqualTo(\"round_robin\");\n+    FakeLoadBalancerProvider fakePickFirstProvider = new FakeLoadBalancerProvider(\"pick_first\");\n+    PolicySelection fakePickFirstSelection =\n+        new PolicySelection(fakePickFirstProvider, null, null);\n+    loadBalancer.handleResolvedAddresses(ResolvedAddresses.newBuilder()\n+        .setAddresses(Collections.<EquivalentAddressGroup>emptyList())\n+        .setAttributes(\n+            Attributes.newBuilder().set(XdsAttributes.XDS_CLIENT_POOL, xdsClientPool).build())\n+        .setLoadBalancingPolicyConfig(\n+            new EdsConfig(\n+                CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, weightedTarget, fakePickFirstSelection))\n+        .build());\n+    assertThat(leafBalancer.shutdown).isTrue();\n+    leafBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    assertThat(leafBalancer.name).isEqualTo(\"pick_first\");\n+  }\n+\n+  @Test\n+  public void endpointDiscoveryError_beforeChildPolicyInstantiated_propagateToUpstream() {\n+    xdsClient.deliverError(Status.UNAUTHENTICATED.withDescription(\"permission denied\"));\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isFalse();\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNAUTHENTICATED);\n+    assertThat(result.getStatus().getDescription()).isEqualTo(\"permission denied\");\n+  }\n+\n+  @Test\n+  public void endpointDiscoveryError_afterChildPolicyInstantiated_keepUsingCurrentEndpoints() {\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+    xdsClient.deliverError(Status.UNAVAILABLE.withDescription(\"not found\"));\n+\n+    assertThat(currentState).isEqualTo(ConnectivityState.CONNECTING);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isTrue();\n+    assertThat(childBalancer.shutdown).isFalse();\n+  }\n+\n+  @Test\n+  public void nameResolutionError_beforeChildPolicyInstantiated_returnErrorPickerToUpstream() {\n+    loadBalancer.handleNameResolutionError(Status.UNIMPLEMENTED.withDescription(\"not found\"));\n+    assertThat(currentState).isEqualTo(ConnectivityState.TRANSIENT_FAILURE);\n+    PickResult result = currentPicker.pickSubchannel(mock(PickSubchannelArgs.class));\n+    assertThat(result.getStatus().isOk()).isFalse();\n+    assertThat(result.getStatus().getCode()).isEqualTo(Code.UNIMPLEMENTED);\n+    assertThat(result.getStatus().getDescription()).isEqualTo(\"not found\");\n+  }\n+\n+  @Test\n+  public void nameResolutionError_afterChildPolicyInstantiated_propagateToDownstream() {\n+    deliverSimpleClusterLoadAssignment(EDS_SERVICE_NAME);\n+    FakeLoadBalancer childBalancer = Iterables.getOnlyElement(downstreamBalancers);\n+\n+    loadBalancer.handleNameResolutionError(\n+        Status.UNAVAILABLE.withDescription(\"cannot reach server\"));\n+    assertThat(childBalancer.upstreamError.getCode()).isEqualTo(Code.UNAVAILABLE);\n+    assertThat(childBalancer.upstreamError.getDescription())\n+        .isEqualTo(\"cannot reach server\");\n+  }\n+\n+  @Test\n+  public void generatePriorityLbConfig() {\n+    Map<Integer, Map<Locality, Integer>> prioritizedLocalityWeights = new HashMap<>();\n+    prioritizedLocalityWeights.put(1, ImmutableMap.of(locality1, 20, locality2, 50));\n+    prioritizedLocalityWeights.put(2, ImmutableMap.of(locality3, 30));\n+    PriorityLbConfig config =\n+        EdsLoadBalancer2.generatePriorityLbConfig(\n+            CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, weightedTarget, roundRobin, registry,\n+            prioritizedLocalityWeights);\n+    assertThat(config.childConfigs).hasSize(2);\n+    assertThat(config.priorities).containsExactly(\"priority1\", \"priority2\");\n+    PolicySelection child1 = config.childConfigs.get(\"priority1\");\n+    assertThat(child1.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig weightedTargetConfig1 = (WeightedTargetConfig) child1.getConfig();\n+    assertThat(weightedTargetConfig1.targets).hasSize(2);\n+    WeightedPolicySelection childTarget1 = weightedTargetConfig1.targets.get(locality1.toString());\n+    assertThat(childTarget1.weight).isEqualTo(20);\n+    assertThat(childTarget1.policySelection.getProvider().getPolicyName())\n+        .isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) childTarget1.policySelection.getConfig(), CLUSTER,\n+        EDS_SERVICE_NAME, LRS_SERVER_NAME, locality1, \"round_robin\");\n+    WeightedPolicySelection childTarget2 = weightedTargetConfig1.targets.get(locality2.toString());\n+    assertThat(childTarget2.weight).isEqualTo(50);\n+    assertThat(childTarget2.policySelection.getProvider().getPolicyName())\n+        .isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) childTarget2.policySelection.getConfig(), CLUSTER,\n+        EDS_SERVICE_NAME, LRS_SERVER_NAME, locality2, \"round_robin\");\n+\n+    PolicySelection child2 = config.childConfigs.get(\"priority2\");\n+    assertThat(child2.getProvider().getPolicyName()).isEqualTo(WEIGHTED_TARGET_POLICY_NAME);\n+    WeightedTargetConfig weightedTargetConfig2 = (WeightedTargetConfig) child2.getConfig();\n+    assertThat(weightedTargetConfig2.targets).hasSize(1);\n+    WeightedPolicySelection childTarget3 = weightedTargetConfig2.targets.get(locality3.toString());\n+    assertThat(childTarget3.weight).isEqualTo(30);\n+    assertThat(childTarget3.policySelection.getProvider().getPolicyName())\n+        .isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) childTarget3.policySelection.getConfig(), CLUSTER,\n+        EDS_SERVICE_NAME, LRS_SERVER_NAME, locality3, \"round_robin\");\n+  }\n+\n+  @Test\n+  public void generateWeightedTargetLbConfig_withLrsPolicy() {\n+    Map<Locality, Integer> localityWeights = ImmutableMap.of(locality1, 30, locality2, 40);\n+    WeightedTargetConfig config =\n+        EdsLoadBalancer2.generateWeightedTargetLbConfig(\n+            CLUSTER, EDS_SERVICE_NAME, LRS_SERVER_NAME, roundRobin, registry, localityWeights);\n+    assertThat(config.targets).hasSize(2);\n+    WeightedPolicySelection target1 = config.targets.get(locality1.toString());\n+    assertThat(target1.weight).isEqualTo(30);\n+    assertThat(target1.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target1.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality1, \"round_robin\");\n+\n+    WeightedPolicySelection target2 = config.targets.get(locality2.toString());\n+    assertThat(target2.weight).isEqualTo(40);\n+    assertThat(target2.policySelection.getProvider().getPolicyName()).isEqualTo(LRS_POLICY_NAME);\n+    assertLrsConfig((LrsConfig) target2.policySelection.getConfig(), CLUSTER, EDS_SERVICE_NAME,\n+        LRS_SERVER_NAME, locality2, \"round_robin\");\n+  }\n+\n+  @Test\n+  public void generateWeightedTargetLbConfig_withoutLrsPolicy() {\n+    Map<Locality, Integer> localityWeights = ImmutableMap.of(locality1, 30, locality2, 40);\n+    WeightedTargetConfig config =\n+        EdsLoadBalancer2.generateWeightedTargetLbConfig(\n+            CLUSTER, EDS_SERVICE_NAME, null, roundRobin, registry, localityWeights);\n+    assertThat(config.targets).hasSize(2);\n+    WeightedPolicySelection target1 = config.targets.get(locality1.toString());\n+    assertThat(target1.weight).isEqualTo(30);\n+    assertThat(target1.policySelection.getProvider().getPolicyName()).isEqualTo(\"round_robin\");\n+\n+    WeightedPolicySelection target2 = config.targets.get(locality2.toString());\n+    assertThat(target2.weight).isEqualTo(40);\n+    assertThat(target2.policySelection.getProvider().getPolicyName()).isEqualTo(\"round_robin\");\n+  }\n+\n+  private void deliverSimpleClusterLoadAssignment(String resourceName) {\n+    EquivalentAddressGroup endpoint1 = makeAddress(\"endpoint-addr-1\");\n+    LocalityLbEndpoints localityLbEndpoints1 =\n+        buildLocalityLbEndpoints(1, 10, Collections.singletonList(endpoint1));\n+    xdsClient.deliverClusterLoadAssignment(\n+        resourceName,\n+        Collections.singletonMap(locality1, localityLbEndpoints1));\n+  }\n+\n+  /**\n+   * Recreate a new {@link EdsLoadBalancer2} that will instantiate its downstream LB policies with\n+   * real implementations, except the leaf policy is replaced with a fake implementation to avoid\n+   * creating connections.\n+   */\n+  private void recreateLoadBalancerWithRealDownstreamLbPolicies(\n+      FakeLoadBalancerProvider fakeLeafPolicyProvider) {\n+    LoadBalancerRegistry lbRegistry = LoadBalancerRegistry.getDefaultRegistry();\n+    lbRegistry.deregister(lbRegistry.getProvider(fakeLeafPolicyProvider.getPolicyName()));\n+    lbRegistry.register(fakeLeafPolicyProvider);\n+    loadBalancer.shutdown();\n+    loadBalancer = new EdsLoadBalancer2(helper, lbRegistry, mockRandom);\n+    PolicySelection weightedTargetSelection =\n+        new PolicySelection(lbRegistry.getProvider(WEIGHTED_TARGET_POLICY_NAME), null, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f191f854e6b0a4fcfcc5a51f80af96addbab055f"}, "originalPosition": 542}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2dae0f8154bccf7a56139aed54eb0d9247c433f", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/c2dae0f8154bccf7a56139aed54eb0d9247c433f", "committedDate": "2020-09-17T17:34:42Z", "message": "Removed unused FakeSubchannel."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "11197c1821efba36bccf40e572b4542019963229", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/11197c1821efba36bccf40e572b4542019963229", "committedDate": "2020-09-17T17:58:14Z", "message": "Reuse existing LoadBalancer registry with real LB policies."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwOTU0NDMz", "url": "https://github.com/grpc/grpc-java/pull/7391#pullrequestreview-490954433", "createdAt": "2020-09-17T20:14:33Z", "commit": {"oid": "11197c1821efba36bccf40e572b4542019963229"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dc07fb1ba6010109c1002d675383e20d97ac901", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/8dc07fb1ba6010109c1002d675383e20d97ac901", "committedDate": "2020-09-18T00:12:45Z", "message": "Should throw away localities/priorities with no healthy endpoints, and turn into TF is no priority can be used."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c574c5ddb8a73e3e82abc60bfe111777e6420dbb", "author": {"user": {"login": "voidzcy", "name": "Chengyuan Zhang"}}, "url": "https://github.com/grpc/grpc-java/commit/c574c5ddb8a73e3e82abc60bfe111777e6420dbb", "committedDate": "2020-09-18T00:13:21Z", "message": "Add tests to cover throwing away localities/priorities with no healthy endpoints."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4019, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}