{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwNTc4ODk0", "number": 6671, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMDowMTo1MlrODc0UiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMDowMTo1MlrODc0UiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTQzOTQ0OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMDowMTo1MlrOFlEKvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNzo0NTo0OVrOFldZyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQwOTkxOQ==", "bodyText": "I though it was intended in order to let client be able to know the exact error. I think a better way might be to populate the error to the empty resolution result like\nif (error.getCode().equals(Code.NOT_FOUND)) {\n    listener.onResult(ResolutionResult.newBuilder()\n        .setAttributes(Attributes.newBuilder().set(RESOLUTION_ERROR, error).build())\n        .build());\t\n    return;       \n}\n@ejona86 any thought?", "url": "https://github.com/grpc/grpc-java/pull/6671#discussion_r374409919", "createdAt": "2020-02-04T00:01:52Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver.java", "diffHunk": "@@ -178,6 +178,7 @@ public void onError(Status error) {\n         //  a temporary solution. More design discussion needs to be done.\n         if (error.getCode().equals(Code.NOT_FOUND)) {\n           listener.onResult(ResolutionResult.newBuilder().build());\n+          return;\n         }\n         listener.onError(error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d0e2019f627587de231411a086b317fbf9c076e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQxNzU5OA==", "bodyText": "This has something to do with the debate of whether we should fail RPCs immediately or continue using it when TD removes the resource that is currently being used. The discussion turns to be ambiguous and results in such a workaround in implementation. Most voices agree on (CDS/EDS) LB policies continue using Cluster/ClusterLoadAssignment information even if TD deletes it. Therefore, in CDS/EDS balancer's handleNameResolutionError() implementations, it's no-op is the policy currently has data to run. I don't have strong opinion on this. On the other hand, quite amount of people are arguing that RPCs should fail immediately if TD removes LDS/RDS resources. Since channel delegates name resolution error handling to LB policies, it would not work if the xDS resolver returns an error to the channel. Last time, we discussed this as our work around, to return an empty resolution result such that xDS LB policies will be offloaded and pick_first will turn channel into transient failure. I hope there could be a consistent decision for LB policies and resolver whether we should fail RPCs immediately if TD removes corresponding resources. In that case, we do not need this workaround to return an empty resolution result that forces channel go into transient failure.\nCalling both onResult() and onError() doesn't seem to be a good solution, although the onError() after onResult() with empty resolution result does not have any behavior-wise operations other than showing the xDS resource not found message.", "url": "https://github.com/grpc/grpc-java/pull/6671#discussion_r374417598", "createdAt": "2020-02-04T00:29:03Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver.java", "diffHunk": "@@ -178,6 +178,7 @@ public void onError(Status error) {\n         //  a temporary solution. More design discussion needs to be done.\n         if (error.getCode().equals(Code.NOT_FOUND)) {\n           listener.onResult(ResolutionResult.newBuilder().build());\n+          return;\n         }\n         listener.onError(error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQwOTkxOQ=="}, "originalCommit": {"oid": "6d0e2019f627587de231411a086b317fbf9c076e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgyMzM2OA==", "bodyText": "I don't think Attributes.newBuilder().set(RESOLUTION_ERROR, error).build() would do anything. We don't want to each every policy about that.\nGiven where we stand today, it seems onResult (to change the policy) + onError (to report a precise error) seems fine. Although the status code should probably be converted to UNAVAILABLE. Just onResult by itself is okay, because it will typically become \"NameResolver returned no usable address\" which isn't the worst. I would like to improve how we handle things like this, but I don't think we should get bogged down trying to make this perfect at this point in time. We have other discussions in play to change how error handling is done.", "url": "https://github.com/grpc/grpc-java/pull/6671#discussion_r374823368", "createdAt": "2020-02-04T17:45:49Z", "author": {"login": "ejona86"}, "path": "xds/src/main/java/io/grpc/xds/XdsNameResolver.java", "diffHunk": "@@ -178,6 +178,7 @@ public void onError(Status error) {\n         //  a temporary solution. More design discussion needs to be done.\n         if (error.getCode().equals(Code.NOT_FOUND)) {\n           listener.onResult(ResolutionResult.newBuilder().build());\n+          return;\n         }\n         listener.onError(error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQwOTkxOQ=="}, "originalCommit": {"oid": "6d0e2019f627587de231411a086b317fbf9c076e"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2952, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}