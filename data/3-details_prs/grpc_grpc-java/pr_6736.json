{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4MDE2MTQx", "number": 6736, "title": "xds: implement XdsRouting config parser", "bodyText": "Implement xds_routing config part of go/grpc-xds-traffic-splitting-and-path-matching", "createdAt": "2020-02-20T22:53:49Z", "url": "https://github.com/grpc/grpc-java/pull/6736", "merged": true, "mergeCommit": {"oid": "37b231348e235b55826a554956748178aaee1823"}, "closed": true, "closedAt": "2020-02-29T01:50:18Z", "author": {"login": "dapengzhang0"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGTPOLgBqjMwNTg1ODE3MDg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcI55IWAFqTM2Njc2MjE5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "180c4c8643488995f8dd9b3f325217731f490be1", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/180c4c8643488995f8dd9b3f325217731f490be1", "committedDate": "2020-02-20T22:52:11Z", "message": "xds: implement XdsRouting config parser"}, "afterCommit": {"oid": "cfe4520e480a61192300d06251a18528fa68323c", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/cfe4520e480a61192300d06251a18528fa68323c", "committedDate": "2020-02-20T22:54:14Z", "message": "xds: implement XdsRouting config parser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "committedDate": "2020-02-21T18:39:49Z", "message": "xds: implement XdsRouting config parser"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cfe4520e480a61192300d06251a18528fa68323c", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/cfe4520e480a61192300d06251a18528fa68323c", "committedDate": "2020-02-20T22:54:14Z", "message": "xds: implement XdsRouting config parser"}, "afterCommit": {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/8bf1728a8e9fa38901cf5d27849358f2b4ded1b2", "committedDate": "2020-02-21T18:39:49Z", "message": "xds: implement XdsRouting config parser"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NzE3ODI5", "url": "https://github.com/grpc/grpc-java/pull/6736#pullrequestreview-366717829", "createdAt": "2020-02-28T22:15:55Z", "commit": {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMjoxNTo1NVrOFwEXdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzowMzoyN1rOFwFPPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0NzUxMQ==", "bodyText": "Little improvement: please rephrase this message. Also, the existing way of selecting policy does the logging more elegantly (It only log at most once).", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385947511", "createdAt": "2020-02-28T22:15:55Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  XdsRoutingLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return XDS_ROUTING_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    // TODO(zdapeng): pass helper and loadBalancerRegistry() to constructor args.\n+    return new XdsRoutingLoadBalancer();\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n+      if (actions == null || actions.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n+      for (String name : actions.keySet()) {\n+        Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n+        if (rawAction == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+        }\n+\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in xds_routing LB policy:\\n {1}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0NzkzMQ==", "bodyText": "nit: may not want to put white space after \\n. Apply to other places as well.", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385947931", "createdAt": "2020-02-28T22:17:04Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  XdsRoutingLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return XDS_ROUTING_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    // TODO(zdapeng): pass helper and loadBalancerRegistry() to constructor args.\n+    return new XdsRoutingLoadBalancer();\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n+      if (actions == null || actions.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NjI1NQ==", "bodyText": "Why not this(LoadBalancerRegistry.getDefaultRegistry()) and make lbRegistry non-null? Then you do not need the method loadBalancerRegistry().", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385956255", "createdAt": "2020-02-28T22:43:42Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MDAwNQ==", "bodyText": "Little improvement: although I am not an opponent for writing giant methods, this one seems to be too big to read. This can be elegantly split into two helper methods: one for parsing route and one for parsing action. Each one returns a list or a map and throws exception.\nI am also fine if you just leave it as is.", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385960005", "createdAt": "2020-02-28T22:57:00Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  XdsRoutingLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return XDS_ROUTING_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    // TODO(zdapeng): pass helper and loadBalancerRegistry() to constructor args.\n+    return new XdsRoutingLoadBalancer();\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTIxMw==", "bodyText": "s/methodName/method_name/g\nError message for input data, not implementation details.", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385961213", "createdAt": "2020-02-28T23:01:15Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  XdsRoutingLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return XDS_ROUTING_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    // TODO(zdapeng): pass helper and loadBalancerRegistry() to constructor args.\n+    return new XdsRoutingLoadBalancer();\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n+      if (actions == null || actions.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n+      for (String name : actions.keySet()) {\n+        Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n+        if (rawAction == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+        }\n+\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in xds_routing LB policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedActions.put(\n+                name,\n+                new ChildConfig(policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+\n+      List<Map<String, ?>> routes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n+      if (routes == null || routes.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No routes provided for xds_routing LB policy:\\n\" + rawConfig));\n+      }\n+      List<Route> parsedRoutes = new ArrayList<>();\n+      Set<MethodName> methodNames = new HashSet<>();\n+      for (int i = 0; i < routes.size(); i++) {\n+        Map<String, ?> route = routes.get(i);\n+        String actionName = JsonUtil.getString(route, \"action\");\n+        if (actionName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action name provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        if (!parsedActions.containsKey(actionName)) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action defined for route \" + route + \" in xds_routing LB policy:\\n\" + rawConfig));\n+        }\n+\n+        Map<String, ?> methodName = JsonUtil.getObject(route, \"methodName\");\n+        if (methodName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No methodName provided for one of the routes in xds_routing LB policy:\\n\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTQ2NQ==", "bodyText": "nit: delete redundant empty line. Check other places.", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385961465", "createdAt": "2020-02-28T23:02:11Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  XdsRoutingLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return XDS_ROUTING_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    // TODO(zdapeng): pass helper and loadBalancerRegistry() to constructor args.\n+    return new XdsRoutingLoadBalancer();\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n+      if (actions == null || actions.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n+      for (String name : actions.keySet()) {\n+        Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n+        if (rawAction == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+        }\n+\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in xds_routing LB policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedActions.put(\n+                name,\n+                new ChildConfig(policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+\n+      List<Map<String, ?>> routes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n+      if (routes == null || routes.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No routes provided for xds_routing LB policy:\\n\" + rawConfig));\n+      }\n+      List<Route> parsedRoutes = new ArrayList<>();\n+      Set<MethodName> methodNames = new HashSet<>();\n+      for (int i = 0; i < routes.size(); i++) {\n+        Map<String, ?> route = routes.get(i);\n+        String actionName = JsonUtil.getString(route, \"action\");\n+        if (actionName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action name provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        if (!parsedActions.containsKey(actionName)) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action defined for route \" + route + \" in xds_routing LB policy:\\n\" + rawConfig));\n+        }\n+\n+        Map<String, ?> methodName = JsonUtil.getObject(route, \"methodName\");\n+        if (methodName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No methodName provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+        String service = JsonUtil.getString(methodName, \"service\");\n+        String method = JsonUtil.getString(methodName, \"method\");\n+        if (service == null || method == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No service or method provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTY0Nw==", "bodyText": "s/rout/route/g", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385961647", "createdAt": "2020-02-28T23:02:55Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  XdsRoutingLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return XDS_ROUTING_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    // TODO(zdapeng): pass helper and loadBalancerRegistry() to constructor args.\n+    return new XdsRoutingLoadBalancer();\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n+      if (actions == null || actions.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n+      for (String name : actions.keySet()) {\n+        Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n+        if (rawAction == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+        }\n+\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in xds_routing LB policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedActions.put(\n+                name,\n+                new ChildConfig(policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+\n+      List<Map<String, ?>> routes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n+      if (routes == null || routes.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No routes provided for xds_routing LB policy:\\n\" + rawConfig));\n+      }\n+      List<Route> parsedRoutes = new ArrayList<>();\n+      Set<MethodName> methodNames = new HashSet<>();\n+      for (int i = 0; i < routes.size(); i++) {\n+        Map<String, ?> route = routes.get(i);\n+        String actionName = JsonUtil.getString(route, \"action\");\n+        if (actionName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action name provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        if (!parsedActions.containsKey(actionName)) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action defined for route \" + route + \" in xds_routing LB policy:\\n\" + rawConfig));\n+        }\n+\n+        Map<String, ?> methodName = JsonUtil.getObject(route, \"methodName\");\n+        if (methodName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No methodName provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+        String service = JsonUtil.getString(methodName, \"service\");\n+        String method = JsonUtil.getString(methodName, \"method\");\n+        if (service == null || method == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No service or method provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        MethodName parseMethodName = new MethodName(service, method);\n+\n+        if (i == routes.size() - 1 && !parseMethodName.isDefault()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"The last route in routes is not the default rout in xds_routing LB policy:\\n\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTc4OA==", "bodyText": "s/methodName/method_name/g", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385961788", "createdAt": "2020-02-28T23:03:27Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  XdsRoutingLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return XDS_ROUTING_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    // TODO(zdapeng): pass helper and loadBalancerRegistry() to constructor args.\n+    return new XdsRoutingLoadBalancer();\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n+      if (actions == null || actions.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n+      for (String name : actions.keySet()) {\n+        Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n+        if (rawAction == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+        }\n+\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in xds_routing LB policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedActions.put(\n+                name,\n+                new ChildConfig(policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+\n+      List<Map<String, ?>> routes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n+      if (routes == null || routes.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No routes provided for xds_routing LB policy:\\n\" + rawConfig));\n+      }\n+      List<Route> parsedRoutes = new ArrayList<>();\n+      Set<MethodName> methodNames = new HashSet<>();\n+      for (int i = 0; i < routes.size(); i++) {\n+        Map<String, ?> route = routes.get(i);\n+        String actionName = JsonUtil.getString(route, \"action\");\n+        if (actionName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action name provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        if (!parsedActions.containsKey(actionName)) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action defined for route \" + route + \" in xds_routing LB policy:\\n\" + rawConfig));\n+        }\n+\n+        Map<String, ?> methodName = JsonUtil.getObject(route, \"methodName\");\n+        if (methodName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No methodName provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+        String service = JsonUtil.getString(methodName, \"service\");\n+        String method = JsonUtil.getString(methodName, \"method\");\n+        if (service == null || method == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No service or method provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        MethodName parseMethodName = new MethodName(service, method);\n+\n+        if (i == routes.size() - 1 && !parseMethodName.isDefault()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"The last route in routes is not the default rout in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        if (methodNames.contains(parseMethodName)) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"Duplicate methodName found in routes in xds_routing LB policy:\\n\" + rawConfig));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2"}, "originalPosition": 195}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NzQ1MTgz", "url": "https://github.com/grpc/grpc-java/pull/6736#pullrequestreview-366745183", "createdAt": "2020-02-28T23:38:44Z", "commit": {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzozODo0NFrOFwFwRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMzozODo0NFrOFwFwRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3MDI0NQ==", "bodyText": "Use XdsLogger? Whatever, can leave it as is and improve as things being stabilized.\nUpdate: don't need to change it, just leave it as is. Configuring log handler io.grpc.xds can still include this logger.", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385970245", "createdAt": "2020-02-28T23:38:44Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NzUyMzI2", "url": "https://github.com/grpc/grpc-java/pull/6736#pullrequestreview-366752326", "createdAt": "2020-02-29T00:08:54Z", "commit": {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwMDowODo1NFrOFwGIpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwMDowODo1NFrOFwGIpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3NjQ4Ng==", "bodyText": "I think we should define a ParsedConfig class with policyName and config fields, similar to LbConfig. This could be useful for all hierarchical LB configs.", "url": "https://github.com/grpc/grpc-java/pull/6736#discussion_r385976486", "createdAt": "2020-02-29T00:08:54Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsRoutingLoadBalancerProvider.java", "diffHunk": "@@ -0,0 +1,370 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.xds;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.grpc.Internal;\n+import io.grpc.LoadBalancer;\n+import io.grpc.LoadBalancer.Helper;\n+import io.grpc.LoadBalancerProvider;\n+import io.grpc.LoadBalancerRegistry;\n+import io.grpc.NameResolver.ConfigOrError;\n+import io.grpc.Status;\n+import io.grpc.internal.JsonUtil;\n+import io.grpc.internal.ServiceConfigUtil;\n+import io.grpc.internal.ServiceConfigUtil.LbConfig;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * The provider for the xds_routing balancing policy.  This class should not be directly referenced\n+ * in code.  The policy should be accessed through {@link LoadBalancerRegistry#getProvider} with the\n+ * name \"xds_routing_experimental\".\n+ */\n+@Internal\n+public final class XdsRoutingLoadBalancerProvider extends LoadBalancerProvider {\n+\n+  static final String XDS_ROUTING_POLICY_NAME = \"xds_routing_experimental\";\n+  private static final Logger logger =\n+      Logger.getLogger(XdsRoutingLoadBalancerProvider.class.getName());\n+\n+  @Nullable\n+  private final LoadBalancerRegistry lbRegistry;\n+\n+  // We can not call this(LoadBalancerRegistry.getDefaultRegistry()), because it will get stuck\n+  // recursively loading LoadBalancerRegistry and XdsRoutingLoadBalancerProvider.\n+  public XdsRoutingLoadBalancerProvider() {\n+    this(null);\n+  }\n+\n+  @VisibleForTesting\n+  XdsRoutingLoadBalancerProvider(@Nullable LoadBalancerRegistry lbRegistry) {\n+    this.lbRegistry = lbRegistry;\n+  }\n+\n+  private LoadBalancerRegistry loadBalancerRegistry() {\n+    return lbRegistry == null ? LoadBalancerRegistry.getDefaultRegistry() : lbRegistry;\n+  }\n+\n+  @Override\n+  public boolean isAvailable() {\n+    return true;\n+  }\n+\n+  @Override\n+  public int getPriority() {\n+    return 5;\n+  }\n+\n+  @Override\n+  public String getPolicyName() {\n+    return XDS_ROUTING_POLICY_NAME;\n+  }\n+\n+  @Override\n+  public LoadBalancer newLoadBalancer(Helper helper) {\n+    // TODO(zdapeng): pass helper and loadBalancerRegistry() to constructor args.\n+    return new XdsRoutingLoadBalancer();\n+  }\n+\n+  @Override\n+  public ConfigOrError parseLoadBalancingPolicyConfig(Map<String, ?> rawConfig) {\n+    try {\n+      Map<String, ?> actions = JsonUtil.getObject(rawConfig, \"action\");\n+      if (actions == null || actions.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No actions provided for xds_routing LB policy:\\n \" + rawConfig));\n+      }\n+      Map<String, ChildConfig> parsedActions = new LinkedHashMap<>();\n+      for (String name : actions.keySet()) {\n+        Map<String, ?> rawAction = JsonUtil.getObject(actions, name);\n+        if (rawAction == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No config for action \" + name + \" in xds_routing LB policy:\\n \" + rawConfig));\n+        }\n+\n+        List<LbConfig> childConfigCandidates = ServiceConfigUtil.unwrapLoadBalancingConfigList(\n+            JsonUtil.getListOfObjects(rawAction, \"childPolicy\"));\n+        if (childConfigCandidates == null || childConfigCandidates.isEmpty()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+        boolean targetParsingSucceeded = false;\n+        for (LbConfig lbConfig : childConfigCandidates) {\n+          String policyName = lbConfig.getPolicyName();\n+          LoadBalancerProvider lbProvider = loadBalancerRegistry().getProvider(policyName);\n+          if (lbProvider == null) {\n+            logger.log(\n+                Level.FINEST,\n+                \"The policy {0} for is not available in xds_routing LB policy:\\n {1}\",\n+                new Object[]{policyName, name});\n+          } else {\n+            ConfigOrError parsedLbPolicyConfig = lbProvider\n+                .parseLoadBalancingPolicyConfig(lbConfig.getRawConfigValue());\n+            if (parsedLbPolicyConfig.getError() != null) {\n+              // Based on service config error-handling spec, if the chosen config is found invalid\n+              // while other configs that come later were valid, the gRPC config would still be\n+              // considered invalid as a whole.\n+              return parsedLbPolicyConfig;\n+            }\n+            parsedActions.put(\n+                name,\n+                new ChildConfig(policyName, parsedLbPolicyConfig.getConfig()));\n+            targetParsingSucceeded = true;\n+            break;\n+          }\n+        }\n+        if (!targetParsingSucceeded) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No child policy available for action \" + name + \" in xds_routing LB policy:\\n \"\n+                  + rawConfig));\n+        }\n+      }\n+\n+      List<Map<String, ?>> routes = JsonUtil.getListOfObjects(rawConfig, \"route\");\n+      if (routes == null || routes.isEmpty()) {\n+        return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+            \"No routes provided for xds_routing LB policy:\\n\" + rawConfig));\n+      }\n+      List<Route> parsedRoutes = new ArrayList<>();\n+      Set<MethodName> methodNames = new HashSet<>();\n+      for (int i = 0; i < routes.size(); i++) {\n+        Map<String, ?> route = routes.get(i);\n+        String actionName = JsonUtil.getString(route, \"action\");\n+        if (actionName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action name provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        if (!parsedActions.containsKey(actionName)) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No action defined for route \" + route + \" in xds_routing LB policy:\\n\" + rawConfig));\n+        }\n+\n+        Map<String, ?> methodName = JsonUtil.getObject(route, \"methodName\");\n+        if (methodName == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No methodName provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+        String service = JsonUtil.getString(methodName, \"service\");\n+        String method = JsonUtil.getString(methodName, \"method\");\n+        if (service == null || method == null) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"No service or method provided for one of the routes in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        MethodName parseMethodName = new MethodName(service, method);\n+\n+        if (i == routes.size() - 1 && !parseMethodName.isDefault()) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"The last route in routes is not the default rout in xds_routing LB policy:\\n\"\n+                  + rawConfig));\n+        }\n+\n+        if (methodNames.contains(parseMethodName)) {\n+          return ConfigOrError.fromError(Status.INTERNAL.withDescription(\n+              \"Duplicate methodName found in routes in xds_routing LB policy:\\n\" + rawConfig));\n+        }\n+        methodNames.add(parseMethodName);\n+\n+        parsedRoutes.add(new Route(actionName, parseMethodName));\n+      }\n+\n+      return ConfigOrError.fromConfig(new XdsRoutingConfig(parsedRoutes, parsedActions));\n+    } catch (RuntimeException e) {\n+      return ConfigOrError.fromError(\n+          Status.fromThrowable(e).withDescription(\n+              \"Failed to parse xds_routing LB config: \" + rawConfig));\n+    }\n+  }\n+\n+  static final class XdsRoutingConfig {\n+\n+    final List<Route> routes;\n+    final Map<String, ChildConfig> actions;\n+\n+    /**\n+     * Constructs a deeply parsed xds_routing config with the given non-empty list of routes, the\n+     * action of each of which is provided by the given map of actions.\n+     */\n+    @VisibleForTesting\n+    XdsRoutingConfig(List<Route> routes,\n+        Map<String, ChildConfig> actions) {\n+      this.routes = ImmutableList.copyOf(routes);\n+      this.actions = ImmutableMap.copyOf(actions);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      XdsRoutingConfig that = (XdsRoutingConfig) o;\n+      return Objects.equals(routes, that.routes)\n+          && Objects.equals(actions, that.actions);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(routes, actions);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"routes\", routes)\n+          .add(\"actions\", actions)\n+          .toString();\n+    }\n+  }\n+\n+  static final class Route {\n+\n+    final String actionName;\n+    final MethodName methodName;\n+\n+    @VisibleForTesting\n+    Route(String actionName, MethodName methodName) {\n+      this.actionName = actionName;\n+      this.methodName = methodName;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      Route route = (Route) o;\n+      return Objects.equals(actionName, route.actionName)\n+          && Objects.equals(methodName, route.methodName);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(actionName, methodName);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"actionName\", actionName)\n+          .add(\"methodName\", methodName)\n+          .toString();\n+    }\n+  }\n+\n+  static final class MethodName {\n+\n+    final String service;\n+    final String method;\n+\n+    @VisibleForTesting\n+    MethodName(String service, String method) {\n+      this.service = service;\n+      this.method = method;\n+    }\n+\n+    boolean isDefault() {\n+      return service.isEmpty() && method.isEmpty();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      MethodName that = (MethodName) o;\n+      return Objects.equals(service, that.service)\n+          && Objects.equals(method, that.method);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(service, method);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return MoreObjects.toStringHelper(this)\n+          .add(\"service\", service)\n+          .add(\"method\", method)\n+          .toString();\n+    }\n+  }\n+\n+  static final class ChildConfig {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf1728a8e9fa38901cf5d27849358f2b4ded1b2"}, "originalPosition": 333}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0ad72237b773f0c62b7c97f2f81e865de0c90fd", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/f0ad72237b773f0c62b7c97f2f81e865de0c90fd", "committedDate": "2020-02-29T00:16:01Z", "message": "fix messages"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NzYyMTkw", "url": "https://github.com/grpc/grpc-java/pull/6736#pullrequestreview-366762190", "createdAt": "2020-02-29T01:04:28Z", "commit": {"oid": "f0ad72237b773f0c62b7c97f2f81e865de0c90fd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4591, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}