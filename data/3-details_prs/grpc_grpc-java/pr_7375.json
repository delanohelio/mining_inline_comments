{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1MDI2NjUw", "number": 7375, "title": "core, api, benchmarks: Random acts of garbage reduction", "bodyText": "I noticed some opportunities to reduce allocations on hot paths", "createdAt": "2020-08-28T00:57:53Z", "url": "https://github.com/grpc/grpc-java/pull/7375", "merged": true, "mergeCommit": {"oid": "2072df9be6ab78159b3f1bb364083d86310b6fd9"}, "closed": true, "closedAt": "2021-01-21T18:45:32Z", "author": {"login": "njhill"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdDLjW3gBqjM3MDIwOTM4MjE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdxdtORAH2gAyNDc1MDI2NjUwOmJlMjg1MjM2MDJiNWYwYTdlYjdiYWU0NzRhYzY1ODgyNDhiZjUzNjQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7491f3669b96852955c10ec7048eec4b005a0c6d", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/grpc/grpc-java/commit/7491f3669b96852955c10ec7048eec4b005a0c6d", "committedDate": "2020-08-28T02:22:43Z", "message": "core, api, benchmarks: Random acts of garbage reduction\n\nI noticed some opportunities to reduce allocations on hot paths"}, "afterCommit": {"oid": "3e3e8af5d4ab7382602d58ceec7343620cd7322f", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/grpc/grpc-java/commit/3e3e8af5d4ab7382602d58ceec7343620cd7322f", "committedDate": "2020-08-28T02:26:17Z", "message": "core, api, benchmarks: Random acts of garbage reduction\n\nI noticed some opportunities to reduce allocations on hot paths"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/grpc/grpc-java/commit/f661a1c522faf479eb905f48d1e826603a20b75d", "committedDate": "2020-08-28T03:47:59Z", "message": "core, api, benchmarks: Random acts of garbage reduction\n\nI noticed some opportunities to reduce allocations on hot paths"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e3e8af5d4ab7382602d58ceec7343620cd7322f", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/grpc/grpc-java/commit/3e3e8af5d4ab7382602d58ceec7343620cd7322f", "committedDate": "2020-08-28T02:26:17Z", "message": "core, api, benchmarks: Random acts of garbage reduction\n\nI noticed some opportunities to reduce allocations on hot paths"}, "afterCommit": {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/grpc/grpc-java/commit/f661a1c522faf479eb905f48d1e826603a20b75d", "committedDate": "2020-08-28T03:47:59Z", "message": "core, api, benchmarks: Random acts of garbage reduction\n\nI noticed some opportunities to reduce allocations on hot paths"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMTM1ODU3", "url": "https://github.com/grpc/grpc-java/pull/7375#pullrequestreview-522135857", "createdAt": "2020-11-03T01:05:19Z", "commit": {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMTowNToxOVrOHsdK0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMjoyOTowNVrOHseZNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM3NzI5Nw==", "bodyText": "So this avoids the copy constructor from allocating the object. Nice. Since this is zero-size, would it be even better to share a single copy cross-instance?", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516377297", "createdAt": "2020-11-03T01:05:19Z", "author": {"login": "ejona86"}, "path": "api/src/main/java/io/grpc/CallOptions.java", "diffHunk": "@@ -61,7 +61,7 @@\n   @Nullable\n   private String compressorName;\n \n-  private Object[][] customOptions = new Object[0][2];\n+  private Object[][] customOptions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM3ODY0Mw==", "bodyText": "I don't think we want to \"cheat\" with these benchmarks. Most users will pay these same costs.\nIf we really wanted to optimize this, we would have a single pre-created ByteString and use it to build a new one of the needed size. That would avoid allocating/copying any of the data. But then it is really a lie.", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516378643", "createdAt": "2020-11-03T01:09:48Z", "author": {"login": "ejona86"}, "path": "benchmarks/src/main/java/io/grpc/benchmarks/Utils.java", "diffHunk": "@@ -252,7 +253,7 @@ public static SimpleResponse makeResponse(SimpleRequest request) {\n         throw Status.INTERNAL.augmentDescription(\"Error creating payload.\").asRuntimeException();\n       }\n \n-      ByteString body = ByteString.copyFrom(new byte[request.getResponseSize()]);\n+      ByteString body = UnsafeByteOperations.unsafeWrap(new byte[request.getResponseSize()]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM3OTU1MA==", "bodyText": "Oh, interesting. I didn't realize IdentityHashMap avoided the Map.Entries.", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516379550", "createdAt": "2020-11-03T01:13:19Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/inprocess/InProcessTransport.java", "diffHunk": "@@ -96,7 +97,8 @@\n   @GuardedBy(\"this\")\n   private Status shutdownStatus;\n   @GuardedBy(\"this\")\n-  private Set<InProcessStream> streams = new HashSet<>();\n+  private Set<InProcessStream> streams = Collections.newSetFromMap(\n+          new IdentityHashMap<InProcessStream, Boolean>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MDIwNw==", "bodyText": "What changed here? It looks the same. The old version grabbed a variable a few more times, but not only is the variable non-volatile, it's even final. So I can't believe it would actually make any difference.", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516380207", "createdAt": "2020-11-03T01:15:40Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -50,9 +58,9 @@ public void addBuffer(ReadableBuffer buffer) {\n     }\n \n     CompositeReadableBuffer compositeBuffer = (CompositeReadableBuffer) buffer;\n-    while (!compositeBuffer.buffers.isEmpty()) {\n-      ReadableBuffer subBuffer = compositeBuffer.buffers.remove();\n-      buffers.add(subBuffer);\n+    Queue<ReadableBuffer> otherBuffers = compositeBuffer.buffers;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MDYwMw==", "bodyText": "I was not a fan of the previous behavior. I prefer an approach like this... although this may not provide any benefit. Since execute() didn't leak the reference to op, I'd expect op to be allocated on the stack. Although maybe the interface being called messes things up (since an op could leak a reference to itself when called). I'd be willing to take this anyway.", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516380603", "createdAt": "2020-11-03T01:17:21Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -64,92 +72,109 @@ public int readableBytes() {\n     return readableBytes;\n   }\n \n+  private static final ReadOperation<Void> UBYTE_OP = new ReadOperation<Void>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, Void unused, int value) {\n+      return buffer.readUnsignedByte();\n+    }\n+  };\n+\n   @Override\n   public int readUnsignedByte() {\n-    ReadOperation op = new ReadOperation() {\n-      @Override\n-      int readInternal(ReadableBuffer buffer, int length) {\n-        return buffer.readUnsignedByte();\n-      }\n-    };\n-    execute(op, 1);\n-    return op.value;\n+    return executeNoThrow(UBYTE_OP, 1, null, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4MjQwOQ==", "bodyText": "Name this as one, since it is not truly immutable.", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516382409", "createdAt": "2020-11-03T01:24:39Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/ReflectionLongAdderCounter.java", "diffHunk": "@@ -97,10 +97,12 @@ static boolean isAvailable() {\n     return initializationException == null;\n   }\n \n+  private static final Object[] ONE = new Object[] { 1L };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5MzEwMg==", "bodyText": "It's unclear if this change improves or worsens performance. Now the type of the return value changes, so the JIT will not optimize the calling code as much. On the other hand, there is less indirection when length is present in a single buffer.", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516393102", "createdAt": "2020-11-03T02:09:50Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -64,92 +72,109 @@ public int readableBytes() {\n     return readableBytes;\n   }\n \n+  private static final ReadOperation<Void> UBYTE_OP = new ReadOperation<Void>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, Void unused, int value) {\n+      return buffer.readUnsignedByte();\n+    }\n+  };\n+\n   @Override\n   public int readUnsignedByte() {\n-    ReadOperation op = new ReadOperation() {\n-      @Override\n-      int readInternal(ReadableBuffer buffer, int length) {\n-        return buffer.readUnsignedByte();\n-      }\n-    };\n-    execute(op, 1);\n-    return op.value;\n+    return executeNoThrow(UBYTE_OP, 1, null, 0);\n   }\n \n+  private static final ReadOperation<Void> SKIP_OP = new ReadOperation<Void>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, Void unused, int unused2) {\n+      buffer.skipBytes(length);\n+      return 0;\n+    }\n+  };\n+\n   @Override\n   public void skipBytes(int length) {\n-    execute(new ReadOperation() {\n-      @Override\n-      public int readInternal(ReadableBuffer buffer, int length) {\n-        buffer.skipBytes(length);\n-        return 0;\n-      }\n-    }, length);\n+    executeNoThrow(SKIP_OP, length, null, 0);\n   }\n \n+  private static final ReadOperation<byte[]> BYTE_ARRAY_OP = new ReadOperation<byte[]>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, byte[] dest, int offset) {\n+      buffer.readBytes(dest, offset, length);\n+      return offset + length;\n+    }\n+  };\n+\n   @Override\n   public void readBytes(final byte[] dest, final int destOffset, int length) {\n-    execute(new ReadOperation() {\n-      int currentOffset = destOffset;\n-      @Override\n-      public int readInternal(ReadableBuffer buffer, int length) {\n-        buffer.readBytes(dest, currentOffset, length);\n-        currentOffset += length;\n-        return 0;\n-      }\n-    }, length);\n+    executeNoThrow(BYTE_ARRAY_OP, length, dest, destOffset);\n   }\n \n+  private static final ReadOperation<ByteBuffer> BYTE_BUF_OP = new ReadOperation<ByteBuffer>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, ByteBuffer dest, int unused) {\n+      // Change the limit so that only lengthToCopy bytes are available.\n+      int prevLimit = dest.limit();\n+      ((Buffer) dest).limit(dest.position() + length);\n+      // Write the bytes and restore the original limit.\n+      buffer.readBytes(dest);\n+      ((Buffer) dest).limit(prevLimit);\n+      return 0;\n+    }\n+  };\n+\n   @Override\n   public void readBytes(final ByteBuffer dest) {\n-    execute(new ReadOperation() {\n-      @Override\n-      public int readInternal(ReadableBuffer buffer, int length) {\n-        // Change the limit so that only lengthToCopy bytes are available.\n-        int prevLimit = dest.limit();\n-        ((Buffer) dest).limit(dest.position() + length);\n-\n-        // Write the bytes and restore the original limit.\n-        buffer.readBytes(dest);\n-        ((Buffer) dest).limit(prevLimit);\n-        return 0;\n-      }\n-    }, dest.remaining());\n+    executeNoThrow(BYTE_BUF_OP, dest.remaining(), dest, 0);\n   }\n \n-  @Override\n-  public void readBytes(final OutputStream dest, int length) throws IOException {\n-    ReadOperation op = new ReadOperation() {\n-      @Override\n-      public int readInternal(ReadableBuffer buffer, int length) throws IOException {\n+  private static final ReadOperation<OutputStream> STREAM_OP = new ReadOperation<OutputStream>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, OutputStream dest, int unused)\n+            throws IOException {\n         buffer.readBytes(dest, length);\n         return 0;\n-      }\n-    };\n-    execute(op, length);\n-\n-    // If an exception occurred, throw it.\n-    if (op.isError()) {\n-      throw op.ex;\n     }\n+  };\n+\n+  @Override\n+  public void readBytes(final OutputStream dest, int length) throws IOException {\n+    execute(STREAM_OP, length, dest, 0);\n   }\n \n   @Override\n-  public CompositeReadableBuffer readBytes(int length) {\n+  public ReadableBuffer readBytes(int length) {\n+    if (length <= 0) {\n+      return ReadableBuffers.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDA3MA==", "bodyText": "We use AssertionError for impossible internally-guaranteed conditions.", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516394070", "createdAt": "2020-11-03T02:14:02Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -189,6 +211,16 @@ private void execute(ReadOperation op, int length) {\n       // Should never get here.\n       throw new AssertionError(\"Failed executing read operation\");\n     }\n+\n+    return value;\n+  }\n+\n+  private <T> int executeNoThrow(ReadOperation<T> op, int length, T dest, int value) {\n+    try {\n+      return execute(op, length, dest, value);\n+    } catch (IOException e) {\n+      throw new RuntimeException(e); // shouldn't happen", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NDYzNQ==", "bodyText": "Don't know if we care, but we could have a NonThrowingReadOperation that extends this interface and doesn't have throws IOException. executeNoThrow() could then have that as a parameter. That would preserve the checked exception checking.", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516394635", "createdAt": "2020-11-03T02:16:43Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -202,32 +234,11 @@ private void advanceBufferIfNecessary() {\n   }\n \n   /**\n-   * A simple read operation to perform on a single {@link ReadableBuffer}. All state management for\n-   * the buffers is done by {@link CompositeReadableBuffer#execute(ReadOperation, int)}.\n+   * A simple read operation to perform on a single {@link ReadableBuffer}.\n+   * All state management for the buffers is done by\n+   * {@link CompositeReadableBuffer#execute(ReadOperation, int, Object, int)}.\n    */\n-  private abstract static class ReadOperation {\n-    /**\n-     * Only used by {@link CompositeReadableBuffer#readUnsignedByte()}.\n-     */\n-    int value;\n-\n-    /**\n-     * Only used by {@link CompositeReadableBuffer#readBytes(OutputStream, int)}.\n-     */\n-    IOException ex;\n-\n-    final void read(ReadableBuffer buffer, int length) {\n-      try {\n-        value = readInternal(buffer, length);\n-      } catch (IOException e) {\n-        ex = e;\n-      }\n-    }\n-\n-    final boolean isError() {\n-      return ex != null;\n-    }\n-\n-    abstract int readInternal(ReadableBuffer buffer, int length) throws IOException;\n+  private interface ReadOperation<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTQ1OQ==", "bodyText": "You might want to clean up the now-unnecessary finals. Not a big deal.", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516395459", "createdAt": "2020-11-03T02:20:14Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -64,92 +72,109 @@ public int readableBytes() {\n     return readableBytes;\n   }\n \n+  private static final ReadOperation<Void> UBYTE_OP = new ReadOperation<Void>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, Void unused, int value) {\n+      return buffer.readUnsignedByte();\n+    }\n+  };\n+\n   @Override\n   public int readUnsignedByte() {\n-    ReadOperation op = new ReadOperation() {\n-      @Override\n-      int readInternal(ReadableBuffer buffer, int length) {\n-        return buffer.readUnsignedByte();\n-      }\n-    };\n-    execute(op, 1);\n-    return op.value;\n+    return executeNoThrow(UBYTE_OP, 1, null, 0);\n   }\n \n+  private static final ReadOperation<Void> SKIP_OP = new ReadOperation<Void>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, Void unused, int unused2) {\n+      buffer.skipBytes(length);\n+      return 0;\n+    }\n+  };\n+\n   @Override\n   public void skipBytes(int length) {\n-    execute(new ReadOperation() {\n-      @Override\n-      public int readInternal(ReadableBuffer buffer, int length) {\n-        buffer.skipBytes(length);\n-        return 0;\n-      }\n-    }, length);\n+    executeNoThrow(SKIP_OP, length, null, 0);\n   }\n \n+  private static final ReadOperation<byte[]> BYTE_ARRAY_OP = new ReadOperation<byte[]>() {\n+    @Override\n+    public int read(ReadableBuffer buffer, int length, byte[] dest, int offset) {\n+      buffer.readBytes(dest, offset, length);\n+      return offset + length;\n+    }\n+  };\n+\n   @Override\n   public void readBytes(final byte[] dest, final int destOffset, int length) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NzM2NQ==", "bodyText": "Somewhere the relationship between value and the returned int needs to be mentioned, since that might be surprising and doesn't \"jump out\" obviously in the code.", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516397365", "createdAt": "2020-11-03T02:29:05Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/CompositeReadableBuffer.java", "diffHunk": "@@ -202,32 +234,11 @@ private void advanceBufferIfNecessary() {\n   }\n \n   /**\n-   * A simple read operation to perform on a single {@link ReadableBuffer}. All state management for\n-   * the buffers is done by {@link CompositeReadableBuffer#execute(ReadOperation, int)}.\n+   * A simple read operation to perform on a single {@link ReadableBuffer}.\n+   * All state management for the buffers is done by\n+   * {@link CompositeReadableBuffer#execute(ReadOperation, int, Object, int)}.\n    */\n-  private abstract static class ReadOperation {\n-    /**\n-     * Only used by {@link CompositeReadableBuffer#readUnsignedByte()}.\n-     */\n-    int value;\n-\n-    /**\n-     * Only used by {@link CompositeReadableBuffer#readBytes(OutputStream, int)}.\n-     */\n-    IOException ex;\n-\n-    final void read(ReadableBuffer buffer, int length) {\n-      try {\n-        value = readInternal(buffer, length);\n-      } catch (IOException e) {\n-        ex = e;\n-      }\n-    }\n-\n-    final boolean isError() {\n-      return ex != null;\n-    }\n-\n-    abstract int readInternal(ReadableBuffer buffer, int length) throws IOException;\n+  private interface ReadOperation<T> {\n+    int read(ReadableBuffer buffer, int length, T dest, int value) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d"}, "originalPosition": 270}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODA4NzY2", "url": "https://github.com/grpc/grpc-java/pull/7375#pullrequestreview-522808766", "createdAt": "2020-11-03T19:23:49Z", "commit": {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOToyMzo0OVrOHs9P-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOToyMzo0OVrOHs9P-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwMjkwNg==", "bodyText": "FWIW, this allocation should exist on the stack.", "url": "https://github.com/grpc/grpc-java/pull/7375#discussion_r516902906", "createdAt": "2020-11-03T19:23:49Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/MessageFramer.java", "diffHunk": "@@ -218,28 +218,26 @@ private int writeKnownLengthUncompressed(InputStream message, int messageLength)\n               String.format(\"message too large %d > %d\", messageLength , maxOutboundMessageSize))\n           .asRuntimeException();\n     }\n-    ByteBuffer header = ByteBuffer.wrap(headerScratch);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f661a1c522faf479eb905f48d1e826603a20b75d"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04f4e98298c8d7fd23c5b455468b62ff2100bb37", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/grpc/grpc-java/commit/04f4e98298c8d7fd23c5b455468b62ff2100bb37", "committedDate": "2021-01-01T01:31:26Z", "message": "Address review comments from @ejona86 and @voidzcy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyMTA5MjY0", "url": "https://github.com/grpc/grpc-java/pull/7375#pullrequestreview-562109264", "createdAt": "2021-01-05T20:29:37Z", "commit": {"oid": "04f4e98298c8d7fd23c5b455468b62ff2100bb37"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMTgzMzY5", "url": "https://github.com/grpc/grpc-java/pull/7375#pullrequestreview-570183369", "createdAt": "2021-01-18T05:41:27Z", "commit": {"oid": "04f4e98298c8d7fd23c5b455468b62ff2100bb37"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be28523602b5f0a7eb7bae474ac6588248bf5364", "author": {"user": {"login": "njhill", "name": "Nick Hill"}}, "url": "https://github.com/grpc/grpc-java/commit/be28523602b5f0a7eb7bae474ac6588248bf5364", "committedDate": "2021-01-18T21:36:10Z", "message": "Fix missing imports in CronetClientTransport.java"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4222, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}