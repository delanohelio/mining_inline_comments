{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4NjE5MDc3", "number": 7264, "title": "core: Add DelayedClientCall", "bodyText": "Adding DelayedClientCall in preparation of implementing ConfigSelector in core. Big picture is shown in #7259.\nDelayedClientCall is implemented exactly in the same way as DelayedStream. Only added logic to monitor initial DEADLINE.", "createdAt": "2020-07-29T18:49:34Z", "url": "https://github.com/grpc/grpc-java/pull/7264", "merged": true, "mergeCommit": {"oid": "afcce8d3c02bfc21bbdb9cd91113fd937e20b7c8"}, "closed": true, "closedAt": "2020-08-04T23:54:35Z", "author": {"login": "dapengzhang0"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc5xhLOgH2gAyNDU4NjE5MDc3OjE2NTI3MzQwMmRiMjZkYzk3OTRiZjFhMjZmMTY4MDlkNWQxMzJlMDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc7uajZgH2gAyNDU4NjE5MDc3OjIyMDcwZjhjMGU4ZjZmMWJmNDg5OTZmOGFkZWM2OWFhYmU5NjE1OTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "165273402db26dc9794bf1a26f16809d5d132e00", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/165273402db26dc9794bf1a26f16809d5d132e00", "committedDate": "2020-07-29T21:01:21Z", "message": "core: Add DelayedClientCall"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e12eaca8b63344622c1aa3d113e76086eaf6505e", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/e12eaca8b63344622c1aa3d113e76086eaf6505e", "committedDate": "2020-07-29T18:48:44Z", "message": "core: Add DelayedClientCall"}, "afterCommit": {"oid": "165273402db26dc9794bf1a26f16809d5d132e00", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/165273402db26dc9794bf1a26f16809d5d132e00", "committedDate": "2020-07-29T21:01:21Z", "message": "core: Add DelayedClientCall"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15696ca67c5070a1d138e46bcc7553d50faf69e3", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/15696ca67c5070a1d138e46bcc7553d50faf69e3", "committedDate": "2020-07-30T18:49:12Z", "message": "correct javadoc for initialDeadlineMonitor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTIwODYy", "url": "https://github.com/grpc/grpc-java/pull/7264#pullrequestreview-461120862", "createdAt": "2020-08-04T19:44:51Z", "commit": {"oid": "15696ca67c5070a1d138e46bcc7553d50faf69e3"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTo0NDo1MVrOG7u_mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMDoxNjo0MlrOG7v-aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4OTExNA==", "bodyText": "This is quite a bit directly in the constructor. Could this all be moved into a function so that it'd become:\nthis.initialDeadlineMonitor = scheduleDeadlineIfNeeded(scheduler, deadline, context);", "url": "https://github.com/grpc/grpc-java/pull/7264#discussion_r465289114", "createdAt": "2020-08-04T19:44:51Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientCall.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.Attributes;\n+import io.grpc.ClientCall;\n+import io.grpc.Context;\n+import io.grpc.Deadline;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * A call that queues requests before the transport is available, and delegates to a real call\n+ * implementation when the transport is available.\n+ *\n+ * <p>{@code ClientCall} itself doesn't require thread-safety. However, the state of {@code\n+ * DelayedCall} may be internally altered by different threads, thus internal synchronization is\n+ * necessary.\n+ */\n+final class DelayedClientCall<ReqT, RespT> extends ClientCall<ReqT, RespT> {\n+  private static final Logger logger = Logger.getLogger(DelayedClientCall.class.getName());\n+  /**\n+   * A timer to monitor the initial deadline. The timer must be cancelled on transition to the real\n+   * call.\n+   */\n+  @Nullable\n+  private final ScheduledFuture<?> initialDeadlineMonitor;\n+  private final Executor callExecutor;\n+  private final Context context;\n+  /** {@code true} once realCall is valid and all pending calls have been drained. */\n+  private volatile boolean passThrough;\n+  /**\n+   * Non-{@code null} iff start has been called. Used to assert methods are called in appropriate\n+   * order, but also used if an error occurs before {@code realCall} is set.\n+   */\n+  private Listener<RespT> listener;\n+  // Must hold {@code this} lock when setting.\n+  private ClientCall<ReqT, RespT> realCall;\n+  @GuardedBy(\"this\")\n+  private Status error;\n+  @GuardedBy(\"this\")\n+  private List<Runnable> pendingRunnables = new ArrayList<>();\n+  @GuardedBy(\"this\")\n+  private DelayedListener<RespT> delayedListener;\n+\n+  DelayedClientCall(\n+      Executor callExecutor, ScheduledExecutorService scheduler, @Nullable Deadline deadline) {\n+    this.callExecutor = checkNotNull(callExecutor, \"callExecutor\");\n+    checkNotNull(scheduler, \"scheduler\");\n+    context = Context.current();\n+    Deadline contextDeadline = context.getDeadline();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15696ca67c5070a1d138e46bcc7553d50faf69e3"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwNTE5Mg==", "bodyText": "It's unclear to me how much this does. What would happen if we didn't have this check?\nI feel like we either don't need this check, or we need to pass a boolean to cancel(Status) saying not to cancel if realCall is set, in a non-racy way.", "url": "https://github.com/grpc/grpc-java/pull/7264#discussion_r465305192", "createdAt": "2020-08-04T20:16:42Z", "author": {"login": "ejona86"}, "path": "core/src/main/java/io/grpc/internal/DelayedClientCall.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Copyright 2020 The gRPC Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.grpc.internal;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.MoreObjects;\n+import io.grpc.Attributes;\n+import io.grpc.ClientCall;\n+import io.grpc.Context;\n+import io.grpc.Deadline;\n+import io.grpc.Metadata;\n+import io.grpc.Status;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * A call that queues requests before the transport is available, and delegates to a real call\n+ * implementation when the transport is available.\n+ *\n+ * <p>{@code ClientCall} itself doesn't require thread-safety. However, the state of {@code\n+ * DelayedCall} may be internally altered by different threads, thus internal synchronization is\n+ * necessary.\n+ */\n+final class DelayedClientCall<ReqT, RespT> extends ClientCall<ReqT, RespT> {\n+  private static final Logger logger = Logger.getLogger(DelayedClientCall.class.getName());\n+  /**\n+   * A timer to monitor the initial deadline. The timer must be cancelled on transition to the real\n+   * call.\n+   */\n+  @Nullable\n+  private final ScheduledFuture<?> initialDeadlineMonitor;\n+  private final Executor callExecutor;\n+  private final Context context;\n+  /** {@code true} once realCall is valid and all pending calls have been drained. */\n+  private volatile boolean passThrough;\n+  /**\n+   * Non-{@code null} iff start has been called. Used to assert methods are called in appropriate\n+   * order, but also used if an error occurs before {@code realCall} is set.\n+   */\n+  private Listener<RespT> listener;\n+  // Must hold {@code this} lock when setting.\n+  private ClientCall<ReqT, RespT> realCall;\n+  @GuardedBy(\"this\")\n+  private Status error;\n+  @GuardedBy(\"this\")\n+  private List<Runnable> pendingRunnables = new ArrayList<>();\n+  @GuardedBy(\"this\")\n+  private DelayedListener<RespT> delayedListener;\n+\n+  DelayedClientCall(\n+      Executor callExecutor, ScheduledExecutorService scheduler, @Nullable Deadline deadline) {\n+    this.callExecutor = checkNotNull(callExecutor, \"callExecutor\");\n+    checkNotNull(scheduler, \"scheduler\");\n+    context = Context.current();\n+    Deadline contextDeadline = context.getDeadline();\n+    if (deadline == null && contextDeadline == null) {\n+      this.initialDeadlineMonitor = null;\n+      return;\n+    }\n+    long remainingNanos = Long.MAX_VALUE;\n+    if (deadline != null) {\n+      remainingNanos = Math.min(remainingNanos, deadline.timeRemaining(NANOSECONDS));\n+    }\n+    if (contextDeadline != null && contextDeadline.timeRemaining(NANOSECONDS) < remainingNanos) {\n+      remainingNanos = contextDeadline.timeRemaining(NANOSECONDS);\n+      if (logger.isLoggable(Level.FINE)) {\n+        StringBuilder builder =\n+            new StringBuilder(\n+                String.format(\n+                    \"Call timeout set to '%d' ns, due to context deadline.\", remainingNanos));\n+        if (deadline == null) {\n+          builder.append(\" Explicit call timeout was not set.\");\n+        } else {\n+          long callTimeout = deadline.timeRemaining(TimeUnit.NANOSECONDS);\n+          builder.append(String.format(\" Explicit call timeout was '%d' ns.\", callTimeout));\n+        }\n+        logger.fine(builder.toString());\n+      }\n+    }\n+    long seconds = Math.abs(remainingNanos) / TimeUnit.SECONDS.toNanos(1);\n+    long nanos = Math.abs(remainingNanos) % TimeUnit.SECONDS.toNanos(1);\n+    final StringBuilder buf = new StringBuilder();\n+    if (remainingNanos < 0) {\n+      buf.append(\"ClientCall started after deadline exceeded. Deadline exceeded after -\");\n+    } else {\n+      buf.append(\"Deadline exceeded after \");\n+    }\n+    buf.append(seconds);\n+    buf.append(String.format(\".%09d\", nanos));\n+    buf.append(\"s. \");\n+    /** Cancels the call if deadline exceeded prior to the real call being set. */\n+    class DeadlineExceededRunnable implements Runnable {\n+      @Override\n+      public void run() {\n+        synchronized (DelayedClientCall.this) {\n+          if (realCall != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15696ca67c5070a1d138e46bcc7553d50faf69e3"}, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c14998f2eb38910d329bb7afa38588b6d8b09fbc", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/c14998f2eb38910d329bb7afa38588b6d8b09fbc", "committedDate": "2020-08-04T22:18:29Z", "message": "fix racy cancel"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd496605e046504096e177a0a496b3907db003a9", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/cd496605e046504096e177a0a496b3907db003a9", "committedDate": "2020-08-04T22:21:52Z", "message": "refactor constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22070f8c0e8f6f1bf48996f8adec69aabe961594", "author": {"user": {"login": "dapengzhang0", "name": "ZHANG Dapeng"}}, "url": "https://github.com/grpc/grpc-java/commit/22070f8c0e8f6f1bf48996f8adec69aabe961594", "committedDate": "2020-08-04T22:32:15Z", "message": "fix typo"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4119, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}