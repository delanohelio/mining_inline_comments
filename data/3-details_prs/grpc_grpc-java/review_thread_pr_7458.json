{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyODM5MDcz", "number": 7458, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo1Mjo0M1rOEoMnnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOTowMDoxM1rOEoOB8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTg1MjQ0OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo1Mjo0M1rOHZJb8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOTozNDo1NlrOHZMxpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzMTA1Nw==", "bodyText": "nit: Move this line inside the if block blow.", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496131057", "createdAt": "2020-09-28T17:52:43Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -1025,63 +891,26 @@ private void handleCdsResponse(DiscoveryResponseData cdsResponse) {\n     if (errorMessage != null) {\n       adsStream.sendNackRequest(\n           ResourceType.CDS,\n-          cdsWatchers.keySet(),\n+          cdsResourceSubscribers.keySet(),\n           cdsResponse.getVersionInfo(),\n           errorMessage);\n       return;\n     }\n-    adsStream.sendAckRequest(ResourceType.CDS, cdsWatchers.keySet(),\n+    adsStream.sendAckRequest(ResourceType.CDS, cdsResourceSubscribers.keySet(),\n         cdsResponse.getVersionInfo());\n \n-    // Update local CDS cache with data in this response.\n-    absentCdsResources.removeAll(cdsUpdates.keySet());\n-    for (Map.Entry<String, CdsUpdate> entry : clusterNamesToCdsUpdates.entrySet()) {\n-      if (!cdsUpdates.containsKey(entry.getKey())) {\n-        // Some previously existing resource no longer exists.\n-        absentCdsResources.add(entry.getKey());\n-      } else if (cdsUpdates.get(entry.getKey()).equals(entry.getValue())) {\n-        cdsUpdates.remove(entry.getKey());\n-      }\n-    }\n-    clusterNamesToCdsUpdates.keySet().removeAll(absentCdsResources);\n-    clusterNamesToCdsUpdates.putAll(cdsUpdates);\n-\n-    // Remove EDS cache entries for ClusterLoadAssignments not referenced by this CDS response.\n-    for (String clusterName : clusterNamesToEdsUpdates.keySet()) {\n-      if (!edsServices.contains(clusterName)) {\n-        absentEdsResources.add(clusterName);\n-        // Notify EDS resource removal to watchers.\n-        if (edsWatchers.containsKey(clusterName)) {\n-          Set<EdsResourceWatcher> watchers = edsWatchers.get(clusterName);\n-          for (EdsResourceWatcher watcher : watchers) {\n-            watcher.onResourceDoesNotExist(clusterName);\n-          }\n-        }\n-      }\n-    }\n-    clusterNamesToEdsUpdates.keySet().retainAll(edsServices);\n-\n-    for (String clusterName : cdsUpdates.keySet()) {\n-      if (cdsRespTimers.containsKey(clusterName)) {\n-        cdsRespTimers.get(clusterName).cancel();\n-        cdsRespTimers.remove(clusterName);\n+    for (String resource : cdsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = cdsResourceSubscribers.get(resource);\n+      if (cdsUpdates.containsKey(resource)) {\n+        subscriber.onData(cdsUpdates.get(resource));\n+      } else {\n+        subscriber.onAbsent();\n       }\n     }\n-\n-    // Notify watchers if clusters interested in present in this CDS response.\n-    for (Map.Entry<String, Set<CdsResourceWatcher>> entry : cdsWatchers.entrySet()) {\n-      String clusterName = entry.getKey();\n-      if (cdsUpdates.containsKey(entry.getKey())) {\n-        CdsUpdate cdsUpdate = cdsUpdates.get(clusterName);\n-        for (CdsResourceWatcher watcher : entry.getValue()) {\n-          watcher.onChanged(cdsUpdate);\n-        }\n-      } else if (!clusterNamesToCdsUpdates.containsKey(entry.getKey())\n-          && !cdsRespTimers.containsKey(clusterName)) {\n-        // Update for previously present resource being removed.\n-        for (CdsResourceWatcher watcher : entry.getValue()) {\n-          watcher.onResourceDoesNotExist(entry.getKey());\n-        }\n+    for (String resource : edsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = edsResourceSubscribers.get(resource);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78aaf2b2aa348bd6b5ad36ee180f087f563f9508"}, "originalPosition": 339}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4NTc2Ng==", "bodyText": "Fixed.", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496185766", "createdAt": "2020-09-28T19:34:56Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -1025,63 +891,26 @@ private void handleCdsResponse(DiscoveryResponseData cdsResponse) {\n     if (errorMessage != null) {\n       adsStream.sendNackRequest(\n           ResourceType.CDS,\n-          cdsWatchers.keySet(),\n+          cdsResourceSubscribers.keySet(),\n           cdsResponse.getVersionInfo(),\n           errorMessage);\n       return;\n     }\n-    adsStream.sendAckRequest(ResourceType.CDS, cdsWatchers.keySet(),\n+    adsStream.sendAckRequest(ResourceType.CDS, cdsResourceSubscribers.keySet(),\n         cdsResponse.getVersionInfo());\n \n-    // Update local CDS cache with data in this response.\n-    absentCdsResources.removeAll(cdsUpdates.keySet());\n-    for (Map.Entry<String, CdsUpdate> entry : clusterNamesToCdsUpdates.entrySet()) {\n-      if (!cdsUpdates.containsKey(entry.getKey())) {\n-        // Some previously existing resource no longer exists.\n-        absentCdsResources.add(entry.getKey());\n-      } else if (cdsUpdates.get(entry.getKey()).equals(entry.getValue())) {\n-        cdsUpdates.remove(entry.getKey());\n-      }\n-    }\n-    clusterNamesToCdsUpdates.keySet().removeAll(absentCdsResources);\n-    clusterNamesToCdsUpdates.putAll(cdsUpdates);\n-\n-    // Remove EDS cache entries for ClusterLoadAssignments not referenced by this CDS response.\n-    for (String clusterName : clusterNamesToEdsUpdates.keySet()) {\n-      if (!edsServices.contains(clusterName)) {\n-        absentEdsResources.add(clusterName);\n-        // Notify EDS resource removal to watchers.\n-        if (edsWatchers.containsKey(clusterName)) {\n-          Set<EdsResourceWatcher> watchers = edsWatchers.get(clusterName);\n-          for (EdsResourceWatcher watcher : watchers) {\n-            watcher.onResourceDoesNotExist(clusterName);\n-          }\n-        }\n-      }\n-    }\n-    clusterNamesToEdsUpdates.keySet().retainAll(edsServices);\n-\n-    for (String clusterName : cdsUpdates.keySet()) {\n-      if (cdsRespTimers.containsKey(clusterName)) {\n-        cdsRespTimers.get(clusterName).cancel();\n-        cdsRespTimers.remove(clusterName);\n+    for (String resource : cdsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = cdsResourceSubscribers.get(resource);\n+      if (cdsUpdates.containsKey(resource)) {\n+        subscriber.onData(cdsUpdates.get(resource));\n+      } else {\n+        subscriber.onAbsent();\n       }\n     }\n-\n-    // Notify watchers if clusters interested in present in this CDS response.\n-    for (Map.Entry<String, Set<CdsResourceWatcher>> entry : cdsWatchers.entrySet()) {\n-      String clusterName = entry.getKey();\n-      if (cdsUpdates.containsKey(entry.getKey())) {\n-        CdsUpdate cdsUpdate = cdsUpdates.get(clusterName);\n-        for (CdsResourceWatcher watcher : entry.getValue()) {\n-          watcher.onChanged(cdsUpdate);\n-        }\n-      } else if (!clusterNamesToCdsUpdates.containsKey(entry.getKey())\n-          && !cdsRespTimers.containsKey(clusterName)) {\n-        // Update for previously present resource being removed.\n-        for (CdsResourceWatcher watcher : entry.getValue()) {\n-          watcher.onResourceDoesNotExist(entry.getKey());\n-        }\n+    for (String resource : edsResourceSubscribers.keySet()) {\n+      ResourceSubscriber subscriber = edsResourceSubscribers.get(resource);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzMTA1Nw=="}, "originalCommit": {"oid": "78aaf2b2aa348bd6b5ad36ee180f087f563f9508"}, "originalPosition": 339}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTk0NjI1OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxODoxOTo1NlrOHZKWIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMDowODozNFrOHZN1WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NTk1Mg==", "bodyText": "Need override equals() for LdsUpdate and RdsUpdate.", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496145952", "createdAt": "2020-09-28T18:19:56Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -1333,6 +1150,131 @@ static ResourceType fromTypeUrl(String typeUrl) {\n     }\n   }\n \n+  /**\n+   * Tracks a single subscribed resource.\n+   */\n+  private final class ResourceSubscriber {\n+    private final ResourceType type;\n+    private final String resource;\n+    private final Set<ResourceWatcher> watchers = new HashSet<>();\n+    private ResourceUpdate data;\n+    private boolean absent;\n+    private ScheduledHandle respTimer;\n+\n+    ResourceSubscriber(ResourceType type, String resource) {\n+      this.type = type;\n+      this.resource = resource;\n+      if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+        return;\n+      }\n+      restartTimer();\n+    }\n+\n+    void addWatcher(ResourceWatcher watcher) {\n+      checkArgument(!watchers.contains(watcher), \"watcher %s already registered\", watcher);\n+      watchers.add(watcher);\n+      if (data != null) {\n+        notifyWatcher(watcher, data);\n+      } else if (absent) {\n+        watcher.onResourceDoesNotExist(resource);\n+      }\n+    }\n+\n+    void removeWatcher(ResourceWatcher watcher) {\n+      checkArgument(watchers.contains(watcher), \"watcher %s not registered\", watcher);\n+      watchers.remove(watcher);\n+    }\n+\n+    void restartTimer() {\n+      class ResourceNotFound implements Runnable {\n+        @Override\n+        public void run() {\n+          respTimer = null;\n+          onAbsent();\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return type + this.getClass().getSimpleName();\n+        }\n+      }\n+\n+      respTimer = syncContext.schedule(\n+          new ResourceNotFound(), INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS,\n+          timeService);\n+    }\n+\n+    void stopTimer() {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+    }\n+\n+    boolean isWatched() {\n+      return !watchers.isEmpty();\n+    }\n+\n+    void onData(ResourceUpdate data) {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+      ResourceUpdate oldData = this.data;\n+      this.data = data;\n+      absent = false;\n+      if (!Objects.equals(oldData, data)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78aaf2b2aa348bd6b5ad36ee180f087f563f9508"}, "originalPosition": 559}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4NTY3OA==", "bodyText": "Fixed.", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496185678", "createdAt": "2020-09-28T19:34:47Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -1333,6 +1150,131 @@ static ResourceType fromTypeUrl(String typeUrl) {\n     }\n   }\n \n+  /**\n+   * Tracks a single subscribed resource.\n+   */\n+  private final class ResourceSubscriber {\n+    private final ResourceType type;\n+    private final String resource;\n+    private final Set<ResourceWatcher> watchers = new HashSet<>();\n+    private ResourceUpdate data;\n+    private boolean absent;\n+    private ScheduledHandle respTimer;\n+\n+    ResourceSubscriber(ResourceType type, String resource) {\n+      this.type = type;\n+      this.resource = resource;\n+      if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+        return;\n+      }\n+      restartTimer();\n+    }\n+\n+    void addWatcher(ResourceWatcher watcher) {\n+      checkArgument(!watchers.contains(watcher), \"watcher %s already registered\", watcher);\n+      watchers.add(watcher);\n+      if (data != null) {\n+        notifyWatcher(watcher, data);\n+      } else if (absent) {\n+        watcher.onResourceDoesNotExist(resource);\n+      }\n+    }\n+\n+    void removeWatcher(ResourceWatcher watcher) {\n+      checkArgument(watchers.contains(watcher), \"watcher %s not registered\", watcher);\n+      watchers.remove(watcher);\n+    }\n+\n+    void restartTimer() {\n+      class ResourceNotFound implements Runnable {\n+        @Override\n+        public void run() {\n+          respTimer = null;\n+          onAbsent();\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return type + this.getClass().getSimpleName();\n+        }\n+      }\n+\n+      respTimer = syncContext.schedule(\n+          new ResourceNotFound(), INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS,\n+          timeService);\n+    }\n+\n+    void stopTimer() {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+    }\n+\n+    boolean isWatched() {\n+      return !watchers.isEmpty();\n+    }\n+\n+    void onData(ResourceUpdate data) {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+      ResourceUpdate oldData = this.data;\n+      this.data = data;\n+      absent = false;\n+      if (!Objects.equals(oldData, data)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NTk1Mg=="}, "originalCommit": {"oid": "78aaf2b2aa348bd6b5ad36ee180f087f563f9508"}, "originalPosition": 559}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwMzA5Nw==", "bodyText": "Also RdsUpdate.", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496203097", "createdAt": "2020-09-28T20:08:34Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -1333,6 +1150,131 @@ static ResourceType fromTypeUrl(String typeUrl) {\n     }\n   }\n \n+  /**\n+   * Tracks a single subscribed resource.\n+   */\n+  private final class ResourceSubscriber {\n+    private final ResourceType type;\n+    private final String resource;\n+    private final Set<ResourceWatcher> watchers = new HashSet<>();\n+    private ResourceUpdate data;\n+    private boolean absent;\n+    private ScheduledHandle respTimer;\n+\n+    ResourceSubscriber(ResourceType type, String resource) {\n+      this.type = type;\n+      this.resource = resource;\n+      if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+        return;\n+      }\n+      restartTimer();\n+    }\n+\n+    void addWatcher(ResourceWatcher watcher) {\n+      checkArgument(!watchers.contains(watcher), \"watcher %s already registered\", watcher);\n+      watchers.add(watcher);\n+      if (data != null) {\n+        notifyWatcher(watcher, data);\n+      } else if (absent) {\n+        watcher.onResourceDoesNotExist(resource);\n+      }\n+    }\n+\n+    void removeWatcher(ResourceWatcher watcher) {\n+      checkArgument(watchers.contains(watcher), \"watcher %s not registered\", watcher);\n+      watchers.remove(watcher);\n+    }\n+\n+    void restartTimer() {\n+      class ResourceNotFound implements Runnable {\n+        @Override\n+        public void run() {\n+          respTimer = null;\n+          onAbsent();\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return type + this.getClass().getSimpleName();\n+        }\n+      }\n+\n+      respTimer = syncContext.schedule(\n+          new ResourceNotFound(), INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS,\n+          timeService);\n+    }\n+\n+    void stopTimer() {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+    }\n+\n+    boolean isWatched() {\n+      return !watchers.isEmpty();\n+    }\n+\n+    void onData(ResourceUpdate data) {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+      ResourceUpdate oldData = this.data;\n+      this.data = data;\n+      absent = false;\n+      if (!Objects.equals(oldData, data)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NTk1Mg=="}, "originalCommit": {"oid": "78aaf2b2aa348bd6b5ad36ee180f087f563f9508"}, "originalPosition": 559}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNjA4MzY4OnYy", "diffSide": "RIGHT", "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOTowMDoxM1rOHZLr7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOTozNDozMlrOHZMwxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE2NzkxNw==", "bodyText": "Is it equivalent to\nif (!absent) {\n  absent = true;\n  data = null;\n  for (ResourceWatcher watcher : watchers) {\n    watcher.onResourceDoesNotExist(resource);\n  }\n}\n?", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496167917", "createdAt": "2020-09-28T19:00:13Z", "author": {"login": "dapengzhang0"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -1333,6 +1150,131 @@ static ResourceType fromTypeUrl(String typeUrl) {\n     }\n   }\n \n+  /**\n+   * Tracks a single subscribed resource.\n+   */\n+  private final class ResourceSubscriber {\n+    private final ResourceType type;\n+    private final String resource;\n+    private final Set<ResourceWatcher> watchers = new HashSet<>();\n+    private ResourceUpdate data;\n+    private boolean absent;\n+    private ScheduledHandle respTimer;\n+\n+    ResourceSubscriber(ResourceType type, String resource) {\n+      this.type = type;\n+      this.resource = resource;\n+      if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+        return;\n+      }\n+      restartTimer();\n+    }\n+\n+    void addWatcher(ResourceWatcher watcher) {\n+      checkArgument(!watchers.contains(watcher), \"watcher %s already registered\", watcher);\n+      watchers.add(watcher);\n+      if (data != null) {\n+        notifyWatcher(watcher, data);\n+      } else if (absent) {\n+        watcher.onResourceDoesNotExist(resource);\n+      }\n+    }\n+\n+    void removeWatcher(ResourceWatcher watcher) {\n+      checkArgument(watchers.contains(watcher), \"watcher %s not registered\", watcher);\n+      watchers.remove(watcher);\n+    }\n+\n+    void restartTimer() {\n+      class ResourceNotFound implements Runnable {\n+        @Override\n+        public void run() {\n+          respTimer = null;\n+          onAbsent();\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return type + this.getClass().getSimpleName();\n+        }\n+      }\n+\n+      respTimer = syncContext.schedule(\n+          new ResourceNotFound(), INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS,\n+          timeService);\n+    }\n+\n+    void stopTimer() {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+    }\n+\n+    boolean isWatched() {\n+      return !watchers.isEmpty();\n+    }\n+\n+    void onData(ResourceUpdate data) {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+      ResourceUpdate oldData = this.data;\n+      this.data = data;\n+      absent = false;\n+      if (!Objects.equals(oldData, data)) {\n+        for (ResourceWatcher watcher : watchers) {\n+          notifyWatcher(watcher, data);\n+        }\n+      }\n+    }\n+\n+    void onAbsent() {\n+      if (respTimer != null && respTimer.isPending()) {  // too early to conclude absence\n+        return;\n+      }\n+      boolean oldAbsent = absent;\n+      data = null;\n+      absent = true;\n+      if (!oldAbsent) {\n+        for (ResourceWatcher watcher : watchers) {\n+          watcher.onResourceDoesNotExist(resource);\n+        }\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78aaf2b2aa348bd6b5ad36ee180f087f563f9508"}, "originalPosition": 577}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4NTU0Mg==", "bodyText": "Yes, fixed.", "url": "https://github.com/grpc/grpc-java/pull/7458#discussion_r496185542", "createdAt": "2020-09-28T19:34:32Z", "author": {"login": "voidzcy"}, "path": "xds/src/main/java/io/grpc/xds/XdsClientImpl.java", "diffHunk": "@@ -1333,6 +1150,131 @@ static ResourceType fromTypeUrl(String typeUrl) {\n     }\n   }\n \n+  /**\n+   * Tracks a single subscribed resource.\n+   */\n+  private final class ResourceSubscriber {\n+    private final ResourceType type;\n+    private final String resource;\n+    private final Set<ResourceWatcher> watchers = new HashSet<>();\n+    private ResourceUpdate data;\n+    private boolean absent;\n+    private ScheduledHandle respTimer;\n+\n+    ResourceSubscriber(ResourceType type, String resource) {\n+      this.type = type;\n+      this.resource = resource;\n+      if (rpcRetryTimer != null && rpcRetryTimer.isPending()) {\n+        return;\n+      }\n+      restartTimer();\n+    }\n+\n+    void addWatcher(ResourceWatcher watcher) {\n+      checkArgument(!watchers.contains(watcher), \"watcher %s already registered\", watcher);\n+      watchers.add(watcher);\n+      if (data != null) {\n+        notifyWatcher(watcher, data);\n+      } else if (absent) {\n+        watcher.onResourceDoesNotExist(resource);\n+      }\n+    }\n+\n+    void removeWatcher(ResourceWatcher watcher) {\n+      checkArgument(watchers.contains(watcher), \"watcher %s not registered\", watcher);\n+      watchers.remove(watcher);\n+    }\n+\n+    void restartTimer() {\n+      class ResourceNotFound implements Runnable {\n+        @Override\n+        public void run() {\n+          respTimer = null;\n+          onAbsent();\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return type + this.getClass().getSimpleName();\n+        }\n+      }\n+\n+      respTimer = syncContext.schedule(\n+          new ResourceNotFound(), INITIAL_RESOURCE_FETCH_TIMEOUT_SEC, TimeUnit.SECONDS,\n+          timeService);\n+    }\n+\n+    void stopTimer() {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+    }\n+\n+    boolean isWatched() {\n+      return !watchers.isEmpty();\n+    }\n+\n+    void onData(ResourceUpdate data) {\n+      if (respTimer != null && respTimer.isPending()) {\n+        respTimer.cancel();\n+        respTimer = null;\n+      }\n+      ResourceUpdate oldData = this.data;\n+      this.data = data;\n+      absent = false;\n+      if (!Objects.equals(oldData, data)) {\n+        for (ResourceWatcher watcher : watchers) {\n+          notifyWatcher(watcher, data);\n+        }\n+      }\n+    }\n+\n+    void onAbsent() {\n+      if (respTimer != null && respTimer.isPending()) {  // too early to conclude absence\n+        return;\n+      }\n+      boolean oldAbsent = absent;\n+      data = null;\n+      absent = true;\n+      if (!oldAbsent) {\n+        for (ResourceWatcher watcher : watchers) {\n+          watcher.onResourceDoesNotExist(resource);\n+        }\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE2NzkxNw=="}, "originalCommit": {"oid": "78aaf2b2aa348bd6b5ad36ee180f087f563f9508"}, "originalPosition": 577}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2361, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}